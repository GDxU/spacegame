var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/// <reference path="../lib/pixi.d.ts" />
var Rance;
(function (Rance) {
    Rance.eventEmitter = new EventEmitter3();
    Rance.eventManager = {
        dispatchEvent: Rance.eventEmitter.emit.bind(Rance.eventEmitter),
        removeEventListener: Rance.eventEmitter.removeListener.bind(Rance.eventEmitter),
        removeAllListeners: Rance.eventEmitter.removeAllListeners.bind(Rance.eventEmitter),
        addEventListener: function (eventType, listener) {
            Rance.eventEmitter.on(eventType, listener);
            return listener;
        }
    };
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    (function (RandomGenUnitRarity) {
        RandomGenUnitRarity[RandomGenUnitRarity["common"] = 0] = "common";
        RandomGenUnitRarity[RandomGenUnitRarity["elite"] = 1] = "elite";
        RandomGenUnitRarity[RandomGenUnitRarity["commander"] = 2] = "commander";
    })(Rance.RandomGenUnitRarity || (Rance.RandomGenUnitRarity = {}));
    var RandomGenUnitRarity = Rance.RandomGenUnitRarity;
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    (function (DamageType) {
        DamageType[DamageType["physical"] = 0] = "physical";
        DamageType[DamageType["magical"] = 1] = "magical";
    })(Rance.DamageType || (Rance.DamageType = {}));
    var DamageType = Rance.DamageType;
})(Rance || (Rance = {}));
/// <reference path="../lib/pixi.d.ts" />
var Rance;
(function (Rance) {
    function randInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1) + min);
    }
    Rance.randInt = randInt;
    function randRange(min, max) {
        return Math.random() * (max - min) + min;
    }
    Rance.randRange = randRange;
    function getRandomArrayKey(target) {
        return Math.floor(Math.random() * (target.length));
    }
    Rance.getRandomArrayKey = getRandomArrayKey;
    function getRandomArrayItem(target) {
        var _rnd = Math.floor(Math.random() * (target.length));
        return target[_rnd];
    }
    Rance.getRandomArrayItem = getRandomArrayItem;
    function getSeededRandomArrayItem(array, rng) {
        var _rnd = Math.floor(rng.uniform() * array.length);
        return array[_rnd];
    }
    Rance.getSeededRandomArrayItem = getSeededRandomArrayItem;
    function getRandomKey(target) {
        var _targetKeys = Object.keys(target);
        var _rnd = Math.floor(Math.random() * (_targetKeys.length));
        return _targetKeys[_rnd];
    }
    Rance.getRandomKey = getRandomKey;
    function getObjectKeysSortedByValue(obj, order) {
        return Object.keys(obj).sort(function (a, b) {
            if (order === "asc") {
                return obj[a] - obj[b];
            }
            else
                return obj[b] - obj[a];
        });
    }
    Rance.getObjectKeysSortedByValue = getObjectKeysSortedByValue;
    function getObjectKeysSortedByValueOfProp(obj, prop, order) {
        return Object.keys(obj).sort(function (a, b) {
            if (order === "asc") {
                return obj[a][prop] - obj[b][prop];
            }
            else
                return obj[b][prop] - obj[a][prop];
        });
    }
    Rance.getObjectKeysSortedByValueOfProp = getObjectKeysSortedByValueOfProp;
    function sortObjectsByProperty(objects, prop, order) {
        return objects.sort(function (a, b) {
            if (order === "asc") {
                return a[prop] - b[prop];
            }
            else
                return b[prop] - a[prop];
        });
    }
    Rance.sortObjectsByProperty = sortObjectsByProperty;
    function getRandomProperty(target) {
        var _rndProp = target[getRandomKey(target)];
        return _rndProp;
    }
    Rance.getRandomProperty = getRandomProperty;
    function getAllPropertiesWithKey(target, keyToFind) {
        var matchingProperties = [];
        for (var key in target) {
            if (target[key][keyToFind]) {
                matchingProperties.push(target[key]);
            }
        }
        return matchingProperties;
    }
    Rance.getAllPropertiesWithKey = getAllPropertiesWithKey;
    function getRandomPropertyWithKey(target, keyToFind) {
        var keys = Object.keys(target);
        while (keys.length > 0) {
            var key = getRandomArrayItem(keys);
            var prop = target[key];
            if (prop[keyToFind]) {
                return prop;
            }
            else {
                keys.splice(keys.indexOf(key), 1);
            }
        }
        return null;
    }
    Rance.getRandomPropertyWithKey = getRandomPropertyWithKey;
    function getRandomKeyWithWeights(target) {
        var totalWeight = 0;
        for (var prop in target) {
            totalWeight += target[prop];
        }
        var selection = randRange(0, totalWeight);
        for (var prop in target) {
            selection -= target[prop];
            if (selection <= 0) {
                return prop;
            }
        }
    }
    Rance.getRandomKeyWithWeights = getRandomKeyWithWeights;
    function getRandomArrayItemWithWeights(arr) {
        var totalWeight = 0;
        for (var i = 0; i < arr.length; i++) {
            totalWeight += arr[i].weight;
        }
        var selection = randRange(0, totalWeight);
        for (var i = 0; i < arr.length; i++) {
            selection -= arr[i].weight;
            if (selection <= 0) {
                return arr[i];
            }
        }
    }
    Rance.getRandomArrayItemWithWeights = getRandomArrayItemWithWeights;
    function findItemWithKey(source, keyToFind, parentKey, hasParentKey) {
        if (hasParentKey === void 0) { hasParentKey = false; }
        var hasParentKey = hasParentKey;
        if (source[keyToFind]) {
            if (!parentKey || hasParentKey) {
                return source[keyToFind];
            }
        }
        ;
        for (var key in source) {
            if (key === parentKey) {
                hasParentKey = true;
            }
            if (source[key][keyToFind]) {
                if (!parentKey || hasParentKey) {
                    return source[key][keyToFind];
                }
            }
            else if (typeof source[key] === "object") {
                return findItemWithKey(source[key], keyToFind, parentKey, hasParentKey);
            }
        }
        return null;
    }
    Rance.findItemWithKey = findItemWithKey;
    function getFrom2dArray(target, arr) {
        var result = [];
        for (var i = 0; i < arr.length; i++) {
            if ((arr[i] !== undefined) &&
                (arr[i][0] >= 0 && arr[i][0] < target.length) &&
                (arr[i][1] >= 0 && arr[i][1] < target[0].length)) {
                result.push(target[arr[i][0]][arr[i][1]]);
            }
            else {
                result.push(null);
            }
        }
        ;
        return result;
    }
    Rance.getFrom2dArray = getFrom2dArray;
    function flatten2dArray(toFlatten) {
        var flattened = [];
        for (var i = 0; i < toFlatten.length; i++) {
            for (var j = 0; j < toFlatten[i].length; j++) {
                flattened.push(toFlatten[i][j]);
            }
        }
        return flattened;
    }
    Rance.flatten2dArray = flatten2dArray;
    function reverseSide(side) {
        switch (side) {
            case "side1":
                {
                    return "side2";
                }
            case "side2":
                {
                    return "side1";
                }
            default:
                {
                    throw new Error("Invalid side");
                }
        }
    }
    Rance.reverseSide = reverseSide;
    function turnOrderSortFunction(a, b) {
        if (a.battleStats.moveDelay !== b.battleStats.moveDelay) {
            return a.battleStats.moveDelay - b.battleStats.moveDelay;
        }
        else {
            return a.id - b.id;
        }
    }
    Rance.turnOrderSortFunction = turnOrderSortFunction;
    function sortByManufactoryCapacityFN(a, b) {
        var aLevel = (a.manufactory ? a.manufactory.capacity : -1);
        var bLevel = (b.manufactory ? b.manufactory.capacity : -1);
        if (bLevel !== aLevel) {
            return bLevel - aLevel;
        }
        var _a = a.name.toLowerCase();
        var _b = b.name.toLowerCase();
        if (_a > _b)
            return 1;
        else if (_a < _b)
            return -1;
        else
            return 0;
    }
    Rance.sortByManufactoryCapacityFN = sortByManufactoryCapacityFN;
    function rectContains(rect, point) {
        var x = point.x;
        var y = point.y;
        var x1 = Math.min(rect.x1, rect.x2);
        var x2 = Math.max(rect.x1, rect.x2);
        var y1 = Math.min(rect.y1, rect.y2);
        var y2 = Math.max(rect.y1, rect.y2);
        return ((x >= x1 && x <= x2) &&
            (y >= y1 && y <= y2));
    }
    Rance.rectContains = rectContains;
    function hexToString(hex) {
        hex = Math.round(hex);
        var converted = hex.toString(16);
        return '000000'.substr(0, 6 - converted.length) + converted;
    }
    Rance.hexToString = hexToString;
    function stringToHex(text) {
        if (text.charAt(0) === "#") {
            text = text.substring(1, 7);
        }
        return parseInt(text, 16);
    }
    Rance.stringToHex = stringToHex;
    function colorImageInPlayerColor(image, player) {
        var canvas = document.createElement("canvas");
        canvas.width = image.width;
        canvas.height = image.height;
        var ctx = canvas.getContext("2d");
        ctx.drawImage(image, 0, 0, image.width, image.height);
        ctx.globalCompositeOperation = "source-in";
        ctx.fillStyle = "#" + hexToString(player.color);
        ctx.fillRect(0, 0, image.width, image.height);
        return canvas.toDataURL();
    }
    Rance.colorImageInPlayerColor = colorImageInPlayerColor;
    // http://stackoverflow.com/a/1042676
    // extends 'from' object with members from 'to'. If 'to' is null, a deep clone of 'from' is returned
    // 
    // to[prop] = from[prop] seems to add a reference instead of actually copying value
    // so calling the constructor with "new" is needed
    function extendObject(from, to, onlyExtendAlreadyPresent) {
        if (onlyExtendAlreadyPresent === void 0) { onlyExtendAlreadyPresent = false; }
        if (from == null || typeof from != "object")
            return from;
        if (from.constructor != Object && from.constructor != Array)
            return from;
        if (from.constructor == Date || from.constructor == RegExp || from.constructor == Function ||
            from.constructor == String || from.constructor == Number || from.constructor == Boolean)
            return new from.constructor(from);
        to = to || new from.constructor();
        var toIterateOver = onlyExtendAlreadyPresent ? to : from;
        for (var name in toIterateOver) {
            if (!onlyExtendAlreadyPresent || from.hasOwnProperty(name)) {
                to[name] = extendObject(from[name], null);
            }
        }
        return to;
    }
    Rance.extendObject = extendObject;
    // https://github.com/KyleAMathews/deepmerge
    function deepMerge(target, src, excludeKeysNotInTarget) {
        if (excludeKeysNotInTarget === void 0) { excludeKeysNotInTarget = false; }
        if (excludeKeysNotInTarget) {
            var merged = deepMerge(target, src, false);
            return deletePropertiesNotSharedWithTarget(merged, target);
        }
        var array = Array.isArray(src);
        var dst = array && [] || {};
        if (array) {
            target = target || [];
            dst = dst.concat(target);
            src.forEach(function (e, i) {
                if (typeof dst[i] === 'undefined') {
                    dst[i] = e;
                }
                else if (typeof e === 'object') {
                    dst[i] = deepMerge(target[i], e);
                }
                else {
                    if (target.indexOf(e) === -1) {
                        dst.push(e);
                    }
                }
            });
        }
        else {
            if (target && typeof target === 'object') {
                Object.keys(target).forEach(function (key) {
                    dst[key] = target[key];
                });
            }
            Object.keys(src).forEach(function (key) {
                if (typeof src[key] !== 'object' || !src[key]) {
                    dst[key] = src[key];
                }
                else {
                    if (!target[key]) {
                        dst[key] = src[key];
                    }
                    else {
                        dst[key] = deepMerge(target[key], src[key]);
                    }
                }
            });
        }
        return dst;
    }
    Rance.deepMerge = deepMerge;
    function deletePropertiesNotSharedWithTarget(source, target) {
        var dst = {};
        for (var key in target) {
            if (typeof target[key] !== "object" || !target[key]) {
                dst[key] = source[key];
            }
            else {
                dst[key] = deletePropertiesNotSharedWithTarget(source[key], target[key]);
            }
        }
        return dst;
    }
    Rance.deletePropertiesNotSharedWithTarget = deletePropertiesNotSharedWithTarget;
    function recursiveRemoveAttribute(parent, attribute) {
        parent.removeAttribute(attribute);
        for (var i = 0; i < parent.children.length; i++) {
            var child = parent.children[i];
            recursiveRemoveAttribute(child, attribute);
        }
    }
    Rance.recursiveRemoveAttribute = recursiveRemoveAttribute;
    function clamp(value, min, max) {
        if (value < min)
            return min;
        else if (value > max)
            return max;
        else
            return value;
    }
    Rance.clamp = clamp;
    // http://stackoverflow.com/a/3254334
    function roundToNearestMultiple(value, multiple) {
        var resto = value % multiple;
        if (resto <= (multiple / 2)) {
            return value - resto;
        }
        else {
            return value + multiple - resto;
        }
    }
    Rance.roundToNearestMultiple = roundToNearestMultiple;
    function getAngleBetweenDegrees(degA, degB) {
        var angle = Math.abs(degB - degA) % 360;
        var distance = Math.min(360 - angle, angle);
        //console.log(degA, degB, distance);
        return distance;
    }
    Rance.getAngleBetweenDegrees = getAngleBetweenDegrees;
    function prettifyDate(date) {
        return ([
            [
                date.getDate(),
                date.getMonth() + 1,
                date.getFullYear().toString().slice(2, 4)
            ].join("/"),
            [
                date.getHours(),
                date.getMinutes().toString().length < 2 ? "0" + date.getMinutes() : date.getMinutes().toString()
            ].join(":")
        ].join(" "));
    }
    Rance.prettifyDate = prettifyDate;
    function getMatchingLocalstorageItemsByDate(stringToMatch) {
        var allKeys = Object.keys(localStorage);
        var matchingItems = [];
        for (var i = 0; i < allKeys.length; i++) {
            if (allKeys[i].indexOf(stringToMatch) !== -1) {
                var item = localStorage.getItem(allKeys[i]);
                var parsed = JSON.parse(item);
                if (parsed.date) {
                    matchingItems.push(parsed);
                }
            }
        }
        matchingItems.sort(function (a, b) {
            return Date.parse(b.date) - Date.parse(a.date);
        });
        return matchingItems;
    }
    Rance.getMatchingLocalstorageItemsByDate = getMatchingLocalstorageItemsByDate;
    function shuffleArray(toShuffle, seed) {
        var rng = new RNG(seed);
        var resultArray = toShuffle.slice(0);
        var i = resultArray.length;
        while (i > 0) {
            i--;
            var n = rng.random(0, i);
            var temp = resultArray[i];
            resultArray[i] = resultArray[n];
            resultArray[n] = temp;
        }
        return resultArray;
    }
    Rance.shuffleArray = shuffleArray;
    function getRelativeValue(value, min, max, inverse) {
        if (inverse === void 0) { inverse = false; }
        if (inverse) {
            if (min === max)
                return 0;
            else {
                return 1 - ((value - min) / (max - min));
            }
        }
        else {
            if (min === max)
                return 1;
            else {
                return (value - min) / (max - min);
            }
        }
    }
    Rance.getRelativeValue = getRelativeValue;
    function getRelativeWeightsFromObject(byCount, inverse) {
        var relativeWeights = {};
        var min = 0;
        var max;
        for (var prop in byCount) {
            var count = byCount[prop];
            max = isFinite(max) ? Math.max(max, count) : count;
        }
        for (var prop in byCount) {
            var count = byCount[prop];
            relativeWeights[prop] = getRelativeValue(count, min, max);
        }
        return relativeWeights;
    }
    Rance.getRelativeWeightsFromObject = getRelativeWeightsFromObject;
    function getDropTargetAtLocation(x, y) {
        var dropTargets = document.getElementsByClassName("drop-target");
        var point = {
            x: x,
            y: y
        };
        for (var i = 0; i < dropTargets.length; i++) {
            var node = dropTargets[i];
            var nodeBounds = node.getBoundingClientRect();
            var rect = {
                x1: nodeBounds.left,
                x2: nodeBounds.right,
                y1: nodeBounds.top,
                y2: nodeBounds.bottom
            };
            if (rectContains(rect, point)) {
                return node;
            }
        }
        return null;
    }
    Rance.getDropTargetAtLocation = getDropTargetAtLocation;
    function onDOMLoaded(onLoaded) {
        if (document.readyState === "interactive" || document.readyState === "complete") {
            onLoaded();
        }
        else {
            document.addEventListener('DOMContentLoaded', onLoaded);
        }
    }
    Rance.onDOMLoaded = onDOMLoaded;
    function meetAllPlayers() {
        for (var i = 0; i < app.game.playerOrder.length; i++) {
            var player = app.game.playerOrder[i];
            if (player !== app.humanPlayer) {
                app.humanPlayer.diplomacyStatus.meetPlayer(player);
            }
        }
    }
    Rance.meetAllPlayers = meetAllPlayers;
    function getItemsFromWeightedProbabilities(probabilities) {
        var allItems = [];
        if (probabilities.length === 0) {
            return allItems;
        }
        // weighted
        if (probabilities[0].weight) {
            var selected = getRandomArrayItemWithWeights(probabilities);
            var firstItem = selected.probabilityItems[0];
            if (firstItem.probabilityItems) {
                var probabilityItems = selected.probabilityItems;
                allItems = allItems.concat(getItemsFromWeightedProbabilities(probabilityItems));
            }
            else {
                var toAdd = selected.probabilityItems;
                allItems = allItems.concat(toAdd);
            }
        }
        else {
            // flat probability
            for (var i = 0; i < probabilities.length; i++) {
                var selected = probabilities[i];
                if (Math.random() < selected.flatProbability) {
                    var firstItem = selected.probabilityItems[0];
                    if (firstItem.probabilityItems) {
                        var probabilityItems = selected.probabilityItems;
                        allItems = allItems.concat(getItemsFromWeightedProbabilities(probabilityItems));
                    }
                    else {
                        var toAdd = selected.probabilityItems;
                        allItems = allItems.concat(toAdd);
                    }
                }
            }
        }
        return allItems;
    }
    Rance.getItemsFromWeightedProbabilities = getItemsFromWeightedProbabilities;
    function defaultNameGenerator(unit) {
        return "" + unit.id + " " + unit.template.displayName;
    }
    Rance.defaultNameGenerator = defaultNameGenerator;
    function transformMat3(a, m) {
        var x = m[0] * a.x + m[3] * a.y + m[6];
        var y = m[1] * a.x + m[4] * a.y + m[7];
        return { x: x, y: y };
    }
    Rance.transformMat3 = transformMat3;
    // creating a dummy sprite for attaching a shader to
    // works much better than using pixi filters
    function createDummySpriteForShader(x, y, width, height) {
        var texture = getDummyTextureForShader();
        var sprite = new PIXI.Sprite(texture);
        if (x || y) {
            sprite.position = new PIXI.Point(x || 0, y || 0);
        }
        if (width) {
            sprite.width = width;
        }
        if (height) {
            sprite.height = height;
        }
        return sprite;
    }
    Rance.createDummySpriteForShader = createDummySpriteForShader;
    function getDummyTextureForShader() {
        var canvas = document.createElement("canvas");
        canvas._pixiId = "dummyShaderTexture"; // pixi will reuse basetexture with this set
        canvas.width = 1;
        canvas.height = 1;
        return PIXI.Texture.fromCanvas(canvas);
    }
    Rance.getDummyTextureForShader = getDummyTextureForShader;
    function findEasingFunctionHighPoint(easingFunction, resolution, maxIterations, startIndex, endIndex, iteration) {
        if (resolution === void 0) { resolution = 10; }
        if (maxIterations === void 0) { maxIterations = 4; }
        if (startIndex === void 0) { startIndex = 0; }
        if (endIndex === void 0) { endIndex = 1; }
        if (iteration === void 0) { iteration = 0; }
        if (iteration >= maxIterations) {
            return (startIndex + endIndex) / 2;
        }
        var highestValue;
        var highestValueIndex;
        var step = (endIndex - startIndex) / resolution;
        for (var i = 0; i < resolution; i++) {
            var currentIndex = startIndex + i * step;
            var currentValue = easingFunction(currentIndex);
            if (!isFinite(highestValue) || currentValue > highestValue) {
                highestValue = currentValue;
                highestValueIndex = currentIndex;
            }
        }
        return findEasingFunctionHighPoint(easingFunction, resolution, maxIterations, highestValueIndex - step / 2, highestValueIndex + step / 2, iteration + 1);
    }
    Rance.findEasingFunctionHighPoint = findEasingFunctionHighPoint;
})(Rance || (Rance = {}));
/// <reference path="../../../src/templateinterfaces/iresourcetemplate.d.ts"/>
/// <reference path="../../../src/templateinterfaces/idistributable.d.ts" />
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var Templates;
            (function (Templates) {
                var Resources;
                (function (Resources) {
                    Resources.testResource1 = {
                        type: "testResource1",
                        displayName: "Test Resource 1",
                        icon: "modules\/default\/img\/resources\/test1.png",
                        rarity: 1,
                        distributionGroups: ["common"]
                    };
                    Resources.testResource2 = {
                        type: "testResource2",
                        displayName: "Test Resource 2",
                        icon: "modules\/default\/img\/resources\/test2.png",
                        rarity: 1,
                        distributionGroups: ["common"]
                    };
                    Resources.testResource3 = {
                        type: "testResource3",
                        displayName: "Test Resource 3",
                        icon: "modules\/default\/img\/resources\/test3.png",
                        rarity: 1,
                        distributionGroups: ["common"]
                    };
                    Resources.testResource4 = {
                        type: "testResource4",
                        displayName: "Test Resource 4",
                        icon: "modules\/default\/img\/resources\/test4.png",
                        rarity: 1,
                        distributionGroups: ["rare"]
                    };
                    Resources.testResource5 = {
                        type: "testResource5",
                        displayName: "Test Resource 5",
                        icon: "modules\/default\/img\/resources\/test5.png",
                        rarity: 1,
                        distributionGroups: ["rare"]
                    };
                })(Resources = Templates.Resources || (Templates.Resources = {}));
            })(Templates = DefaultModule.Templates || (DefaultModule.Templates = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
/// <reference path="templateinterfaces/ibuildingtemplate.d.ts" />
/// <reference path="savedata/ibuildingsavedata.d.ts" />
/// <reference path="star.ts" />
/// <reference path="player.ts" />
var Rance;
(function (Rance) {
    var Building = (function () {
        function Building(props) {
            this.template = props.template;
            this.id = (props.id && isFinite(props.id)) ?
                props.id : Rance.idGenerators.building++;
            this.location = props.location;
            this.controller = props.controller || this.location.owner;
            this.upgradeLevel = props.upgradeLevel || 1;
            this.totalCost = props.totalCost || this.template.buildCost || 0;
        }
        Building.prototype.getEffect = function (effect) {
            if (effect === void 0) { effect = {}; }
            if (!this.template.effect)
                return {};
            var multiplier = this.template.effectMultiplierFN ?
                this.template.effectMultiplierFN(this.upgradeLevel) :
                this.upgradeLevel;
            for (var key in this.template.effect) {
                var prop = this.template.effect[key];
                if (isFinite(prop)) {
                    if (!effect[key]) {
                        effect[key] = 0;
                    }
                    effect[key] += prop * multiplier;
                }
                else {
                    if (!effect[key]) {
                        effect[key] = {};
                    }
                    for (var key2 in prop) {
                        if (!effect[key][key2]) {
                            effect[key][key2] = 0;
                        }
                        effect[key][key2] += prop[key2] * multiplier;
                    }
                }
            }
            return effect;
        };
        Building.prototype.getPossibleUpgrades = function () {
            var self = this;
            var upgrades = [];
            if (this.upgradeLevel < this.template.maxUpgradeLevel) {
                upgrades.push({
                    template: this.template,
                    level: this.upgradeLevel + 1,
                    cost: this.template.buildCost * (this.upgradeLevel + 1),
                    parentBuilding: this
                });
            }
            else if (this.template.upgradeInto && this.template.upgradeInto.length > 0) {
                var templatedUpgrades = this.template.upgradeInto.map(function (upgradeData) {
                    var template = app.moduleData.Templates.Buildings[upgradeData.templateType];
                    return ({
                        level: upgradeData.level,
                        template: template,
                        cost: template.buildCost,
                        parentBuilding: self
                    });
                });
                upgrades = upgrades.concat(templatedUpgrades);
            }
            return upgrades;
        };
        Building.prototype.upgrade = function () {
        };
        Building.prototype.setController = function (newController) {
            var oldController = this.controller;
            if (oldController === newController)
                return;
            this.controller = newController;
            this.location.updateController();
        };
        Building.prototype.serialize = function () {
            var data = {
                templateType: this.template.type,
                id: this.id,
                locationId: this.location.id,
                controllerId: this.controller.id,
                upgradeLevel: this.upgradeLevel,
                totalCost: this.totalCost
            };
            return data;
        };
        return Building;
    }());
    Rance.Building = Building;
})(Rance || (Rance = {}));
/// <reference path="templateinterfaces/imanufacturablething.d.ts" />
/// <reference path="savedata/imanufactorysavedata.d.ts" />
var Rance;
(function (Rance) {
    var Manufactory = (function () {
        function Manufactory(star, serializedData) {
            this.buildQueue = [];
            this.unitStatsModifier = 1;
            this.unitHealthModifier = 1;
            this.star = star;
            this.player = star.owner;
            if (serializedData) {
                this.makeFromData(serializedData);
            }
            else {
                this.capacity = app.moduleData.ruleSet.manufactory.startingCapacity;
                this.maxCapacity = app.moduleData.ruleSet.manufactory.maxCapacity;
            }
        }
        Manufactory.prototype.makeFromData = function (data) {
            this.capacity = data.capacity;
            this.maxCapacity = data.maxCapacity;
            this.unitStatsModifier = data.unitStatsModifier;
            this.unitHealthModifier = data.unitHealthModifier;
            this.buildQueue = data.buildQueue.map(function (savedThing) {
                var templatesString;
                switch (savedThing.type) {
                    case "unit":
                        {
                            templatesString = "Units";
                            break;
                        }
                    case "item":
                        {
                            templatesString = "Items";
                        }
                }
                return ({
                    type: savedThing.type,
                    template: app.moduleData.Templates[templatesString][savedThing.templateType]
                });
            });
        };
        Manufactory.prototype.queueIsFull = function () {
            return this.buildQueue.length >= this.capacity;
        };
        Manufactory.prototype.addThingToQueue = function (template, type) {
            this.buildQueue.push({ type: type, template: template });
            this.player.money -= template.buildCost;
        };
        Manufactory.prototype.removeThingAtIndex = function (index) {
            var template = this.buildQueue[index].template;
            this.player.money += template.buildCost;
            this.buildQueue.splice(index, 1);
        };
        Manufactory.prototype.buildAllThings = function () {
            var units = [];
            var toBuild = this.buildQueue.slice(0, this.capacity);
            this.buildQueue = this.buildQueue.slice(this.capacity);
            while (toBuild.length > 0) {
                var thingData = toBuild.pop();
                switch (thingData.type) {
                    case "unit":
                        {
                            var unitTemplate = thingData.template;
                            var unit = new Rance.Unit(unitTemplate);
                            unit.setAttributes(this.unitStatsModifier);
                            unit.setBaseHealth(this.unitHealthModifier);
                            units.push(unit);
                            this.player.addUnit(unit);
                            break;
                        }
                    case "item":
                        {
                            var itemTemplate = thingData.template;
                            var item = new Rance.Item(itemTemplate);
                            this.player.addItem(item);
                            break;
                        }
                }
            }
            if (units.length > 0) {
                var fleet = new Rance.Fleet(this.player, units, this.star);
            }
            if (!this.player.isAI) {
                Rance.eventManager.dispatchEvent("playerManufactoryBuiltThings");
            }
        };
        Manufactory.prototype.getLocalUnitTypes = function () {
            var manufacturable = [];
            var potential = [];
            for (var i = 0; i < this.star.buildableUnitTypes.length; i++) {
                var type = this.star.buildableUnitTypes[i];
                if (!type.technologyRequirements || this.player.meetsTechnologyRequirements(type.technologyRequirements)) {
                    manufacturable.push(type);
                }
                else {
                    potential.push(type);
                }
            }
            return ({
                manufacturable: manufacturable,
                potential: potential
            });
        };
        Manufactory.prototype.getLocalItemTypes = function () {
            var manufacturable = [];
            var potential = [];
            // TODO manufactory
            return ({
                manufacturable: manufacturable,
                potential: potential
            });
        };
        Manufactory.prototype.getManufacturableThingsForType = function (type) {
            switch (type) {
                case "item":
                    {
                        return this.getLocalItemTypes().manufacturable;
                    }
                case "unit":
                    {
                        return this.getLocalUnitTypes().manufacturable;
                    }
            }
        };
        Manufactory.prototype.canManufactureThing = function (template, type) {
            var manufacturableThings = this.getManufacturableThingsForType(type);
            return manufacturableThings.indexOf(template) !== -1;
        };
        Manufactory.prototype.handleOwnerChange = function () {
            while (this.buildQueue.length > 0) {
                this.removeThingAtIndex(this.buildQueue.length - 1);
            }
            this.player = this.star.owner;
            this.capacity = Math.max(1, this.capacity - 1);
        };
        Manufactory.prototype.getCapacityUpgradeCost = function () {
            return app.moduleData.ruleSet.manufactory.buildCost * this.capacity;
        };
        Manufactory.prototype.upgradeCapacity = function (amount) {
            this.player.money -= this.getCapacityUpgradeCost();
            this.capacity = Math.min(this.capacity + amount, this.maxCapacity);
        };
        Manufactory.prototype.getUnitUpgradeCost = function () {
            var totalUpgrades = (this.unitStatsModifier + this.unitHealthModifier - 2) / 0.1;
            return Math.round((totalUpgrades + 1) * 100);
        };
        Manufactory.prototype.upgradeUnitStatsModifier = function (amount) {
            this.player.money -= this.getUnitUpgradeCost();
            this.unitStatsModifier += amount;
        };
        Manufactory.prototype.upgradeUnitHealthModifier = function (amount) {
            this.player.money -= this.getUnitUpgradeCost();
            this.unitHealthModifier += amount;
        };
        Manufactory.prototype.serialize = function () {
            var buildQueue = this.buildQueue.map(function (thingData) {
                return ({
                    type: thingData.type,
                    templateType: thingData.template.type
                });
            });
            return ({
                capacity: this.capacity,
                maxCapacity: this.maxCapacity,
                unitStatsModifier: this.unitStatsModifier,
                unitHealthModifier: this.unitHealthModifier,
                buildQueue: buildQueue
            });
        };
        return Manufactory;
    }());
    Rance.Manufactory = Manufactory;
})(Rance || (Rance = {}));
/// <reference path="../modules/default/templates/resources.ts" />
/// <reference path="templateinterfaces/iresourcetemplate.d.ts" />
/// <reference path="point.ts" />
/// <reference path="player.ts" />
/// <reference path="fleet.ts" />
/// <reference path="building.ts" />
/// <reference path="manufactory.ts" />
/// <reference path="ifleetattacktarget.d.ts" />
/// <reference path="savedata/istarsavedata.d.ts" />
var Rance;
(function (Rance) {
    var Star = (function () {
        function Star(x, y, id) {
            // separated so we can iterate through star[].linksTo to only get each connection once
            // use star.getAllLinks() for individual star connections
            this.linksTo = [];
            this.linksFrom = [];
            // can be used during map gen to attach temporary variables for easier debugging
            // nulled and deleted after map gen is done
            this.mapGenData = {};
            this.fleets = {};
            this.buildings = {};
            this.buildingsEffectIsDirty = true;
            this.indexedNeighborsInRange = {};
            this.indexedDistanceToStar = {};
            this.buildableUnitTypes = [];
            this.id = isFinite(id) ? id : Rance.idGenerators.star++;
            this.name = "Star " + this.id;
            this.x = x;
            this.y = y;
        }
        // BUILDINGS
        Star.prototype.addBuilding = function (building) {
            if (!this.buildings[building.template.category]) {
                this.buildings[building.template.category] = [];
            }
            var buildings = this.buildings[building.template.category];
            if (buildings.indexOf(building) >= 0) {
                throw new Error("Already has building");
            }
            buildings.push(building);
            this.buildingsEffectIsDirty = true;
            if (building.template.category === "defence") {
                this.sortDefenceBuildings();
                Rance.eventManager.dispatchEvent("renderLayer", "nonFillerStars", this);
            }
            if (building.template.category === "vision") {
                this.owner.updateVisibleStars();
            }
            if (this.owner === app.humanPlayer) {
                for (var key in building.template.effect) {
                    Rance.eventManager.dispatchEvent("builtBuildingWithEffect_" + key);
                }
                Rance.eventManager.dispatchEvent("humanPlayerBuiltBuilding");
            }
        };
        Star.prototype.removeBuilding = function (building) {
            if (!this.buildings[building.template.category] ||
                this.buildings[building.template.category].indexOf(building) < 0) {
                throw new Error("Location doesn't have building");
            }
            var buildings = this.buildings[building.template.category];
            this.buildings[building.template.category].splice(buildings.indexOf(building), 1);
            this.buildingsEffectIsDirty = true;
        };
        Star.prototype.sortDefenceBuildings = function () {
            this.buildings["defence"].sort(function (a, b) {
                if (a.template.maxPerType === 1) {
                    return -1;
                }
                else if (b.template.maxPerType === 1) {
                    return 1;
                }
                if (a.upgradeLevel !== b.upgradeLevel) {
                    return b.upgradeLevel - a.upgradeLevel;
                }
                return a.id - b.id;
            });
        };
        Star.prototype.getSecondaryController = function () {
            if (!this.buildings["defence"])
                return null;
            var defenceBuildings = this.buildings["defence"];
            for (var i = 0; i < defenceBuildings.length; i++) {
                if (defenceBuildings[i].controller !== this.owner) {
                    return defenceBuildings[i].controller;
                }
            }
            return null;
        };
        Star.prototype.updateController = function () {
            if (!this.buildings["defence"])
                return;
            var oldOwner = this.owner;
            var newOwner = this.buildings["defence"][0].controller;
            if (oldOwner) {
                if (oldOwner === newOwner)
                    return;
                oldOwner.removeStar(this);
            }
            newOwner.addStar(this);
            if (this.manufactory) {
                this.manufactory.handleOwnerChange();
            }
            Rance.eventManager.dispatchEvent("renderLayer", "nonFillerStars", this);
            Rance.eventManager.dispatchEvent("renderLayer", "starOwners", this);
            Rance.eventManager.dispatchEvent("renderLayer", "ownerBorders", this);
            // TODO display | update starOwners if secondary controller changes
        };
        Star.prototype.updateBuildingsEffect = function () {
            var effect = {};
            for (var category in this.buildings) {
                for (var i = 0; i < this.buildings[category].length; i++) {
                    var building = this.buildings[category][i];
                    building.getEffect(effect);
                }
            }
            this.buildingsEffect = effect;
            this.buildingsEffectIsDirty = false;
        };
        Star.prototype.getBuildingsEffect = function () {
            if (this.buildingsEffectIsDirty) {
                this.updateBuildingsEffect();
            }
            return this.buildingsEffect;
        };
        Star.prototype.getEffectWithBuildingsEffect = function (base, effectType) {
            var effect = base;
            var buildingsEffect = this.getBuildingsEffect()[effectType];
            if (isFinite(buildingsEffect)) {
                return effect + buildingsEffect;
            }
            else if (buildingsEffect) {
                effect += (buildingsEffect.flat || 0);
                effect *= (isFinite(buildingsEffect.multiplier) ? 1 + buildingsEffect.multiplier : 1);
            }
            return effect;
        };
        Star.prototype.getIncome = function () {
            return this.getEffectWithBuildingsEffect(this.baseIncome, "income");
        };
        Star.prototype.getResourceIncome = function () {
            if (!this.resource)
                return null;
            return ({
                resource: this.resource,
                amount: this.getEffectWithBuildingsEffect(0, "resourceIncome")
            });
        };
        Star.prototype.getResearchPoints = function () {
            return this.getEffectWithBuildingsEffect(0, "research");
        };
        Star.prototype.getAllBuildings = function () {
            var buildings = [];
            for (var category in this.buildings) {
                buildings = buildings.concat(this.buildings[category]);
            }
            return buildings;
        };
        Star.prototype.getBuildingsForPlayer = function (player) {
            var allBuildings = this.getAllBuildings();
            return allBuildings.filter(function (building) {
                return building.controller.id === player.id;
            });
        };
        Star.prototype.getBuildingsByFamily = function (buildingTemplate) {
            var propToCheck = buildingTemplate.family ? "family" : "type";
            var categoryBuildings = this.buildings[buildingTemplate.category];
            var buildings = [];
            if (categoryBuildings) {
                for (var i = 0; i < categoryBuildings.length; i++) {
                    if (categoryBuildings[i].template[propToCheck] === buildingTemplate[propToCheck]) {
                        buildings.push(categoryBuildings[i]);
                    }
                }
            }
            return buildings;
        };
        Star.prototype.getBuildableBuildings = function () {
            var canBuild = [];
            for (var buildingType in app.moduleData.Templates.Buildings) {
                var template = app.moduleData.Templates.Buildings[buildingType];
                var alreadyBuilt;
                if (template.category === "mine" && !this.resource) {
                    continue;
                }
                alreadyBuilt = this.getBuildingsByFamily(template);
                if (alreadyBuilt.length < template.maxPerType && !template.upgradeOnly) {
                    canBuild.push(template);
                }
            }
            return canBuild;
        };
        Star.prototype.getBuildingUpgrades = function () {
            var allUpgrades = {};
            var self = this;
            var ownerBuildings = this.getBuildingsForPlayer(this.owner);
            for (var i = 0; i < ownerBuildings.length; i++) {
                var building = ownerBuildings[i];
                var upgrades = building.getPossibleUpgrades();
                upgrades = upgrades.filter(function (upgradeData) {
                    var parent = upgradeData.parentBuilding.template;
                    var template = upgradeData.template;
                    if (parent.type === template.type) {
                        return true;
                    }
                    else {
                        var isSameFamily = (template.family && parent.family === template.family);
                        var maxAllowed = template.maxPerType;
                        if (isSameFamily) {
                            maxAllowed += 1;
                        }
                        var alreadyBuilt = self.getBuildingsByFamily(template);
                        return alreadyBuilt.length < maxAllowed;
                    }
                });
                if (upgrades.length > 0) {
                    allUpgrades[building.id] = upgrades;
                }
            }
            return allUpgrades;
        };
        // FLEETS
        Star.prototype.getAllFleets = function () {
            var allFleets = [];
            for (var playerId in this.fleets) {
                allFleets = allFleets.concat(this.fleets[playerId]);
            }
            return allFleets;
        };
        Star.prototype.getFleetIndex = function (fleet) {
            if (!this.fleets[fleet.player.id])
                return -1;
            return this.fleets[fleet.player.id].indexOf(fleet);
        };
        Star.prototype.hasFleet = function (fleet) {
            return this.getFleetIndex(fleet) >= 0;
        };
        Star.prototype.addFleet = function (fleet) {
            if (!this.fleets[fleet.player.id]) {
                this.fleets[fleet.player.id] = [];
            }
            if (this.hasFleet(fleet))
                return false;
            this.fleets[fleet.player.id].push(fleet);
        };
        Star.prototype.addFleets = function (fleets) {
            for (var i = 0; i < fleets.length; i++) {
                this.addFleet(fleets[i]);
            }
        };
        Star.prototype.removeFleet = function (fleet) {
            var fleetIndex = this.getFleetIndex(fleet);
            if (fleetIndex < 0)
                return false;
            this.fleets[fleet.player.id].splice(fleetIndex, 1);
            if (this.fleets[fleet.player.id].length === 0) {
                delete this.fleets[fleet.player.id];
            }
        };
        Star.prototype.removeFleets = function (fleets) {
            for (var i = 0; i < fleets.length; i++) {
                this.removeFleet(fleets[i]);
            }
        };
        Star.prototype.getAllUnitsOfPlayer = function (player) {
            var allUnits = [];
            var fleets = this.fleets[player.id];
            if (!fleets)
                return [];
            for (var i = 0; i < fleets.length; i++) {
                allUnits = allUnits.concat(fleets[i].units);
            }
            return allUnits;
        };
        Star.prototype.getAllUnits = function () {
            var allUnits = [];
            for (var playerId in this.fleets) {
                var fleets = this.fleets[playerId];
                allUnits = allUnits.concat(this.getAllUnitsOfPlayer(fleets[0].player));
            }
            return allUnits;
        };
        Star.prototype.getIndependentUnits = function () {
            var units = [];
            for (var playerId in this.fleets) {
                var player = this.fleets[playerId][0].player;
                if (player.isIndependent) {
                    units = units.concat(this.getAllUnitsOfPlayer(player));
                }
            }
            return units;
        };
        Star.prototype.getTargetsForPlayer = function (player) {
            var buildingTarget = this.getFirstEnemyDefenceBuilding(player);
            var buildingController = buildingTarget ? buildingTarget.controller : null;
            var fleetOwners = this.getEnemyFleetOwners(player, buildingController);
            var diplomacyStatus = player.diplomacyStatus;
            var targets = [];
            if (buildingTarget &&
                (player === this.owner ||
                    diplomacyStatus.canAttackBuildingOfPlayer(buildingTarget.controller))) {
                targets.push({
                    type: "building",
                    enemy: buildingTarget.controller,
                    building: buildingTarget,
                    units: this.getAllUnitsOfPlayer(buildingTarget.controller)
                });
            }
            for (var i = 0; i < fleetOwners.length; i++) {
                if (diplomacyStatus.canAttackFleetOfPlayer(fleetOwners[i])) {
                    targets.push({
                        type: "fleet",
                        enemy: fleetOwners[i],
                        building: null,
                        units: this.getAllUnitsOfPlayer(fleetOwners[i])
                    });
                }
            }
            return targets;
        };
        Star.prototype.getFirstEnemyDefenceBuilding = function (player) {
            if (!this.buildings["defence"])
                return null;
            var defenceBuildings = this.buildings["defence"].slice(0);
            if (this.owner === player)
                defenceBuildings = defenceBuildings.reverse();
            for (var i = defenceBuildings.length - 1; i >= 0; i--) {
                if (defenceBuildings[i].controller.id !== player.id) {
                    return defenceBuildings[i];
                }
            }
            return null;
        };
        Star.prototype.getEnemyFleetOwners = function (player, excludedTarget) {
            var fleetOwners = [];
            for (var playerId in this.fleets) {
                var intPlayerId = parseInt(playerId);
                if (intPlayerId == player.id)
                    continue;
                else if (excludedTarget && intPlayerId == excludedTarget.id)
                    continue;
                else if (this.fleets[playerId].length < 1)
                    continue;
                fleetOwners.push(this.fleets[playerId][0].player);
            }
            return fleetOwners;
        };
        // MAP GEN
        Star.prototype.setPosition = function (x, y) {
            this.x = x;
            this.y = y;
        };
        Star.prototype.setResource = function (resource) {
            this.resource = resource;
        };
        Star.prototype.hasLink = function (linkTo) {
            return this.linksTo.indexOf(linkTo) >= 0 || this.linksFrom.indexOf(linkTo) >= 0;
        };
        // could maybe use adding / removing links as a gameplay mechanic
        Star.prototype.addLink = function (linkTo) {
            if (this.hasLink(linkTo))
                return;
            this.linksTo.push(linkTo);
            linkTo.linksFrom.push(this);
        };
        Star.prototype.removeLink = function (linkTo, removeOpposite) {
            if (removeOpposite === void 0) { removeOpposite = true; }
            if (!this.hasLink(linkTo)) {
                throw new Error("Tried to remove nonexistant link between stars: " + this.id + " <-> " + linkTo.id);
            }
            var toIndex = this.linksTo.indexOf(linkTo);
            if (toIndex >= 0) {
                this.linksTo.splice(toIndex, 1);
            }
            else {
                this.linksFrom.splice(this.linksFrom.indexOf(linkTo), 1);
            }
            if (removeOpposite) {
                linkTo.removeLink(this, false);
            }
        };
        Star.prototype.getAllLinks = function () {
            return this.linksTo.concat(this.linksFrom);
        };
        Star.prototype.getEdgeWith = function (neighbor) {
            for (var i = 0; i < this.voronoiCell.halfedges.length; i++) {
                var edge = this.voronoiCell.halfedges[i].edge;
                if ((edge.lSite && edge.lSite === neighbor) ||
                    (edge.rSite && edge.rSite === neighbor)) {
                    return edge;
                }
            }
            return null;
        };
        Star.prototype.getSharedNeighborsWith = function (neighbor) {
            var ownNeighbors = this.getNeighbors();
            var neighborNeighbors = neighbor.getNeighbors();
            var sharedNeighbors = [];
            for (var i = 0; i < ownNeighbors.length; i++) {
                var star = ownNeighbors[i];
                if (star !== neighbor && neighborNeighbors.indexOf(star) !== -1) {
                    sharedNeighbors.push(star);
                }
            }
            return sharedNeighbors;
        };
        // return adjacent stars whether they're linked to this or not
        Star.prototype.getNeighbors = function () {
            var neighbors = [];
            for (var i = 0; i < this.voronoiCell.halfedges.length; i++) {
                var edge = this.voronoiCell.halfedges[i].edge;
                if (edge.lSite !== null && edge.lSite.id !== this.id) {
                    neighbors.push(edge.lSite);
                }
                else if (edge.rSite !== null && edge.rSite.id !== this.id) {
                    neighbors.push(edge.rSite);
                }
            }
            return neighbors;
        };
        Star.prototype.getLinkedInRange = function (range) {
            if (this.indexedNeighborsInRange[range]) {
                return this.indexedNeighborsInRange[range];
            }
            var visited = {};
            var visitedByRange = {};
            if (range >= 0) {
                visited[this.id] = this;
            }
            var current = [];
            var frontier = [this];
            for (var i = 0; i < range; i++) {
                current = frontier.slice(0);
                if (current.length <= 0)
                    break;
                frontier = [];
                visitedByRange[i + 1] = [];
                for (var j = 0; j < current.length; j++) {
                    var neighbors = current[j].getAllLinks();
                    for (var k = 0; k < neighbors.length; k++) {
                        if (visited[neighbors[k].id])
                            continue;
                        visited[neighbors[k].id] = neighbors[k];
                        visitedByRange[i + 1].push(neighbors[k]);
                        frontier.push(neighbors[k]);
                        this.indexedDistanceToStar[neighbors[k].id] = i;
                    }
                }
            }
            var allVisited = [];
            for (var id in visited) {
                allVisited.push(visited[id]);
            }
            this.indexedNeighborsInRange[range] =
                {
                    all: allVisited,
                    byRange: visitedByRange
                };
            return ({
                all: allVisited,
                byRange: visitedByRange
            });
        };
        // Recursively gets all neighbors that fulfill the callback condition with this star
        // Optional earlyReturnSize parameter returns if an island of specified size is found
        Star.prototype.getIslandForQualifier = function (qualifier, earlyReturnSize) {
            var visited = {};
            var connected = {};
            var sizeFound = 1;
            var initialStar = this;
            var frontier = [initialStar];
            visited[initialStar.id] = true;
            while (frontier.length > 0) {
                var current = frontier.pop();
                connected[current.id] = current;
                var neighbors = current.getLinkedInRange(1).all;
                for (var i = 0; i < neighbors.length; i++) {
                    var neighbor = neighbors[i];
                    if (visited[neighbor.id])
                        continue;
                    visited[neighbor.id] = true;
                    if (qualifier(current, neighbor)) {
                        sizeFound++;
                        frontier.push(neighbor);
                    }
                }
                // breaks when sufficiently big island has been found
                if (earlyReturnSize && sizeFound >= earlyReturnSize) {
                    for (var i = 0; i < frontier.length; i++) {
                        connected[frontier[i].id] = frontier[i];
                    }
                    break;
                }
            }
            var island = [];
            for (var starId in connected) {
                island.push(connected[starId]);
            }
            return island;
        };
        Star.prototype.getNearestStarForQualifier = function (qualifier) {
            if (qualifier(this))
                return this;
            var visited = {};
            var frontier = [this];
            visited[this.id] = true;
            while (frontier.length > 0) {
                var current = frontier.shift();
                var neighbors = current.getLinkedInRange(1).all;
                for (var i = 0; i < neighbors.length; i++) {
                    var neighbor = neighbors[i];
                    if (visited[neighbor.id])
                        continue;
                    visited[neighbor.id] = true;
                    if (qualifier(neighbor)) {
                        return neighbor;
                    }
                    else {
                        frontier.push(neighbor);
                    }
                }
            }
            return null;
        };
        Star.prototype.getDistanceToStar = function (target) {
            // don't index distance while generating map as distance can change
            // if (this.mapGenData)
            if (!app.game) {
                var a = Rance.aStar(this, target);
                return a.cost[target.id];
            }
            else if (!this.indexedDistanceToStar[target.id]) {
                var a = Rance.aStar(this, target);
                if (!a) {
                    this.indexedDistanceToStar[target.id] = -1;
                }
                else {
                    for (var id in a.cost) {
                        this.indexedDistanceToStar[id] = a.cost[id];
                    }
                }
            }
            return this.indexedDistanceToStar[target.id];
        };
        Star.prototype.getVisionRange = function () {
            return this.getEffectWithBuildingsEffect(1, "vision");
        };
        Star.prototype.getVision = function () {
            return this.getLinkedInRange(this.getVisionRange()).all;
        };
        Star.prototype.getDetectionRange = function () {
            return this.getEffectWithBuildingsEffect(0, "detection");
        };
        Star.prototype.getDetection = function () {
            return this.getLinkedInRange(this.getDetectionRange()).all;
        };
        Star.prototype.getHealingFactor = function (player) {
            var factor = 0;
            if (player === this.owner) {
                factor += 0.15;
            }
            return factor;
        };
        Star.prototype.getPresentPlayersByVisibility = function () {
            var byVisibilityAndId = {
                visible: {},
                detected: {},
                all: {}
            };
            var allPlayers = [];
            byVisibilityAndId.visible[this.owner.id] = this.owner;
            var secondaryController = this.getSecondaryController();
            if (secondaryController) {
                byVisibilityAndId.visible[secondaryController.id] = secondaryController;
            }
            for (var playerId in this.fleets) {
                var fleets = this.fleets[playerId];
                for (var i = 0; i < fleets.length; i++) {
                    var fleetPlayer = fleets[i].player;
                    if (byVisibilityAndId.detected[fleetPlayer.id] && byVisibilityAndId.visible[fleetPlayer.id]) {
                        break;
                    }
                    byVisibilityAndId.all[fleetPlayer.id] = fleetPlayer;
                    if (fleets[i].isStealthy) {
                        byVisibilityAndId.detected[fleetPlayer.id] = fleetPlayer;
                    }
                    else {
                        byVisibilityAndId.visible[fleetPlayer.id] = fleetPlayer;
                    }
                }
            }
            return byVisibilityAndId;
        };
        Star.prototype.getSeed = function () {
            if (!this.seed) {
                var bgString = "";
                bgString += Math.round(this.x);
                bgString += Math.round(this.y);
                bgString += new Date().getTime();
                this.seed = bgString;
            }
            return this.seed;
        };
        Star.prototype.buildManufactory = function () {
            this.manufactory = new Rance.Manufactory(this);
        };
        Star.prototype.serialize = function () {
            var buildings = {};
            for (var category in this.buildings) {
                buildings[category] = [];
                for (var i = 0; i < this.buildings[category].length; i++) {
                    buildings[category].push(this.buildings[category][i].serialize());
                }
            }
            var data = {
                id: this.id,
                x: this.basisX,
                y: this.basisY,
                baseIncome: this.baseIncome,
                name: this.name,
                ownerId: this.owner ? this.owner.id : null,
                linksToIds: this.linksTo.map(function (star) { return star.id; }),
                linksFromIds: this.linksFrom.map(function (star) { return star.id; }),
                seed: this.seed,
                buildableUnitTypes: this.buildableUnitTypes.map(function (template) {
                    return template.type;
                }),
                buildings: buildings,
            };
            if (this.resource) {
                data.resourceType = this.resource.type;
            }
            if (this.manufactory) {
                data.manufactory = this.manufactory.serialize();
            }
            return data;
        };
        return Star;
    }());
    Rance.Star = Star;
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    // not very efficient. probably doesn't matter though
    var PriorityQueue = (function () {
        function PriorityQueue() {
            this.items = {};
        }
        PriorityQueue.prototype.isEmpty = function () {
            if (Object.keys(this.items).length > 0)
                return false;
            else
                return true;
        };
        PriorityQueue.prototype.push = function (priority, data) {
            if (!this.items[priority]) {
                this.items[priority] = [];
            }
            this.items[priority].push(data);
        };
        PriorityQueue.prototype.pop = function () {
            var highestPriority = Math.min.apply(null, Object.keys(this.items));
            var toReturn = this.items[highestPriority].pop();
            if (this.items[highestPriority].length < 1) {
                delete this.items[highestPriority];
            }
            return toReturn;
        };
        PriorityQueue.prototype.peek = function () {
            var highestPriority = Math.min.apply(null, Object.keys(this.items));
            var toReturn = this.items[highestPriority][0];
            return [highestPriority, toReturn.mapPosition[1], toReturn.mapPosition[2]];
        };
        return PriorityQueue;
    }());
    Rance.PriorityQueue = PriorityQueue;
})(Rance || (Rance = {}));
/// <reference path="star.ts" />
/// <reference path="priorityqueue.ts" />
var Rance;
(function (Rance) {
    function backTrace(graph, target) {
        var parent = graph[target.id];
        if (!parent)
            return [];
        var path = [
            {
                star: target,
                cost: parent.cost
            }
        ];
        while (parent) {
            path.push({
                star: parent.star,
                cost: parent.cost
            });
            parent = graph[parent.star.id];
        }
        path.reverse();
        path[0].cost = null;
        return path;
    }
    Rance.backTrace = backTrace;
    function aStar(start, target) {
        var frontier = new Rance.PriorityQueue();
        frontier.push(0, start);
        //var frontier = new EasyStar.PriorityQueue("p", 1);
        //frontier.insert({p: 0, tile: start})
        var cameFrom = {};
        var costSoFar = {};
        cameFrom[start.id] = null;
        costSoFar[start.id] = 0;
        while (!frontier.isEmpty()) 
        //while (frontier.length > 0)
        {
            var current = frontier.pop();
            //var current = frontier.shiftHighestPriorityElement().tile;
            if (current === target)
                return { came: cameFrom, cost: costSoFar, queue: frontier };
            var neighbors = current.getAllLinks();
            for (var i = 0; i < neighbors.length; i++) {
                var neigh = neighbors[i];
                if (!neigh)
                    continue;
                var moveCost = 1;
                var newCost = costSoFar[current.id] + moveCost;
                if (costSoFar[neigh.id] === undefined || newCost < costSoFar[neigh.id]) {
                    costSoFar[neigh.id] = newCost;
                    // ^ done
                    var dx = Math.abs(neigh.id[1] - target.id[1]);
                    var dy = Math.abs(neigh.id[2] - target.id[2]);
                    var priority = newCost;
                    frontier.push(priority, neigh);
                    //frontier.insert({p: priority, tile: neigh});
                    cameFrom[neigh.id] =
                        {
                            star: current,
                            cost: moveCost
                        };
                }
            }
        }
        return null; // didnt find path 
    }
    Rance.aStar = aStar;
})(Rance || (Rance = {}));
/// <reference path="templateinterfaces/istatuseffecttemplate.d.ts" />
var Rance;
(function (Rance) {
    var StatusEffect = (function () {
        function StatusEffect(template, duration) {
            this.template = template;
            this.duration = duration;
        }
        StatusEffect.prototype.processTurnEnd = function () {
            if (this.duration > 0) {
                this.duration--;
            }
        };
        StatusEffect.prototype.clone = function () {
            return new StatusEffect(this.template, this.duration);
        };
        return StatusEffect;
    }());
    Rance.StatusEffect = StatusEffect;
})(Rance || (Rance = {}));
/// <reference path="player.ts" />
/// <reference path="unit.ts" />
/// <reference path="star.ts" />
/// <reference path="pathfinding.ts"/>
/// <reference path="savedata/ifleetsavedata.d.ts" />
var Rance;
(function (Rance) {
    var Fleet = (function () {
        function Fleet(player, units, location, id, shouldRender) {
            if (shouldRender === void 0) { shouldRender = true; }
            this.units = [];
            this.visionIsDirty = true;
            this.visibleStars = [];
            this.detectedStars = [];
            this.player = player;
            this.location = location;
            this.id = isFinite(id) ? id : Rance.idGenerators.fleet++;
            this.name = "Fleet " + this.id;
            this.location.addFleet(this);
            this.player.addFleet(this);
            this.addUnits(units);
            if (shouldRender) {
                Rance.eventManager.dispatchEvent("renderLayer", "fleets", this.location);
            }
        }
        Fleet.prototype.getUnitIndex = function (unit) {
            return this.units.indexOf(unit);
        };
        Fleet.prototype.hasUnit = function (unit) {
            return this.getUnitIndex(unit) >= 0;
        };
        Fleet.prototype.deleteFleet = function (shouldRender) {
            if (shouldRender === void 0) { shouldRender = true; }
            this.location.removeFleet(this);
            this.player.removeFleet(this);
            if (shouldRender) {
                Rance.eventManager.dispatchEvent("renderLayer", "fleets", this.location);
            }
        };
        Fleet.prototype.mergeWith = function (fleet, shouldRender) {
            if (shouldRender === void 0) { shouldRender = true; }
            if (fleet.isStealthy !== this.isStealthy) {
                console.warn("Tried to merge stealthy fleet with non stealthy or other way around");
                return;
            }
            fleet.addUnits(this.units);
            this.deleteFleet(shouldRender);
        };
        Fleet.prototype.addUnit = function (unit) {
            if (this.hasUnit(unit))
                return false;
            if (this.units.length === 0) {
                this.isStealthy = unit.isStealthy();
            }
            else if (unit.isStealthy() !== this.isStealthy) {
                console.warn("Tried to add stealthy unit to non stealthy fleet or other way around");
                return;
            }
            this.units.push(unit);
            unit.addToFleet(this);
            this.visionIsDirty = true;
        };
        Fleet.prototype.addUnits = function (units) {
            for (var i = 0; i < units.length; i++) {
                this.addUnit(units[i]);
            }
        };
        Fleet.prototype.removeUnit = function (unit) {
            var index = this.getUnitIndex(unit);
            if (index < 0)
                return false;
            this.units.splice(index, 1);
            unit.removeFromFleet();
            this.visionIsDirty = true;
            if (this.units.length <= 0) {
                this.deleteFleet();
            }
        };
        Fleet.prototype.removeUnits = function (units) {
            for (var i = 0; i < units.length; i++) {
                this.removeUnit(units[i]);
            }
        };
        Fleet.prototype.transferUnit = function (fleet, unit) {
            if (fleet === this)
                return;
            if (unit.isStealthy() !== this.isStealthy) {
                console.warn("Tried to transfer stealthy unit to non stealthy fleet");
                return;
            }
            var index = this.getUnitIndex(unit);
            if (index < 0)
                return false;
            fleet.addUnit(unit);
            this.units.splice(index, 1);
            Rance.eventManager.dispatchEvent("renderLayer", "fleets", this.location);
        };
        Fleet.prototype.split = function () {
            var newFleet = new Fleet(this.player, [], this.location);
            this.location.addFleet(newFleet);
            return newFleet;
        };
        Fleet.prototype.splitStealthyUnits = function () {
            var stealthyUnits = this.units.filter(function (unit) {
                return unit.isStealthy();
            });
            var newFleet = new Fleet(this.player, stealthyUnits, this.location);
            this.location.addFleet(newFleet);
            this.removeUnits(stealthyUnits);
            return newFleet;
        };
        Fleet.prototype.getMinCurrentMovePoints = function () {
            if (!this.units[0])
                return 0;
            var min = this.units[0].currentMovePoints;
            for (var i = 0; i < this.units.length; i++) {
                min = Math.min(this.units[i].currentMovePoints, min);
            }
            return min;
        };
        Fleet.prototype.getMinMaxMovePoints = function () {
            if (!this.units[0])
                return 0;
            var min = this.units[0].maxMovePoints;
            for (var i = 0; i < this.units.length; i++) {
                min = Math.min(this.units[i].maxMovePoints, min);
            }
            return min;
        };
        Fleet.prototype.canMove = function () {
            for (var i = 0; i < this.units.length; i++) {
                if (this.units[i].currentMovePoints <= 0) {
                    return false;
                }
            }
            if (this.getMinCurrentMovePoints() > 0) {
                return true;
            }
            return false;
        };
        Fleet.prototype.subtractMovePoints = function () {
            for (var i = 0; i < this.units.length; i++) {
                this.units[i].currentMovePoints--;
            }
        };
        Fleet.prototype.move = function (newLocation) {
            if (newLocation === this.location)
                return;
            if (!this.canMove())
                return;
            var oldLocation = this.location;
            oldLocation.removeFleet(this);
            this.location = newLocation;
            newLocation.addFleet(this);
            this.subtractMovePoints();
            this.visionIsDirty = true;
            this.player.visionIsDirty = true;
            // maybe send an event instead?
            for (var i = 0; i < app.game.playerOrder.length; i++) {
                var player = app.game.playerOrder[i];
                if (player.isIndependent || player === this.player) {
                    continue;
                }
                player.updateAllVisibilityInStar(newLocation);
            }
            Rance.eventManager.dispatchEvent("renderLayer", "fleets", this.location);
            Rance.eventManager.dispatchEvent("updateSelection", null);
        };
        Fleet.prototype.getPathTo = function (newLocation) {
            var a = Rance.aStar(this.location, newLocation);
            if (!a)
                return;
            var path = Rance.backTrace(a.came, newLocation);
            return path;
        };
        Fleet.prototype.pathFind = function (newLocation, onMove, afterMove) {
            var path = this.getPathTo(newLocation);
            var interval = window.setInterval(function () {
                if (!path || path.length <= 0) {
                    window.clearInterval(interval);
                    if (afterMove)
                        afterMove();
                    return;
                }
                var move = path.shift();
                this.move(move.star);
                if (onMove)
                    onMove();
            }.bind(this), 10);
        };
        Fleet.prototype.getFriendlyFleetsAtOwnLocation = function () {
            return this.location.fleets[this.player.id];
        };
        Fleet.prototype.getTotalStrengthEvaluation = function () {
            var total = 0;
            for (var i = 0; i < this.units.length; i++) {
                total += this.units[i].getStrengthEvaluation();
            }
            return total;
        };
        Fleet.prototype.getTotalHealth = function () {
            var total = {
                current: 0,
                max: 0
            };
            for (var i = 0; i < this.units.length; i++) {
                total.current += this.units[i].currentHealth;
                total.max += this.units[i].maxHealth;
            }
            return total;
        };
        Fleet.prototype.updateVisibleStars = function () {
            var highestVisionRange = 0;
            var highestDetectionRange = -1;
            for (var i = 0; i < this.units.length; i++) {
                highestVisionRange = Math.max(this.units[i].getVisionRange(), highestVisionRange);
                highestDetectionRange = Math.max(this.units[i].getDetectionRange(), highestDetectionRange);
            }
            var inVision = this.location.getLinkedInRange(highestVisionRange);
            var inDetection = this.location.getLinkedInRange(highestDetectionRange);
            this.visibleStars = inVision.all;
            this.detectedStars = inDetection.all;
            this.visionIsDirty = false;
        };
        Fleet.prototype.getVision = function () {
            if (this.visionIsDirty) {
                this.updateVisibleStars();
            }
            return this.visibleStars;
        };
        Fleet.prototype.getDetection = function () {
            if (this.visionIsDirty) {
                this.updateVisibleStars();
            }
            return this.detectedStars;
        };
        Fleet.prototype.serialize = function () {
            var data = {
                id: this.id,
                name: this.name,
                locationId: this.location.id,
                playerId: this.player.id,
                units: this.units.map(function (unit) {
                    return unit.serialize(false);
                })
            };
            return data;
        };
        return Fleet;
    }());
    Rance.Fleet = Fleet;
})(Rance || (Rance = {}));
/// <reference path="../lib/husl.d.ts" />
/// <reference path="range.ts" />
var Rance;
(function (Rance) {
    function hex2rgb(hex) {
        return ([
            (hex >> 16 & 0xFF) / 255,
            (hex >> 8 & 0xFF) / 255,
            (hex & 0xFF) / 255
        ]);
    }
    Rance.hex2rgb = hex2rgb;
    function rgb2hex(rgb) {
        return ((rgb[0] * 255 << 16) + (rgb[1] * 255 << 8) + rgb[2] * 255);
    }
    Rance.rgb2hex = rgb2hex;
    //http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
    /* accepts parameters
     * h  Object = {h:x, s:y, v:z}
     * OR
     * h, s, v
    */
    function hsvToRgb(h, s, v) {
        var r, g, b, i, f, p, q, t;
        i = Math.floor(h * 6);
        f = h * 6 - i;
        p = v * (1 - s);
        q = v * (1 - f * s);
        t = v * (1 - (1 - f) * s);
        switch (i % 6) {
            case 0:
                r = v, g = t, b = p;
                break;
            case 1:
                r = q, g = v, b = p;
                break;
            case 2:
                r = p, g = v, b = t;
                break;
            case 3:
                r = p, g = q, b = v;
                break;
            case 4:
                r = t, g = p, b = v;
                break;
            case 5:
                r = v, g = p, b = q;
                break;
        }
        return [r, g, b];
    }
    Rance.hsvToRgb = hsvToRgb;
    function hslToRgb(h, s, l) {
        var r, g, b;
        if (s == 0) {
            r = g = b = l; // achromatic
        }
        else {
            function hue2rgb(p, q, t) {
                if (t < 0)
                    t += 1;
                if (t > 1)
                    t -= 1;
                if (t < 1 / 6)
                    return p + (q - p) * 6 * t;
                if (t < 1 / 2)
                    return q;
                if (t < 2 / 3)
                    return p + (q - p) * (2 / 3 - t) * 6;
                return p;
            }
            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            var p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
        }
        return [r, g, b];
    }
    Rance.hslToRgb = hslToRgb;
    function rgbToHsv(r, g, b) {
        var max = Math.max(r, g, b), min = Math.min(r, g, b);
        var h, s, v = max;
        var d = max - min;
        s = max == 0 ? 0 : d / max;
        if (max == min) {
            h = 0; // achromatic
        }
        else {
            switch (max) {
                case r:
                    h = (g - b) / d + (g < b ? 6 : 0);
                    break;
                case g:
                    h = (b - r) / d + 2;
                    break;
                case b:
                    h = (r - g) / d + 4;
                    break;
            }
            h /= 6;
        }
        return [h, s, v];
    }
    Rance.rgbToHsv = rgbToHsv;
    function rgbToHsl(r, g, b) {
        var max = Math.max(r, g, b), min = Math.min(r, g, b);
        var h, s, l = (max + min) / 2;
        if (max == min) {
            h = s = 0; // achromatic
        }
        else {
            var d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r:
                    h = (g - b) / d + (g < b ? 6 : 0);
                    break;
                case g:
                    h = (b - r) / d + 2;
                    break;
                case b:
                    h = (r - g) / d + 4;
                    break;
            }
            h /= 6;
        }
        return [h, s, l];
    }
    Rance.rgbToHsl = rgbToHsl;
    function hslToHex(h, s, l) {
        return rgb2hex(hslToRgb(h, s, l));
    }
    Rance.hslToHex = hslToHex;
    function hsvToHex(h, s, v) {
        return rgb2hex(hsvToRgb(h, s, v));
    }
    Rance.hsvToHex = hsvToHex;
    function hexToHsl(hex) {
        return rgbToHsl.apply(null, hex2rgb(hex));
    }
    Rance.hexToHsl = hexToHsl;
    function hexToHsv(hex) {
        return rgbToHsv.apply(null, hex2rgb(hex));
    }
    Rance.hexToHsv = hexToHsv;
    function excludeFromRanges(ranges, toExclude) {
        var intersecting = getIntersectingRanges(ranges, toExclude);
        var newRanges = ranges.slice(0);
        for (var i = 0; i < intersecting.length; i++) {
            newRanges.splice(newRanges.indexOf(intersecting[i]), 1);
            var intersectedRanges = excludeFromRange(intersecting[i], toExclude);
            if (intersectedRanges) {
                newRanges = newRanges.concat(intersectedRanges);
            }
        }
        return newRanges;
    }
    Rance.excludeFromRanges = excludeFromRanges;
    function getIntersectingRanges(ranges, toIntersectWith) {
        var intersecting = [];
        for (var i = 0; i < ranges.length; i++) {
            var range = ranges[i];
            if (toIntersectWith.max < range.min || toIntersectWith.min > range.max) {
                continue;
            }
            intersecting.push(range);
        }
        return intersecting;
    }
    Rance.getIntersectingRanges = getIntersectingRanges;
    function excludeFromRange(range, toExclude) {
        if (toExclude.max < range.min || toExclude.min > range.max) {
            return null;
        }
        else if (toExclude.min < range.min && toExclude.max > range.max) {
            return null;
        }
        if (toExclude.min <= range.min) {
            return ([{ min: toExclude.max, max: range.max }]);
        }
        else if (toExclude.max >= range.max) {
            return ([{ min: range.min, max: toExclude.min }]);
        }
        var a = {
            min: range.min,
            max: toExclude.min
        };
        var b = {
            min: toExclude.max,
            max: range.max
        };
        return [a, b];
    }
    Rance.excludeFromRange = excludeFromRange;
    function randomSelectFromRanges(ranges) {
        var totalWeight = 0;
        var rangesByRelativeWeight = {};
        var currentRelativeWeight = 0;
        for (var i = 0; i < ranges.length; i++) {
            var range = ranges[i];
            if (!isFinite(range.max))
                range.max = 1;
            if (!isFinite(range.min))
                range.min = 0;
            var weight = range.max - range.min;
            totalWeight += weight;
        }
        for (var i = 0; i < ranges.length; i++) {
            var range = ranges[i];
            var relativeWeight = (range.max - range.min) / totalWeight;
            if (totalWeight === 0)
                relativeWeight = 1;
            currentRelativeWeight += relativeWeight;
            rangesByRelativeWeight[currentRelativeWeight] = range;
        }
        var rand = Math.random();
        var selectedRange;
        var sortedWeights = Object.keys(rangesByRelativeWeight).map(function (w) {
            return parseFloat(w);
        });
        var sortedWeights = sortedWeights.sort();
        for (var i = 0; i < sortedWeights.length; i++) {
            if (rand < sortedWeights[i]) {
                selectedRange = rangesByRelativeWeight[sortedWeights[i]];
                break;
            }
        }
        if (!selectedRange)
            console.log(rangesByRelativeWeight);
        return Rance.randRange(selectedRange.min, selectedRange.max);
    }
    Rance.randomSelectFromRanges = randomSelectFromRanges;
    function makeRandomVibrantColor() {
        var hRanges = [
            { min: 0, max: 90 / 360 },
            { min: 120 / 360, max: 150 / 360 },
            { min: 180 / 360, max: 290 / 360 },
            { min: 320 / 360, max: 1 }
        ];
        return [randomSelectFromRanges(hRanges), Rance.randRange(0.8, 0.9), Rance.randRange(0.88, 0.92)];
    }
    Rance.makeRandomVibrantColor = makeRandomVibrantColor;
    function makeRandomDeepColor() {
        // yellow
        if (Math.random() < 0.1) {
            return [Rance.randRange(15 / 360, 80 / 360), Rance.randRange(0.92, 1), Rance.randRange(0.92, 1)];
        }
        var hRanges = [
            { min: 0, max: 15 / 360 },
            { min: 100 / 360, max: 195 / 360 },
            { min: 210 / 360, max: 1 }
        ];
        return [randomSelectFromRanges(hRanges), 1, Rance.randRange(0.55, 0.65)];
    }
    Rance.makeRandomDeepColor = makeRandomDeepColor;
    function makeRandomLightColor() {
        return [Rance.randRange(0, 360), Rance.randRange(0.55, 0.65), 1];
    }
    Rance.makeRandomLightColor = makeRandomLightColor;
    function makeRandomColor(values) {
        values = values || {};
        var color = {};
        ["h", "s", "l"].forEach(function (v) {
            if (!values[v])
                values[v] = [];
        });
        for (var value in values) {
            if (values[value].length < 1) {
                values[value] = [{ min: 0, max: 1 }];
            }
            color[value] = randomSelectFromRanges(values[value]);
        }
        return [color.h, color.s, color.l];
    }
    Rance.makeRandomColor = makeRandomColor;
    function colorFromScalars(color) {
        return [color[0] * 360, color[1] * 100, color[2] * 100];
    }
    Rance.colorFromScalars = colorFromScalars;
    function scalarsFromColor(scalars) {
        return [scalars[0] / 360, scalars[1] / 100, scalars[2] / 100];
    }
    Rance.scalarsFromColor = scalarsFromColor;
    function makeContrastingColor(props) {
        var initialRanges = props.initialRanges || {};
        var exclusions = props.minDifference || {};
        var maxDifference = props.maxDifference || {};
        var color = props.color;
        var hMaxDiffernece = isFinite(maxDifference.h) ?
            maxDifference.h : 360;
        var sMaxDiffernece = isFinite(maxDifference.s) ?
            maxDifference.s : 100;
        var lMaxDiffernece = isFinite(maxDifference.l) ?
            maxDifference.l : 100;
        var hRange = initialRanges.h || { min: 0, max: 360 };
        var sRange = initialRanges.s || { min: 50, max: 100 };
        var lRange = initialRanges.l || { min: 0, max: 100 };
        var hExclusion = exclusions.h || 30;
        var hMin = (color[0] - hExclusion) % 360;
        var hMax = (color[0] + hExclusion) % 360;
        var hRange2 = excludeFromRange(hRange, { min: hMin, max: hMax });
        var h = randomSelectFromRanges(hRange2);
        h = Rance.clamp(h, color[0] - hMaxDiffernece, color[0] + hMaxDiffernece);
        var hDistance = Rance.getAngleBetweenDegrees(h, color[0]);
        var relativeHDistance = 1 / (180 / hDistance);
        var lExclusion = exclusions.l || 30;
        // if (relativeHDistance < 0.2)
        // {
        //   lExclusion /= 2;
        //   clamp(lExclusion, 0, 100);
        // }
        // 
        var lMin = Rance.clamp(color[2] - lExclusion, lRange.min, 100);
        var lMax = Rance.clamp(color[2] + lExclusion, lMin, 100);
        var sExclusion = exclusions.s || 0;
        var sMin = Rance.clamp(color[1] - sExclusion, sRange.min, 100);
        var sMax = Rance.clamp(color[1] + sExclusion, sMin, 100);
        var ranges = {
            h: [{ min: h, max: h }],
            s: excludeFromRange(sRange, { min: sMin, max: sMax }),
            l: excludeFromRange(lRange, { min: lMin, max: lMax }),
        };
        return makeRandomColor(ranges);
    }
    Rance.makeContrastingColor = makeContrastingColor;
    function hexToHusl(hex) {
        return HUSL.fromHex(Rance.hexToString(hex));
    }
    Rance.hexToHusl = hexToHusl;
    function generateMainColor() {
        var color;
        var hexColor;
        var genType;
        if (Math.random() < 0.6) {
            color = makeRandomDeepColor();
            hexColor = hsvToHex.apply(null, color);
            genType = "deep";
        }
        else if (Math.random() < 0.25) {
            color = makeRandomLightColor();
            hexColor = hsvToHex.apply(null, color);
            genType = "light";
        }
        else if (Math.random() < 0.3) {
            color = makeRandomVibrantColor();
            hexColor = hsvToHex.apply(null, color);
            genType = "vibrant";
        }
        else {
            color = makeRandomColor({
                s: [{ min: 1, max: 1 }],
                l: [{ min: 0.88, max: 1 }]
            });
            hexColor = Rance.stringToHex(HUSL.toHex.apply(null, colorFromScalars(color)));
            genType = "husl";
        }
        var huslColor = hexToHusl(hexColor);
        huslColor[2] = Rance.clamp(huslColor[2], 30, 100);
        hexColor = Rance.stringToHex(HUSL.toHex.apply(null, huslColor));
        return hexColor;
    }
    Rance.generateMainColor = generateMainColor;
    function generateSecondaryColor(mainColor) {
        var huslColor = hexToHusl(mainColor);
        var hexColor;
        if (huslColor[2] < 0.3 || Math.random() < 0.4) {
            var contrastingColor = makeContrastingColor({
                color: huslColor,
                minDifference: {
                    h: 30,
                    l: 30
                }
            });
            hexColor = Rance.stringToHex(HUSL.toHex.apply(null, contrastingColor));
        }
        else {
            function contrasts(c1, c2) {
                return ((c1[2] < c2[2] - 20 || c1[2] > c2[2] + 20));
            }
            function makeColor(c1, easing) {
                var hsvColor = hexToHsv(c1); // scalar
                hsvColor = colorFromScalars(hsvColor);
                var contrastingColor = makeContrastingColor({
                    color: hsvColor,
                    initialRanges: {
                        l: { min: 60 * easing, max: 100 }
                    },
                    minDifference: {
                        h: 20 * easing,
                        s: 30 * easing
                    }
                });
                var hex = hsvToHex.apply(null, scalarsFromColor(contrastingColor));
                return hexToHusl(hex);
            }
            var huslBg = hexToHusl(mainColor);
            var easing = 1;
            var candidateColor = makeColor(mainColor, easing);
            while (!contrasts(huslBg, candidateColor)) {
                easing -= 0.1;
                candidateColor = makeColor(mainColor, easing);
            }
            hexColor = Rance.stringToHex(HUSL.toHex.apply(null, candidateColor));
        }
        return hexColor;
    }
    Rance.generateSecondaryColor = generateSecondaryColor;
    function generateColorScheme(mainColor) {
        var mainColor = mainColor !== null && isFinite(mainColor) ?
            mainColor :
            generateMainColor();
        var secondaryColor = generateSecondaryColor(mainColor);
        return ({
            main: mainColor,
            secondary: secondaryColor
        });
    }
    Rance.generateColorScheme = generateColorScheme;
    function checkRandomGenHues(amt) {
        var maxBarSize = 80;
        var hues = {};
        for (var i = 0; i < amt; i++) {
            var color = generateMainColor();
            var hue = colorFromScalars(hexToHsv(color))[0];
            var roundedHue = Math.round(hue / 10) * 10;
            if (!hues[roundedHue])
                hues[roundedHue] = 0;
            hues[roundedHue]++;
        }
        var min;
        var max;
        for (var _hue in hues) {
            var count = hues[_hue];
            if (!min) {
                min = count;
            }
            if (!max) {
                max = count;
            }
            min = Math.min(min, count);
            max = Math.max(max, count);
        }
        var args = [""];
        var toPrint = "";
        for (var _hue in hues) {
            var hue = parseInt(_hue);
            var color = hsvToHex(hue / 360, 1, 1);
            var count = hues[_hue];
            var difference = max - min;
            var relative = (count - min) / difference;
            var chars = relative * maxBarSize;
            var line = "\n%c ";
            for (var i = 0; i < chars; i++) {
                line += "#";
            }
            toPrint += line;
            args.push("color: " + "#" + Rance.hexToString(color));
        }
        args[0] = toPrint;
        console.log.apply(console, args);
    }
    Rance.checkRandomGenHues = checkRandomGenHues;
})(Rance || (Rance = {}));
/// <reference path="../lib/rng.d.ts" />
/// <reference path="templateinterfaces/isubemblemtemplate.d.ts" />
/// <reference path="savedata/iemblemsavedata.d.ts" />
/// <reference path="color.ts"/>
var Rance;
(function (Rance) {
    (function (SubEmblemCoverage) {
        SubEmblemCoverage[SubEmblemCoverage["inner"] = 0] = "inner";
        SubEmblemCoverage[SubEmblemCoverage["outer"] = 1] = "outer";
        SubEmblemCoverage[SubEmblemCoverage["both"] = 2] = "both";
    })(Rance.SubEmblemCoverage || (Rance.SubEmblemCoverage = {}));
    var SubEmblemCoverage = Rance.SubEmblemCoverage;
    (function (SubEmblemPosition) {
        SubEmblemPosition[SubEmblemPosition["foreground"] = 0] = "foreground";
        SubEmblemPosition[SubEmblemPosition["background"] = 1] = "background";
        SubEmblemPosition[SubEmblemPosition["both"] = 2] = "both"; // can be alone
    })(Rance.SubEmblemPosition || (Rance.SubEmblemPosition = {}));
    var SubEmblemPosition = Rance.SubEmblemPosition;
    var Emblem = (function () {
        function Emblem(color, alpha, inner, outer) {
            this.color = color;
            this.alpha = isFinite(alpha) ? alpha : 1;
            this.inner = inner;
            this.outer = outer;
        }
        Emblem.prototype.generateRandom = function (minAlpha, rng) {
            var rng = rng || new RNG(Math.random);
            this.alpha = rng.uniform();
            this.alpha = Rance.clamp(this.alpha, minAlpha, 1);
            this.generateSubEmblems(rng);
        };
        Emblem.prototype.canAddOuterTemplate = function () {
            return (this.inner && this.inner.coverage.indexOf(SubEmblemCoverage.inner) !== -1);
        };
        Emblem.prototype.getPossibleSubEmblemsToAdd = function () {
            var possibleTemplates = [];
            if (this.inner && this.outer) {
                throw new Error("Tried to get available sub emblems for emblem that already has both inner and outer");
            }
            if (!this.inner) {
                for (var key in app.moduleData.Templates.SubEmblems) {
                    if (!app.moduleData.Templates.SubEmblems[key].disallowRandomGeneration) {
                        possibleTemplates.push(app.moduleData.Templates.SubEmblems[key]);
                    }
                }
            }
            else {
                if (this.canAddOuterTemplate()) {
                    for (var key in app.moduleData.Templates.SubEmblems) {
                        var template = app.moduleData.Templates.SubEmblems[key];
                        if (!template.disallowRandomGeneration && template.coverage.indexOf(SubEmblemCoverage.outer) !== -1) {
                            possibleTemplates.push(template);
                        }
                    }
                }
            }
            return possibleTemplates;
        };
        Emblem.prototype.generateSubEmblems = function (rng) {
            var candidates = this.getPossibleSubEmblemsToAdd();
            this.inner = Rance.getSeededRandomArrayItem(candidates, rng);
            candidates = this.getPossibleSubEmblemsToAdd();
            if (candidates.length > 0 && rng.uniform() > 0.4) {
                this.outer = Rance.getSeededRandomArrayItem(candidates, rng);
            }
        };
        Emblem.prototype.canAddBackground = function () {
            if (this.inner.position.indexOf(SubEmblemPosition.foreground) !== -1) {
                return (!this.outer || this.outer.position.indexOf(SubEmblemPosition.foreground) !== -1);
            }
            return false;
        };
        Emblem.prototype.drawSubEmblem = function (toDraw, maxWidth, maxHeight, stretch) {
            var image = app.images[toDraw.src];
            var width = image.width;
            var height = image.height;
            if (stretch) {
                var widthRatio = width / maxWidth;
                var heightRatio = height / maxHeight;
                var largestRatio = Math.max(widthRatio, heightRatio);
                width /= largestRatio;
                height /= largestRatio;
            }
            var canvas = document.createElement("canvas");
            canvas.width = width;
            canvas.height = height;
            var ctx = canvas.getContext("2d");
            ctx.drawImage(image, 0, 0, width, height);
            ctx.globalCompositeOperation = "source-in";
            ctx.fillStyle = "#" + Rance.hexToString(this.color);
            ctx.fillRect(0, 0, width, height);
            return canvas;
        };
        Emblem.prototype.draw = function (maxWidth, maxHeight, stretch) {
            var canvas = document.createElement("canvas");
            var ctx = canvas.getContext("2d");
            ctx.globalAlpha = this.alpha;
            var inner = this.drawSubEmblem(this.inner, maxWidth, maxHeight, stretch);
            canvas.width = inner.width;
            canvas.height = inner.height;
            ctx.drawImage(inner, 0, 0);
            if (this.outer) {
                var outer = this.drawSubEmblem(this.outer, maxWidth, maxHeight, stretch);
                ctx.drawImage(outer, 0, 0);
            }
            return canvas;
        };
        // drawSvgSubEmblem(toDraw: Templates.ISubEmblemTemplate, className: string)
        // {
        //   var htmlColor = "#" + hexToString(this.color);
        //   var container = document.createElement("object");
        //   container.addEventListener("load", function(e: Event)
        //   {
        //     var svg = container.contentDocument;
        //     var elementsToColor = svg.getElementsByClassName("emblem-color");
        //     for (var i = 0; i < elementsToColor.length; i++)
        //     {
        //       var svgElementToColor = <SVGSVGElement> elementsToColor[i];
        //       svgElementToColor.style.fill = htmlColor;
        //     }
        //   }, false);
        //   container.setAttribute("data", toDraw.src);
        //   container.setAttribute("type", "image/svg+xml");
        //   container.classList.add(className);
        //   return container;
        // }
        // drawSvg()
        // {
        //   var container = document.createElement("object");
        //   container.classList.add("emblem-container");
        //   var inner = this.drawSvgSubEmblem(this.inner, "inner-sub-emblem");
        //   container.appendChild(inner);
        //   if (this.outer)
        //   {
        //     var outer = this.drawSvgSubEmblem(this.outer, "outer-sub-emblem");
        //     container.appendChild(outer);
        //   }
        //   return container;
        // }
        Emblem.prototype.serialize = function () {
            var data = {
                alpha: this.alpha,
                innerKey: this.inner.key
            };
            if (this.outer) {
                data.outerKey = this.outer.key;
            }
            return data;
        };
        return Emblem;
    }());
    Rance.Emblem = Emblem;
})(Rance || (Rance = {}));
/// <reference path="../lib/rng.d.ts" />
/// <reference path="emblem.ts" />
/// <reference path="color.ts"/>
/// <reference path="savedata/iflagsavedata.d.ts" />
var Rance;
(function (Rance) {
    var Flag = (function () {
        function Flag(props) {
            this.cachedCanvases = {};
            this.width = props.width;
            this.height = props.height || props.width;
            this.mainColor = props.mainColor;
            this.secondaryColor = props.secondaryColor;
            this.tetriaryColor = props.tetriaryColor; // TODO flag | currently never set
        }
        Flag.prototype.setColorScheme = function (main, secondary, tetriary) {
            this.mainColor = main;
            this.secondaryColor = secondary;
            if (this.foregroundEmblem && isFinite(secondary)) {
                this.foregroundEmblem.color = this.secondaryColor;
            }
            this.tetriaryColor = tetriary;
            if (this.backgroundEmblem && isFinite(tetriary)) {
                this.backgroundEmblem.color = this.tetriaryColor;
            }
        };
        Flag.prototype.generateRandom = function (seed) {
            this.seed = seed || Math.random();
            var rng = new RNG(this.seed);
            this.foregroundEmblem = new Rance.Emblem(this.secondaryColor);
            this.foregroundEmblem.generateRandom(1, rng);
            if (this.foregroundEmblem.canAddBackground() && rng.uniform() > 0.5) {
                this.backgroundEmblem = new Rance.Emblem(this.tetriaryColor);
                this.backgroundEmblem.generateRandom(0.4, rng);
            }
        };
        Flag.prototype.clearContent = function () {
            this.customImage = null;
            this._customImageToRender = null;
            this.foregroundEmblem = null;
            this.backgroundEmblem = null;
            this.seed = null;
        };
        Flag.prototype.setForegroundEmblem = function (emblem) {
            if (!emblem) {
                this.foregroundEmblem = null;
                return;
            }
            this.clearContent();
            this.foregroundEmblem = emblem;
            if (isFinite(emblem.color) && emblem.color !== null) {
                this.secondaryColor = emblem.color;
            }
            else {
                emblem.color = this.secondaryColor;
            }
        };
        Flag.prototype.setBackgroundEmblem = function (emblem) {
            if (!emblem) {
                this.backgroundEmblem = null;
                return;
            }
            this.clearContent();
            this.backgroundEmblem = emblem;
            if (isFinite(emblem.color) && emblem.color !== null) {
                this.tetriaryColor = emblem.color;
            }
            else {
                emblem.color = this.tetriaryColor;
            }
        };
        // TODO flag | custom images
        Flag.prototype.setCustomImage = function (imageSrc) {
            this.clearContent();
            this.customImage = imageSrc;
            var canvas = document.createElement("canvas");
            canvas.width = this.width;
            canvas.height = this.height;
            var ctx = canvas.getContext("2d");
            var image = new Image();
            image.src = imageSrc;
            var xPos, xWidth, yPos, yHeight;
            // center image if smaller than canvas we're drawing on
            if (image.width < this.width) {
                xPos = (this.width - image.width) / 2;
                xWidth = image.width;
            }
            else {
                xPos = 0;
                xWidth = this.width;
            }
            if (image.height < this.height) {
                yPos = (this.height - image.height) / 2;
                yHeight = image.height;
            }
            else {
                yPos = 0;
                yHeight = this.height;
            }
            ctx.drawImage(image, xPos, yPos, xWidth, yHeight);
            this._customImageToRender = canvas;
        };
        Flag.prototype.getCanvas = function (width, height, stretch, useCache) {
            if (stretch === void 0) { stretch = true; }
            if (useCache === void 0) { useCache = true; }
            if (useCache) {
                var sizeString = "" + width + "," + height + stretch;
                if (!this.cachedCanvases[sizeString]) {
                    var canvas = this.draw(width, height, stretch);
                    this.cachedCanvases[sizeString] = canvas;
                }
                return this.cachedCanvases[sizeString];
            }
            else {
                var canvas = this.draw(width, height, stretch);
                return (canvas);
            }
        };
        // getReactMarkup()
        // {
        //   if (!this._reactMarkup)
        //   {
        //     var tempContainer = document.createElement("div");
        //     tempContainer.appendChild(this.drawSvg());
        //     this._reactMarkup =
        //     {
        //       __html: tempContainer.innerHTML
        //     }
        //   }
        //   return this._reactMarkup;
        // }
        // drawSvg(): HTMLElement
        // {
        //   if (!this._renderedSvg)
        //   {
        //     var container = document.createElement("div");
        //     container.classList.add("player-flag");
        //     container.style.backgroundColor = "#" + hexToString(this.mainColor);
        //     if (this.backgroundEmblem && isFinite(this.tetriaryColor) && this.tetriaryColor !== null)
        //     {
        //       container.appendChild(this.backgroundEmblem.drawSvg());
        //     }
        //     if (this.foregroundEmblem && isFinite(this.secondaryColor) && this.secondaryColor !== null)
        //     {
        //       container.appendChild(this.foregroundEmblem.drawSvg());
        //     }
        //     this._renderedSvg = container;
        //   }
        //   return this._renderedSvg;
        // }
        Flag.prototype.draw = function (width, height, stretch) {
            if (width === void 0) { width = this.width; }
            if (height === void 0) { height = this.height; }
            if (stretch === void 0) { stretch = true; }
            var canvas = document.createElement("canvas");
            canvas.width = width;
            canvas.height = height;
            if (!isFinite(this.mainColor))
                return canvas;
            var ctx = canvas.getContext("2d");
            ctx.globalCompositeOperation = "source-over";
            ctx.fillStyle = "#" + Rance.hexToString(this.mainColor);
            ctx.fillRect(0, 0, width, height);
            if (this._customImageToRender) {
                ctx.drawImage(this._customImageToRender, 0, 0);
            }
            else {
                if (this.backgroundEmblem && isFinite(this.tetriaryColor) && this.tetriaryColor !== null) {
                    var background = this.backgroundEmblem.draw(width, height, stretch);
                    var x = (width - background.width) / 2;
                    var y = (height - background.height) / 2;
                    ctx.drawImage(background, x, y);
                }
                if (this.foregroundEmblem && isFinite(this.secondaryColor) && this.secondaryColor !== null) {
                    var foreground = this.foregroundEmblem.draw(width, height, stretch);
                    var x = (width - foreground.width) / 2;
                    var y = (height - foreground.height) / 2;
                    ctx.drawImage(foreground, x, y);
                }
            }
            return canvas;
        };
        Flag.prototype.serialize = function () {
            var data = {
                mainColor: this.mainColor
            };
            if (isFinite(this.secondaryColor))
                data.secondaryColor = this.secondaryColor;
            if (isFinite(this.tetriaryColor))
                data.tetriaryColor = this.tetriaryColor;
            if (this.customImage) {
                data.customImage = this.customImage;
            }
            else if (this.seed) {
                data.seed = this.seed;
            }
            else {
                if (this.foregroundEmblem)
                    data.foregroundEmblem = this.foregroundEmblem.serialize();
                if (this.backgroundEmblem)
                    data.backgroundEmblem = this.backgroundEmblem.serialize();
            }
            return data;
        };
        return Flag;
    }());
    Rance.Flag = Flag;
})(Rance || (Rance = {}));
/// <reference path="templateinterfaces/iitemtemplate.d.ts" />
/// <reference path="unit.ts" />
/// <reference path="savedata/iitemsavedata.d.ts" />
var Rance;
(function (Rance) {
    var Item = (function () {
        function Item(template, id) {
            this.id = isFinite(id) ? id : Rance.idGenerators.item++;
            this.template = template;
        }
        Item.prototype.serialize = function () {
            var data = {
                id: this.id,
                templateType: this.template.type
            };
            if (this.unit) {
                data.unitId = this.unit.id;
            }
            return data;
        };
        return Item;
    }());
    Rance.Item = Item;
})(Rance || (Rance = {}));
/// <reference path="templateinterfaces/iabilitytemplate.d.ts" />
/// <reference path="battle.ts" />
/// <reference path="unit.ts"/>
var Rance;
(function (Rance) {
    var MCTreeNode = (function () {
        function MCTreeNode(battle, move) {
            this.depth = 0;
            this.children = [];
            this.visits = 0;
            this.wins = 0;
            this.winRate = 0;
            this.totalScore = 0;
            this.averageScore = 0;
            this.uctIsDirty = true;
            this.battle = battle;
            this.sideId = battle.activeUnit.battleStats.side;
            this.move = move;
            this.isBetweenAI = battle.side1Player.isAI && battle.side2Player.isAI;
            this.currentScore = battle.getEvaluation();
        }
        MCTreeNode.prototype.getPossibleMoves = function () {
            if (!this.battle.activeUnit) {
                return [];
            }
            var targets = Rance.getTargetsForAllAbilities(this.battle, this.battle.activeUnit);
            var actions = [];
            for (var id in targets) {
                var targetActions = targets[id];
                for (var i = 0; i < targetActions.length; i++) {
                    if (!this.isBetweenAI || !targetActions[i].disableInAIBattles) {
                        actions.push({
                            targetId: parseInt(id),
                            ability: targetActions[i]
                        });
                    }
                }
            }
            return actions;
        };
        MCTreeNode.prototype.addChild = function (possibleMovesIndex) {
            if (!this.possibleMoves) {
                this.possibleMoves = this.getPossibleMoves();
            }
            if (isFinite(possibleMovesIndex)) {
                var move = this.possibleMoves.splice(possibleMovesIndex, 1)[0];
            }
            else {
                var move = this.possibleMoves.pop();
            }
            var battle = this.battle.makeVirtualClone();
            var child = new MCTreeNode(battle, move);
            child.parent = this;
            child.depth = this.depth + 1;
            this.children.push(child);
            Rance.useAbility(battle, battle.activeUnit, move.ability, battle.unitsById[move.targetId]);
            child.currentScore = battle.getEvaluation();
            battle.endTurn();
            return child;
        };
        MCTreeNode.prototype.getChildForMove = function (move) {
            for (var i = 0; i < this.children.length; i++) {
                var child = this.children[i];
                if (child.move.targetId === move.targetId &&
                    child.move.ability.type === move.ability.type) {
                    return child;
                }
            }
            if (!this.possibleMoves) {
                this.possibleMoves = this.getPossibleMoves();
            }
            for (var i = 0; i < this.possibleMoves.length; i++) {
                var possibleMove = this.possibleMoves[i];
                if (possibleMove.targetId === move.targetId &&
                    possibleMove.ability.type === move.ability.type) {
                    return this.addChild(i);
                }
            }
            return null;
            // var currId = this.battle.activeUnit.id;
            // throw new Error("Tried to fetch child node for impossible move " +
            //   currId + ": " + move.ability.type + " -> " + move.targetId);
        };
        MCTreeNode.prototype.updateResult = function (result) {
            this.visits++;
            this.totalScore += result;
            if (this.sideId === "side1") {
                if (result > 0)
                    this.wins++;
            }
            if (this.sideId === "side2") {
                if (result < 0)
                    this.wins++;
            }
            this.averageScore = this.totalScore / this.visits;
            this.winRate = this.wins / this.visits;
            this.uctIsDirty = true;
            if (this.parent)
                this.parent.updateResult(result);
        };
        MCTreeNode.prototype.pickRandomAbilityAndTarget = function (actions) {
            var prioritiesByAbilityAndTarget = {};
            for (var targetId in actions) {
                var abilities = actions[targetId];
                for (var i = 0; i < abilities.length; i++) {
                    var priority = isFinite(abilities[i].AIEvaluationPriority) ? abilities[i].AIEvaluationPriority : 1;
                    prioritiesByAbilityAndTarget["" + targetId + ":" + abilities[i].type] = priority;
                }
            }
            var selected = Rance.getRandomKeyWithWeights(prioritiesByAbilityAndTarget);
            var separatorIndex = selected.indexOf(":");
            return ({
                targetId: parseInt(selected.slice(0, separatorIndex)),
                abilityType: selected.slice(separatorIndex + 1)
            });
        };
        MCTreeNode.prototype.simulateOnce = function (battle) {
            var actions = Rance.getTargetsForAllAbilities(battle, battle.activeUnit);
            var targetData = this.pickRandomAbilityAndTarget(actions);
            var ability = app.moduleData.Templates.Abilities[targetData.abilityType];
            var target = battle.unitsById[targetData.targetId];
            Rance.useAbility(battle, battle.activeUnit, ability, target);
            battle.endTurn();
        };
        MCTreeNode.prototype.simulateToEnd = function () {
            var battle = this.battle.makeVirtualClone();
            while (!battle.ended) {
                this.simulateOnce(battle);
            }
            this.updateResult(battle.getEvaluation());
        };
        MCTreeNode.prototype.clearResult = function () {
            this.visits = 0;
            this.wins = 0;
            this.averageScore = 0;
            this.totalScore = 0;
        };
        MCTreeNode.prototype.getCombinedScore = function () {
            var sign = this.sideId === "side1" ? 1 : -1;
            var baseScore = this.averageScore * sign / 2;
            var winRate = this.winRate;
            var aiAdjust = this.move.ability.AIScoreAdjust || 0;
            return (baseScore + winRate) + aiAdjust * 1.5;
        };
        MCTreeNode.prototype.setUct = function () {
            if (!this.parent) {
                this.uctEvaluation = -1;
                this.uctIsDirty = false;
                return;
            }
            //this.uctEvaluation = this.winRate + Math.sqrt(2 * Math.log(this.parent.visits) / this.visits);
            this.uctEvaluation = this.getCombinedScore() + Math.sqrt(2 * Math.log(this.parent.visits) / this.visits);
            if (this.move.ability.AIEvaluationPriority) {
                this.uctEvaluation *= this.move.ability.AIEvaluationPriority;
            }
            this.uctIsDirty = false;
        };
        MCTreeNode.prototype.getHighestUctChild = function () {
            var highest = this.children[0];
            for (var i = 0; i < this.children.length; i++) {
                var child = this.children[i];
                if (child.uctIsDirty) {
                    child.setUct();
                }
                if (child.uctEvaluation > highest.uctEvaluation) {
                    highest = child;
                }
            }
            return highest;
        };
        MCTreeNode.prototype.getRecursiveBestUctChild = function () {
            // terminal
            if (this.battle.ended) {
                return this;
            }
            if (!this.possibleMoves) {
                this.possibleMoves = this.getPossibleMoves();
            }
            // not fully expanded
            if (this.possibleMoves && this.possibleMoves.length > 0) {
                return this.addChild();
            }
            else if (this.children.length === 1) {
                return this.children[0];
            }
            else if (this.children.length > 1) {
                return this.getHighestUctChild().getRecursiveBestUctChild();
            }
        };
        return MCTreeNode;
    }());
    Rance.MCTreeNode = MCTreeNode;
})(Rance || (Rance = {}));
/// <reference path="mctreenode.ts"/>
/// <reference path="battle.ts"/>
var Rance;
(function (Rance) {
    var MCTree = (function () {
        function MCTree(battle, sideId, fastMode) {
            if (fastMode === void 0) { fastMode = false; }
            var cloned = battle.makeVirtualClone();
            this.rootNode = new Rance.MCTreeNode(cloned);
            this.actualBattle = battle;
            this.sideId = sideId;
            if (fastMode) {
                this.countVisitsAsIterations = true;
            }
        }
        MCTree.prototype.sortByWinRateFN = function (a, b) {
            return b.winRate - a.winRate;
        };
        MCTree.prototype.sortByCombinedScoreFN = function (a, b) {
            if (a.sideId !== b.sideId)
                debugger;
            return b.getCombinedScore() - a.getCombinedScore();
        };
        MCTree.prototype.evaluate = function (iterations) {
            var root = this.rootNode;
            if (!root.possibleMoves)
                root.possibleMoves = root.getPossibleMoves();
            if (this.rootSimulationNeedsToBeRemade()) {
                this.remakeSimulation();
                root = this.rootNode;
            }
            var iterationStart = this.countVisitsAsIterations ? Math.min(iterations - 1, root.visits - root.depth) : 0;
            for (var i = iterationStart; i < iterations; i++) {
                // select & expand
                var toSimulateFrom = root.getRecursiveBestUctChild();
                // simulate & backpropagate
                toSimulateFrom.simulateToEnd();
            }
            var sortedMoves = root.children.sort(this.sortByCombinedScoreFN.bind(this));
            //this.printToConsole(sortedMoves);
            var best = sortedMoves[0];
            if (!best) {
                debugger;
            }
            return best;
        };
        MCTree.prototype.getChildForMove = function (move) {
            return this.rootNode.getChildForMove(move);
        };
        MCTree.prototype.rootSimulationNeedsToBeRemade = function () {
            var scoreVariationTolerance = 0.1;
            var scoreVariance = Math.abs(this.actualBattle.getEvaluation() - this.rootNode.currentScore);
            if (scoreVariance > scoreVariationTolerance) {
                return true;
            }
            else if (this.actualBattle.activeUnit !== this.rootNode.battle.activeUnit) {
                return true;
            }
            else if (this.rootNode.children.length === 0) {
                if (!this.rootNode.possibleMoves) {
                    this.rootNode.possibleMoves = this.rootNode.getPossibleMoves();
                }
                if (this.rootNode.possibleMoves.length === 0) {
                    return true;
                }
            }
            return false;
        };
        MCTree.prototype.remakeSimulation = function () {
            this.rootNode = new Rance.MCTreeNode(this.actualBattle.makeVirtualClone());
            return this.rootNode;
        };
        MCTree.prototype.advanceMove = function (move) {
            this.rootNode = this.getChildForMove(move);
            if (!this.rootNode) {
                this.remakeSimulation();
            }
        };
        MCTree.prototype.getBestMoveAndAdvance = function (iterations) {
            var best = this.evaluate(iterations);
            this.rootNode = best;
            return best.move;
        };
        MCTree.prototype.printToConsole = function (nodes) {
            var consoleRows = [];
            for (var i = 0; i < nodes.length; i++) {
                var node = nodes[i];
                var row = {
                    visits: node.visits,
                    uctEvaluation: node.uctEvaluation,
                    winRate: node.winRate,
                    currentScore: node.currentScore,
                    averageScore: node.averageScore,
                    finalScore: node.getCombinedScore(),
                    abilityName: node.move.ability.displayName,
                    targetId: node.move.targetId
                };
                consoleRows.push(row);
            }
            var _ = window;
            if (_.console.table) {
                _.console.table(consoleRows);
            }
            console.log(nodes);
        };
        return MCTree;
    }());
    Rance.MCTree = MCTree;
})(Rance || (Rance = {}));
/// <reference path="battle.ts"/>
/// <reference path="mctree.ts"/>
var Rance;
(function (Rance) {
    var BattleSimulator = (function () {
        function BattleSimulator(battle) {
            this.hasEnded = false;
            this.battle = battle;
            battle.isSimulated = true;
            if (!battle.ended) {
                this.tree = new Rance.MCTree(this.battle, this.battle.activeUnit.battleStats.side, true);
            }
        }
        BattleSimulator.prototype.simulateBattle = function () {
            while (!this.battle.ended) {
                this.simulateMove();
            }
        };
        BattleSimulator.prototype.simulateMove = function () {
            if (!this.battle.activeUnit || this.battle.ended) {
                throw new Error("Simulated battle already ended");
            }
            var move = this.tree.getBestMoveAndAdvance(Rance.Options.debugOptions.battleSimulationDepth);
            var target = this.battle.unitsById[move.targetId];
            this.simulateAbility(move.ability, target);
            this.battle.endTurn();
        };
        BattleSimulator.prototype.simulateAbility = function (ability, target) {
            Rance.useAbility(this.battle, this.battle.activeUnit, ability, target);
        };
        BattleSimulator.prototype.getBattleEndData = function () {
            if (!this.battle.ended) {
                throw new Error("Simulated battle hasn't ended yet");
            }
            var captured = this.battle.capturedUnits;
            var destroyed = this.battle.deadUnits;
            var victor = this.battle.getVictor();
        };
        BattleSimulator.prototype.finishBattle = function () {
            this.battle.finishBattle();
        };
        return BattleSimulator;
    }());
    Rance.BattleSimulator = BattleSimulator;
})(Rance || (Rance = {}));
/// <reference path="unit.ts"/>
/// <reference path="player.ts"/>
/// <reference path="battle.ts"/>
/// <reference path="ibattledata.d.ts"/>
var Rance;
(function (Rance) {
    var BattlePrep = (function () {
        function BattlePrep(battleData) {
            this.alreadyPlaced = {};
            this.minDefendersInNeutralTerritory = 1;
            this.afterBattleFinishCallbacks = [];
            this.attacker = battleData.attacker.player;
            this.attackerUnits = battleData.attacker.units;
            this.defender = battleData.defender.player;
            this.defenderUnits = battleData.defender.units;
            this.battleData = battleData;
            this.resetBattleStats();
            this.triggerPassiveSkills();
            this.makeAIFormations();
            this.setupPlayer();
        }
        BattlePrep.prototype.resetBattleStats = function () {
            var star = this.battleData.location;
            var allUnits = star.getAllUnitsOfPlayer(this.attacker).concat(star.getAllUnitsOfPlayer(this.defender));
            for (var i = 0; i < allUnits.length; i++) {
                allUnits[i].resetBattleStats();
            }
        };
        BattlePrep.prototype.triggerPassiveSkills = function () {
            var star = this.battleData.location;
            var allUnits = star.getAllUnitsOfPlayer(this.attacker).concat(star.getAllUnitsOfPlayer(this.defender));
            for (var i = 0; i < allUnits.length; i++) {
                var unit = allUnits[i];
                var passiveSkillsByPhase = unit.getPassiveSkillsByPhase();
                if (passiveSkillsByPhase.inBattlePrep) {
                    for (var j = 0; j < passiveSkillsByPhase.inBattlePrep.length; j++) {
                        var skill = passiveSkillsByPhase.inBattlePrep[j];
                        for (var k = 0; k < skill.inBattlePrep.length; k++) {
                            skill.inBattlePrep[k](unit, this);
                        }
                    }
                }
            }
        };
        BattlePrep.prototype.makeEmptyFormation = function () {
            var formation = [];
            for (var i = 0; i < app.moduleData.ruleSet.battle.rowsPerFormation; i++) {
                var row = [];
                for (var j = 0; j < app.moduleData.ruleSet.battle.cellsPerRow; j++) {
                    row.push(null);
                }
                formation.push(row);
            }
            return formation;
        };
        BattlePrep.prototype.makeAIFormations = function () {
            if (this.attacker.isAI) {
                this.attackerFormation = this.makeAutoFormation(this.battleData.attacker.units, this.battleData.defender.units, this.attacker);
            }
            if (this.defender.isAI) {
                this.defenderFormation = this.makeAutoFormation(this.battleData.defender.units, this.battleData.attacker.units, this.defender);
            }
        };
        BattlePrep.prototype.setupPlayer = function () {
            if (!this.attacker.isAI) {
                this.availableUnits = this.battleData.attacker.units;
                this.enemyUnits = this.battleData.defender.units;
                this.attackerFormation = this.makeEmptyFormation();
                this.playerFormation = this.attackerFormation;
                this.enemyFormation = this.defenderFormation;
                this.humanPlayer = this.attacker;
                this.enemyPlayer = this.defender;
            }
            else if (!this.defender.isAI) {
                this.availableUnits = this.battleData.defender.units;
                this.enemyUnits = this.battleData.attacker.units;
                this.defenderFormation = this.makeEmptyFormation();
                this.playerFormation = this.defenderFormation;
                this.enemyFormation = this.attackerFormation;
                this.humanPlayer = this.defender;
                this.enemyPlayer = this.attacker;
            }
        };
        // TODO ruleset | handle variable amount of rows
        BattlePrep.prototype.makeAutoFormation = function (units, enemyUnits, player) {
            var self = this;
            var maxUnitsPerSide = app.moduleData.ruleSet.battle.maxUnitsPerSide;
            var maxUnitsPerRow = app.moduleData.ruleSet.battle.maxUnitsPerRow;
            var formation = this.makeEmptyFormation();
            var unitsToPlace = units.filter(function (unit) {
                return unit.canActThisTurn();
            });
            var placedInFront = 0;
            var placedInBack = 0;
            var totalPlaced = 0;
            var unitsPlacedByArchetype = {};
            var getUnitScoreFN = function (unit, row) {
                var score = unit.getStrengthEvaluation();
                var archetype = unit.template.archetype;
                var rowModifier = archetype.rowScores[row];
                if (archetype.scoreMultiplierForRowFN) {
                    var rowUnits = row === "ROW_FRONT" ? formation[1] : formation[0];
                    var scoutedUnits = player.starIsDetected(self.battleData.location) ? enemyUnits : null;
                    rowModifier = archetype.scoreMultiplierForRowFN(row, rowUnits, scoutedUnits);
                }
                var idealMaxUnits = Math.ceil(maxUnitsPerSide / archetype.idealWeightInBattle);
                var unitsPlaced = unitsPlacedByArchetype[archetype.type] || 0;
                var overMax = Math.max(0, unitsPlaced - idealMaxUnits);
                score *= 1 - overMax * 0.15;
                score *= rowModifier;
                return ({
                    unit: unit,
                    score: score,
                    row: row
                });
            };
            while (unitsToPlace.length > 0 && totalPlaced < maxUnitsPerSide) {
                var positionScores = [];
                for (var i = 0; i < unitsToPlace.length; i++) {
                    var unit = unitsToPlace[i];
                    if (placedInFront < maxUnitsPerRow) {
                        positionScores.push(getUnitScoreFN(unit, "ROW_FRONT"));
                    }
                    if (placedInBack < maxUnitsPerRow) {
                        positionScores.push(getUnitScoreFN(unit, "ROW_BACK"));
                    }
                }
                positionScores.sort(function (a, b) {
                    return (b.score - a.score);
                });
                var topScore = positionScores[0];
                if (topScore.row === "ROW_FRONT") {
                    placedInFront++;
                    formation[1][placedInFront - 1] = topScore.unit;
                }
                else {
                    placedInBack++;
                    formation[0][placedInBack - 1] = topScore.unit;
                }
                totalPlaced++;
                if (!unitsPlacedByArchetype[topScore.unit.template.archetype.type]) {
                    unitsPlacedByArchetype[topScore.unit.template.archetype.type] = 0;
                }
                unitsPlacedByArchetype[topScore.unit.template.archetype.type]++;
                unitsToPlace.splice(unitsToPlace.indexOf(topScore.unit), 1);
            }
            return formation;
        };
        // Human formation stuff
        BattlePrep.prototype.getUnitPosition = function (unit) {
            return this.alreadyPlaced[unit.id];
        };
        BattlePrep.prototype.getUnitAtPosition = function (position) {
            return this.playerFormation[position[0]][position[1]];
        };
        BattlePrep.prototype.clearPlayerFormation = function () {
            this.alreadyPlaced = {};
            this.playerFormation = this.makeEmptyFormation();
        };
        // called after player formation is created automatically
        BattlePrep.prototype.setupPlayerFormation = function (formation) {
            for (var i = 0; i < formation.length; i++) {
                for (var j = 0; j < formation[i].length; j++) {
                    if (formation[i][j]) {
                        this.setUnit(formation[i][j], [i, j]);
                    }
                }
            }
        };
        BattlePrep.prototype.setUnit = function (unit, position) {
            this.removeUnit(unit);
            if (!position) {
                return;
            }
            var oldUnitInPosition = this.getUnitAtPosition(position);
            if (oldUnitInPosition) {
                this.removeUnit(oldUnitInPosition);
            }
            this.playerFormation[position[0]][position[1]] = unit;
            this.alreadyPlaced[unit.id] = position;
        };
        BattlePrep.prototype.swapUnits = function (unit1, unit2) {
            if (unit1 === unit2)
                return;
            var new1Pos = this.getUnitPosition(unit2);
            var new2Pos = this.getUnitPosition(unit1);
            this.setUnit(unit1, new1Pos);
            this.setUnit(unit2, new2Pos);
        };
        BattlePrep.prototype.removeUnit = function (unit) {
            var currentPosition = this.getUnitPosition(unit);
            if (!currentPosition)
                return;
            this.playerFormation[currentPosition[0]][currentPosition[1]] = null;
            this.alreadyPlaced[unit.id] = null;
            delete this.alreadyPlaced[unit.id];
        };
        BattlePrep.prototype.humanFormationIsValid = function () {
            /*
            invalid if
              attacking and no units placed
              battle is in territory not controlled by either and units placed
                is smaller than requirement and player hasn't placed all available units
             */
            var unitsPlaced = 0;
            this.forEachUnitInFormation(this.playerFormation, function (unit) {
                if (unit)
                    unitsPlaced++;
            });
            var minRequiredUnits = 0;
            if (!this.attacker.isAI) {
                minRequiredUnits = 1;
            }
            else if (!this.battleData.building) {
                minRequiredUnits = this.minDefendersInNeutralTerritory;
            }
            minRequiredUnits = Math.min(minRequiredUnits, this.availableUnits.length);
            return unitsPlaced >= minRequiredUnits;
        };
        // end player formation
        BattlePrep.prototype.forEachUnitInFormation = function (formation, operator) {
            for (var i = 0; i < formation.length; i++) {
                for (var j = 0; j < formation[i].length; j++) {
                    operator(formation[i][j]);
                }
            }
        };
        BattlePrep.prototype.makeBattle = function () {
            var side1Formation = this.playerFormation || this.attackerFormation;
            var side2Formation = this.enemyFormation || this.defenderFormation;
            var side1Player = this.humanPlayer || this.attacker;
            var side2Player = this.enemyPlayer || this.defender;
            var battle = new Rance.Battle({
                battleData: this.battleData,
                side1: side1Formation,
                side2: side2Formation.reverse(),
                side1Player: side1Player,
                side2Player: side2Player
            });
            battle.afterFinishCallbacks = battle.afterFinishCallbacks.concat(this.afterBattleFinishCallbacks);
            battle.init();
            return battle;
        };
        return BattlePrep;
    }());
    Rance.BattlePrep = BattlePrep;
})(Rance || (Rance = {}));
/// <reference path="templateinterfaces/iattitudemodifiertemplate.d.ts" />
/// <reference path="savedata/iattitudemodifiersavedata.d.ts" />
var Rance;
(function (Rance) {
    var AttitudeModifier = (function () {
        function AttitudeModifier(props) {
            this.isOverRidden = false;
            this.template = props.template;
            this.startTurn = props.startTurn;
            this.currentTurn = this.startTurn;
            if (isFinite(props.endTurn)) {
                this.endTurn = props.endTurn;
            }
            else if (isFinite(this.template.duration)) {
                if (this.template.duration < 0) {
                    this.endTurn = -1;
                }
                else {
                    this.endTurn = this.startTurn + this.template.duration;
                }
            }
            else {
                throw new Error("Attitude modifier has no duration or end turn set");
            }
            if (isFinite(this.template.constantEffect)) {
                this.strength = this.template.constantEffect;
            }
            else {
                this.strength = props.strength;
            }
        }
        AttitudeModifier.prototype.setStrength = function (evaluation) {
            if (this.template.constantEffect) {
                this.strength = this.template.constantEffect;
            }
            else if (this.template.getEffectFromEvaluation) {
                this.strength = this.template.getEffectFromEvaluation(evaluation);
            }
            else {
                throw new Error("Attitude modifier has no constant effect " +
                    "or effect from evaluation defined");
            }
            return this.strength;
        };
        AttitudeModifier.prototype.getFreshness = function (currentTurn) {
            if (currentTurn === void 0) { currentTurn = this.currentTurn; }
            if (this.endTurn < 0)
                return 1;
            else {
                return 1 - Rance.getRelativeValue(currentTurn, this.startTurn, this.endTurn);
            }
        };
        AttitudeModifier.prototype.refresh = function (newModifier) {
            this.startTurn = newModifier.startTurn;
            this.endTurn = newModifier.endTurn;
            this.strength = newModifier.strength;
        };
        AttitudeModifier.prototype.getAdjustedStrength = function (currentTurn) {
            if (currentTurn === void 0) { currentTurn = this.currentTurn; }
            var freshenss = this.getFreshness(currentTurn);
            return Math.round(this.strength * freshenss);
        };
        AttitudeModifier.prototype.hasExpired = function (currentTurn) {
            if (currentTurn === void 0) { currentTurn = this.currentTurn; }
            return (this.endTurn >= 0 && currentTurn > this.endTurn);
        };
        AttitudeModifier.prototype.shouldEnd = function (evaluation) {
            if (this.hasExpired(evaluation.currentTurn)) {
                return true;
            }
            else if (this.template.endCondition) {
                return this.template.endCondition(evaluation);
            }
            else if (this.template.duration < 0 && this.template.startCondition) {
                return !this.template.startCondition(evaluation);
            }
            else {
                return false;
            }
        };
        AttitudeModifier.prototype.serialize = function () {
            var data = {
                templateType: this.template.type,
                startTurn: this.startTurn,
                endTurn: this.endTurn,
                strength: this.strength
            };
            return data;
        };
        return AttitudeModifier;
    }());
    Rance.AttitudeModifier = AttitudeModifier;
})(Rance || (Rance = {}));
/// <reference path="eventmanager.ts" />
/// <reference path="player.ts" />
/// <reference path="attitudemodifier.ts" />
/// <reference path="savedata/idiplomacystatussavedata.d.ts" />
var Rance;
(function (Rance) {
    (function (DiplomaticState) {
        DiplomaticState[DiplomaticState["peace"] = 0] = "peace";
        DiplomaticState[DiplomaticState["coldWar"] = 1] = "coldWar";
        DiplomaticState[DiplomaticState["war"] = 2] = "war"; // any fighting
    })(Rance.DiplomaticState || (Rance.DiplomaticState = {}));
    var DiplomaticState = Rance.DiplomaticState;
    var DiplomacyStatus = (function () {
        function DiplomacyStatus(player) {
            this.metPlayers = {};
            this.statusByPlayer = {};
            this.attitudeModifiersByPlayer = {};
            this.listeners = {};
            this.player = player;
            this.addEventListeners();
        }
        DiplomacyStatus.prototype.addEventListeners = function () {
            for (var key in app.moduleData.Templates.AttitudeModifiers) {
                var template = app.moduleData.Templates.AttitudeModifiers[key];
                if (template.triggers) {
                    for (var i = 0; i < template.triggers.length; i++) {
                        var listenerKey = template.triggers[i];
                        var listener = Rance.eventManager.addEventListener(listenerKey, this.triggerAttitudeModifier.bind(this, template));
                        if (!this.listeners[listenerKey]) {
                            this.listeners[listenerKey] = [];
                        }
                        this.listeners[listenerKey].push(listener);
                    }
                }
            }
        };
        DiplomacyStatus.prototype.destroy = function () {
            for (var key in this.listeners) {
                for (var i = 0; i < this.listeners[key].length; i++) {
                    Rance.eventManager.removeEventListener(key, this.listeners[key][i]);
                }
            }
        };
        DiplomacyStatus.prototype.removePlayer = function (player) {
            ["metPlayers", "statusByPlayer", "attitudeModifiersByPlayer"].forEach(function (prop) {
                this[prop][player.id] = null;
                delete this[prop][player.id];
            }.bind(this));
        };
        DiplomacyStatus.prototype.getBaseOpinion = function () {
            if (isFinite(this.baseOpinion))
                return this.baseOpinion;
            var friendliness = this.player.AIController.personality.friendliness;
            this.baseOpinion = Math.round((friendliness - 0.5) * 10);
            return this.baseOpinion;
        };
        DiplomacyStatus.prototype.updateAttitudes = function () {
            if (!this.player.AIController) {
                return;
            }
            this.player.AIController.diplomacyAI.setAttitudes();
        };
        DiplomacyStatus.prototype.handleDiplomaticStatusUpdate = function () {
            Rance.eventManager.dispatchEvent("diplomaticStatusUpdated");
        };
        DiplomacyStatus.prototype.getOpinionOf = function (player) {
            var baseOpinion = this.getBaseOpinion();
            var attitudeModifiers = this.attitudeModifiersByPlayer[player.id];
            var modifierOpinion = 0;
            for (var i = 0; i < attitudeModifiers.length; i++) {
                modifierOpinion += attitudeModifiers[i].getAdjustedStrength();
            }
            return Math.round(baseOpinion + modifierOpinion);
        };
        DiplomacyStatus.prototype.getUnMetPlayerCount = function () {
            return app.game.playerOrder.length - Object.keys(this.metPlayers).length;
        };
        DiplomacyStatus.prototype.meetPlayer = function (player) {
            if (this.metPlayers[player.id] || player === this.player)
                return;
            else {
                this.metPlayers[player.id] = player;
                this.statusByPlayer[player.id] = DiplomaticState.coldWar;
                this.attitudeModifiersByPlayer[player.id] = [];
                player.diplomacyStatus.meetPlayer(this.player);
            }
        };
        DiplomacyStatus.prototype.canDeclareWarOn = function (player) {
            return (this.statusByPlayer[player.id] < DiplomaticState.war);
        };
        DiplomacyStatus.prototype.canMakePeaceWith = function (player) {
            return (this.statusByPlayer[player.id] > DiplomaticState.peace);
        };
        DiplomacyStatus.prototype.declareWarOn = function (player) {
            if (this.statusByPlayer[player.id] >= DiplomaticState.war) {
                // TODO crash
                console.error("Players " + this.player.id + " and " + player.id + " are already at war");
                return;
            }
            this.statusByPlayer[player.id] = DiplomaticState.war;
            player.diplomacyStatus.statusByPlayer[this.player.id] = DiplomaticState.war;
            Rance.eventManager.dispatchEvent("addDeclaredWarAttitudeModifier", player, this.player);
            var playersAreRelevantToHuman = true;
            [this.player, player].forEach(function (p) {
                if (app.humanPlayer !== p && !app.humanPlayer.diplomacyStatus.metPlayers[p.id]) {
                    playersAreRelevantToHuman = false;
                }
            });
            if (playersAreRelevantToHuman) {
                Rance.eventManager.dispatchEvent("makeWarDeclarationNotification", {
                    player1: this.player,
                    player2: player
                });
            }
        };
        DiplomacyStatus.prototype.makePeaceWith = function (player) {
            if (this.statusByPlayer[player.id] <= DiplomaticState.peace) {
                throw new Error("Players " + this.player.id + " and " + player.id + " are already at peace");
            }
            this.statusByPlayer[player.id] = DiplomaticState.peace;
            player.diplomacyStatus.statusByPlayer[this.player.id] = DiplomaticState.peace;
            player.diplomacyStatus.updateAttitudes();
        };
        DiplomacyStatus.prototype.canAttackFleetOfPlayer = function (player) {
            if (player.isIndependent)
                return true;
            if (this.statusByPlayer[player.id] >= DiplomaticState.coldWar) {
                return true;
            }
            return false;
        };
        DiplomacyStatus.prototype.canAttackBuildingOfPlayer = function (player) {
            if (player.isIndependent)
                return true;
            if (this.statusByPlayer[player.id] >= DiplomaticState.war) {
                return true;
            }
            return false;
        };
        DiplomacyStatus.prototype.getModifierOfSameType = function (player, modifier) {
            var modifiers = this.attitudeModifiersByPlayer[player.id];
            for (var i = 0; i < modifiers.length; i++) {
                if (modifiers[i].template.type === modifier.template.type) {
                    return modifiers[i];
                }
            }
            return null;
        };
        DiplomacyStatus.prototype.addAttitudeModifier = function (player, modifier) {
            if (!this.attitudeModifiersByPlayer[player.id]) {
                this.attitudeModifiersByPlayer[player.id] = [];
            }
            var sameType = this.getModifierOfSameType(player, modifier);
            if (sameType) {
                sameType.refresh(modifier);
                return;
            }
            this.attitudeModifiersByPlayer[player.id].push(modifier);
            this.updateAttitudes();
        };
        DiplomacyStatus.prototype.triggerAttitudeModifier = function (template, player, source) {
            if (player !== this.player)
                return;
            var modifier = new Rance.AttitudeModifier({
                template: template,
                startTurn: app.game.turnNumber
            });
            this.addAttitudeModifier(source, modifier);
        };
        DiplomacyStatus.prototype.processAttitudeModifiersForPlayer = function (player, evaluation) {
            /*
            remove modifiers that should be removed
            add modifiers that should be added. throw if type was already removed
            set new strength for modifier
             */
            var modifiersByPlayer = this.attitudeModifiersByPlayer;
            var allModifiers = app.moduleData.Templates.AttitudeModifiers;
            for (var playerId in modifiersByPlayer)
                var playerModifiers = modifiersByPlayer[player.id];
            var activeModifiers = {};
            // debugging
            var modifiersAdded = {};
            var modifiersRemoved = {};
            // remove modifiers & build active modifiers index
            for (var i = playerModifiers.length - 1; i >= 0; i--) {
                var modifier = playerModifiers[i];
                if (modifier.shouldEnd(evaluation)) {
                    playerModifiers.splice(i, 1);
                    modifiersRemoved[modifier.template.type] = modifier;
                }
                else {
                    activeModifiers[modifier.template.type] = modifier;
                }
            }
            // loop through all modifiers
            // if modifier is not active and should start,
            // add it and mark as active
            // 
            // if modifier is active, set strength based on evaluation
            for (var modifierType in allModifiers) {
                var template = allModifiers[modifierType];
                var modifier;
                modifier = activeModifiers[template.type];
                var alreadyHasModifierOfType = modifier;
                if (!alreadyHasModifierOfType && !template.triggers) {
                    if (!template.startCondition) {
                        throw new Error("Attitude modifier has no start condition or triggers");
                    }
                    else {
                        var shouldStart = template.startCondition(evaluation);
                        if (shouldStart) {
                            modifier = new Rance.AttitudeModifier({
                                template: template,
                                startTurn: evaluation.currentTurn
                            });
                            playerModifiers.push(modifier);
                            modifiersAdded[template.type] = modifier;
                        }
                    }
                }
                if (modifier) {
                    modifier.currentTurn = evaluation.currentTurn;
                    modifier.setStrength(evaluation);
                }
            }
        };
        DiplomacyStatus.prototype.serialize = function () {
            var metPlayerIds = [];
            for (var playerId in this.metPlayers) {
                metPlayerIds.push(this.metPlayers[playerId].id);
            }
            var attitudeModifiersByPlayer = {};
            for (var playerId in this.attitudeModifiersByPlayer) {
                var serializedModifiers = this.attitudeModifiersByPlayer[playerId].map(function (modifier) {
                    return modifier.serialize();
                });
                attitudeModifiersByPlayer[playerId] = serializedModifiers;
            }
            var data = {
                metPlayerIds: metPlayerIds,
                statusByPlayer: this.statusByPlayer,
                attitudeModifiersByPlayer: attitudeModifiersByPlayer
            };
            return data;
        };
        return DiplomacyStatus;
    }());
    Rance.DiplomacyStatus = DiplomacyStatus;
})(Rance || (Rance = {}));
/// <reference path="savedata/iplayertechnologysavedata.d.ts" />
var Rance;
(function (Rance) {
    var PlayerTechnology = (function () {
        function PlayerTechnology(getResearchSpeed, savedData) {
            this.tempOverflowedResearchAmount = 0;
            this.getResearchSpeed = getResearchSpeed;
            this.technologies = {};
            var totalTechnologies = Object.keys(app.moduleData.Templates.Technologies).length;
            for (var key in app.moduleData.Templates.Technologies) {
                var technology = app.moduleData.Templates.Technologies[key];
                this.technologies[key] =
                    {
                        technology: technology,
                        totalResearch: 0,
                        level: 0,
                        priority: undefined,
                        priorityIsLocked: false
                    };
                if (savedData && savedData[key]) {
                    this.addResearchTowardsTechnology(technology, savedData[key].totalResearch);
                    this.technologies[key].priority = savedData[key].priority;
                    this.technologies[key].priorityIsLocked = savedData[key].priorityIsLocked;
                }
            }
            this.initPriorities();
        }
        PlayerTechnology.prototype.initPriorities = function () {
            var priorityToAllocate = 1;
            var techsToInit = [];
            for (var key in this.technologies) {
                var techData = this.technologies[key];
                if (techData.priority === undefined) {
                    techsToInit.push(techData.technology);
                }
                else {
                    priorityToAllocate -= techData.priority;
                }
            }
            techsToInit.sort(function (a, b) {
                return b.maxLevel - a.maxLevel;
            });
            while (techsToInit.length > 0) {
                var averagePriority = priorityToAllocate / techsToInit.length;
                var technology = techsToInit.pop();
                var maxNeededPriority = this.getMaxNeededPriority(technology);
                var priorityForTech = Math.min(averagePriority, maxNeededPriority);
                this.technologies[technology.key].priority = priorityForTech;
                priorityToAllocate -= priorityForTech;
            }
        };
        PlayerTechnology.prototype.allocateResearchPoints = function (amount, iteration) {
            if (iteration === void 0) { iteration = 0; }
            // probably not needed as priority should always add up to 1 anyway,
            // but this is cheap and infrequently called so this is here as a safeguard at least for now
            var totalPriority = 0;
            for (var key in this.technologies) {
                totalPriority += this.technologies[key].priority;
            }
            for (var key in this.technologies) {
                var techData = this.technologies[key];
                var relativePriority = techData.priority / totalPriority;
                if (relativePriority > 0) {
                    this.addResearchTowardsTechnology(techData.technology, relativePriority * amount);
                }
            }
            if (this.tempOverflowedResearchAmount) {
                if (iteration > 10) {
                    throw new RangeError("Maximum call stack size exceeded");
                }
                this.allocateOverflowedResearchPoints(iteration);
            }
            else {
                this.capTechnologyPrioritiesToMaxNeeded();
            }
        };
        PlayerTechnology.prototype.allocateOverflowedResearchPoints = function (iteration) {
            if (iteration === void 0) { iteration = 0; }
            var overflow = this.tempOverflowedResearchAmount;
            this.tempOverflowedResearchAmount = 0;
            this.allocateResearchPoints(overflow, ++iteration);
        };
        PlayerTechnology.prototype.getResearchNeededForTechnologyLevel = function (level) {
            if (level <= 0)
                return 0;
            if (level === 1)
                return 40;
            var a = 20;
            var b = 40;
            var swap;
            var total = 0;
            for (var i = 0; i < level; i++) {
                swap = a;
                a = b;
                b = swap + b;
                total += a;
            }
            return total;
        };
        PlayerTechnology.prototype.addResearchTowardsTechnology = function (technology, amount) {
            var tech = this.technologies[technology.key];
            var overflow = 0;
            if (tech.level >= technology.maxLevel) {
                return;
            }
            else {
                tech.totalResearch += amount;
                while (tech.level < technology.maxLevel &&
                    this.getResearchNeededForTechnologyLevel(tech.level + 1) <= tech.totalResearch) {
                    tech.level++;
                }
                if (tech.level === technology.maxLevel) {
                    var neededForMaxLevel = this.getResearchNeededForTechnologyLevel(tech.level);
                    overflow += tech.totalResearch - neededForMaxLevel;
                    tech.totalResearch -= overflow;
                    this.setTechnologyPriority(technology, 0, true);
                    tech.priorityIsLocked = true;
                }
            }
            this.tempOverflowedResearchAmount += overflow;
        };
        PlayerTechnology.prototype.getMaxNeededPriority = function (technology) {
            var researchUntilMaxed = this.getResearchNeededForTechnologyLevel(technology.maxLevel) -
                this.technologies[technology.key].totalResearch;
            return researchUntilMaxed / this.getResearchSpeed();
        };
        PlayerTechnology.prototype.getOpenTechnologiesPriority = function () {
            var openPriority = 0;
            for (var key in this.technologies) {
                var techData = this.technologies[key];
                if (!techData.priorityIsLocked) {
                    openPriority += techData.priority;
                }
            }
            return openPriority;
        };
        PlayerTechnology.prototype.getRelativeOpenTechnologyPriority = function (technology) {
            var totalOpenPriority = this.getOpenTechnologiesPriority();
            if (this.technologies[technology.key].priorityIsLocked || !totalOpenPriority) {
                return 0;
            }
            return this.technologies[technology.key].priority / totalOpenPriority;
        };
        PlayerTechnology.prototype.setTechnologyPriority = function (technology, priority, force) {
            if (force === void 0) { force = false; }
            var remainingPriority = 1;
            var totalOtherPriority = 0;
            var totalOtherPriorityWasZero = false;
            var totalOthersCount = 0;
            for (var key in this.technologies) {
                if (key !== technology.key) {
                    if (this.technologies[key].priorityIsLocked) {
                        remainingPriority -= this.technologies[key].priority;
                    }
                    else {
                        totalOtherPriority += this.technologies[key].priority;
                        totalOthersCount++;
                    }
                }
            }
            if (totalOthersCount === 0) {
                if (force) {
                    this.technologies[technology.key].priority = priority;
                    Rance.eventManager.dispatchEvent("technologyPrioritiesUpdated");
                }
                return;
            }
            if (remainingPriority < 0.0001) {
                remainingPriority = 0;
            }
            if (priority > remainingPriority) {
                priority = remainingPriority;
            }
            var priorityNeededForMaxLevel = this.getMaxNeededPriority(technology);
            var maxNeededPriority = Math.min(priorityNeededForMaxLevel, priority);
            this.technologies[technology.key].priority = maxNeededPriority;
            remainingPriority -= maxNeededPriority;
            if (totalOtherPriority === 0) {
                totalOtherPriority = 1;
                totalOtherPriorityWasZero = true;
            }
            for (var key in this.technologies) {
                if (key !== technology.key && !this.technologies[key].priorityIsLocked) {
                    var techData = this.technologies[key];
                    if (totalOtherPriorityWasZero) {
                        techData.priority = 1 / totalOthersCount;
                    }
                    var maxNeededPriorityForOtherTech = this.getMaxNeededPriority(techData.technology);
                    var relativePriority = techData.priority / totalOtherPriority;
                    var reservedPriority = relativePriority * remainingPriority;
                    if (reservedPriority > maxNeededPriorityForOtherTech) {
                        techData.priority = maxNeededPriorityForOtherTech;
                        var priorityOverflow = reservedPriority - maxNeededPriorityForOtherTech;
                        remainingPriority += priorityOverflow;
                    }
                    else {
                        techData.priority = reservedPriority;
                    }
                }
            }
            Rance.eventManager.dispatchEvent("technologyPrioritiesUpdated");
        };
        PlayerTechnology.prototype.capTechnologyPrioritiesToMaxNeeded = function () {
            var overflowPriority = 0;
            for (var key in this.technologies) {
                var techData = this.technologies[key];
                var maxNeededPriorityForOtherTech = this.getMaxNeededPriority(techData.technology);
                if (techData.priority > maxNeededPriorityForOtherTech) {
                    overflowPriority += techData.priority - maxNeededPriorityForOtherTech;
                    this.setTechnologyPriority(techData.technology, maxNeededPriorityForOtherTech, true);
                    break;
                }
            }
        };
        PlayerTechnology.prototype.serialize = function () {
            var data = {};
            for (var key in this.technologies) {
                data[key] =
                    {
                        totalResearch: this.technologies[key].totalResearch,
                        priority: this.technologies[key].priority,
                        priorityIsLocked: this.technologies[key].priorityIsLocked
                    };
            }
            return data;
        };
        return PlayerTechnology;
    }());
    Rance.PlayerTechnology = PlayerTechnology;
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    function makeRandomPersonality() {
        var unitCompositionPreference = {};
        for (var archetype in app.moduleData.Templates.UnitArchetypes) {
            unitCompositionPreference[archetype] = Math.random();
        }
        return ({
            expansiveness: Math.random(),
            aggressiveness: Math.random(),
            friendliness: Math.random(),
            unitCompositionPreference: unitCompositionPreference
        });
    }
    Rance.makeRandomPersonality = makeRandomPersonality;
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var MapVoronoiInfo = (function () {
        function MapVoronoiInfo() {
            this.nonFillerLines = {};
        }
        MapVoronoiInfo.prototype.getNonFillerVoronoiLines = function (visibleStars) {
            if (!this.diagram)
                return [];
            var indexString = "";
            if (!visibleStars)
                indexString = "all";
            else {
                var ids = visibleStars.map(function (star) { return star.id; });
                ids = ids.sort();
                indexString = ids.join();
            }
            if (!this.nonFillerLines[indexString] ||
                this.nonFillerLines[indexString].length <= 0) {
                this.nonFillerLines[indexString] =
                    this.diagram.edges.filter(function (edge) {
                        var adjacentSites = [edge.lSite, edge.rSite];
                        var adjacentFillerSites = 0;
                        var maxAllowedFillerSites = 2;
                        for (var i = 0; i < adjacentSites.length; i++) {
                            var site = adjacentSites[i];
                            if (!site) {
                                // draw all border edges
                                //return true;
                                // draw all non filler border edges
                                maxAllowedFillerSites--;
                                if (adjacentFillerSites >= maxAllowedFillerSites) {
                                    return false;
                                }
                                continue;
                            }
                            ;
                            if (visibleStars && visibleStars.indexOf(site) < 0) {
                                maxAllowedFillerSites--;
                                if (adjacentFillerSites >= maxAllowedFillerSites) {
                                    return false;
                                }
                                continue;
                            }
                            ;
                            if (!isFinite(site.id)) {
                                adjacentFillerSites++;
                                if (adjacentFillerSites >= maxAllowedFillerSites) {
                                    return false;
                                }
                            }
                            ;
                        }
                        return true;
                    });
            }
            return this.nonFillerLines[indexString];
        };
        MapVoronoiInfo.prototype.getStarAtPoint = function (point) {
            var items = this.treeMap.retrieve(point);
            for (var i = 0; i < items.length; i++) {
                var cell = items[i].cell;
                if (cell.pointIntersection(point.x, point.y) > -1) {
                    return cell.site;
                }
            }
            return null;
        };
        return MapVoronoiInfo;
    }());
    Rance.MapVoronoiInfo = MapVoronoiInfo;
})(Rance || (Rance = {}));
/// <reference path="point.ts" />
var Rance;
(function (Rance) {
    var FillerPoint = (function () {
        function FillerPoint(x, y) {
            this.mapGenData = {};
            this.x = x;
            this.y = y;
        }
        FillerPoint.prototype.setPosition = function (x, y) {
            this.x = x;
            this.y = y;
        };
        FillerPoint.prototype.serialize = function () {
            return ({
                x: this.x,
                y: this.y
            });
        };
        return FillerPoint;
    }());
    Rance.FillerPoint = FillerPoint;
})(Rance || (Rance = {}));
/// <reference path="../point.ts"/>
var Rance;
(function (Rance) {
    var MapGenCore;
    (function (MapGenCore) {
        var Triangle = (function () {
            function Triangle(a, b, c) {
                this.a = a;
                this.b = b;
                this.c = c;
            }
            Triangle.prototype.getPoints = function () {
                return [this.a, this.b, this.c];
            };
            Triangle.prototype.getCircumCenter = function () {
                if (!this.circumRadius) {
                    this.calculateCircumCircle();
                }
                return [this.circumCenterX, this.circumCenterY];
            };
            Triangle.prototype.calculateCircumCircle = function (tolerance) {
                if (tolerance === void 0) { tolerance = 0.00001; }
                var pA = this.a;
                var pB = this.b;
                var pC = this.c;
                var m1, m2;
                var mx1, mx2;
                var my1, my2;
                var cX, cY;
                if (Math.abs(pB.y - pA.y) < tolerance) {
                    m2 = -(pC.x - pB.x) / (pC.y - pB.y);
                    mx2 = (pB.x + pC.x) * 0.5;
                    my2 = (pB.y + pC.y) * 0.5;
                    cX = (pB.x + pA.x) * 0.5;
                    cY = m2 * (cX - mx2) + my2;
                }
                else {
                    m1 = -(pB.x - pA.x) / (pB.y - pA.y);
                    mx1 = (pA.x + pB.x) * 0.5;
                    my1 = (pA.y + pB.y) * 0.5;
                    if (Math.abs(pC.y - pB.y) < tolerance) {
                        cX = (pC.x + pB.x) * 0.5;
                        cY = m1 * (cX - mx1) + my1;
                    }
                    else {
                        m2 = -(pC.x - pB.x) / (pC.y - pB.y);
                        mx2 = (pB.x + pC.x) * 0.5;
                        my2 = (pB.y + pC.y) * 0.5;
                        cX = (m1 * mx1 - m2 * mx2 + my2 - my1) / (m1 - m2);
                        cY = m1 * (cX - mx1) + my1;
                    }
                }
                this.circumCenterX = cX;
                this.circumCenterY = cY;
                mx1 = pB.x - cX;
                my1 = pB.y - cY;
                this.circumRadius = Math.sqrt(mx1 * mx1 + my1 * my1);
            };
            Triangle.prototype.circumCircleContainsPoint = function (point) {
                this.calculateCircumCircle();
                var x = point.x - this.circumCenterX;
                var y = point.y - this.circumCenterY;
                var contains = x * x + y * y <= this.circumRadius * this.circumRadius;
                return (contains);
            };
            Triangle.prototype.getEdges = function () {
                var edges = [
                    [this.a, this.b],
                    [this.b, this.c],
                    [this.c, this.a]
                ];
                return edges;
            };
            Triangle.prototype.getAmountOfSharedVerticesWith = function (toCheckAgainst) {
                var ownPoints = this.getPoints();
                var otherPoints = toCheckAgainst.getPoints();
                var shared = 0;
                for (var i = 0; i < ownPoints.length; i++) {
                    if (otherPoints.indexOf(ownPoints[i]) >= 0) {
                        shared++;
                    }
                }
                return shared;
            };
            return Triangle;
        }());
        MapGenCore.Triangle = Triangle;
    })(MapGenCore = Rance.MapGenCore || (Rance.MapGenCore = {}));
})(Rance || (Rance = {}));
/// <reference path="triangle.ts" />
/// <reference path="../point.ts" />
var Rance;
(function (Rance) {
    var MapGenCore;
    (function (MapGenCore) {
        function triangulate(vertices) {
            var triangles = [];
            var superTriangle = makeSuperTriangle(vertices);
            triangles.push(superTriangle);
            for (var i = 0; i < vertices.length; i++) {
                var vertex = vertices[i];
                var edgeBuffer = [];
                for (var j = 0; j < triangles.length; j++) {
                    var triangle = triangles[j];
                    if (triangle.circumCircleContainsPoint(vertex)) {
                        var edges = triangle.getEdges();
                        edgeBuffer = edgeBuffer.concat(edges);
                        triangles.splice(j, 1);
                        j--;
                    }
                }
                if (i >= vertices.length)
                    continue;
                for (var j = edgeBuffer.length - 2; j >= 0; j--) {
                    for (var k = edgeBuffer.length - 1; k >= j + 1; k--) {
                        if (edgesEqual(edgeBuffer[k], edgeBuffer[j])) {
                            edgeBuffer.splice(k, 1);
                            edgeBuffer.splice(j, 1);
                            k--;
                            continue;
                        }
                    }
                }
                for (var j = 0; j < edgeBuffer.length; j++) {
                    var newTriangle = new MapGenCore.Triangle(edgeBuffer[j][0], edgeBuffer[j][1], vertex);
                    triangles.push(newTriangle);
                }
            }
            for (var i = triangles.length - 1; i >= 0; i--) {
                if (triangles[i].getAmountOfSharedVerticesWith(superTriangle)) {
                    triangles.splice(i, 1);
                }
            }
            return triangles;
        }
        MapGenCore.triangulate = triangulate;
        function getCentroid(vertices) {
            var signedArea = 0;
            var x = 0;
            var y = 0;
            var x0; // Current vertex X
            var y0; // Current vertex Y
            var x1; // Next vertex X
            var y1; // Next vertex Y
            var a; // Partial signed area
            var i = 0;
            for (i = 0; i < vertices.length - 1; i++) {
                x0 = vertices[i].x;
                y0 = vertices[i].y;
                x1 = vertices[i + 1].x;
                y1 = vertices[i + 1].y;
                a = x0 * y1 - x1 * y0;
                signedArea += a;
                x += (x0 + x1) * a;
                y += (y0 + y1) * a;
            }
            x0 = vertices[i].x;
            y0 = vertices[i].y;
            x1 = vertices[0].x;
            y1 = vertices[0].y;
            a = x0 * y1 - x1 * y0;
            signedArea += a;
            x += (x0 + x1) * a;
            y += (y0 + y1) * a;
            signedArea *= 0.5;
            x /= (6.0 * signedArea);
            y /= (6.0 * signedArea);
            return ({
                x: x,
                y: y
            });
        }
        MapGenCore.getCentroid = getCentroid;
        function makeSuperTriangle(vertices, highestCoordinateValue) {
            var max;
            if (highestCoordinateValue) {
                max = highestCoordinateValue;
            }
            else {
                max = vertices[0].x;
                for (var i = 0; i < vertices.length; i++) {
                    if (vertices[i].x > max) {
                        max = vertices[i].x;
                    }
                    if (vertices[i].y > max) {
                        max = vertices[i].y;
                    }
                }
            }
            var triangle = new MapGenCore.Triangle({
                x: 3 * max,
                y: 0
            }, {
                x: 0,
                y: 3 * max
            }, {
                x: -3 * max,
                y: -3 * max
            });
            return (triangle);
        }
        function pointsEqual(p1, p2) {
            return (p1.x === p2.x && p1.y === p2.y);
        }
        MapGenCore.pointsEqual = pointsEqual;
        function edgesEqual(e1, e2) {
            return ((pointsEqual(e1[0], e2[0]) && pointsEqual(e1[1], e2[1])) ||
                (pointsEqual(e1[0], e2[1]) && pointsEqual(e1[1], e2[0])));
        }
    })(MapGenCore = Rance.MapGenCore || (Rance.MapGenCore = {}));
})(Rance || (Rance = {}));
/// <reference path="../../lib/voronoi.d.ts" />
/// <reference path="../point.ts" />
/// <reference path="triangulation.ts" />
var Rance;
(function (Rance) {
    var MapGenCore;
    (function (MapGenCore) {
        function makeVoronoi(points, width, height) {
            var boundingBox = {
                xl: 0,
                xr: width,
                yt: 0,
                yb: height
            };
            var voronoi = new Voronoi();
            var diagram = voronoi.compute(points, boundingBox);
            for (var i = 0; i < diagram.cells.length; i++) {
                var cell = diagram.cells[i];
                cell.site.voronoiCell = cell;
                cell.vertices = getVerticesFromCell(cell);
            }
            return diagram;
        }
        MapGenCore.makeVoronoi = makeVoronoi;
        /**
         * Perform one iteration of Lloyd's Algorithm to move points in voronoi diagram to their centroid
         * @param {any}             diagram Voronoi diagram to relax
         * @param {(any) => number} dampeningFunction If specified, use value returned by dampeningFunction(cell.site)
         *                                            to adjust how far towards centroid the point is moved.
         *                                            0.0 = not moved, 0.5 = moved halfway, 1.0 = moved fully
         */
        function relaxVoronoi(diagram, dampeningFunction) {
            for (var i = 0; i < diagram.cells.length; i++) {
                var cell = diagram.cells[i];
                var point = cell.site;
                var centroid = MapGenCore.getCentroid(cell.vertices);
                if (dampeningFunction) {
                    var dampeningValue = dampeningFunction(point);
                    var xDelta = (centroid.x - point.x) * dampeningValue;
                    var yDelta = (centroid.y - point.y) * dampeningValue;
                    point.setPosition(point.x + xDelta, point.y + yDelta);
                }
                else {
                    point.setPosition(centroid.x, centroid.y);
                }
            }
        }
        MapGenCore.relaxVoronoi = relaxVoronoi;
        function getVerticesFromCell(cell) {
            var vertices = [];
            for (var i = 0; i < cell.halfedges.length; i++) {
                vertices.push(cell.halfedges[i].getStartpoint());
            }
            return vertices;
        }
    })(MapGenCore = Rance.MapGenCore || (Rance.MapGenCore = {}));
})(Rance || (Rance = {}));
/// <reference path="../../lib/quadtree.d.ts" />
/// <reference path="../mapvoronoiinfo.ts" />
/// <reference path="../galaxymap.ts" />
/// <reference path="../star.ts" />
/// <reference path="../fillerpoint.ts" />
/// <reference path="../player.ts" />
/// <reference path="voronoi.ts" />
var Rance;
(function (Rance) {
    var MapGenCore;
    (function (MapGenCore) {
        var MapGenResult = (function () {
            function MapGenResult(props) {
                this.stars = props.stars;
                this.fillerPoints = props.fillerPoints;
                this.width = props.width;
                this.height = props.height;
                this.seed = props.seed;
                this.independents = props.independents;
            }
            MapGenResult.prototype.getAllPoints = function () {
                return this.fillerPoints.concat(this.stars);
            };
            MapGenResult.prototype.makeMap = function () {
                this.voronoiInfo = this.makeVoronoiInfo();
                this.clearMapGenData();
                var map = new Rance.GalaxyMap(this);
                return map;
            };
            MapGenResult.prototype.makeVoronoiInfo = function () {
                var voronoiInfo = new Rance.MapVoronoiInfo();
                voronoiInfo.diagram = MapGenCore.makeVoronoi(this.getAllPoints(), this.width, this.height);
                voronoiInfo.treeMap = this.makeVoronoiTreeMap();
                voronoiInfo.bounds =
                    {
                        x1: 0,
                        x2: this.width,
                        y1: 0,
                        y2: this.height
                    };
                // move all stars to centroid of their voronoi cell. store original position for serialization
                for (var i = 0; i < this.stars.length; i++) {
                    var star = this.stars[i];
                    star.basisX = star.x;
                    star.basisY = star.y;
                }
                MapGenCore.relaxVoronoi(voronoiInfo.diagram, function (point) {
                    // dont move filler points
                    return isFinite(point.id) ? 1 : 0;
                });
                return voronoiInfo;
            };
            MapGenResult.prototype.makeVoronoiTreeMap = function () {
                var treeMap = new QuadTree({
                    x: 0,
                    y: 0,
                    width: this.width,
                    height: this.height
                });
                for (var i = 0; i < this.stars.length; i++) {
                    var cell = this.stars[i].voronoiCell;
                    var bbox = cell.getBbox();
                    bbox.cell = cell;
                    treeMap.insert(bbox);
                }
                return treeMap;
            };
            MapGenResult.prototype.clearMapGenData = function () {
                if (Rance.Options.debugMode) {
                    console.log("Skipped cleaning map gen data due to debug mode being enabled");
                    return;
                }
                for (var i = 0; i < this.stars.length; i++) {
                    this.stars[i].mapGenData = null;
                    delete this.stars[i].mapGenData;
                    delete this.stars[i].voronoiId;
                }
            };
            return MapGenResult;
        }());
        MapGenCore.MapGenResult = MapGenResult;
    })(MapGenCore = Rance.MapGenCore || (Rance.MapGenCore = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    (function (NotificationFilterState) {
        NotificationFilterState[NotificationFilterState["alwaysShow"] = 0] = "alwaysShow";
        NotificationFilterState[NotificationFilterState["showIfInvolved"] = 1] = "showIfInvolved";
        NotificationFilterState[NotificationFilterState["neverShow"] = 2] = "neverShow";
    })(Rance.NotificationFilterState || (Rance.NotificationFilterState = {}));
    var NotificationFilterState = Rance.NotificationFilterState;
})(Rance || (Rance = {}));
/// <reference path="templateinterfaces/inotificationtemplate.d.ts" />
/// <reference path="savedata/inotificationsavedata.d.ts" />
var Rance;
(function (Rance) {
    var Notification = (function () {
        function Notification(template, props, turn) {
            this.hasBeenRead = false;
            this.template = template;
            this.props = props;
            this.turn = turn;
        }
        Notification.prototype.makeMessage = function () {
            return this.template.messageConstructor(this.props);
        };
        Notification.prototype.serialize = function () {
            var data = {
                templateKey: this.template.key,
                hasBeenRead: this.hasBeenRead,
                turn: this.turn,
                props: this.template.serializeProps(this.props)
            };
            return data;
        };
        return Notification;
    }());
    Rance.Notification = Notification;
})(Rance || (Rance = {}));
/// <reference path="notificationfilterstate.ts" />
/// <reference path="notification.ts" />
/// <reference path="player.ts" />
var Rance;
(function (Rance) {
    var NotificationFilter = (function () {
        function NotificationFilter(player) {
            this.filters = {};
            this.player = player;
            this.setDefaultFilterStates();
            this.load();
        }
        NotificationFilter.prototype.setDefaultFilterStates = function () {
            var notifications = app.moduleData.Templates.Notifications;
            for (var key in notifications) {
                var notificationTemplate = notifications[key];
                this.filters[key] = notificationTemplate.defaultFilterState.slice(0);
            }
        };
        NotificationFilter.prototype.shouldDisplayNotification = function (notification) {
            var filterStates = this.filters[notification.template.key];
            if (filterStates.indexOf(Rance.NotificationFilterState.alwaysShow) !== -1) {
                return true;
            }
            else if (filterStates.indexOf(Rance.NotificationFilterState.neverShow) !== -1) {
                return false;
            }
            var playerIsInvolved = false;
            for (var key in notification.props) {
                if (notification.props[key] === this.player) {
                    playerIsInvolved = true;
                    break;
                }
            }
            if (playerIsInvolved) {
                return filterStates.indexOf(Rance.NotificationFilterState.showIfInvolved) !== -1;
            }
            return false;
        };
        NotificationFilter.prototype.getCompatibleFilterStates = function (filterState) {
            switch (filterState) {
                case Rance.NotificationFilterState.alwaysShow:
                    {
                        return [];
                    }
                case Rance.NotificationFilterState.showIfInvolved:
                    {
                        return [];
                    }
                case Rance.NotificationFilterState.neverShow:
                    {
                        return [];
                    }
            }
        };
        NotificationFilter.prototype.handleFilterStateChange = function (filterKey, state) {
            var stateIndex = this.filters[filterKey].indexOf(state);
            if (stateIndex !== -1) {
                if (this.filters[filterKey].length === 1) {
                    this.filters[filterKey] = [Rance.NotificationFilterState.neverShow];
                }
                else {
                    this.filters[filterKey].splice(stateIndex, 1);
                }
            }
            else {
                var newState = [state];
                var compatibleStates = this.getCompatibleFilterStates(state);
                for (var i = 0; i < this.filters[filterKey].length; i++) {
                    if (compatibleStates.indexOf(this.filters[filterKey][i]) !== -1) {
                        newState.push(this.filters[filterKey][i]);
                    }
                }
                this.filters[filterKey] = newState;
            }
        };
        NotificationFilter.prototype.getFiltersByCategory = function () {
            var filtersByCategory = {};
            var notifications = app.moduleData.Templates.Notifications;
            for (var key in this.filters) {
                var notificationTemplate = notifications[key];
                if (notificationTemplate) {
                    if (!filtersByCategory[notificationTemplate.category]) {
                        filtersByCategory[notificationTemplate.category] = [];
                    }
                    filtersByCategory[notificationTemplate.category].push({
                        notificationTemplate: notificationTemplate,
                        filterState: this.filters[key]
                    });
                }
            }
            return filtersByCategory;
        };
        NotificationFilter.prototype.setDefaultFilterStatesForCategory = function (category) {
            var byCategory = this.getFiltersByCategory();
            var forSelectedCategory = byCategory[category];
            for (var i = 0; i < forSelectedCategory.length; i++) {
                var template = forSelectedCategory[i].notificationTemplate;
                this.filters[template.key] = template.defaultFilterState.slice(0);
            }
        };
        NotificationFilter.prototype.load = function (slot) {
            var baseString = "Rance.NotificationFilter.";
            var parsedData;
            if (slot && localStorage[baseString + slot]) {
                parsedData = JSON.parse(localStorage.getItem(baseString + slot));
            }
            else {
                parsedData = Rance.getMatchingLocalstorageItemsByDate(baseString)[0];
            }
            if (parsedData) {
                this.filters = Rance.extendObject(parsedData.filters, this.filters, false);
            }
        };
        NotificationFilter.prototype.save = function (slot) {
            if (slot === void 0) { slot = 0; }
            var data = JSON.stringify({
                filters: this.filters,
                date: new Date()
            });
            localStorage.setItem("Rance.NotificationFilter." + slot, data);
        };
        return NotificationFilter;
    }());
    Rance.NotificationFilter = NotificationFilter;
})(Rance || (Rance = {}));
/// <reference path="templateinterfaces/inotificationtemplate.d.ts" />
/// <reference path="notification.ts" />
/// <reference path="notificationfilter.ts" />
/// <reference path="eventmanager.ts" />
/// <reference path="star.ts" />
/// <reference path="savedata/inotificationsavedata.d.ts" />
var Rance;
(function (Rance) {
    var NotificationLog = (function () {
        function NotificationLog(player) {
            this.byTurn = {};
            this.unread = [];
            this.isHumanTurn = true;
            this.listeners = {};
            this.addEventListeners();
            this.notificationFilter = new Rance.NotificationFilter(player);
        }
        NotificationLog.prototype.addEventListeners = function () {
            for (var key in app.moduleData.Templates.Notifications) {
                var template = app.moduleData.Templates.Notifications[key];
                for (var i = 0; i < template.eventListeners.length; i++) {
                    var listenerKey = template.eventListeners[i];
                    var listener = Rance.eventManager.addEventListener(listenerKey, this.makeNotification.bind(this, template));
                    if (!this.listeners[listenerKey]) {
                        this.listeners[listenerKey] = [];
                    }
                    this.listeners[listenerKey].push(listener);
                }
            }
        };
        NotificationLog.prototype.destroy = function () {
            for (var key in this.listeners) {
                for (var i = 0; i < this.listeners[key].length; i++) {
                    Rance.eventManager.removeEventListener(key, this.listeners[key][i]);
                }
            }
        };
        NotificationLog.prototype.setTurn = function (turn, isHumanTurn) {
            this.currentTurn = turn;
            this.isHumanTurn = isHumanTurn;
        };
        NotificationLog.prototype.makeNotification = function (template, props) {
            var notification = new Rance.Notification(template, props, this.currentTurn);
            this.addNotification(notification);
            if (this.isHumanTurn) {
                Rance.eventManager.dispatchEvent("updateNotificationLog");
            }
        };
        NotificationLog.prototype.addNotification = function (notification) {
            if (!this.byTurn[notification.turn]) {
                this.byTurn[notification.turn] = [];
            }
            this.byTurn[notification.turn].unshift(notification);
            if (!notification.hasBeenRead) {
                this.unread.unshift(notification);
            }
        };
        NotificationLog.prototype.markAsRead = function (notification) {
            var index = this.unread.indexOf(notification);
            if (index === -1)
                throw new Error("Notification is already unread");
            notification.hasBeenRead = true;
            this.unread.splice(index, 1);
        };
        NotificationLog.prototype.getUnreadNotificationsForTurn = function (turn) {
            return this.byTurn[turn].filter(function (notification) {
                return !notification.hasBeenRead;
            });
        };
        NotificationLog.prototype.filterNotifications = function (notifications) {
            var filtered = [];
            for (var i = 0; i < notifications.length; i++) {
                if (this.notificationFilter.shouldDisplayNotification(notifications[i])) {
                    filtered.push(notifications[i]);
                }
            }
            return filtered;
        };
        NotificationLog.prototype.serialize = function () {
            var notificationsSaveData = [];
            for (var turnNumber in this.byTurn) {
                var notifications = this.byTurn[turnNumber];
                for (var i = 0; i < notifications.length; i++) {
                    notificationsSaveData.push(notifications[i].serialize());
                }
            }
            var data = {
                notifications: notificationsSaveData
            };
            return data;
        };
        return NotificationLog;
    }());
    Rance.NotificationLog = NotificationLog;
})(Rance || (Rance = {}));
/// <reference path="player.ts"/>
/// <reference path="galaxymap.ts"/>
/// <reference path="eventmanager.ts"/>
/// <reference path="notificationlog.ts" />
/// <reference path="manufactory.ts" />
/// <reference path="savedata/igamesavedata.d.ts" />
var Rance;
(function (Rance) {
    var Game = (function () {
        function Game(map, players, humanPlayer) {
            this.independents = [];
            this.galaxyMap = map;
            if (map.independents) {
                this.independents = map.independents;
                map.independents = null;
                delete map.independents;
            }
            this.playerOrder = players;
            this.humanPlayer = humanPlayer;
            this.turnNumber = 1;
        }
        Game.prototype.destroy = function () {
            this.notificationLog.destroy();
            this.notificationLog = null;
            for (var i = 0; i < this.playerOrder.length; i++) {
                this.playerOrder[i].destroy();
            }
            for (var i = 0; i < this.independents.length; i++) {
                this.independents[i].destroy();
            }
        };
        Game.prototype.endTurn = function () {
            this.setNextPlayer();
            while (this.activePlayer.controlledLocations.length === 0) {
                this.killPlayer(this.activePlayer);
                this.activePlayer = this.playerOrder[0];
            }
            this.processPlayerStartTurn(this.activePlayer);
            this.notificationLog.setTurn(this.turnNumber, !this.activePlayer.isAI);
            if (this.activePlayer.isAI) {
                this.activePlayer.AIController.processTurn(this.endTurn.bind(this));
            }
            else {
                this.turnNumber++;
                for (var i = 0; i < this.independents.length; i++) {
                    this.processPlayerStartTurn(this.independents[i]);
                }
            }
            Rance.eventManager.dispatchEvent("endTurn", null);
            Rance.eventManager.dispatchEvent("updateSelection", null);
        };
        Game.prototype.processPlayerStartTurn = function (player) {
            var unitStartTurnFN = function (unit) {
                unit.resetMovePoints();
                unit.heal();
                var passiveSkillsByPhase = unit.getPassiveSkillsByPhase();
                if (passiveSkillsByPhase.atTurnStart) {
                    for (var i = 0; i < passiveSkillsByPhase.atTurnStart.length; i++) {
                        var skill = passiveSkillsByPhase.atTurnStart[i];
                        for (var j = 0; j < skill.atTurnStart.length; j++) {
                            skill.atTurnStart[j](unit);
                        }
                    }
                }
                unit.timesActedThisTurn = 0;
            };
            player.forEachUnit(unitStartTurnFN);
            if (!player.isIndependent) {
                player.money += player.getIncome();
                var allResourceIncomeData = player.getResourceIncome();
                for (var resourceType in allResourceIncomeData) {
                    var resourceData = allResourceIncomeData[resourceType];
                    player.addResource(resourceData.resource, resourceData.amount);
                }
                player.playerTechnology.allocateResearchPoints(player.getResearchSpeed());
                player.getAllManufactories().forEach(function (manufactory) {
                    manufactory.buildAllThings();
                });
            }
        };
        Game.prototype.setNextPlayer = function () {
            this.playerOrder.push(this.playerOrder.shift());
            this.activePlayer = this.playerOrder[0];
        };
        Game.prototype.killPlayer = function (playerToKill) {
            var playerOrderIndex;
            for (var i = 0; i < this.playerOrder.length; i++) {
                var player = this.playerOrder[i];
                if (player === playerToKill) {
                    playerOrderIndex = i;
                    continue;
                }
                player.diplomacyStatus.removePlayer(playerToKill);
            }
            playerToKill.die();
            playerToKill.destroy();
            this.playerOrder.splice(playerOrderIndex, 1);
        };
        Game.prototype.serialize = function () {
            var playersSaveData = this.playerOrder.map(function (player) {
                return player.serialize();
            });
            var independentsSaveData = this.independents.map(function (player) {
                return player.serialize();
            });
            var data = {
                turnNumber: this.turnNumber,
                galaxyMap: this.galaxyMap.serialize(),
                players: playersSaveData.concat(independentsSaveData),
                humanPlayerId: this.humanPlayer.id,
                notificationLog: this.notificationLog.serialize()
            };
            return data;
        };
        Game.prototype.save = function (name) {
            var saveString = "Rance.Save." + name;
            this.gameStorageKey = saveString;
            var date = new Date();
            var gameData = this.serialize();
            var stringified = JSON.stringify({
                name: name,
                date: date,
                gameData: gameData,
                idGenerators: Rance.extendObject(Rance.idGenerators),
                cameraLocation: app.renderer.camera.getCenterPosition()
            });
            localStorage.setItem(saveString, stringified);
        };
        return Game;
    }());
    Rance.Game = Game;
})(Rance || (Rance = {}));
/// <reference path="../lib/voronoi.d.ts" />
/// <reference path="mapgencore/mapgenresult.ts" />
/// <reference path="game.ts" />
/// <reference path="fillerpoint.ts" />
/// <reference path="star.ts" />
/// <reference path="mapvoronoiinfo.ts" />
/// <reference path="savedata/igalaxymapsavedata.d.ts" />
var Rance;
(function (Rance) {
    var GalaxyMap = (function () {
        function GalaxyMap(mapGen) {
            this.width = mapGen.width;
            this.height = mapGen.height;
            this.seed = mapGen.seed;
            this.stars = mapGen.stars;
            this.fillerPoints = mapGen.fillerPoints;
            this.independents = mapGen.independents;
            this.voronoi = mapGen.voronoiInfo;
        }
        GalaxyMap.prototype.getIncomeBounds = function () {
            var min, max;
            for (var i = 0; i < this.stars.length; i++) {
                var star = this.stars[i];
                var income = star.getIncome();
                if (!min)
                    min = max = income;
                else {
                    if (income < min)
                        min = income;
                    else if (income > max)
                        max = income;
                }
            }
            return ({
                min: min,
                max: max
            });
        };
        GalaxyMap.prototype.serialize = function () {
            var data = {
                stars: this.stars.map(function (star) {
                    return star.serialize();
                }),
                fillerPoints: this.fillerPoints.map(function (fillerPoint) {
                    return fillerPoint.serialize();
                }),
                width: this.width,
                height: this.height,
                seed: this.seed
            };
            return data;
        };
        return GalaxyMap;
    }());
    Rance.GalaxyMap = GalaxyMap;
})(Rance || (Rance = {}));
/// <reference path="../galaxymap.ts"/>
/// <reference path="../player.ts"/>
/// <reference path="../star.ts" />
/// <reference path="../game.ts" />
/// <reference path="../fleet.ts" />
var Rance;
(function (Rance) {
    var MapAI;
    (function (MapAI) {
        MapAI.defaultEvaluationParameters = {
            starDesirability: {
                neighborRange: 1,
                neighborWeight: 0.5,
                defendabilityWeight: 1,
                totalIncomeWeight: 1,
                baseIncomeWeight: 0.5,
                infrastructureWeight: 1,
                productionWeight: 1,
            }
        };
        // TODO ai | split into multiple classes eg vision, influence maps etc.
        var MapEvaluator = (function () {
            function MapEvaluator(map, player, game) {
                this.cachedInfluenceMaps = {};
                this.cachedVisibleFleets = {};
                this.cachedVisionMaps = {};
                this.map = map;
                this.player = player;
                this.game = game;
                this.evaluationParameters = MapAI.defaultEvaluationParameters;
            }
            MapEvaluator.prototype.processTurnStart = function () {
                this.cachedInfluenceMaps = {};
                this.cachedVisibleFleets = {};
                this.cachedVisionMaps = {};
                this.cachedOwnIncome = undefined;
            };
            MapEvaluator.prototype.evaluateStarIncome = function (star) {
                var evaluation = 0;
                evaluation += star.baseIncome;
                evaluation += (star.getIncome() - star.baseIncome) *
                    (1 - this.evaluationParameters.starDesirability.baseIncomeWeight);
                return evaluation;
            };
            MapEvaluator.prototype.evaluateStarInfrastructure = function (star) {
                var evaluation = 0;
                for (var category in star.buildings) {
                    for (var i = 0; i < star.buildings[category].length; i++) {
                        evaluation += star.buildings[category][i].totalCost / 25;
                    }
                }
                return evaluation;
            };
            MapEvaluator.prototype.evaluateStarProduction = function (star) {
                var evaluation = 0;
                // TODO manufactory TODO ai
                return evaluation;
            };
            MapEvaluator.prototype.evaluateStarDefendability = function (star) {
                var evaluation = 0;
                // neighboring own stars ++
                // neighboring neutral stars -
                // neighboring other player stars --
                // neighboring other player with low trust stars --- TODO ai
                var nearbyStars = star.getLinkedInRange(2).byRange;
                for (var rangeString in nearbyStars) {
                    var distanceMultiplier = 1 / parseInt(rangeString);
                    var starsInRange = nearbyStars[rangeString];
                    for (var i = 0; i < starsInRange.length; i++) {
                        var neighbor = starsInRange[i];
                        var neighborDefendability;
                        if (neighbor.owner === this.player) {
                            neighborDefendability = 3;
                        }
                        else if (neighbor.owner.isIndependent) {
                            neighborDefendability = -0.75;
                        }
                        else {
                            neighborDefendability = -2;
                        }
                        evaluation += neighborDefendability * distanceMultiplier;
                    }
                }
                if (star.owner === this.player) {
                    evaluation += 3;
                }
                return evaluation * 5;
            };
            MapEvaluator.prototype.evaluateIndividualStarDesirability = function (star) {
                var evaluation = 0;
                var p = this.evaluationParameters.starDesirability;
                if (!isFinite(this.cachedOwnIncome)) {
                    this.cachedOwnIncome = this.player.getIncome();
                }
                var incomeEvaluation = this.evaluateStarIncome(star) * p.totalIncomeWeight;
                // prioritize income when would make big relative boost, penalize when opposite
                incomeEvaluation *= incomeEvaluation / (this.cachedOwnIncome / 4);
                evaluation += incomeEvaluation;
                var infrastructureEvaluation = this.evaluateStarInfrastructure(star) * p.infrastructureWeight;
                evaluation += infrastructureEvaluation;
                var productionEvaluation = this.evaluateStarProduction(star) * p.productionWeight;
                evaluation += productionEvaluation;
                var defendabilityEvaluation = this.evaluateStarDefendability(star) * p.defendabilityWeight;
                evaluation += defendabilityEvaluation;
                return evaluation;
            };
            MapEvaluator.prototype.evaluateNeighboringStarsDesirability = function (star, range) {
                var evaluation = 0;
                var getDistanceFalloff = function (distance) {
                    return 1 / (distance + 1);
                };
                var inRange = star.getLinkedInRange(range).byRange;
                for (var distanceString in inRange) {
                    var stars = inRange[distanceString];
                    var distanceFalloff = getDistanceFalloff(parseInt(distanceString));
                    for (var i = 0; i < stars.length; i++) {
                        evaluation += this.evaluateIndividualStarDesirability(stars[i]) * distanceFalloff;
                    }
                }
                return evaluation;
            };
            MapEvaluator.prototype.evaluateStarDesirability = function (star) {
                var evaluation = 0;
                var p = this.evaluationParameters.starDesirability;
                evaluation += this.evaluateIndividualStarDesirability(star);
                evaluation += this.evaluateNeighboringStarsDesirability(star, p.neighborRange) *
                    p.neighborWeight;
                return evaluation;
            };
            MapEvaluator.prototype.evaluateIndependentTargets = function (targetStars) {
                var evaluationByStar = {};
                for (var i = 0; i < targetStars.length; i++) {
                    var star = targetStars[i];
                    var desirability = this.evaluateStarDesirability(star);
                    var independentStrength = this.getIndependentStrengthAtStar(star) || 1;
                    var ownInfluenceMap = this.getPlayerInfluenceMap(this.player);
                    var ownInfluenceAtStar = ownInfluenceMap[star.id] || 1;
                    evaluationByStar[star.id] =
                        {
                            star: star,
                            desirability: desirability,
                            independentStrength: independentStrength,
                            ownInfluence: ownInfluenceAtStar
                        };
                }
                return evaluationByStar;
            };
            MapEvaluator.prototype.scoreIndependentTargets = function (evaluations) {
                var scores = [];
                for (var starId in evaluations) {
                    var evaluation = evaluations[starId];
                    var easeOfCapturing = evaluation.ownInfluence / evaluation.independentStrength;
                    var score = evaluation.desirability * easeOfCapturing;
                    if (evaluation.star.getSecondaryController() === this.player) {
                        score *= 1.5;
                    }
                    scores.push({
                        star: evaluation.star,
                        score: score
                    });
                }
                return scores.sort(function (a, b) {
                    return b.score - a.score;
                });
            };
            MapEvaluator.prototype.evaluateDesirabilityOfPlayersStars = function (player) {
                var byStar = {};
                var total = 0;
                var stars = this.getVisibleStarsOfPlayer(player);
                for (var i = 0; i < stars.length; i++) {
                    var star = stars[i];
                    var desirability = this.evaluateStarDesirability(star);
                    byStar[star.id] =
                        {
                            star: star,
                            desirability: desirability
                        };
                    total += desirability;
                }
                return ({
                    byStar: byStar,
                    total: total
                });
            };
            MapEvaluator.prototype.getIndependentNeighborStars = function () {
                var self = this;
                var independentNeighborStars = this.player.getNeighboringStars().filter(function (star) {
                    var secondaryController = star.getSecondaryController();
                    return star.owner.isIndependent && (!secondaryController || secondaryController === self.player);
                });
                return independentNeighborStars;
            };
            MapEvaluator.prototype.getIndependentNeighborStarIslands = function (earlyReturnSize) {
                var self = this;
                var alreadyVisited = {};
                var allStars = [];
                var islandQualifierFN = function (a, b) {
                    var secondaryController = b.getSecondaryController();
                    return b.owner.isIndependent && (!secondaryController || secondaryController === self.player);
                };
                var neighborStars = this.getIndependentNeighborStars();
                for (var i = 0; i < neighborStars.length; i++) {
                    var neighborStar = neighborStars[i];
                    if (alreadyVisited[neighborStar.id]) {
                        continue;
                    }
                    var island = neighborStar.getIslandForQualifier(islandQualifierFN, earlyReturnSize);
                    for (var j = 0; j < island.length; j++) {
                        var star = island[j];
                        alreadyVisited[star.id] = true;
                        allStars.push(star);
                    }
                }
                return allStars;
            };
            MapEvaluator.prototype.getHostileUnitsAtStar = function (star) {
                var hostilePlayers = star.getEnemyFleetOwners(this.player);
                var unitsByEnemy = {};
                var allUnits = [];
                for (var i = 0; i < hostilePlayers.length; i++) {
                    unitsByEnemy[hostilePlayers[i].id] = star.getAllUnitsOfPlayer(hostilePlayers[i]);
                    allUnits = allUnits.concat(unitsByEnemy[hostilePlayers[i].id]);
                }
                return ({
                    byEnemy: unitsByEnemy,
                    all: allUnits
                });
            };
            MapEvaluator.prototype.getHostileStrengthAtStar = function (star) {
                var hostileUnitsByPlayer = this.getHostileUnitsAtStar(star).byEnemy;
                var strengthByEnemy = {};
                for (var playerId in hostileUnitsByPlayer) {
                    var strength = 0;
                    for (var i = 0; i < hostileUnitsByPlayer[playerId].length; i++) {
                        strength += hostileUnitsByPlayer[playerId][i].getStrengthEvaluation();
                    }
                    strengthByEnemy[playerId] = strength;
                }
                return strengthByEnemy;
            };
            MapEvaluator.prototype.getIndependentStrengthAtStar = function (star) {
                var units = star.getIndependentUnits();
                var total = 0;
                for (var i = 0; i < units.length; i++) {
                    total += units[i].getStrengthEvaluation();
                }
                return total;
            };
            MapEvaluator.prototype.getTotalHostileStrengthAtStar = function (star) {
                var byPlayer = this.getHostileStrengthAtStar(star);
                var total = 0;
                for (var playerId in byPlayer) {
                    total += byPlayer[playerId];
                }
                return total;
            };
            MapEvaluator.prototype.getDefenceBuildingStrengthAtStarByPlayer = function (star) {
                var byPlayer = {};
                for (var i = 0; i < star.buildings["defence"].length; i++) {
                    var building = star.buildings["defence"][i];
                    if (!byPlayer[building.controller.id]) {
                        byPlayer[building.controller.id] = 0;
                    }
                    byPlayer[building.controller.id] += building.totalCost;
                }
                return byPlayer;
            };
            MapEvaluator.prototype.getTotalDefenceBuildingStrengthAtStar = function (star) {
                var strength = 0;
                for (var i = 0; i < star.buildings["defence"].length; i++) {
                    var building = star.buildings["defence"][i];
                    if (building.controller.id === this.player.id)
                        continue;
                    strength += building.totalCost;
                }
                return strength;
            };
            MapEvaluator.prototype.evaluateFleetStrength = function (fleet) {
                return fleet.getTotalStrengthEvaluation();
            };
            MapEvaluator.prototype.getVisibleFleetsByPlayer = function () {
                if (this.game && this.cachedVisibleFleets[this.game.turnNumber]) {
                    return this.cachedVisibleFleets[this.game.turnNumber];
                }
                var stars = this.player.getVisibleStars();
                var byPlayer = {};
                for (var i = 0; i < stars.length; i++) {
                    var star = stars[i];
                    for (var playerId in star.fleets) {
                        var playerFleets = star.fleets[playerId];
                        if (!byPlayer[playerId]) {
                            byPlayer[playerId] = [];
                        }
                        for (var j = 0; j < playerFleets.length; j++) {
                            if (playerFleets[j].isStealthy && !this.player.starIsDetected(star)) {
                                continue;
                            }
                            byPlayer[playerId] = byPlayer[playerId].concat(playerFleets[j]);
                        }
                    }
                }
                if (this.game) {
                    this.cachedVisibleFleets[this.game.turnNumber] = byPlayer;
                }
                return byPlayer;
            };
            MapEvaluator.prototype.buildPlayerInfluenceMap = function (player) {
                var playerIsImmobile = player.isIndependent;
                var influenceByStar = {};
                var stars = this.player.getRevealedStars();
                for (var i = 0; i < stars.length; i++) {
                    var star = stars[i];
                    var defenceBuildingStrengths = this.getDefenceBuildingStrengthAtStarByPlayer(star);
                    if (defenceBuildingStrengths[player.id]) {
                        if (!isFinite(influenceByStar[star.id])) {
                            influenceByStar[star.id] = 0;
                        }
                        ;
                        influenceByStar[star.id] += defenceBuildingStrengths[player.id];
                    }
                }
                var fleets = this.getVisibleFleetsByPlayer()[player.id] || [];
                function getDistanceFalloff(distance) {
                    return 1 / (distance + 1);
                }
                for (var i = 0; i < fleets.length; i++) {
                    var fleet = fleets[i];
                    var strength = this.evaluateFleetStrength(fleet);
                    var location = fleet.location;
                    var range = fleet.getMinMaxMovePoints();
                    var turnsToCheck = 4;
                    var inFleetRange = location.getLinkedInRange(range * turnsToCheck).byRange;
                    inFleetRange[0] = [location];
                    for (var distance in inFleetRange) {
                        var numericDistance = parseInt(distance);
                        var turnsToReach = Math.floor((numericDistance - 1) / range);
                        if (turnsToReach < 0)
                            turnsToReach = 0;
                        var distanceFalloff = getDistanceFalloff(turnsToReach);
                        var adjustedStrength = strength * distanceFalloff;
                        for (var j = 0; j < inFleetRange[distance].length; j++) {
                            var star = inFleetRange[distance][j];
                            if (!isFinite(influenceByStar[star.id])) {
                                influenceByStar[star.id] = 0;
                            }
                            ;
                            influenceByStar[star.id] += adjustedStrength;
                        }
                    }
                }
                return influenceByStar;
            };
            MapEvaluator.prototype.getPlayerInfluenceMap = function (player) {
                if (!this.game) {
                    throw new Error("Can't use cached influence maps when game isn't specified for MapEvaluator");
                }
                if (!this.cachedInfluenceMaps[this.game.turnNumber]) {
                    this.cachedInfluenceMaps[this.game.turnNumber] = {};
                }
                if (!this.cachedInfluenceMaps[this.game.turnNumber][player.id]) {
                    this.cachedInfluenceMaps[this.game.turnNumber][player.id] = this.buildPlayerInfluenceMap(player);
                }
                return this.cachedInfluenceMaps[this.game.turnNumber][player.id];
            };
            MapEvaluator.prototype.getInfluenceMapsForKnownPlayers = function () {
                var byPlayer = {};
                for (var playerId in this.player.diplomacyStatus.metPlayers) {
                    var player = this.player.diplomacyStatus.metPlayers[playerId];
                    byPlayer[playerId] = this.getPlayerInfluenceMap(player);
                }
                return byPlayer;
            };
            MapEvaluator.prototype.getVisibleStarsOfPlayer = function (player) {
                return this.player.getVisibleStars().filter(function (star) {
                    return star.owner === player;
                });
            };
            MapEvaluator.prototype.getVisibleStarsOfKnownPlayers = function () {
                var byPlayer = {};
                for (var playerId in this.player.diplomacyStatus.metPlayers) {
                    var player = this.player.diplomacyStatus.metPlayers[playerId];
                    byPlayer[playerId] = this.getVisibleStarsOfPlayer(player);
                }
                return byPlayer;
            };
            MapEvaluator.prototype.estimateGlobalStrength = function (player) {
                var visibleStrength = 0;
                var invisibleStrength = 0;
                var fleets = this.getVisibleFleetsByPlayer()[player.id] || [];
                for (var i = 0; i < fleets.length; i++) {
                    visibleStrength += this.evaluateFleetStrength(fleets[i]);
                }
                if (player !== this.player) {
                    invisibleStrength = visibleStrength * 0.5; // TODO ai
                }
                return visibleStrength + invisibleStrength;
            };
            MapEvaluator.prototype.getPerceivedThreatOfPlayer = function (player) {
                if (!this.player.diplomacyStatus.metPlayers[player.id]) {
                    throw new Error(this.player.name +
                        " tried to call getPerceivedThreatOfPlayer on unkown player " + player.name);
                }
                var otherInfluenceMap = this.getPlayerInfluenceMap(player);
                var ownInfluenceMap = this.getPlayerInfluenceMap(this.player);
                var totalInfluenceInOwnStars = 0;
                for (var starId in otherInfluenceMap) {
                    for (var i = 0; i < this.player.controlledLocations.length; i++) {
                        var star = this.player.controlledLocations[i];
                        if (star.id === parseInt(starId)) {
                            var otherInfluence = otherInfluenceMap[starId];
                            var ownInfluence = ownInfluenceMap[starId];
                            totalInfluenceInOwnStars += otherInfluence - 0.5 * ownInfluence;
                            break;
                        }
                    }
                }
                var globalStrengthDifference = this.estimateGlobalStrength(player) - this.estimateGlobalStrength(this.player);
                return totalInfluenceInOwnStars + globalStrengthDifference;
            };
            MapEvaluator.prototype.getPerceivedThreatOfAllKnownPlayers = function () {
                var byPlayer = {};
                for (var playerId in this.player.diplomacyStatus.metPlayers) {
                    var player = this.player.diplomacyStatus.metPlayers[playerId];
                    byPlayer[playerId] = this.getPerceivedThreatOfPlayer(player);
                }
                return byPlayer;
            };
            MapEvaluator.prototype.getRelativePerceivedThreatOfAllKnownPlayers = function () {
                var byPlayer = this.getPerceivedThreatOfAllKnownPlayers();
                var relative = {};
                var min, max;
                for (var playerId in byPlayer) {
                    var threat = byPlayer[playerId];
                    min = isFinite(min) ? Math.min(min, threat) : threat;
                    max = isFinite(max) ? Math.max(max, threat) : threat;
                }
                for (var playerId in byPlayer) {
                    relative[playerId] = Rance.getRelativeValue(byPlayer[playerId], min, max);
                }
                return relative;
            };
            MapEvaluator.prototype.getVisionCoverageAroundStar = function (star, range, useDetection) {
                if (useDetection === void 0) { useDetection = false; }
                var toCheck = star.getLinkedInRange(range).all;
                var scorePerVisibleStar = 1 / toCheck.length;
                var coverageScore = 0;
                var visibilityCheckFN = useDetection ? this.player.starIsDetected : this.player.starIsVisible;
                for (var i = 0; i < toCheck.length; i++) {
                    var neighbor = toCheck[i];
                    if (visibilityCheckFN.call(this.player, neighbor)) {
                        coverageScore += scorePerVisibleStar;
                    }
                }
                return coverageScore;
            };
            MapEvaluator.prototype.estimateFleetRange = function (fleet, baseRange, afterSixUnits, getRangeFNName) {
                var range = baseRange;
                if (fleet.units.length >= 6) {
                    range += afterSixUnits;
                }
                for (var i = 0; i < fleet.units.length; i++) {
                    var unit = fleet.units[i];
                    if (this.player.unitIsIdentified(unit)) {
                        range = Math.max(range, unit[getRangeFNName]());
                    }
                }
                return range;
            };
            MapEvaluator.prototype.estimateFleetVisionRange = function (fleet) {
                return this.estimateFleetRange(fleet, 1, 1, "getVisionRange");
            };
            MapEvaluator.prototype.estimateFleetDetectionRange = function (fleet) {
                return this.estimateFleetRange(fleet, -1, 1, "getDetectionRange");
            };
            MapEvaluator.prototype.buildPlayerVisionMap = function (player) {
                var detectedStars = {};
                var visibleStars = {};
                var revealedStarsOfPlayer = this.player.getRevealedStars().filter(function (star) {
                    return star.owner === player;
                });
                var visibleFleetsOfPlayer = this.getVisibleFleetsByPlayer()[player.id] || [];
                var processDetectionSource = function (source, detectionRange, visionRange) {
                    var detected = source.getLinkedInRange(detectionRange).all;
                    for (var i = 0; i < detected.length; i++) {
                        var star = detected[i];
                        if (!detectedStars[star.id]) {
                            detectedStars[star.id] = star;
                        }
                    }
                    var visible = source.getLinkedInRange(visionRange).all;
                    for (var i = 0; i < visible.length; i++) {
                        var star = visible[i];
                        if (!visibleStars[star.id]) {
                            visibleStars[star.id] = star;
                        }
                    }
                };
                for (var i = 0; i < revealedStarsOfPlayer.length; i++) {
                    var star = revealedStarsOfPlayer[i];
                    var detectionRange = this.player.starIsDetected(star) ? star.getDetectionRange() : 0;
                    var visionRange = this.player.starIsDetected(star) ? star.getVisionRange() : 1;
                    processDetectionSource(star, detectionRange, visionRange);
                }
                for (var i = 0; i < visibleFleetsOfPlayer.length; i++) {
                    var fleet = visibleFleetsOfPlayer[i];
                    var detectionRange = this.estimateFleetDetectionRange(fleet);
                    var visionRange = this.estimateFleetVisionRange(fleet);
                    processDetectionSource(fleet.location, detectionRange, visionRange);
                }
                return ({
                    visible: visibleStars,
                    detected: detectedStars
                });
            };
            MapEvaluator.prototype.getPlayerVisionMap = function (player) {
                if (!this.cachedVisionMaps[player.id]) {
                    this.cachedVisionMaps[player.id] = this.buildPlayerVisionMap(player);
                }
                return this.cachedVisionMaps[player.id];
            };
            MapEvaluator.prototype.getScoredPerimeterLocationsAgainstPlayer = function (player, safetyFactor, forScouting) {
                var ownInfluence = this.getPlayerInfluenceMap(this.player);
                var enemyInfluence = this.getPlayerInfluenceMap(player);
                var enemyVision = this.getPlayerVisionMap(player);
                var scores = [];
                var revealedStars = this.player.getRevealedStars();
                var stars = revealedStars.filter(function (star) {
                    return star.owner.isIndependent || star.owner === this.player;
                }, this);
                for (var i = 0; i < stars.length; i++) {
                    var star = stars[i];
                    var nearestOwnedStar = player.getNearestOwnedStarTo(star);
                    if (!nearestOwnedStar)
                        debugger;
                    var distanceToEnemy = star.getDistanceToStar(nearestOwnedStar);
                    distanceToEnemy = Math.max(distanceToEnemy - 1, 1);
                    var distanceScore = Math.pow(1 / distanceToEnemy, 2);
                    var danger = enemyInfluence[star.id] || 1;
                    if (!enemyVision.visible[star.id]) {
                        danger *= 0.5;
                    }
                    danger *= safetyFactor;
                    if (forScouting) {
                        var safety = ownInfluence[star.id] / (danger * safetyFactor);
                        var score = safety * distanceScore;
                    }
                    else {
                        var score = (danger / ownInfluence[star.id]) / safetyFactor;
                    }
                    scores.push({
                        star: star,
                        score: score
                    });
                }
                return scores;
            };
            MapEvaluator.prototype.getDesireToGoToWarWith = function (player) {
                // potential gain
                // perceived difficulty
                var strength = this.estimateGlobalStrength(player);
                // relations
                var opinion = this.player.diplomacyStatus.getOpinionOf(player);
                // trust
                // own allies
                //   ally ability to go to war with
                //   ally trustworthiness
                //   ally opinion of us
                // enemy allies
                //   enemy ally strength
                // perceived threat
                var threat = this.getPerceivedThreatOfPlayer(player);
                return Math.random(); // TODO ai
            };
            MapEvaluator.prototype.getAbilityToGoToWarWith = function (player) {
                // perceived strength
                var strength = this.estimateGlobalStrength(player);
                // own trustworthy allies who can join
                //   ally ability to go to war with
                //   ally trustworthiness
                //   ally opinion of us
                // enemy allies
                //   enemy ally strength
                // enemy is well liked
                // distance
                return Math.random(); // TODO ai
            };
            MapEvaluator.prototype.getDiplomacyEvaluations = function (currentTurn) {
                var evaluationByPlayer = {};
                var neighborStarsCountByPlayer = {};
                var allNeighbors = this.player.getNeighboringStars();
                var neighborStarsForPlayer = [];
                for (var i = 0; i < allNeighbors.length; i++) {
                    var star = allNeighbors[i];
                    if (!star.owner.isIndependent) {
                        if (!neighborStarsCountByPlayer[star.owner.id]) {
                            neighborStarsCountByPlayer[star.owner.id] = 0;
                        }
                        neighborStarsCountByPlayer[star.owner.id]++;
                    }
                }
                for (var playerId in this.player.diplomacyStatus.metPlayers) {
                    var player = this.player.diplomacyStatus.metPlayers[playerId];
                    evaluationByPlayer[player.id] =
                        {
                            currentTurn: currentTurn,
                            opinion: this.player.diplomacyStatus.getOpinionOf(player),
                            neighborStars: neighborStarsCountByPlayer[player.id],
                            currentStatus: this.player.diplomacyStatus.statusByPlayer[player.id]
                        };
                }
                return evaluationByPlayer;
            };
            return MapEvaluator;
        }());
        MapAI.MapEvaluator = MapEvaluator;
    })(MapAI = Rance.MapAI || (Rance.MapAI = {}));
})(Rance || (Rance = {}));
/// <reference path="../../modules/default/templates/personalities.ts" />
/// <reference path="mapevaluator.ts"/>
var Rance;
(function (Rance) {
    var MapAI;
    (function (MapAI) {
        var GrandStrategyAI = (function () {
            function GrandStrategyAI(personality, mapEvaluator) {
                this.personality = personality;
                this.mapEvaluator = mapEvaluator;
            }
            GrandStrategyAI.prototype.setDesiredStars = function () {
                var totalStarsInMap = this.mapEvaluator.map.stars.length;
                var playersInGame = this.mapEvaluator.game.playerOrder.length;
                var starsPerPlayer = totalStarsInMap / playersInGame;
                var baseMinStarsDesired = starsPerPlayer * 0.34;
                var baseMaxStarsDesired = starsPerPlayer;
                var extraMinStarsDesired = this.personality.expansiveness * (starsPerPlayer * 0.66);
                var extraMaxStarsDesired = this.personality.expansiveness * (starsPerPlayer * (playersInGame / 4));
                var minStarsDesired = baseMinStarsDesired + extraMinStarsDesired;
                var maxStarsDesired = baseMaxStarsDesired + extraMaxStarsDesired;
                this.desiredStars =
                    {
                        min: minStarsDesired,
                        max: maxStarsDesired
                    };
            };
            GrandStrategyAI.prototype.setDesires = function () {
                this.desireForExpansion = this.getDesireForExpansion();
                this.desireForWar = this.getDesireForWar();
                this.desireForConsolidation = 0.4 + 0.6 * (1 - this.desireForExpansion);
            };
            GrandStrategyAI.prototype.getDesireForWar = function () {
                if (!this.desiredStars)
                    this.setDesiredStars();
                var fromAggressiveness = this.personality.aggressiveness;
                var fromExpansiveness = 0;
                var minStarsStillDesired = this.mapEvaluator.player.controlledLocations.length - this.desiredStars.min;
                var availableExpansionTargets = this.mapEvaluator.getIndependentNeighborStarIslands(minStarsStillDesired);
                if (availableExpansionTargets.length < minStarsStillDesired) {
                    fromExpansiveness += this.personality.expansiveness / (1 + availableExpansionTargets.length);
                }
                // TODO ai | penalize for lots of ongoing objectives (maybe in objectivesAI instead)
                var desire = fromAggressiveness + fromExpansiveness;
                return Rance.clamp(desire, 0, 1);
            };
            GrandStrategyAI.prototype.getDesireForExpansion = function () {
                if (!this.desiredStars)
                    this.setDesiredStars();
                var starsOwned = this.mapEvaluator.player.controlledLocations.length;
                var desire = 1 - Rance.getRelativeValue(starsOwned, this.desiredStars.min, this.desiredStars.max);
                // console.table([
                // {
                //   player: this.mapEvaluator.player.id,
                //   expansiveness: this.personality.expansiveness.toFixed(2),
                //   minDesired: Math.round(minStarsDesired),
                //   maxdesired: Math.round(maxStarsDesired),
                //   currentStars: starsOwned,
                //   desire: desire.toFixed(2)
                // }]);
                return Rance.clamp(desire, 0.1, 1);
            };
            return GrandStrategyAI;
        }());
        MapAI.GrandStrategyAI = GrandStrategyAI;
    })(MapAI = Rance.MapAI || (Rance.MapAI = {}));
})(Rance || (Rance = {}));
/// <reference path="../star.ts"/>
/*
objectives:
  defend area
  attack player at area
  expand

  clean up pirates
  heal

  ~~building
 */
var Rance;
(function (Rance) {
    var MapAI;
    (function (MapAI) {
        var Objective = (function () {
            function Objective(template, priority, target, targetPlayer) {
                this.isOngoing = false; // used to slightly prioritize old objectives
                this.id = Rance.idGenerators.objective++;
                this.template = template;
                this.type = this.template.key;
                this.priority = priority;
                this.target = target;
                this.targetPlayer = targetPlayer;
            }
            Object.defineProperty(Objective.prototype, "priority", {
                get: function () {
                    return this.isOngoing ? this._basePriority * 1.25 : this._basePriority;
                },
                set: function (priority) {
                    this._basePriority = priority;
                },
                enumerable: true,
                configurable: true
            });
            Objective.prototype.getUnitsDesired = function (mapEvaluator) {
                return this.template.unitsToFillObjectiveFN(mapEvaluator, this);
            };
            return Objective;
        }());
        MapAI.Objective = Objective;
    })(MapAI = Rance.MapAI || (Rance.MapAI = {}));
})(Rance || (Rance = {}));
/// <reference path="../galaxymap.ts"/>
/// <reference path="../game.ts"/>
/// <reference path="mapevaluator.ts"/>
/// <reference path="grandstrategyai.ts" />
/// <reference path="objective.ts"/>
/*
-- objectives ai
get expansion targets
create expansion objectives with priority based on score
add flat amount of priority if objective is ongoing
sort objectives by priority
while under max active expansion objectives
  make highest priority expansion objective active

-- fronts ai
divide available units to fronts based on priority
make requests for extra units if needed
muster units at muster location
when requested units arrive
  move units to target location
  execute action

-- economy ai
build units near request target
 */
/*
scouting objectives
  discovery
    find new locations
  tracking
    track enemy armies
  perimeter
    create perimeter of vision around own locations
 */
var Rance;
(function (Rance) {
    var MapAI;
    (function (MapAI) {
        var ObjectivesAI = (function () {
            function ObjectivesAI(mapEvaluator, grandStrategyAI) {
                this.objectivesByType = {};
                this.objectives = [];
                this.requests = [];
                this.mapEvaluator = mapEvaluator;
                this.map = mapEvaluator.map;
                this.player = mapEvaluator.player;
                this.grandStrategyAI = grandStrategyAI;
            }
            ObjectivesAI.prototype.clearObjectives = function () {
                this.objectives = [];
            };
            ObjectivesAI.prototype.setAllDiplomaticObjectives = function () {
                this.clearObjectives();
                this.setAllObjectivesWithTemplateProperty("diplomacyRoutineFN");
            };
            ObjectivesAI.prototype.setAllEconomicObjectives = function () {
                this.clearObjectives();
                this.setAllObjectivesWithTemplateProperty("economyRoutineFN");
            };
            ObjectivesAI.prototype.setAllMoveObjectives = function () {
                this.clearObjectives();
                this.setAllObjectivesWithTemplateProperty("moveRoutineFN");
            };
            ObjectivesAI.prototype.setAllObjectivesWithTemplateProperty = function (propKey) {
                var objectiveTemplates = app.moduleData.Templates.Objectives;
                for (var key in objectiveTemplates) {
                    var template = objectiveTemplates[key];
                    if (template[propKey]) {
                        this.setObjectivesOfType(objectiveTemplates[key]);
                    }
                }
            };
            ObjectivesAI.prototype.getNewObjectivesOfType = function (objectiveTemplate) {
                var objectiveType = objectiveTemplate.key;
                var byTarget = this.getObjectivesByTarget(objectiveType, true);
                var newObjectives = objectiveTemplate.creatorFunction(this.grandStrategyAI, this.mapEvaluator, this);
                var finalObjectives = [];
                for (var i = 0; i < newObjectives.length; i++) {
                    var newObjective = newObjectives[i];
                    if (newObjective.priority < 0.04) {
                        continue;
                    }
                    var keyString = newObjective.target ? newObjective.target.id : "noTarget";
                    var oldObjective = byTarget[keyString];
                    if (oldObjective) {
                        oldObjective.priority = newObjective.priority;
                        finalObjectives.push(oldObjective);
                    }
                    else {
                        finalObjectives.push(newObjective);
                    }
                }
                return finalObjectives;
            };
            ObjectivesAI.prototype.setObjectivesOfType = function (objectiveTemplate) {
                var newObjectives = this.getNewObjectivesOfType(objectiveTemplate);
                this.objectivesByType[objectiveTemplate.key] = newObjectives;
                this.objectives = this.objectives.concat(newObjectives);
            };
            ObjectivesAI.prototype.getObjectivesByTarget = function (objectiveType, markAsOngoing) {
                var objectivesByTarget = {};
                if (!this.objectivesByType[objectiveType]) {
                    return objectivesByTarget;
                }
                for (var i = 0; i < this.objectivesByType[objectiveType].length; i++) {
                    var objective = this.objectivesByType[objectiveType][i];
                    if (markAsOngoing)
                        objective.isOngoing = true;
                    var keyString = objective.target ? objective.target.id : "noTarget";
                    objectivesByTarget[keyString] = objective;
                }
                return objectivesByTarget;
            };
            ObjectivesAI.prototype.getObjectivesWithTemplateProperty = function (propKey) {
                return this.objectives.filter(function (objective) {
                    return Boolean(objective.template[propKey]);
                });
            };
            ObjectivesAI.prototype.getAdjustmentsForTemplateProperty = function (propKey) {
                var withAdjustment = this.getObjectivesWithTemplateProperty(propKey);
                var adjustments;
                for (var i = 0; i < withAdjustment.length; i++) {
                    for (var j = 0; j < withAdjustment[i].template[propKey].length; j++) {
                        var adjustment = withAdjustment[i].template[propKey][j];
                        if (!adjustments[adjustment.target.id]) {
                            adjustments[adjustment.target.id] =
                                {
                                    target: adjustment.target,
                                    multiplier: 1
                                };
                        }
                        adjustments[adjustment.target.id].multiplier += adjustment.multiplier;
                    }
                }
                return adjustments;
            };
            return ObjectivesAI;
        }());
        MapAI.ObjectivesAI = ObjectivesAI;
    })(MapAI = Rance.MapAI || (Rance.MapAI = {}));
})(Rance || (Rance = {}));
/// <reference path="../unit.ts"/>
/// <reference path="../star.ts"/>
var Rance;
(function (Rance) {
    var MapAI;
    (function (MapAI) {
        var Front = (function () {
            function Front(props) {
                this.hasMustered = false;
                this.id = props.id;
                this.objective = props.objective;
                this.units = props.units || [];
                this.minUnitsDesired = props.minUnitsDesired;
                this.idealUnitsDesired = props.idealUnitsDesired;
                this.targetLocation = props.targetLocation;
                this.musterLocation = props.musterLocation;
            }
            Front.prototype.organizeFleets = function () {
                // pure fleet only has units belonging to this front in it
                /*
                get all pure fleets + location
                get all units in impure fleets + location
                merge pure fleets at same location
                move impure units to pure fleets at location if possible
                create new pure fleets with remaining impure units
                 */
                var allFleets = this.getAssociatedFleets();
                var pureFleetsByLocation = {};
                var impureFleetMembersByLocation = {};
                var ownUnitFilterFN = function (unit) {
                    return this.getUnitIndex(unit) >= 0;
                }.bind(this);
                // build indexes of pure fleets and impure units
                for (var i = 0; i < allFleets.length; i++) {
                    var fleet = allFleets[i];
                    var star = fleet.location;
                    if (this.isFleetPure(fleet)) {
                        if (!pureFleetsByLocation[star.id]) {
                            pureFleetsByLocation[star.id] = [];
                        }
                        pureFleetsByLocation[star.id].push(fleet);
                    }
                    else {
                        var ownUnits = fleet.units.filter(ownUnitFilterFN);
                        for (var j = 0; j < ownUnits.length; j++) {
                            if (!impureFleetMembersByLocation[star.id]) {
                                impureFleetMembersByLocation[star.id] = [];
                            }
                            impureFleetMembersByLocation[star.id].push(ownUnits[j]);
                        }
                    }
                }
                var sortFleetsBySizeFN = function (a, b) {
                    return b.units.length - a.units.length;
                };
                for (var starId in pureFleetsByLocation) {
                    // combine pure fleets at same location
                    var fleets = pureFleetsByLocation[starId];
                    if (fleets.length > 1) {
                        fleets.sort(sortFleetsBySizeFN);
                        // only goes down to i = 1 !!
                        for (var i = fleets.length - 1; i >= 1; i--) {
                            fleets[i].mergeWith(fleets[0]);
                            fleets.splice(i, 1);
                        }
                    }
                    // move impure units to pure fleets at same location
                    if (impureFleetMembersByLocation[starId]) {
                        for (var i = impureFleetMembersByLocation[starId].length - 1; i >= 0; i--) {
                            var unit = impureFleetMembersByLocation[starId][i];
                            unit.fleet.transferUnit(fleets[0], unit);
                            impureFleetMembersByLocation[starId].splice(i, 1);
                        }
                    }
                }
                // create new pure fleets from leftover impure units
                for (var starId in impureFleetMembersByLocation) {
                    var units = impureFleetMembersByLocation[starId];
                    if (units.length < 1)
                        continue;
                    var newFleet = new Rance.Fleet(units[0].fleet.player, [], units[0].fleet.location);
                    for (var i = units.length - 1; i >= 0; i--) {
                        units[i].fleet.transferUnit(newFleet, units[i]);
                    }
                }
            };
            Front.prototype.isFleetPure = function (fleet) {
                for (var i = 0; i < fleet.units.length; i++) {
                    if (this.getUnitIndex(fleet.units[i]) === -1) {
                        return false;
                    }
                }
                return true;
            };
            Front.prototype.getAssociatedFleets = function () {
                var fleetsById = {};
                for (var i = 0; i < this.units.length; i++) {
                    if (!this.units[i].fleet)
                        continue;
                    if (!fleetsById[this.units[i].fleet.id]) {
                        fleetsById[this.units[i].fleet.id] = this.units[i].fleet;
                    }
                }
                var allFleets = [];
                for (var fleetId in fleetsById) {
                    allFleets.push(fleetsById[fleetId]);
                }
                return allFleets;
            };
            Front.prototype.getUnitIndex = function (unit) {
                return this.units.indexOf(unit);
            };
            Front.prototype.addUnit = function (unit) {
                if (unit.front) {
                    unit.front.removeUnit(unit);
                }
                unit.front = this;
                this.units.push(unit);
            };
            Front.prototype.removeUnit = function (unit) {
                var unitIndex = this.getUnitIndex(unit);
                unit.front = null;
                this.units.splice(unitIndex, 1);
            };
            Front.prototype.getUnitCountByArchetype = function () {
                var unitCountByArchetype = {};
                for (var i = 0; i < this.units.length; i++) {
                    var archetype = this.units[i].template.archetype;
                    if (!unitCountByArchetype[archetype.type]) {
                        unitCountByArchetype[archetype.type] = 0;
                    }
                    unitCountByArchetype[archetype.type]++;
                }
                return unitCountByArchetype;
            };
            Front.prototype.getUnitsByLocation = function () {
                var byLocation = {};
                for (var i = 0; i < this.units.length; i++) {
                    var star = this.units[i].fleet.location;
                    if (!byLocation[star.id]) {
                        byLocation[star.id] = [];
                    }
                    byLocation[star.id].push(this.units[i]);
                }
                return byLocation;
            };
            Front.prototype.moveFleets = function (afterMoveCallback) {
                if (this.units.length < 1) {
                    afterMoveCallback();
                    return;
                }
                else {
                    var moveRoutine = this.objective.template.moveRoutineFN;
                    moveRoutine(this, afterMoveCallback);
                }
            };
            Front.prototype.hasUnit = function (unit) {
                return this.units.indexOf(unit) !== -1;
            };
            Front.prototype.scoreUnitFit = function (unit) {
                var template = this.objective.template;
                var score = 1;
                if (this.hasUnit(unit)) {
                    score += 0.2;
                    if (this.hasMustered) {
                        score += 0.3;
                    }
                    this.removeUnit(unit);
                }
                score *= this.objective.priority;
                score *= template.unitFitFN(unit, this);
                score *= template.unitDesireFN(this);
                return score;
            };
            Front.prototype.getNewUnitArchetypeScores = function () {
                var countByArchetype = this.getUnitCountByArchetype();
                var totalUnits = this.units.length;
                var idealWeights = this.objective.template.preferredUnitComposition;
                var scores = {};
                for (var unitType in idealWeights) {
                    var archetypeCount = countByArchetype[unitType] || 0;
                    scores[unitType] = totalUnits * idealWeights[unitType] - archetypeCount;
                }
                return scores;
            };
            return Front;
        }());
        MapAI.Front = Front;
    })(MapAI = Rance.MapAI || (Rance.MapAI = {}));
})(Rance || (Rance = {}));
/// <reference path="../../modules/default/templates/personalities.ts" />
/// <reference path="../player.ts"/>
/// <reference path="../galaxymap.ts"/>
/// <reference path="objectivesai.ts"/>
/// <reference path="front.ts"/>
/// <reference path="mapevaluator.ts"/>
var Rance;
(function (Rance) {
    var MapAI;
    (function (MapAI) {
        var FrontsAI = (function () {
            function FrontsAI(mapEvaluator, objectivesAI, personality) {
                this.fronts = [];
                this.frontsRequestingUnits = [];
                this.frontsToMove = [];
                this.mapEvaluator = mapEvaluator;
                this.map = mapEvaluator.map;
                this.player = mapEvaluator.player;
                this.objectivesAI = objectivesAI;
                this.personality = personality;
            }
            FrontsAI.prototype.getUnitScoresForFront = function (units, front) {
                var scores = [];
                for (var i = 0; i < units.length; i++) {
                    scores.push({
                        unit: units[i],
                        score: front.scoreUnitFit(units[i]),
                        front: front
                    });
                }
                return scores;
            };
            FrontsAI.prototype.assignUnits = function () {
                var units = this.player.getAllUnits();
                var allUnitScores = [];
                var unitScoresByFront = {};
                var recalculateScoresForFront = function (front) {
                    var frontScores = unitScoresByFront[front.id];
                    for (var i = 0; i < frontScores.length; i++) {
                        frontScores[i].score = front.scoreUnitFit(frontScores[i].unit);
                    }
                };
                var removeUnit = function (unit) {
                    for (var frontId in unitScoresByFront) {
                        unitScoresByFront[frontId] = unitScoresByFront[frontId].filter(function (score) {
                            return score.unit !== unit;
                        });
                    }
                };
                // ascending
                var sortByScoreFN = function (a, b) {
                    return a.score - b.score;
                };
                for (var i = 0; i < this.fronts.length; i++) {
                    var frontScores = this.getUnitScoresForFront(units, this.fronts[i]);
                    unitScoresByFront[this.fronts[i].id] = frontScores;
                    allUnitScores = allUnitScores.concat(frontScores);
                }
                var alreadyAdded = {};
                while (allUnitScores.length > 0) {
                    // sorted in loop as scores get recalculated every iteration
                    allUnitScores.sort(sortByScoreFN);
                    var bestScore = allUnitScores.pop();
                    if (alreadyAdded[bestScore.unit.id]) {
                        continue;
                    }
                    bestScore.front.addUnit(bestScore.unit);
                    removeUnit(bestScore.unit);
                    alreadyAdded[bestScore.unit.id] = true;
                    recalculateScoresForFront(bestScore.front);
                }
            };
            FrontsAI.prototype.getFrontWithId = function (id) {
                for (var i = 0; i < this.fronts.length; i++) {
                    if (this.fronts[i].id === id) {
                        return this.fronts[i];
                    }
                }
                return null;
            };
            FrontsAI.prototype.createFront = function (objective) {
                var musterLocation = objective.target ?
                    this.player.getNearestOwnedStarTo(objective.target) :
                    null;
                var unitsDesired = objective.getUnitsDesired(this.mapEvaluator);
                var front = new MapAI.Front({
                    id: objective.id,
                    objective: objective,
                    minUnitsDesired: unitsDesired.min,
                    idealUnitsDesired: unitsDesired.ideal,
                    targetLocation: objective.target,
                    musterLocation: musterLocation
                });
                return front;
            };
            FrontsAI.prototype.removeInactiveFronts = function () {
                // loop backwards because splicing
                for (var i = this.fronts.length - 1; i >= 0; i--) {
                    var front = this.fronts[i];
                    var hasActiveObjective = false;
                    for (var j = 0; j < this.objectivesAI.objectives.length; j++) {
                        var objective = this.objectivesAI.objectives[j];
                        if (objective.id === front.id) {
                            hasActiveObjective = true;
                            break;
                        }
                    }
                    if (!hasActiveObjective) {
                        this.fronts.splice(i, 1);
                    }
                }
            };
            FrontsAI.prototype.formFronts = function () {
                /*
                dissolve old fronts without an active objective
                create new fronts for every objective not already assoicated with one
                 */
                this.removeInactiveFronts();
                for (var i = 0; i < this.objectivesAI.objectives.length; i++) {
                    var objective = this.objectivesAI.objectives[i];
                    if (!objective.template.moveRoutineFN) {
                        continue;
                    }
                    if (!this.getFrontWithId(objective.id)) {
                        var front = this.createFront(objective);
                        this.fronts.push(front);
                    }
                }
            };
            FrontsAI.prototype.organizeFleets = function () {
                for (var i = 0; i < this.fronts.length; i++) {
                    this.fronts[i].organizeFleets();
                }
            };
            FrontsAI.prototype.setFrontsToMove = function () {
                this.frontsToMove = this.fronts.slice(0);
                this.frontsToMove.sort(function (a, b) {
                    return a.objective.template.movePriority - b.objective.template.movePriority;
                });
            };
            FrontsAI.prototype.moveFleets = function (afterMovingAllCallback) {
                var front = this.frontsToMove.pop();
                if (!front) {
                    afterMovingAllCallback();
                    return;
                }
                front.moveFleets(this.moveFleets.bind(this, afterMovingAllCallback));
            };
            FrontsAI.prototype.setUnitRequests = function () {
                /*for each front that doesnt fulfill minimum unit requirement
                  make request with same priority of front
                */
                this.frontsRequestingUnits = [];
                for (var i = 0; i < this.fronts.length; i++) {
                    var front = this.fronts[i];
                    if (front.units.length < front.idealUnitsDesired) {
                        this.frontsRequestingUnits.push(front);
                    }
                }
            };
            return FrontsAI;
        }());
        MapAI.FrontsAI = FrontsAI;
    })(MapAI = Rance.MapAI || (Rance.MapAI = {}));
})(Rance || (Rance = {}));
/// <reference path="../../modules/default/templates/personalities.ts" />
/// <reference path="../galaxymap.ts"/>
/// <reference path="../game.ts"/>
/// <reference path="mapevaluator.ts"/>
/// <reference path="objectivesai.ts"/>
/// <reference path="frontsai.ts"/>
var Rance;
(function (Rance) {
    var MapAI;
    (function (MapAI) {
        var EconomyAI = (function () {
            function EconomyAI(props) {
                this.objectivesAI = props.objectivesAI;
                this.frontsAI = props.frontsAI;
                this.mapEvaluator = props.mapEvaluator;
                this.player = props.mapEvaluator.player;
                this.personality = props.personality;
            }
            EconomyAI.prototype.resolveEconomicObjectives = function () {
                var objectives = this.objectivesAI.getObjectivesWithTemplateProperty("economyRoutineFN");
                var adjustments = this.objectivesAI.getAdjustmentsForTemplateProperty("economyRoutineAdjustments");
                for (var i = 0; i < objectives.length; i++) {
                    var objective = objectives[i];
                    objective.template.economyRoutineFN(objective, this, adjustments);
                }
            };
            EconomyAI.prototype.satisfyAllRequests = function () {
                /*
                get all requests from OAI and FAI
                sort by priority
                fulfill by priority
                 */
                var allRequests = this.frontsAI.frontsRequestingUnits;
                allRequests.sort(function (a, b) {
                    return b.objective.priority - a.objective.priority;
                });
                for (var i = 0; i < allRequests.length; i++) {
                    var request = allRequests[i];
                    // is front
                    if (request.targetLocation) {
                        this.satisfyFrontRequest(request);
                    }
                    else {
                    }
                }
            };
            EconomyAI.prototype.satisfyFrontRequest = function (front) {
                var player = this.player;
                var starQualifierFN = function (star) {
                    return star.owner === player && star.manufactory && !star.manufactory.queueIsFull();
                };
                var star = front.musterLocation.getNearestStarForQualifier(starQualifierFN);
                if (!star) {
                    return;
                }
                var manufactory = star.manufactory;
                var archetypeScores = front.getNewUnitArchetypeScores();
                var buildableUnitTypesByArchetype = {};
                var buildableUnitTypes = player.getGloballyBuildableUnits().concat(manufactory.getLocalUnitTypes().manufacturable);
                for (var i = 0; i < buildableUnitTypes.length; i++) {
                    var archetype = buildableUnitTypes[i].archetype;
                    if (!buildableUnitTypesByArchetype[archetype.type]) {
                        buildableUnitTypesByArchetype[archetype.type] = [];
                    }
                    if (!archetypeScores[archetype.type]) {
                        archetypeScores[archetype.type] = 0;
                    }
                    buildableUnitTypesByArchetype[archetype.type].push(buildableUnitTypes[i]);
                }
                var sortedScores = Rance.getObjectKeysSortedByValue(archetypeScores, "desc");
                var unitType;
                for (var i = 0; i < sortedScores.length; i++) {
                    if (buildableUnitTypesByArchetype[sortedScores[i]]) {
                        // TODO ai | should actually try to figure out which unit type to build
                        unitType = Rance.getRandomArrayItem(buildableUnitTypesByArchetype[sortedScores[i]]);
                        if (this.player.money < unitType.buildCost) {
                            return;
                        }
                        else {
                            break;
                        }
                    }
                }
                if (!unitType)
                    debugger;
                manufactory.addThingToQueue(unitType, "unit");
            };
            return EconomyAI;
        }());
        MapAI.EconomyAI = EconomyAI;
    })(MapAI = Rance.MapAI || (Rance.MapAI = {}));
})(Rance || (Rance = {}));
/// <reference path="../game.ts"/>
/// <reference path="../player.ts"/>
/// <reference path="../diplomacystatus.ts"/>
/// <reference path="mapevaluator.ts"/>
/// <reference path="objectivesai.ts"/>
var Rance;
(function (Rance) {
    var MapAI;
    (function (MapAI) {
        var DiplomacyAI = (function () {
            function DiplomacyAI(mapEvaluator, objectivesAI, game, personality) {
                this.game = game;
                this.player = mapEvaluator.player;
                this.diplomacyStatus = this.player.diplomacyStatus;
                this.mapEvaluator = mapEvaluator;
                this.objectivesAI = objectivesAI;
                this.personality = personality;
            }
            DiplomacyAI.prototype.setAttitudes = function () {
                var diplomacyEvaluations = this.mapEvaluator.getDiplomacyEvaluations(this.game.turnNumber);
                for (var playerId in diplomacyEvaluations) {
                    this.diplomacyStatus.processAttitudeModifiersForPlayer(this.diplomacyStatus.metPlayers[playerId], diplomacyEvaluations[playerId]);
                }
            };
            DiplomacyAI.prototype.resolveDiplomaticObjectives = function (afterAllDoneCallback) {
                var objectives = this.objectivesAI.getObjectivesWithTemplateProperty("diplomacyRoutineFN");
                var adjustments = this.objectivesAI.getAdjustmentsForTemplateProperty("diplomacyRoutineAdjustments");
                this.resolveNextObjective(objectives, adjustments, afterAllDoneCallback);
            };
            DiplomacyAI.prototype.resolveNextObjective = function (objectives, adjustments, afterAllDoneCallback) {
                var objective = objectives.pop();
                if (!objective) {
                    afterAllDoneCallback();
                    return;
                }
                var boundResolveNextFN = this.resolveNextObjective.bind(this, objectives, adjustments, afterAllDoneCallback);
                objective.template.diplomacyRoutineFN(objective, this, adjustments, boundResolveNextFN);
            };
            return DiplomacyAI;
        }());
        MapAI.DiplomacyAI = DiplomacyAI;
    })(MapAI = Rance.MapAI || (Rance.MapAI = {}));
})(Rance || (Rance = {}));
/// <reference path="../../modules/default/templates/personalities.ts" />
/// <reference path="../galaxymap.ts"/>
/// <reference path="../game.ts"/>
/// <reference path="../player.ts"/>
/// <reference path="mapevaluator.ts"/>
/// <reference path="objectivesai.ts"/>
/// <reference path="economyai.ts"/>
/// <reference path="frontsai.ts"/>
/// <reference path="diplomacyai.ts"/>
/// <reference path="grandstrategyai.ts"/>
var Rance;
(function (Rance) {
    var MapAI;
    (function (MapAI) {
        var AIController = (function () {
            function AIController(player, game, personality) {
                this.personality = personality || Rance.makeRandomPersonality();
                this.player = player;
                this.game = game;
                this.map = game.galaxyMap;
                this.mapEvaluator = new MapAI.MapEvaluator(this.map, this.player, this.game);
                this.grandStrategyAI = new MapAI.GrandStrategyAI(this.personality, this.mapEvaluator);
                this.objectivesAI = new MapAI.ObjectivesAI(this.mapEvaluator, this.grandStrategyAI);
                this.frontsAI = new MapAI.FrontsAI(this.mapEvaluator, this.objectivesAI, this.personality);
                this.economyAI = new MapAI.EconomyAI({
                    objectivesAI: this.objectivesAI,
                    frontsAI: this.frontsAI,
                    mapEvaluator: this.mapEvaluator,
                    personality: this.personality
                });
                this.diplomacyAI = new MapAI.DiplomacyAI(this.mapEvaluator, this.objectivesAI, this.game, this.personality);
            }
            AIController.prototype.processTurn = function (afterFinishedCallback) {
                // clear cached stuff from mapevaluator
                this.mapEvaluator.processTurnStart();
                // gsai evaluate grand strategy
                this.grandStrategyAI.setDesires();
                // dai set attitude
                this.diplomacyAI.setAttitudes();
                // oai make objectives
                this.objectivesAI.setAllDiplomaticObjectives();
                // dai resolve diplomatic objectives
                this.diplomacyAI.resolveDiplomaticObjectives(this.processTurnAfterDiplomaticObjectives.bind(this, afterFinishedCallback));
            };
            AIController.prototype.processTurnAfterDiplomaticObjectives = function (afterFinishedCallback) {
                this.objectivesAI.setAllEconomicObjectives();
                this.economyAI.resolveEconomicObjectives();
                // oai make objectives
                this.objectivesAI.setAllMoveObjectives();
                // fai form fronts
                this.frontsAI.formFronts();
                // fai assign units
                this.frontsAI.assignUnits();
                // fai request units
                this.frontsAI.setUnitRequests();
                // eai fulfill requests
                this.economyAI.satisfyAllRequests();
                // fai organize fleets
                this.frontsAI.organizeFleets();
                // fai set fleets yet to move
                this.frontsAI.setFrontsToMove();
                // fai move fleets
                // function param is called after all fronts have moved
                this.frontsAI.moveFleets(this.finishMovingFleets.bind(this, afterFinishedCallback));
            };
            AIController.prototype.finishMovingFleets = function (afterFinishedCallback) {
                this.frontsAI.organizeFleets();
                if (afterFinishedCallback) {
                    afterFinishedCallback();
                }
            };
            return AIController;
        }());
        MapAI.AIController = AIController;
    })(MapAI = Rance.MapAI || (Rance.MapAI = {}));
})(Rance || (Rance = {}));
/// <reference path="unit.ts"/>
/// <reference path="fleet.ts"/>
/// <reference path="utility.ts"/>
/// <reference path="building.ts" />
/// <reference path="star.ts" />
/// <reference path="flag.ts" />
/// <reference path="item.ts" />
/// <reference path="battlesimulator.ts" />
/// <reference path="battleprep.ts" />
/// <reference path="diplomacystatus.ts" />
/// <reference path="manufactory.ts" />
/// <reference path="playertechnology.ts" />
/// <reference path="ifleetattacktarget.d.ts" />
/// <reference path="mapai/aicontroller.ts"/>
/// <reference path="savedata/iplayersavedata.d.ts" />
var Rance;
(function (Rance) {
    var Player = (function () {
        function Player(isAI, id) {
            this.units = {};
            this.resources = {};
            this.fleets = [];
            this.items = [];
            this.isAI = false;
            this.isIndependent = false;
            this.controlledLocations = [];
            this.visionIsDirty = true;
            this.visibleStars = {};
            this.revealedStars = {};
            this.detectedStars = {};
            this.identifiedUnits = {};
            this.tempOverflowedResearchAmount = 0;
            this.listeners = {};
            this.id = isFinite(id) ? id : Rance.idGenerators.player++;
            this.name = "Player " + this.id;
            this.isAI = isAI;
            this.diplomacyStatus = new Rance.DiplomacyStatus(this);
            this.money = 1000;
        }
        Object.defineProperty(Player.prototype, "money", {
            get: function () {
                return this._money;
            },
            set: function (amount) {
                this._money = amount;
                if (!this.isAI) {
                    Rance.eventManager.dispatchEvent("playerMoneyUpdated");
                }
            },
            enumerable: true,
            configurable: true
        });
        Player.prototype.destroy = function () {
            this.diplomacyStatus.destroy();
            this.diplomacyStatus = null;
            this.AIController = null;
            for (var key in this.listeners) {
                Rance.eventManager.removeEventListener(key, this.listeners[key]);
            }
        };
        Player.prototype.die = function () {
            for (var i = 0; i < this.fleets.length; i++) {
                this.fleets[i].deleteFleet(false);
            }
            Rance.eventManager.dispatchEvent("makePlayerDiedNotification", {
                deadPlayerName: this.name
            });
            console.log(this.name + " died");
        };
        Player.prototype.initTechnologies = function (savedData) {
            this.playerTechnology = new Rance.PlayerTechnology(this.getResearchSpeed.bind(this), savedData);
            this.listeners["builtBuildingWithEffect_research"] = Rance.eventManager.addEventListener("builtBuildingWithEffect_research", this.playerTechnology.capTechnologyPrioritiesToMaxNeeded.bind(this.playerTechnology));
        };
        Player.prototype.makeColorScheme = function () {
            var scheme = Rance.generateColorScheme(this.color);
            this.color = scheme.main;
            this.secondaryColor = scheme.secondary;
        };
        Player.prototype.setupAI = function (game) {
            this.AIController = new Rance.MapAI.AIController(this, game, this.personality);
        };
        Player.prototype.makeRandomFlag = function (seed) {
            if (!this.color || !this.secondaryColor)
                this.makeColorScheme();
            this.flag = new Rance.Flag({
                width: 46,
                mainColor: this.color,
                secondaryColor: this.secondaryColor
            });
            this.flag.generateRandom(seed);
        };
        Player.prototype.addUnit = function (unit) {
            this.units[unit.id] = unit;
        };
        Player.prototype.removeUnit = function (unit) {
            this.units[unit.id] = null;
            delete this.units[unit.id];
        };
        Player.prototype.getAllUnits = function () {
            var allUnits = [];
            for (var unitId in this.units) {
                allUnits.push(this.units[unitId]);
            }
            return allUnits;
        };
        Player.prototype.forEachUnit = function (operator) {
            for (var unitId in this.units) {
                operator(this.units[unitId]);
            }
        };
        Player.prototype.getFleetIndex = function (fleet) {
            return this.fleets.indexOf(fleet);
        };
        Player.prototype.addFleet = function (fleet) {
            if (this.getFleetIndex(fleet) >= 0) {
                return;
            }
            this.fleets.push(fleet);
            this.visionIsDirty = true;
        };
        Player.prototype.removeFleet = function (fleet) {
            var fleetIndex = this.getFleetIndex(fleet);
            if (fleetIndex < 0)
                return;
            this.fleets.splice(fleetIndex, 1);
            this.visionIsDirty = true;
        };
        Player.prototype.getFleetsWithPositions = function () {
            var positions = [];
            for (var i = 0; i < this.fleets.length; i++) {
                var fleet = this.fleets[i];
                positions.push({
                    position: fleet.location,
                    data: fleet
                });
            }
            return positions;
        };
        Player.prototype.hasStar = function (star) {
            return (this.controlledLocations.indexOf(star) >= 0);
        };
        Player.prototype.addStar = function (star) {
            if (this.hasStar(star))
                return false;
            star.owner = this;
            this.controlledLocations.push(star);
            this.visionIsDirty = true;
        };
        Player.prototype.removeStar = function (star) {
            var index = this.controlledLocations.indexOf(star);
            if (index < 0)
                return false;
            star.owner = null;
            this.controlledLocations.splice(index, 1);
            this.visionIsDirty = true;
            if (this.controlledLocations.length === 0) {
                app.game.killPlayer(this);
            }
        };
        Player.prototype.getIncome = function () {
            var income = 0;
            for (var i = 0; i < this.controlledLocations.length; i++) {
                income += this.controlledLocations[i].getIncome();
            }
            return income;
        };
        Player.prototype.addResource = function (resource, amount) {
            if (!this.resources[resource.type]) {
                this.resources[resource.type] = 0;
            }
            this.resources[resource.type] += amount;
        };
        Player.prototype.getResourceIncome = function () {
            var incomeByResource = {};
            for (var i = 0; i < this.controlledLocations.length; i++) {
                var star = this.controlledLocations[i];
                var starIncome = star.getResourceIncome();
                if (!starIncome)
                    continue;
                if (!incomeByResource[starIncome.resource.type]) {
                    incomeByResource[starIncome.resource.type] =
                        {
                            resource: starIncome.resource,
                            amount: 0
                        };
                }
                incomeByResource[starIncome.resource.type].amount += starIncome.amount;
            }
            return incomeByResource;
        };
        Player.prototype.getNeighboringStars = function () {
            var stars = {};
            for (var i = 0; i < this.controlledLocations.length; i++) {
                var currentOwned = this.controlledLocations[i];
                var frontier = currentOwned.getLinkedInRange(1).all;
                for (var j = 0; j < frontier.length; j++) {
                    if (stars[frontier[j].id]) {
                        continue;
                    }
                    else if (frontier[j].owner.id === this.id) {
                        continue;
                    }
                    else {
                        stars[frontier[j].id] = frontier[j];
                    }
                }
            }
            var allStars = [];
            for (var id in stars) {
                allStars.push(stars[id]);
            }
            return allStars;
        };
        Player.prototype.updateVisionInStar = function (star) {
            // meet players
            if (this.diplomacyStatus.getUnMetPlayerCount() > 0) {
                this.meetPlayersInStarByVisibility(star, "visible");
            }
        };
        Player.prototype.updateDetectionInStar = function (star) {
            // meet players
            if (this.diplomacyStatus.getUnMetPlayerCount() > 0) {
                this.meetPlayersInStarByVisibility(star, "detected");
            }
            // identify units
            var unitsToIdentify = star.getAllUnits();
            for (var i = 0; i < unitsToIdentify.length; i++) {
                this.identifyUnit(unitsToIdentify[i]);
            }
        };
        Player.prototype.updateAllVisibilityInStar = function (star) {
            if (this.starIsVisible(star)) {
                this.updateVisionInStar(star);
            }
            if (this.starIsDetected(star)) {
                this.updateDetectionInStar(star);
            }
        };
        Player.prototype.meetPlayersInStarByVisibility = function (star, visibility) {
            var presentPlayersByVisibility = star.getPresentPlayersByVisibility();
            for (var playerId in presentPlayersByVisibility[visibility]) {
                var player = presentPlayersByVisibility[visibility][playerId];
                if (!player.isIndependent && !this.diplomacyStatus.metPlayers[playerId] && !this.isIndependent) {
                    this.diplomacyStatus.meetPlayer(player);
                }
            }
        };
        Player.prototype.updateVisibleStars = function () {
            var previousVisibleStars = Rance.extendObject(this.visibleStars);
            var previousDetectedStars = Rance.extendObject(this.detectedStars);
            var newVisibleStars = [];
            var newDetectedStars = [];
            var visibilityHasChanged = false;
            var detectionHasChanged = false;
            this.visibleStars = {};
            this.detectedStars = {};
            var allVisible = [];
            var allDetected = [];
            for (var i = 0; i < this.controlledLocations.length; i++) {
                allVisible = allVisible.concat(this.controlledLocations[i].getVision());
                allDetected = allDetected.concat(this.controlledLocations[i].getDetection());
            }
            for (var i = 0; i < this.fleets.length; i++) {
                allVisible = allVisible.concat(this.fleets[i].getVision());
                allDetected = allDetected.concat(this.fleets[i].getDetection());
            }
            for (var i = 0; i < allVisible.length; i++) {
                var star = allVisible[i];
                if (!this.visibleStars[star.id]) {
                    this.visibleStars[star.id] = star;
                    if (!previousVisibleStars[star.id]) {
                        visibilityHasChanged = true;
                        newVisibleStars.push(star);
                    }
                    if (!this.revealedStars[star.id]) {
                        this.revealedStars[star.id] = star;
                    }
                }
            }
            for (var i = 0; i < allDetected.length; i++) {
                var star = allDetected[i];
                if (!this.detectedStars[star.id]) {
                    this.detectedStars[star.id] = star;
                    if (!previousDetectedStars[star.id]) {
                        detectionHasChanged = true;
                        newDetectedStars.push(star);
                    }
                }
            }
            this.visionIsDirty = false;
            if (!visibilityHasChanged) {
                visibilityHasChanged = (Object.keys(this.visibleStars).length !==
                    Object.keys(previousVisibleStars).length);
            }
            if (!visibilityHasChanged && !detectionHasChanged) {
                detectionHasChanged = (Object.keys(this.detectedStars).length !==
                    Object.keys(previousDetectedStars).length);
            }
            for (var i = 0; i < newVisibleStars.length; i++) {
                this.updateVisionInStar(newVisibleStars[i]);
            }
            for (var i = 0; i < newDetectedStars.length; i++) {
                this.updateDetectionInStar(newDetectedStars[i]);
            }
            if (visibilityHasChanged && !this.isAI) {
                Rance.eventManager.dispatchEvent("renderMap");
            }
            if (detectionHasChanged && !this.isAI) {
                Rance.eventManager.dispatchEvent("renderLayer", "fleets");
            }
        };
        Player.prototype.getVisibleStars = function () {
            if (!this.isAI && Rance.Options.debugMode) {
                return this.controlledLocations[0].getLinkedInRange(9999).all;
            }
            if (this.visionIsDirty)
                this.updateVisibleStars();
            var visible = [];
            for (var id in this.visibleStars) {
                var star = this.visibleStars[id];
                visible.push(star);
            }
            return visible;
        };
        Player.prototype.getRevealedStars = function () {
            if (!this.isAI && Rance.Options.debugMode) {
                return this.controlledLocations[0].getLinkedInRange(9999).all;
            }
            if (this.visionIsDirty)
                this.updateVisibleStars();
            var toReturn = [];
            for (var id in this.revealedStars) {
                toReturn.push(this.revealedStars[id]);
            }
            return toReturn;
        };
        Player.prototype.getRevealedButNotVisibleStars = function () {
            if (this.visionIsDirty)
                this.updateVisibleStars();
            var toReturn = [];
            for (var id in this.revealedStars) {
                if (!this.visibleStars[id]) {
                    toReturn.push(this.revealedStars[id]);
                }
            }
            return toReturn;
        };
        Player.prototype.getDetectedStars = function () {
            if (!this.isAI && Rance.Options.debugMode) {
                return this.controlledLocations[0].getLinkedInRange(9999).all;
            }
            if (this.visionIsDirty)
                this.updateVisibleStars();
            var toReturn = [];
            for (var id in this.detectedStars) {
                toReturn.push(this.detectedStars[id]);
            }
            return toReturn;
        };
        Player.prototype.starIsVisible = function (star) {
            if (!this.isAI && Rance.Options.debugMode)
                return true;
            if (this.visionIsDirty)
                this.updateVisibleStars();
            return Boolean(this.visibleStars[star.id]);
        };
        Player.prototype.starIsRevealed = function (star) {
            if (!this.isAI && Rance.Options.debugMode)
                return true;
            if (this.visionIsDirty)
                this.updateVisibleStars();
            return Boolean(this.revealedStars[star.id]);
        };
        Player.prototype.starIsDetected = function (star) {
            if (!this.isAI && Rance.Options.debugMode)
                return true;
            if (this.visionIsDirty)
                this.updateVisibleStars();
            return Boolean(this.detectedStars[star.id]);
        };
        Player.prototype.getLinksToUnRevealedStars = function () {
            if (this.visionIsDirty)
                this.updateVisibleStars();
            var linksBySourceStarId = {};
            for (var starId in this.revealedStars) {
                var star = this.revealedStars[starId];
                var links = star.getAllLinks();
                for (var i = 0; i < links.length; i++) {
                    var linkedStar = links[i];
                    if (!this.revealedStars[linkedStar.id]) {
                        if (!linksBySourceStarId[star.id]) {
                            linksBySourceStarId[star.id] = [linkedStar];
                        }
                        else {
                            linksBySourceStarId[star.id].push(linkedStar);
                        }
                    }
                }
            }
            return linksBySourceStarId;
        };
        Player.prototype.identifyUnit = function (unit) {
            if (!this.identifiedUnits[unit.id]) {
                this.identifiedUnits[unit.id] = unit;
            }
        };
        Player.prototype.unitIsIdentified = function (unit) {
            if (Rance.Options.debugMode && !this.isAI) {
                return true;
            }
            else
                return Boolean(this.identifiedUnits[unit.id]) || Boolean(this.units[unit.id]);
        };
        Player.prototype.fleetIsFullyIdentified = function (fleet) {
            if (Rance.Options.debugMode && !this.isAI) {
                return true;
            }
            for (var i = 0; i < fleet.units.length; i++) {
                if (!this.identifiedUnits[fleet.units[i].id]) {
                    return false;
                }
            }
            return true;
        };
        Player.prototype.addItem = function (item) {
            this.items.push(item);
        };
        Player.prototype.removeItem = function (item) {
            var index = this.items.indexOf(item);
            if (index === -1) {
                throw new Error("Player " + this.name + " has no item " + item.id);
            }
            this.items.splice(index, 1);
        };
        Player.prototype.getNearestOwnedStarTo = function (star) {
            var self = this;
            var isOwnedByThisFN = function (star) {
                return star.owner === self;
            };
            return star.getNearestStarForQualifier(isOwnedByThisFN);
        };
        Player.prototype.attackTarget = function (location, target, battleFinishCallback) {
            var battleData = {
                location: location,
                building: target.building,
                attacker: {
                    player: this,
                    units: location.getAllUnitsOfPlayer(this)
                },
                defender: {
                    player: target.enemy,
                    units: target.units
                }
            };
            var battlePrep = new Rance.BattlePrep(battleData);
            if (battlePrep.humanPlayer) {
                app.reactUI.battlePrep = battlePrep;
                if (battleFinishCallback) {
                    battlePrep.afterBattleFinishCallbacks.push(battleFinishCallback);
                }
                app.reactUI.switchScene("battlePrep");
            }
            else {
                var battle = battlePrep.makeBattle();
                battle.afterFinishCallbacks.push(battleFinishCallback);
                var simulator = new Rance.BattleSimulator(battle);
                simulator.simulateBattle();
                simulator.finishBattle();
            }
        };
        // research and technology
        Player.prototype.getResearchSpeed = function () {
            var research = 0;
            research += app.moduleData.ruleSet.research.baseResearchSpeed;
            for (var i = 0; i < this.controlledLocations.length; i++) {
                research += this.controlledLocations[i].getResearchPoints();
            }
            return research;
        };
        // MANUFACTORIES
        Player.prototype.getAllManufactories = function () {
            var manufactories = [];
            for (var i = 0; i < this.controlledLocations.length; i++) {
                if (this.controlledLocations[i].manufactory) {
                    manufactories.push(this.controlledLocations[i].manufactory);
                }
            }
            return manufactories;
        };
        Player.prototype.meetsTechnologyRequirements = function (requirements) {
            for (var i = 0; i < requirements.length; i++) {
                var requirement = requirements[i];
                if (this.playerTechnology.technologies[requirement.technology.key].level < requirement.level) {
                    return false;
                }
            }
            return true;
        };
        Player.prototype.getGloballyBuildableUnits = function () {
            var templates = [];
            var typesAlreadyAddedChecked = {};
            var unitsToAdd = app.moduleData.Templates.UnitFamilies["basic"].associatedTemplates.slice(0);
            if (!this.isAI && Rance.Options.debugMode) {
                unitsToAdd = unitsToAdd.concat(app.moduleData.Templates.UnitFamilies["debug"].associatedTemplates);
            }
            for (var i = 0; i < unitsToAdd.length; i++) {
                var template = unitsToAdd[i];
                if (typesAlreadyAddedChecked[template.type])
                    continue;
                else if (template.technologyRequirements && !this.meetsTechnologyRequirements(template.technologyRequirements)) {
                    typesAlreadyAddedChecked[template.type] = true;
                    continue;
                }
                else {
                    typesAlreadyAddedChecked[template.type] = true;
                    templates.push(template);
                }
            }
            return templates;
        };
        Player.prototype.getGloballyBuildableItems = function () {
            // TODO manufactory
            var itemTypes = [];
            for (var key in app.moduleData.Templates.Items) {
                itemTypes.push(app.moduleData.Templates.Items[key]);
            }
            return itemTypes;
        };
        Player.prototype.getManufacturingCapacityFor = function (template, type) {
            var totalCapacity = 0;
            var capacityByStar = [];
            var isGloballyBuildable;
            switch (type) {
                case "item":
                    {
                        var globallyBuildableItems = this.getGloballyBuildableItems();
                        isGloballyBuildable = globallyBuildableItems.indexOf(template) !== -1;
                    }
                case "unit":
                    {
                        var globallyBuildableUnits = this.getGloballyBuildableUnits();
                        isGloballyBuildable = globallyBuildableUnits.indexOf(template) !== -1;
                    }
            }
            var manufactories = this.getAllManufactories();
            for (var i = 0; i < manufactories.length; i++) {
                var manufactory = manufactories[i];
                var isBuildable = !manufactory.queueIsFull() &&
                    (isGloballyBuildable || manufactory.canManufactureThing(template, type));
                if (isBuildable) {
                    var capacity = manufactory.capacity - manufactory.buildQueue.length;
                    totalCapacity += capacity;
                    capacityByStar.push({
                        star: manufactory.star,
                        capacity: capacity
                    });
                }
            }
            return totalCapacity;
        };
        Player.prototype.serialize = function () {
            var unitIds = [];
            for (var id in this.units) {
                unitIds.push(this.units[id].id);
            }
            var revealedStarIds = [];
            for (var id in this.revealedStars) {
                revealedStarIds.push(this.revealedStars[id].id);
            }
            var identifiedUnitIds = [];
            for (var id in this.identifiedUnits) {
                identifiedUnitIds.push(this.identifiedUnits[id].id);
            }
            var data = {
                id: this.id,
                name: this.name,
                color: this.color,
                colorAlpha: this.colorAlpha,
                secondaryColor: this.secondaryColor,
                isIndependent: this.isIndependent,
                isAI: this.isAI,
                resources: Rance.extendObject(this.resources),
                diplomacyStatus: this.diplomacyStatus.serialize(),
                fleets: this.fleets.map(function (fleet) { return fleet.serialize(); }),
                money: this.money,
                controlledLocationIds: this.controlledLocations.map(function (star) { return star.id; }),
                items: this.items.map(function (item) { return item.serialize(); }),
                unitIds: unitIds,
                revealedStarIds: revealedStarIds,
                identifiedUnitIds: identifiedUnitIds
            };
            if (this.playerTechnology) {
                data.researchByTechnology = this.playerTechnology.serialize();
            }
            if (this.flag) {
                data.flag = this.flag.serialize();
            }
            if (this.isAI && this.AIController) {
                data.personality = Rance.extendObject(this.AIController.personality);
            }
            return data;
        };
        return Player;
    }());
    Rance.Player = Player;
})(Rance || (Rance = {}));
/// <reference path="ibattledata.d.ts"/>
/// <reference path="unit.ts"/>
/// <reference path="eventmanager.ts"/>
var Rance;
(function (Rance) {
    var Battle = (function () {
        function Battle(props) {
            this.unitsById = {};
            this.unitsBySide = {
                side1: [],
                side2: []
            };
            this.turnOrder = [];
            this.evaluation = {};
            this.isSimulated = false; // true when battle is between two
            // ai players
            this.isVirtual = false; // true when a clone made by battle ai
            this.ended = false;
            this.afterFinishCallbacks = [];
            this.side1 = props.side1;
            this.side1Player = props.side1Player;
            this.side2 = props.side2;
            this.side2Player = props.side2Player;
            this.battleData = props.battleData;
        }
        Battle.prototype.init = function () {
            var self = this;
            Rance.UnitBattleSidesArray.forEach(function (sideId) {
                var side = self[sideId];
                for (var i = 0; i < side.length; i++) {
                    for (var j = 0; j < side[i].length; j++) {
                        if (side[i][j]) {
                            self.unitsById[side[i][j].id] = side[i][j];
                            self.unitsBySide[sideId].push(side[i][j]);
                            var pos = self.getAbsolutePositionFromSidePosition([i, j], sideId);
                            self.initUnit(side[i][j], sideId, pos);
                        }
                    }
                }
            });
            this.currentTurn = 0;
            this.maxTurns = 24;
            this.turnsLeft = this.maxTurns;
            this.updateTurnOrder();
            this.setActiveUnit();
            this.startHealth =
                {
                    side1: this.getTotalHealthForSide("side1").current,
                    side2: this.getTotalHealthForSide("side2").current
                };
            if (this.checkBattleEnd()) {
                this.endBattle();
            }
            else {
                this.shiftRowsIfNeeded();
            }
            this.triggerBattleStartAbilities();
        };
        Battle.prototype.forEachUnit = function (operator) {
            for (var id in this.unitsById) {
                operator.call(this, this.unitsById[id]);
            }
        };
        Battle.prototype.initUnit = function (unit, side, position) {
            unit.resetBattleStats();
            unit.setBattlePosition(this, side, position);
            this.addUnitToTurnOrder(unit);
            unit.timesActedThisTurn++;
        };
        Battle.prototype.triggerBattleStartAbilities = function () {
            this.forEachUnit(function (unit) {
                var passiveSkillsByPhase = unit.getPassiveSkillsByPhase();
                if (passiveSkillsByPhase["atBattleStart"]) {
                    var skills = passiveSkillsByPhase["atBattleStart"];
                    for (var i = 0; i < skills.length; i++) {
                        for (var j = 0; j < skills[i].atBattleStart.length; j++) {
                            var effect = skills[i].atBattleStart[j];
                            effect.template.effect(unit, unit, this, effect.data);
                        }
                    }
                }
            });
        };
        Battle.prototype.removeUnitFromTurnOrder = function (unit) {
            var unitIndex = this.turnOrder.indexOf(unit);
            if (unitIndex < 0)
                return false; //not in list
            this.turnOrder.splice(unitIndex, 1);
        };
        Battle.prototype.addUnitToTurnOrder = function (unit) {
            var unitIndex = this.turnOrder.indexOf(unit);
            if (unitIndex >= 0)
                return false; //already in list
            this.turnOrder.push(unit);
        };
        Battle.prototype.updateTurnOrder = function () {
            //Sorting function is in utility.ts for reusing in turn order UI.
            //Maybe should make separate TurnOrder class?
            this.turnOrder.sort(Rance.turnOrderSortFunction);
            function turnOrderFilterFunction(unit) {
                if (unit.battleStats.currentActionPoints <= 0) {
                    return false;
                }
                if (unit.currentHealth <= 0) {
                    return false;
                }
                return true;
            }
            this.turnOrder = this.turnOrder.filter(turnOrderFilterFunction);
        };
        Battle.prototype.setActiveUnit = function () {
            this.activeUnit = this.turnOrder[0];
        };
        Battle.prototype.endTurn = function () {
            this.currentTurn++;
            this.turnsLeft--;
            this.updateTurnOrder();
            this.setActiveUnit();
            if (!this.isVirtual) {
                this.forEachUnit(function (unit) {
                    if (unit.currentHealth <= 0) {
                        unit.displayFlags.isAnnihilated = true;
                        unit.uiDisplayIsDirty = true;
                    }
                });
            }
            var shouldEnd = this.checkBattleEnd();
            if (shouldEnd) {
                this.endBattle();
            }
            else {
                this.shiftRowsIfNeeded();
            }
        };
        Battle.prototype.getPlayerForSide = function (side) {
            if (side === "side1")
                return this.side1Player;
            else if (side === "side2")
                return this.side2Player;
            else
                throw new Error("invalid side");
        };
        Battle.prototype.getSideForPlayer = function (player) {
            if (this.side1Player === player)
                return "side1";
            else if (this.side2Player === player)
                return "side2";
            else
                throw new Error("invalid player");
        };
        Battle.prototype.getActivePlayer = function () {
            if (!this.activeUnit)
                return null;
            var side = this.activeUnit.battleStats.side;
            return this.getPlayerForSide(side);
        };
        Battle.prototype.getRowByPosition = function (position) {
            var rowsPerSide = app.moduleData.ruleSet.battle.rowsPerFormation;
            var side = position < rowsPerSide ? "side1" : "side2";
            var relativePosition = position % rowsPerSide;
            return this[side][relativePosition];
        };
        Battle.prototype.getCapturedUnits = function (victor, maxCapturedUnits) {
            if (!victor || victor.isIndependent)
                return [];
            var winningSide = this.getSideForPlayer(victor);
            var losingSide = Rance.reverseSide(winningSide);
            var losingUnits = this.unitsBySide[losingSide].slice(0);
            losingUnits.sort(function (a, b) {
                var captureChanceSort = b.battleStats.captureChance - a.battleStats.captureChance;
                if (captureChanceSort) {
                    return captureChanceSort;
                }
                else {
                    return Rance.randInt(0, 1) * 2 - 1; // -1 or 1
                }
            });
            var capturedUnits = [];
            for (var i = 0; i < losingUnits.length; i++) {
                if (capturedUnits.length >= maxCapturedUnits)
                    break;
                var unit = losingUnits[i];
                if (unit.currentHealth <= 0 &&
                    Math.random() <= unit.battleStats.captureChance) {
                    capturedUnits.push(unit);
                }
            }
            return capturedUnits;
        };
        Battle.prototype.getUnitDeathChance = function (unit, victor) {
            var ruleSet = app.moduleData.ruleSet;
            var player = unit.fleet.player;
            var deathChance;
            if (player.isIndependent) {
                deathChance = ruleSet.battle.independentUnitDeathChance;
            }
            else if (player.isAI) {
                deathChance = ruleSet.battle.aiUnitDeathChance;
            }
            else {
                deathChance = ruleSet.battle.humanUnitDeathChance;
            }
            var playerDidLose = (victor && player !== victor);
            if (playerDidLose) {
                deathChance += ruleSet.battle.loserUnitExtraDeathChance;
            }
            return deathChance;
        };
        Battle.prototype.getDeadUnits = function (capturedUnits, victor) {
            var deadUnits = [];
            this.forEachUnit(function (unit) {
                if (unit.currentHealth <= 0) {
                    var wasCaptured = capturedUnits.indexOf(unit) >= 0;
                    if (!wasCaptured) {
                        var deathChance = this.getUnitDeathChance(unit, victor);
                        if (Math.random() < deathChance) {
                            deadUnits.push(unit);
                        }
                    }
                }
            });
            return deadUnits;
        };
        Battle.prototype.endBattle = function () {
            this.ended = true;
            if (this.isVirtual)
                return;
            this.activeUnit = null;
            var victor = this.getVictor();
            var maxCapturedUnits = app.moduleData.ruleSet.battle.baseMaxCapturedUnits;
            // TODO content | Abilities that increase max captured units
            this.capturedUnits = this.getCapturedUnits(victor, maxCapturedUnits);
            this.deadUnits = this.getDeadUnits(this.capturedUnits, victor);
            Rance.eventManager.dispatchEvent("battleEnd", null);
        };
        Battle.prototype.finishBattle = function (forcedVictor) {
            var victor = forcedVictor || this.getVictor();
            for (var i = 0; i < this.deadUnits.length; i++) {
                this.deadUnits[i].removeFromPlayer();
            }
            var experiencePerSide = this.getGainedExperiencePerSide();
            this.forEachUnit(function (unit) {
                unit.addExperience(experiencePerSide[unit.battleStats.side]);
                unit.resetBattleStats();
                if (unit.currentHealth < Math.round(unit.maxHealth * 0.1)) {
                    unit.currentHealth = Math.round(unit.maxHealth * 0.1);
                }
                this.side1Player.identifyUnit(unit);
                this.side2Player.identifyUnit(unit);
            });
            if (victor) {
                for (var i = 0; i < this.capturedUnits.length; i++) {
                    this.capturedUnits[i].transferToPlayer(victor);
                    this.capturedUnits[i].experienceForCurrentLevel = 0;
                }
            }
            if (this.battleData.building) {
                if (victor) {
                    this.battleData.building.setController(victor);
                }
            }
            if (this.isSimulated) {
                Rance.eventManager.dispatchEvent("renderLayer", "fleets", this.battleData.location);
            }
            else {
                Rance.eventManager.dispatchEvent("setCameraToCenterOn", this.battleData.location);
                Rance.eventManager.dispatchEvent("switchScene", "galaxyMap");
            }
            if (app.humanPlayer.starIsVisible(this.battleData.location)) {
                Rance.eventManager.dispatchEvent("makeBattleFinishNotification", {
                    location: this.battleData.location,
                    attacker: this.battleData.attacker.player,
                    defender: this.battleData.defender.player,
                    victor: victor
                });
            }
            for (var i = 0; i < this.afterFinishCallbacks.length; i++) {
                this.afterFinishCallbacks[i]();
            }
        };
        Battle.prototype.getVictor = function () {
            var evaluation = this.getEvaluation();
            if (evaluation > 0)
                return this.side1Player;
            else if (evaluation < 0)
                return this.side2Player;
            else
                return null;
        };
        Battle.prototype.getTotalHealthForRow = function (position) {
            var row = this.getRowByPosition(position);
            var total = 0;
            for (var i = 0; i < row.length; i++) {
                if (row[i]) {
                    total += row[i].currentHealth;
                }
            }
            return total;
        };
        Battle.prototype.getTotalHealthForSide = function (side) {
            var health = {
                current: 0,
                max: 0
            };
            var units = this.unitsBySide[side];
            for (var i = 0; i < units.length; i++) {
                var unit = units[i];
                health.current += unit.currentHealth;
                health.max += unit.maxHealth;
            }
            return health;
        };
        Battle.prototype.getEvaluation = function () {
            var self = this;
            var evaluation = 0;
            Rance.UnitBattleSidesArray.forEach(function (side) {
                // positive * sign === good, negative * sign === bad
                var sign = side === "side1" ? 1 : -1; // positive = side1 advantage
                var currentHealth = self.getTotalHealthForSide(side).current;
                if (currentHealth <= 0) {
                    return -999 * sign;
                }
                // how much health remains from strating health 0.0-1.0
                var currentHealthFactor = currentHealth / self.startHealth[side];
                for (var i = 0; i < self.unitsBySide[side].length; i++) {
                    if (self.unitsBySide[side][i].currentHealth <= 0) {
                        evaluation -= 0.2 * sign;
                    }
                }
                var defenderMultiplier = 1;
                if (self.battleData.building) {
                    var template = self.battleData.building.template;
                    var isDefender = self.battleData.defender.player === self.getPlayerForSide(side);
                    if (isDefender) {
                        defenderMultiplier += template.defenderAdvantage;
                    }
                }
                evaluation += currentHealthFactor * defenderMultiplier * sign;
            });
            evaluation = Rance.clamp(evaluation, -1, 1);
            this.evaluation[this.currentTurn] = evaluation;
            return this.evaluation[this.currentTurn];
        };
        Battle.prototype.getAbsolutePositionFromSidePosition = function (relativePosition, side) {
            if (side === "side1") {
                return relativePosition;
            }
            else {
                var rowsPerSide = app.moduleData.ruleSet.battle.rowsPerFormation;
                return [relativePosition[0] + rowsPerSide, relativePosition[1]];
            }
        };
        Battle.prototype.updateBattlePositions = function (side) {
            var units = this[side];
            for (var i = 0; i < units.length; i++) {
                var row = this[side][i];
                for (var j = 0; j < row.length; j++) {
                    var pos = this.getAbsolutePositionFromSidePosition([i, j], side);
                    var unit = row[j];
                    if (unit) {
                        unit.setBattlePosition(this, side, pos);
                    }
                }
            }
        };
        Battle.prototype.shiftRowsForSide = function (side) {
            var formation = this[side];
            if (side === "side1") {
                formation.reverse();
            }
            var nextHealthyRowIndex;
            // start at 1 because frontmost row shouldn't be healthy if this is called
            for (var i = 1; i < formation.length; i++) {
                var absoluteRow = side === "side1" ? i : i + app.moduleData.ruleSet.battle.rowsPerFormation;
                if (this.getTotalHealthForRow(absoluteRow) > 0) {
                    nextHealthyRowIndex = i;
                    break;
                }
            }
            if (!isFinite(nextHealthyRowIndex)) {
                throw new Error("Tried to shift battle rows when all rows are defeated");
            }
            var rowsToShift = formation.splice(0, nextHealthyRowIndex);
            formation = formation.concat(rowsToShift);
            if (side === "side1") {
                formation.reverse();
            }
            this[side] = formation;
            this.updateBattlePositions(side);
        };
        Battle.prototype.shiftRowsIfNeeded = function () {
            var rowsPerSide = app.moduleData.ruleSet.battle.rowsPerFormation;
            var side1FrontRowHealth = this.getTotalHealthForRow(rowsPerSide - 1);
            if (side1FrontRowHealth <= 0) {
                this.shiftRowsForSide("side1");
            }
            var side2FrontRowHealth = this.getTotalHealthForRow(rowsPerSide);
            if (side2FrontRowHealth <= 0) {
                this.shiftRowsForSide("side2");
            }
        };
        Battle.prototype.getGainedExperiencePerSide = function () {
            var totalValuePerSide = {
                side1: 0,
                side2: 0
            };
            for (var side in this.unitsBySide) {
                var totalValue = 0;
                var units = this.unitsBySide[side];
                for (var i = 0; i < units.length; i++) {
                    totalValuePerSide[side] += units[i].level + 1;
                }
            }
            return ({
                side1: totalValuePerSide.side2 / totalValuePerSide.side1 * 10,
                side2: totalValuePerSide.side1 / totalValuePerSide.side2 * 10
            });
        };
        Battle.prototype.checkBattleEnd = function () {
            if (!this.activeUnit)
                return true;
            if (this.turnsLeft <= 0)
                return true;
            if (this.getTotalHealthForSide("side1").current <= 0 ||
                this.getTotalHealthForSide("side2").current <= 0) {
                return true;
            }
            return false;
        };
        Battle.prototype.makeVirtualClone = function () {
            var battleData = this.battleData;
            function cloneUnits(units) {
                var clones = [];
                for (var i = 0; i < units.length; i++) {
                    var row = [];
                    for (var j = 0; j < units[i].length; j++) {
                        var unit = units[i][j];
                        if (!unit) {
                            row.push(unit);
                        }
                        else {
                            row.push(unit.makeVirtualClone());
                        }
                    }
                    clones.push(row);
                }
                return clones;
            }
            var side1 = cloneUnits(this.side1);
            var side2 = cloneUnits(this.side2);
            var side1Player = this.side1Player;
            var side2Player = this.side2Player;
            var clone = new Battle({
                battleData: battleData,
                side1: side1,
                side2: side2,
                side1Player: side1Player,
                side2Player: side2Player
            });
            [side1, side2].forEach(function (side) {
                for (var i = 0; i < side.length; i++) {
                    for (var j = 0; j < side[i].length; j++) {
                        if (!side[i][j])
                            continue;
                        clone.addUnitToTurnOrder(side[i][j]);
                        clone.unitsById[side[i][j].id] = side[i][j];
                        clone.unitsBySide[side[i][j].battleStats.side].push(side[i][j]);
                    }
                }
            });
            clone.isVirtual = true;
            clone.currentTurn = this.currentTurn;
            clone.maxTurns = this.maxTurns;
            clone.turnsLeft = this.turnsLeft;
            clone.startHealth = this.startHealth;
            clone.updateTurnOrder();
            clone.setActiveUnit();
            if (clone.checkBattleEnd()) {
                clone.endBattle();
            }
            else {
                clone.shiftRowsIfNeeded();
            }
            return clone;
        };
        return Battle;
    }());
    Rance.Battle = Battle;
})(Rance || (Rance = {}));
/// <reference path="utility.ts"/>
/// <reference path="unit.ts"/>
var Rance;
(function (Rance) {
    (function (TargetFormation) {
        TargetFormation[TargetFormation["ally"] = 0] = "ally";
        TargetFormation[TargetFormation["enemy"] = 1] = "enemy";
        TargetFormation[TargetFormation["either"] = 2] = "either";
    })(Rance.TargetFormation || (Rance.TargetFormation = {}));
    var TargetFormation = Rance.TargetFormation;
    Rance.targetSelf = function (units, user) {
        return [user];
    };
    Rance.targetNextRow = function (units, user) {
        var ownPosition = user.battleStats.position;
        var increment = user.battleStats.side === "side1" ? 1 : -1;
        return units[ownPosition[0] + increment];
    };
    Rance.targetAll = function (units, user) {
        return Rance.flatten2dArray(units);
    };
    //**
    //**
    //X*
    //**
    Rance.areaSingle = function (units, target) {
        return Rance.getFrom2dArray(units, [target]);
    };
    //XX
    //XX
    //XX
    //XX
    Rance.areaAll = function (units, target) {
        return Rance.flatten2dArray(units);
    };
    //**
    //**
    //XX
    //**
    Rance.areaColumn = function (units, target) {
        var y = target[1];
        var targetLocations = [];
        for (var i = 0; i < units.length; i++) {
            targetLocations.push([i, y]);
        }
        return Rance.getFrom2dArray(units, targetLocations);
    };
    //X*
    //X*
    //X*
    //X*
    Rance.areaRow = function (units, target) {
        var x = target[0];
        var targetLocations = [];
        for (var i = 0; i < units[x].length; i++) {
            targetLocations.push([x, i]);
        }
        return Rance.getFrom2dArray(units, targetLocations);
    };
    //**
    //X*
    //X*
    //X*
    Rance.areaRowNeighbors = function (units, target) {
        var x = target[0];
        var y = target[1];
        var targetLocations = [];
        targetLocations.push([x, y]);
        targetLocations.push([x, y - 1]);
        targetLocations.push([x, y + 1]);
        return Rance.getFrom2dArray(units, targetLocations);
    };
    //**
    //X*
    //XX
    //X*
    Rance.areaNeighbors = function (units, target) {
        var x = target[0];
        var y = target[1];
        var targetLocations = [];
        targetLocations.push([x, y]);
        targetLocations.push([x - 1, y]);
        targetLocations.push([x + 1, y]);
        targetLocations.push([x, y - 1]);
        targetLocations.push([x, y + 1]);
        return Rance.getFrom2dArray(units, targetLocations);
    };
})(Rance || (Rance = {}));
/// <reference path="templateinterfaces/iabilitytemplate.d.ts" />
/// <reference path="templateinterfaces/iabilitytemplateeffect.d.ts" />
/// <reference path="templateinterfaces/ibattlesfxtemplate.d.ts" />
/// <reference path="battle.ts"/>
/// <reference path="unit.ts"/>
/// <reference path="targeting.ts"/>
var Rance;
(function (Rance) {
    function getAbilityUseData(battle, user, ability, target) {
        if (ability.preparation) {
            if (!user.battleStats.queuedAction) {
                user.setQueuedAction(ability, target);
                return getPreparationDummyData(user);
            }
            else {
                user.updateQueuedAction();
                if (!user.isReadyToUseQueuedAction()) {
                    return getPreparationDummyData(user);
                }
                else {
                    var action = user.battleStats.queuedAction;
                    var target = battle.unitsById[action.targetId];
                    var ability = action.ability;
                    user.clearQueuedAction();
                }
            }
        }
        var data = {
            user: user,
            originalTarget: target,
            actualTarget: getTargetOrGuard(battle, user, ability, target),
            effectsToCall: [],
            beforeUse: [],
            afterUse: []
        };
        var passiveSkills = user.getPassiveSkillsByPhase();
        var beforeUseEffects = [];
        if (ability.beforeUse) {
            beforeUseEffects = beforeUseEffects.concat(ability.beforeUse);
        }
        if (passiveSkills.beforeAbilityUse) {
            for (var i = 0; i < passiveSkills.beforeAbilityUse.length; i++) {
                beforeUseEffects = beforeUseEffects.concat(passiveSkills.beforeAbilityUse[i].beforeAbilityUse);
            }
        }
        for (var i = 0; i < beforeUseEffects.length; i++) {
            var hasSfx = Boolean(beforeUseEffects[i].sfx);
            if (hasSfx) {
                data.effectsToCall.push({
                    effects: [beforeUseEffects[i].template.effect.bind(null, user, data.actualTarget, battle, beforeUseEffects[i].data)],
                    user: user,
                    target: data.actualTarget,
                    sfx: beforeUseEffects[i].sfx,
                    trigger: beforeUseEffects[i].trigger
                });
            }
            else {
                data.beforeUse.push(beforeUseEffects[i].template.effect.bind(null, user, data.actualTarget, battle, beforeUseEffects[i].data));
            }
        }
        data.beforeUse.push(user.removeActionPoints.bind(user, ability.actionsUse));
        if (!ability.addsGuard) {
            data.beforeUse.push(user.removeAllGuard.bind(user));
        }
        var effectsToCall = [ability.mainEffect];
        if (ability.secondaryEffects) {
            effectsToCall = effectsToCall.concat(ability.secondaryEffects);
        }
        for (var i = 0; i < effectsToCall.length; i++) {
            var effect = effectsToCall[i];
            var targetsInArea = getUnitsInEffectArea(battle, user, effect.template, data.actualTarget.battleStats.position);
            for (var j = 0; j < targetsInArea.length; j++) {
                var effectTarget = targetsInArea[j];
                var boundEffects = [effect.template.effect.bind(null, user, effectTarget, battle, effect.data)];
                var attachedEffectsToAddAfter = [];
                if (effect.attachedEffects) {
                    for (var k = 0; k < effect.attachedEffects.length; k++) {
                        var attachedEffect = effect.attachedEffects[k];
                        var boundAttachedEffect = attachedEffect.template.effect.bind(null, user, effectTarget, battle, attachedEffect.data);
                        if (attachedEffect.sfx) {
                            attachedEffectsToAddAfter.push({
                                effects: [boundAttachedEffect],
                                user: user,
                                target: effectTarget,
                                sfx: attachedEffect.sfx,
                                trigger: attachedEffect.trigger
                            });
                        }
                        else {
                            boundEffects.push(boundAttachedEffect);
                        }
                    }
                }
                data.effectsToCall.push({
                    effects: boundEffects,
                    user: user,
                    target: effectTarget,
                    sfx: effect.sfx,
                    trigger: effect.trigger
                });
                if (attachedEffectsToAddAfter.length > 0) {
                    data.effectsToCall = data.effectsToCall.concat(attachedEffectsToAddAfter);
                }
            }
        }
        var afterUseEffects = [];
        if (ability.afterUse) {
            afterUseEffects = afterUseEffects.concat(ability.afterUse);
        }
        if (passiveSkills.afterAbilityUse) {
            for (var i = 0; i < passiveSkills.afterAbilityUse.length; i++) {
                afterUseEffects = afterUseEffects.concat(passiveSkills.afterAbilityUse[i].afterAbilityUse);
            }
        }
        for (var i = 0; i < afterUseEffects.length; i++) {
            var hasSfx = Boolean(afterUseEffects[i].sfx);
            if (hasSfx) {
                data.effectsToCall.push({
                    effects: [afterUseEffects[i].template.effect.bind(null, user, data.actualTarget, battle, afterUseEffects[i].data)],
                    user: user,
                    target: data.actualTarget,
                    sfx: afterUseEffects[i].sfx,
                    trigger: afterUseEffects[i].trigger
                });
            }
            else {
                data.afterUse.push(afterUseEffects[i].template.effect.bind(null, user, data.actualTarget, battle, afterUseEffects[i].data));
            }
        }
        data.afterUse.push(user.addMoveDelay.bind(user, ability.moveDelay));
        data.afterUse.push(user.updateStatusEffects.bind(user));
        return data;
    }
    Rance.getAbilityUseData = getAbilityUseData;
    // used for ai simulation. otherwise UIComponents.Battle steps through ability use data
    function useAbility(battle, user, ability, target) {
        var abilityData = getAbilityUseData(battle, user, ability, target);
        for (var i = 0; i < abilityData.beforeUse.length; i++) {
            abilityData.beforeUse[i]();
        }
        for (var i = 0; i < abilityData.effectsToCall.length; i++) {
            var effectData = abilityData.effectsToCall[i];
            if (!effectData.trigger || effectData.trigger(effectData.user, effectData.target)) {
                for (var j = 0; j < effectData.effects.length; j++) {
                    effectData.effects[j]();
                }
            }
        }
        for (var i = 0; i < abilityData.afterUse.length; i++) {
            abilityData.afterUse[i]();
        }
    }
    Rance.useAbility = useAbility;
    function getPreparationDummyData(user) {
        var action = user.battleStats.queuedAction;
        var dummyData = {
            user: user,
            originalTarget: user,
            actualTarget: user,
            effectsToCall: [],
            beforeUse: [],
            afterUse: []
        };
        dummyData.beforeUse.push(user.removeAllGuard.bind(user));
        dummyData.effectsToCall.push({
            effects: [],
            user: user,
            target: user,
            sfx: {
                duration: 100
            },
            trigger: null
        });
        dummyData.afterUse.push(user.addMoveDelay.bind(user, action.ability.preparation.prepDelay));
        return dummyData;
    }
    Rance.getPreparationDummyData = getPreparationDummyData;
    function validateTarget(battle, user, ability, target) {
        var potentialTargets = getPotentialTargets(battle, user, ability);
        return potentialTargets.indexOf(target) >= 0;
    }
    Rance.validateTarget = validateTarget;
    function getTargetOrGuard(battle, user, ability, target) {
        if (ability.bypassesGuard) {
            return target;
        }
        var guarding = getGuarders(battle, user, ability, target);
        guarding = guarding.sort(function (a, b) {
            return a.battleStats.guardAmount - b.battleStats.guardAmount;
        });
        for (var i = 0; i < guarding.length; i++) {
            var guardRoll = Math.random() * 100;
            if (guardRoll <= guarding[i].battleStats.guardAmount) {
                return guarding[i];
            }
        }
        return target;
    }
    Rance.getTargetOrGuard = getTargetOrGuard;
    function getGuarders(battle, user, ability, target) {
        var enemySide = Rance.reverseSide(user.battleStats.side);
        if (target.battleStats.side !== enemySide)
            return [];
        var allEnemies = battle.unitsBySide[enemySide];
        var guarders = allEnemies.filter(function (unit) {
            if (!unit.isTargetable)
                return false;
            if (unit.battleStats.guardCoverage === Rance.GuardCoverage.all) {
                return unit.battleStats.guardAmount > 0;
            }
            else if (unit.battleStats.guardCoverage === Rance.GuardCoverage.row) {
                // same row
                if (unit.battleStats.position[0] === target.battleStats.position[0]) {
                    return unit.battleStats.guardAmount > 0;
                }
            }
        });
        return guarders;
    }
    Rance.getGuarders = getGuarders;
    function getPotentialTargets(battle, user, ability) {
        var targetFormations = getFormationsToTarget(battle, user, ability.mainEffect.template);
        var targetsInRange = ability.mainEffect.template.targetRangeFunction(targetFormations, user);
        var untargetableFilterFN = function (target) {
            if (!Boolean(target)) {
                return false;
            }
            else if (!target.isTargetable()) {
                return false;
            }
            return true;
        };
        var targets = targetsInRange.filter(untargetableFilterFN);
        return targets;
    }
    Rance.getPotentialTargets = getPotentialTargets;
    function getFormationsToTarget(battle, user, effect) {
        var nullFormation = [];
        var rows = app.moduleData.ruleSet.battle.rowsPerFormation;
        var columns = app.moduleData.ruleSet.battle.cellsPerRow;
        for (var i = 0; i < rows; i++) {
            nullFormation.push([]);
            for (var j = 0; j < columns; j++) {
                nullFormation[i].push(null);
            }
        }
        var insertNullBefore;
        var toConcat;
        switch (effect.targetFormations) {
            case Rance.TargetFormation.either:
                {
                    return battle.side1.concat(battle.side2);
                }
            case Rance.TargetFormation.ally:
                {
                    insertNullBefore = user.battleStats.side === "side1" ? false : true;
                    toConcat = battle[user.battleStats.side];
                    break;
                }
            case Rance.TargetFormation.enemy:
                {
                    insertNullBefore = user.battleStats.side === "side1" ? true : false;
                    toConcat = battle[Rance.reverseSide(user.battleStats.side)];
                    break;
                }
        }
        if (insertNullBefore) {
            return nullFormation.concat(toConcat);
        }
        else {
            return toConcat.concat(nullFormation);
        }
    }
    Rance.getFormationsToTarget = getFormationsToTarget;
    function getPotentialTargetsByPosition(battle, user, ability) {
        var targets = getPotentialTargets(battle, user, ability);
        var targetPositions = [];
        for (var i = 0; i < targets.length; i++) {
            targetPositions.push(targets[i].battleStats.position);
        }
        return targetPositions;
    }
    Rance.getPotentialTargetsByPosition = getPotentialTargetsByPosition;
    function getUnitsInAbilityArea(battle, user, ability, target) {
        var inArea = getUnitsInEffectArea(battle, user, ability.mainEffect.template, target);
        if (ability.secondaryEffects) {
            for (var i = 0; i < ability.secondaryEffects.length; i++) {
                var inSecondary = getUnitsInEffectArea(battle, user, ability.secondaryEffects[i].template, target);
                for (var j = 0; j < inSecondary.length; j++) {
                    if (inArea.indexOf(inSecondary[j]) === -1) {
                        inArea.push(inSecondary[j]);
                    }
                }
            }
        }
        return inArea;
    }
    Rance.getUnitsInAbilityArea = getUnitsInAbilityArea;
    function getUnitsInEffectArea(battle, user, effect, target) {
        var targetFormations = getFormationsToTarget(battle, user, effect);
        var inArea = effect.battleAreaFunction(targetFormations, target);
        return inArea.filter(function (unit) {
            if (!unit)
                return false;
            else
                return unit.isActiveInBattle();
        });
    }
    Rance.getUnitsInEffectArea = getUnitsInEffectArea;
    function getTargetsForAllAbilities(battle, user) {
        if (!user || !battle.activeUnit) {
            return null;
        }
        var allTargets = {};
        var abilities = user.getAllAbilities();
        for (var i = 0; i < abilities.length; i++) {
            var ability = abilities[i];
            var targets = getPotentialTargets(battle, user, ability);
            for (var j = 0; j < targets.length; j++) {
                var target = targets[j];
                if (!allTargets[target.id]) {
                    allTargets[target.id] = [];
                }
                allTargets[target.id].push(ability);
            }
        }
        return allTargets;
    }
    Rance.getTargetsForAllAbilities = getTargetsForAllAbilities;
})(Rance || (Rance = {}));
/// <reference path="templateinterfaces/iunittemplate.d.ts" />
/// <reference path="damagetype.ts" />
/// <reference path="iunitattributes.d.ts"/>
/// <reference path="utility.ts"/>
/// <reference path="ability.ts"/>
/// <reference path="battle.ts"/>
/// <reference path="item.ts"/>
/// <reference path="statuseffect.ts" />
/// <reference path="savedata/iunitsavedata.d.ts" />
var Rance;
(function (Rance) {
    Rance.UnitBattleSidesArray = ["side1", "side2"];
    (function (GuardCoverage) {
        GuardCoverage[GuardCoverage["row"] = 0] = "row";
        GuardCoverage[GuardCoverage["all"] = 1] = "all";
    })(Rance.GuardCoverage || (Rance.GuardCoverage = {}));
    var GuardCoverage = Rance.GuardCoverage;
    var Unit = (function () {
        function Unit(template, id, data) {
            this.abilities = [];
            this.passiveSkills = [];
            this.items = {
                low: null,
                mid: null,
                high: null
            };
            this.passiveSkillsByPhase = {};
            this.passiveSkillsByPhaseAreDirty = true;
            this.uiDisplayIsDirty = true;
            this.id = isFinite(id) ? id : Rance.idGenerators.unit++;
            this.template = template;
            this.isSquadron = template.isSquadron;
            if (data) {
                this.makeFromData(data);
            }
            else {
                this.setCulture();
                this.setInitialValues();
            }
            this.displayFlags =
                {
                    isAnnihilated: false
                };
        }
        Object.defineProperty(Unit.prototype, "attributes", {
            get: function () {
                if (this.attributesAreDirty || !this.cachedAttributes) {
                    this.updateCachedAttributes();
                }
                return this.cachedAttributes;
            },
            enumerable: true,
            configurable: true
        });
        Unit.prototype.makeFromData = function (data) {
            var items = {};
            ["low", "mid", "high"].forEach(function (slot) {
                if (data.items[slot]) {
                    var item = data.items[slot];
                    if (!item)
                        return;
                    if (item.templateType) {
                        items[slot] = new Rance.Item(app.moduleData.Templates.Items[item.templateType], item.id);
                    }
                    else {
                        items[slot] = item;
                    }
                }
            });
            this.name = data.name;
            this.maxHealth = data.maxHealth;
            this.currentHealth = data.currentHealth;
            this.currentMovePoints = data.currentMovePoints;
            this.maxMovePoints = data.maxMovePoints;
            this.timesActedThisTurn = data.timesActedThisTurn;
            this.baseAttributes = Rance.extendObject(data.baseAttributes);
            this.attributes = Rance.extendObject(this.baseAttributes);
            this.abilities = data.abilityTemplateTypes.map(function (key) {
                var template = app.moduleData.Templates.Abilities[key];
                if (!template) {
                    throw new Error("Couldn't find ability " + key);
                }
                return template;
            });
            this.passiveSkills = data.passiveSkillTemplateTypes.map(function (key) {
                var template = app.moduleData.Templates.PassiveSkills[key];
                if (!template) {
                    throw new Error("Couldn't find passive skill " + key);
                }
                return template;
            });
            this.experienceForCurrentLevel = data.experienceForCurrentLevel;
            this.level = data.level;
            var battleStats = {};
            battleStats.moveDelay = data.battleStats.moveDelay;
            battleStats.side = data.battleStats.side;
            battleStats.position = data.battleStats.position;
            battleStats.currentActionPoints = data.battleStats.currentActionPoints;
            battleStats.guardAmount = data.battleStats.guardAmount;
            battleStats.guardCoverage = data.battleStats.guardCoverage;
            battleStats.captureChance = data.battleStats.captureChance;
            battleStats.statusEffects = data.battleStats.statusEffects;
            battleStats.lastHealthBeforeReceivingDamage = this.currentHealth;
            battleStats.queuedAction = data.queuedAction;
            this.battleStats = battleStats;
            this.items =
                {
                    low: null,
                    mid: null,
                    high: null
                };
            for (var slot in items) {
                this.addItem(items[slot]);
            }
            if (data.portraitKey) {
                this.portrait = Rance.findItemWithKey(app.moduleData.Templates.Cultures, data.portraitKey, "portraits");
            }
        };
        Unit.prototype.setInitialValues = function () {
            this.setBaseHealth();
            this.setAttributes();
            this.resetBattleStats();
            this.maxMovePoints = this.template.maxMovePoints;
            this.resetMovePoints();
            this.setInitialAbilities();
            this.setInitialPassiveSkills();
            this.level = 1;
            this.experienceForCurrentLevel = 0;
            this.timesActedThisTurn = 0;
        };
        Unit.prototype.setBaseHealth = function (multiplier) {
            if (multiplier === void 0) { multiplier = 1; }
            var min = 200 * this.template.maxHealth * multiplier;
            var max = 300 * this.template.maxHealth * multiplier;
            this.maxHealth = Rance.randInt(min, max);
            this.currentHealth = this.maxHealth;
        };
        Unit.prototype.setAttributes = function (baseSkill, variance) {
            if (baseSkill === void 0) { baseSkill = 1; }
            if (variance === void 0) { variance = 1; }
            var template = this.template;
            var attributes = {
                attack: 1,
                defence: 1,
                intelligence: 1,
                speed: 1,
                maxActionPoints: Rance.randInt(3, 5)
            };
            for (var attribute in template.attributeLevels) {
                var attributeLevel = template.attributeLevels[attribute];
                var min = Math.max(3 * baseSkill * attributeLevel, 1);
                var max = Math.max(5 * baseSkill * attributeLevel + variance, 1);
                attributes[attribute] = Rance.randInt(min, max);
                if (attributes[attribute] > 9)
                    attributes[attribute] = 9;
            }
            this.baseAttributes = Rance.extendObject(attributes);
            this.attributes = attributes;
            this.attributesAreDirty = true;
        };
        Unit.prototype.setCulture = function () {
            var templateCultures = this.template.cultures;
            var nameGeneratorFN;
            var nameGeneratorCandidateCultures = templateCultures.filter(function (cultureTemplate) {
                return Boolean(cultureTemplate.nameGenerator);
            });
            if (nameGeneratorCandidateCultures.length > 0) {
                nameGeneratorFN = Rance.getRandomArrayItem(nameGeneratorCandidateCultures).nameGenerator;
            }
            else {
                nameGeneratorFN = Rance.defaultNameGenerator;
            }
            this.name = nameGeneratorFN(this);
            var portraitCandidateCultures = templateCultures.filter(function (cultureTemplate) {
                return Boolean(cultureTemplate.portraits);
            });
            if (portraitCandidateCultures.length === 0) {
                portraitCandidateCultures = Rance.getAllPropertiesWithKey(app.moduleData.Templates.Cultures, "portraits");
                if (portraitCandidateCultures.length === 0) {
                    console.warn("No culture has portraits specified"); //TODO culture
                    return;
                }
            }
            var portraitCandidateCulturesWithWeights = portraitCandidateCultures.map(function (culture) {
                return ({
                    weight: Object.keys(culture.portraits).length,
                    culture: culture
                });
            });
            var portraitCulture = Rance.getRandomArrayItemWithWeights(portraitCandidateCulturesWithWeights).culture;
            this.portrait = Rance.getRandomProperty(portraitCulture.portraits);
        };
        Unit.prototype.getBaseMoveDelay = function () {
            return 30 - this.attributes.speed;
        };
        Unit.prototype.resetMovePoints = function () {
            this.currentMovePoints = this.maxMovePoints;
        };
        Unit.prototype.resetBattleStats = function () {
            this.battleStats =
                {
                    moveDelay: this.getBaseMoveDelay(),
                    currentActionPoints: this.attributes.maxActionPoints,
                    side: null,
                    position: null,
                    guardAmount: 0,
                    guardCoverage: null,
                    captureChance: app.moduleData.ruleSet.battle.baseUnitCaptureChance,
                    statusEffects: [],
                    lastHealthBeforeReceivingDamage: this.currentHealth,
                    queuedAction: null
                };
            this.displayFlags =
                {
                    isAnnihilated: false
                };
        };
        Unit.prototype.setBattlePosition = function (battle, side, position) {
            this.battleStats.side = side;
            this.battleStats.position = position;
        };
        Unit.prototype.addStrength = function (amount) {
            this.currentHealth += Math.round(amount);
            if (this.currentHealth > this.maxHealth) {
                this.currentHealth = this.maxHealth;
            }
            this.uiDisplayIsDirty = true;
        };
        Unit.prototype.removeStrength = function (amount) {
            this.currentHealth -= Math.round(amount);
            this.currentHealth = Rance.clamp(this.currentHealth, 0, this.maxHealth);
            if (amount > 0) {
                this.removeGuard(40);
            }
            this.uiDisplayIsDirty = true;
        };
        Unit.prototype.removeActionPoints = function (amount) {
            this.battleStats.currentActionPoints -= amount;
            if (this.battleStats.currentActionPoints < 0) {
                this.battleStats.currentActionPoints = 0;
            }
            this.uiDisplayIsDirty = true;
        };
        Unit.prototype.addMoveDelay = function (amount) {
            this.battleStats.moveDelay += amount;
        };
        Unit.prototype.updateStatusEffects = function () {
            for (var i = 0; i < this.battleStats.statusEffects.length; i++) {
                this.battleStats.statusEffects[i].processTurnEnd();
                if (this.battleStats.statusEffects[i].duration === 0) {
                    this.removeStatusEffect(this.battleStats.statusEffects[i]);
                }
            }
            this.uiDisplayIsDirty = true;
        };
        Unit.prototype.setQueuedAction = function (ability, target) {
            this.battleStats.queuedAction =
                {
                    ability: ability,
                    targetId: target.id,
                    turnsPrepared: 0,
                    timesInterrupted: 0
                };
            this.uiDisplayIsDirty = true;
        };
        Unit.prototype.interruptQueuedAction = function (interruptStrength) {
            var action = this.battleStats.queuedAction;
            if (!action)
                return;
            action.timesInterrupted += interruptStrength;
            if (action.timesInterrupted >= action.ability.preparation.interruptsNeeded) {
                this.clearQueuedAction();
            }
            this.uiDisplayIsDirty = true;
        };
        Unit.prototype.updateQueuedAction = function () {
            var action = this.battleStats.queuedAction;
            if (!action)
                return;
            action.turnsPrepared++;
            this.uiDisplayIsDirty = true;
        };
        Unit.prototype.isReadyToUseQueuedAction = function () {
            var action = this.battleStats.queuedAction;
            return (action && action.turnsPrepared >= action.ability.preparation.turnsToPrep);
        };
        Unit.prototype.clearQueuedAction = function () {
            this.battleStats.queuedAction = null;
            this.uiDisplayIsDirty = true;
        };
        // redundant
        Unit.prototype.isTargetable = function () {
            return this.currentHealth > 0;
        };
        Unit.prototype.isActiveInBattle = function () {
            return this.currentHealth > 0;
        };
        Unit.prototype.addItem = function (item) {
            var itemSlot = item.template.slot;
            if (this.items[itemSlot])
                return false;
            if (item.unit) {
                item.unit.removeItem(item);
            }
            this.items[itemSlot] = item;
            item.unit = this;
            if (item.template.attributes) {
                this.attributesAreDirty = true;
            }
            if (item.template.passiveSkill) {
                this.passiveSkillsByPhaseAreDirty = true;
            }
        };
        Unit.prototype.removeItem = function (item) {
            var itemSlot = item.template.slot;
            if (this.items[itemSlot] === item) {
                this.items[itemSlot] = null;
                item.unit = null;
                if (item.template.attributes) {
                    this.attributesAreDirty = true;
                }
                if (item.template.passiveSkill) {
                    this.passiveSkillsByPhaseAreDirty = true;
                }
                return true;
            }
            return false;
        };
        Unit.prototype.destroyAllItems = function () {
            for (var slot in this.items) {
                var item = this.items[slot];
                if (item) {
                    this.fleet.player.removeItem(item);
                }
            }
        };
        Unit.prototype.getAttributesWithItems = function () {
            var attributes = Rance.extendObject(this.baseAttributes);
            for (var itemSlot in this.items) {
                if (this.items[itemSlot]) {
                    var item = this.items[itemSlot];
                    for (var attribute in item.template.attributes) {
                        attributes[attribute] = Rance.clamp(attributes[attribute] + item.template.attributes[attribute], 1, 9);
                    }
                }
            }
            return attributes;
        };
        Unit.prototype.addStatusEffect = function (statusEffect) {
            if (this.battleStats.statusEffects.indexOf(statusEffect) !== -1) {
                throw new Error("Tried to add duplicate status effect to unit " + this.name);
            }
            else if (statusEffect.duration === 0) {
                console.warn("Tried to add status effect", statusEffect, "with 0 duration");
                return;
            }
            this.battleStats.statusEffects.push(statusEffect);
            if (statusEffect.template.attributes) {
                this.attributesAreDirty = true;
            }
            if (statusEffect.template.passiveSkills) {
                this.passiveSkillsByPhaseAreDirty = true;
            }
            this.uiDisplayIsDirty = true;
        };
        Unit.prototype.removeStatusEffect = function (statusEffect) {
            var index = this.battleStats.statusEffects.indexOf(statusEffect);
            if (index === -1) {
                throw new Error("Tried to remove status effect not active on unit " + this.name);
            }
            this.battleStats.statusEffects.splice(index, 1);
            if (statusEffect.template.attributes) {
                this.attributesAreDirty = true;
            }
            if (statusEffect.template.passiveSkills) {
                this.passiveSkillsByPhaseAreDirty = true;
            }
            this.uiDisplayIsDirty = true;
        };
        /*
        sort by attribute, positive/negative, additive vs multiplicative
        apply additive, multiplicative
         */
        Unit.prototype.getTotalStatusEffectAttributeAdjustments = function () {
            if (!this.battleStats || !this.battleStats.statusEffects) {
                return null;
            }
            var adjustments = {};
            for (var i = 0; i < this.battleStats.statusEffects.length; i++) {
                var statusEffect = this.battleStats.statusEffects[i];
                if (!statusEffect.template.attributes)
                    continue;
                for (var attribute in statusEffect.template.attributes) {
                    adjustments[attribute] = {};
                    for (var type in statusEffect.template.attributes[attribute]) {
                        if (!adjustments[attribute][type]) {
                            adjustments[attribute][type] = 0;
                        }
                        adjustments[attribute][type] += statusEffect.template.attributes[attribute][type];
                    }
                }
            }
            return adjustments;
        };
        Unit.prototype.getAttributesWithEffects = function () {
            var withItems = this.getAttributesWithItems();
            var adjustments = this.getTotalStatusEffectAttributeAdjustments();
            for (var attribute in adjustments) {
                if (adjustments[attribute].flat) {
                    withItems[attribute] += adjustments[attribute].flat;
                }
                if (adjustments[attribute].multiplier) {
                    withItems[attribute] *= 1 + adjustments[attribute].multiplier;
                }
                withItems[attribute] = Rance.clamp(withItems[attribute], -5, 20);
            }
            return withItems;
        };
        Unit.prototype.updateCachedAttributes = function () {
            this.cachedAttributes = this.getAttributesWithEffects();
        };
        Unit.prototype.removeItemAtSlot = function (slot) {
            if (this.items[slot]) {
                this.removeItem(this.items[slot]);
                return true;
            }
            return false;
        };
        Unit.prototype.setInitialAbilities = function () {
            this.abilities = Rance.getItemsFromWeightedProbabilities(this.template.possibleAbilities);
        };
        Unit.prototype.setInitialPassiveSkills = function () {
            if (this.template.possiblePassiveSkills) {
                this.passiveSkills = Rance.getItemsFromWeightedProbabilities(this.template.possiblePassiveSkills);
            }
        };
        Unit.prototype.getItemAbilities = function () {
            var itemAbilities = [];
            for (var slot in this.items) {
                if (!this.items[slot] || !this.items[slot].template.ability)
                    continue;
                itemAbilities.push(this.items[slot].template.ability);
            }
            return itemAbilities;
        };
        Unit.prototype.getAllAbilities = function () {
            return this.abilities.concat(this.getItemAbilities());
        };
        Unit.prototype.getItemPassiveSkills = function () {
            var itemPassiveSkills = [];
            for (var slot in this.items) {
                if (!this.items[slot] || !this.items[slot].template.passiveSkill)
                    continue;
                itemPassiveSkills.push(this.items[slot].template.passiveSkill);
            }
            return itemPassiveSkills;
        };
        Unit.prototype.getStatusEffectPassiveSkills = function () {
            var statusEffectPassiveSkills = [];
            if (!this.battleStats || !this.battleStats.statusEffects) {
                return statusEffectPassiveSkills;
            }
            for (var i = 0; i < this.battleStats.statusEffects.length; i++) {
                var templateSkills = this.battleStats.statusEffects[i].template.passiveSkills;
                if (templateSkills) {
                    statusEffectPassiveSkills = statusEffectPassiveSkills.concat(templateSkills);
                }
            }
            return statusEffectPassiveSkills;
        };
        Unit.prototype.getAllPassiveSkills = function () {
            var allSkills = [];
            allSkills = allSkills.concat(this.passiveSkills);
            allSkills = allSkills.concat(this.getItemPassiveSkills());
            allSkills = allSkills.concat(this.getStatusEffectPassiveSkills());
            return allSkills;
        };
        Unit.prototype.updatePassiveSkillsByPhase = function () {
            var updatedSkills = {};
            var allSkills = this.getAllPassiveSkills();
            for (var i = 0; i < allSkills.length; i++) {
                var skill = allSkills[i];
                ["atBattleStart", "beforeAbilityUse", "afterAbilityUse", "atTurnStart", "inBattlePrep"].forEach(function (phase) {
                    if (skill[phase]) {
                        if (!updatedSkills[phase]) {
                            updatedSkills[phase] = [];
                        }
                        if (updatedSkills[phase].indexOf(skill) === -1) {
                            updatedSkills[phase].push(skill);
                        }
                    }
                });
            }
            this.passiveSkillsByPhase = updatedSkills;
            this.passiveSkillsByPhaseAreDirty = false;
        };
        Unit.prototype.getPassiveSkillsByPhase = function () {
            if (this.passiveSkillsByPhaseAreDirty) {
                this.updatePassiveSkillsByPhase();
            }
            return this.passiveSkillsByPhase;
        };
        Unit.prototype.receiveDamage = function (amount, damageType) {
            var damageReduction = this.getReducedDamageFactor(damageType);
            var adjustedDamage = amount * damageReduction;
            this.battleStats.lastHealthBeforeReceivingDamage = this.currentHealth;
            this.removeStrength(adjustedDamage);
        };
        Unit.prototype.getAdjustedTroopSize = function () {
            // used so unit will always counter with at least 1/3 strength it had before being attacked
            var balancedHealth = this.currentHealth + this.battleStats.lastHealthBeforeReceivingDamage / 3;
            this.battleStats.lastHealthBeforeReceivingDamage = this.currentHealth;
            var currentHealth = this.isSquadron ?
                balancedHealth :
                Math.min(this.maxHealth, balancedHealth + this.maxHealth * 0.2);
            if (currentHealth <= 500) {
                return currentHealth;
            }
            else if (currentHealth <= 2000) {
                return currentHealth / 2 + 250;
            }
            else {
                return currentHealth / 4 + 750;
            }
        };
        Unit.prototype.getAttackDamageIncrease = function (damageType) {
            var attackStat, attackFactor;
            switch (damageType) {
                case Rance.DamageType.physical:
                    {
                        attackStat = this.attributes.attack;
                        attackFactor = 0.1;
                        break;
                    }
                case Rance.DamageType.magical:
                    {
                        attackStat = this.attributes.intelligence;
                        attackFactor = 0.1;
                        break;
                    }
            }
            var troopSize = this.getAdjustedTroopSize() / 4;
            return (1 + attackStat * attackFactor) * troopSize;
        };
        Unit.prototype.getReducedDamageFactor = function (damageType) {
            var defensiveStat, defenceFactor;
            var finalDamageMultiplier = 1;
            switch (damageType) {
                case Rance.DamageType.physical:
                    {
                        defensiveStat = this.attributes.defence;
                        defenceFactor = 0.045;
                        var guardAmount = Math.min(this.battleStats.guardAmount, 100);
                        finalDamageMultiplier = 1 - guardAmount / 200; // 1 - 0.5;
                        break;
                    }
                case Rance.DamageType.magical:
                    {
                        defensiveStat = this.attributes.intelligence;
                        defenceFactor = 0.045;
                        break;
                    }
            }
            var damageReduction = defensiveStat * defenceFactor;
            var finalDamageFactor = (1 - damageReduction) * finalDamageMultiplier;
            return finalDamageFactor;
        };
        Unit.prototype.addToFleet = function (fleet) {
            this.fleet = fleet;
        };
        Unit.prototype.removeFromFleet = function () {
            this.fleet = null;
        };
        Unit.prototype.removeFromPlayer = function () {
            var player = this.fleet.player;
            this.destroyAllItems();
            player.removeUnit(this);
            this.fleet.removeUnit(this);
            if (this.front) {
                this.front.removeUnit(this);
            }
            this.uiDisplayIsDirty = true;
        };
        Unit.prototype.transferToPlayer = function (newPlayer) {
            var oldPlayer = this.fleet.player;
            var location = this.fleet.location;
            this.removeFromPlayer();
            newPlayer.addUnit(this);
            var newFleet = new Rance.Fleet(newPlayer, [this], location);
        };
        Unit.prototype.removeGuard = function (amount) {
            this.battleStats.guardAmount -= amount;
            if (this.battleStats.guardAmount < 0)
                this.removeAllGuard();
            this.uiDisplayIsDirty = true;
        };
        Unit.prototype.addGuard = function (amount, coverage) {
            this.battleStats.guardAmount += amount;
            this.battleStats.guardCoverage = coverage;
            this.uiDisplayIsDirty = true;
        };
        Unit.prototype.removeAllGuard = function () {
            this.battleStats.guardAmount = 0;
            this.battleStats.guardCoverage = null;
            this.uiDisplayIsDirty = true;
        };
        Unit.prototype.getCounterAttackStrength = function () {
            return 1; // TODO unit
        };
        Unit.prototype.canActThisTurn = function () {
            return this.timesActedThisTurn < 1 || this.fleet.player.isIndependent;
        };
        Unit.prototype.isStealthy = function () {
            // TODO unit
            return this.template.isStealthy;
        };
        Unit.prototype.getVisionRange = function () {
            // TODO unit
            return this.template.visionRange;
        };
        Unit.prototype.getDetectionRange = function () {
            // TODO unit
            return this.template.detectionRange;
        };
        Unit.prototype.heal = function () {
            var location = this.fleet.location;
            var baseHealFactor = 0.05;
            var healingFactor = baseHealFactor + location.getHealingFactor(this.fleet.player);
            var healAmount = this.maxHealth * healingFactor;
            this.addStrength(healAmount);
        };
        Unit.prototype.getStrengthEvaluation = function () {
            // TODO unit TODO ai
            return this.currentHealth;
        };
        Unit.prototype.getTotalCost = function () {
            var totalCost = 0;
            totalCost += this.template.buildCost;
            for (var slot in this.items) {
                if (this.items[slot]) {
                    totalCost += this.items[slot].template.buildCost;
                }
            }
            return totalCost;
        };
        Unit.prototype.getTurnsToReachStar = function (star) {
            var currentLocation = this.fleet.location;
            var distance = currentLocation.getDistanceToStar(star);
            if (distance <= this.currentMovePoints) {
                if (this.currentMovePoints === 0) {
                    return 0;
                }
                else {
                    return distance / this.currentMovePoints;
                }
            }
            distance -= this.currentMovePoints; // current turn
            return distance / this.maxMovePoints; // future turns
        };
        Unit.prototype.getExperienceToNextLevel = function () {
            return (4 + this.level) * 10;
        };
        Unit.prototype.addExperience = function (amount) {
            this.experienceForCurrentLevel += Math.round(amount);
        };
        Unit.prototype.canLevelUp = function () {
            return this.experienceForCurrentLevel >= this.getExperienceToNextLevel();
        };
        Unit.prototype.handleLevelUp = function () {
            this.experienceForCurrentLevel -= this.getExperienceToNextLevel();
            this.level++;
        };
        Unit.prototype.hasAbility = function (ability, allAbilities) {
            for (var i = 0; i < allAbilities.length; i++) {
                if (allAbilities[i].type === ability.type) {
                    return true;
                }
            }
            return false;
        };
        Unit.prototype.getLearnableAbilities = function (allAbilities) {
            var abilities = [];
            if (!this.template.learnableAbilities)
                return abilities;
            for (var i = 0; i < this.template.learnableAbilities.length; i++) {
                var learnableItem = this.template.learnableAbilities[i];
                if (Array.isArray(learnableItem)) {
                    var hasAbilityFromGroup = false;
                    for (var j = 0; j < learnableItem.length; j++) {
                        if (this.hasAbility(learnableItem[j], allAbilities)) {
                            hasAbilityFromGroup = true;
                            break;
                        }
                    }
                    if (!hasAbilityFromGroup) {
                        abilities = abilities.concat(learnableItem);
                    }
                }
                else if (!this.hasAbility(learnableItem, allAbilities)) {
                    abilities.push(learnableItem);
                }
            }
            return abilities;
        };
        Unit.prototype.canUpgradeIntoAbility = function (ability, allAbilities) {
            if (ability.onlyAllowExplicitUpgrade) {
                if (!this.template.specialAbilityUpgrades || this.template.specialAbilityUpgrades.indexOf(ability) === -1) {
                    return false;
                }
            }
            if (this.hasAbility(ability, allAbilities)) {
                return false;
            }
            return true;
        };
        Unit.prototype.getAbilityUpgradeData = function () {
            var upgradeData = {};
            var allAbilities = this.getAllAbilities();
            allAbilities = allAbilities.concat(this.getAllPassiveSkills());
            var templates = app.moduleData.Templates;
            for (var i = 0; i < allAbilities.length; i++) {
                var parentAbility = allAbilities[i];
                if (!parentAbility.canUpgradeInto)
                    continue;
                for (var j = 0; j < parentAbility.canUpgradeInto.length; j++) {
                    var childAbilityType = parentAbility.canUpgradeInto[j];
                    var childAbility = templates.Abilities[childAbilityType] || templates.PassiveSkills[childAbilityType];
                    if (!childAbility)
                        throw new Error("Invalid ability upgrade " + childAbilityType);
                    if (this.canUpgradeIntoAbility(childAbility, allAbilities)) {
                        if (!upgradeData[parentAbility.type]) {
                            upgradeData[parentAbility.type] =
                                {
                                    base: parentAbility,
                                    possibleUpgrades: []
                                };
                        }
                        upgradeData[parentAbility.type].possibleUpgrades.push(childAbility);
                    }
                }
            }
            var learnable = this.getLearnableAbilities(allAbilities);
            if (learnable.length > 0) {
                upgradeData["learnable"] =
                    {
                        base: null,
                        possibleUpgrades: learnable
                    };
            }
            return upgradeData;
        };
        Unit.prototype.upgradeAbility = function (source, newAbility) {
            var newAbilityIsPassiveSkill = !newAbility.mainEffect;
            if (source) {
                var sourceIsPassiveSkill = !source.mainEffect;
                if (sourceIsPassiveSkill) {
                    this.passiveSkills.splice(this.passiveSkills.indexOf(source), 1);
                }
                else {
                    var castedSource = source;
                    this.abilities.splice(this.abilities.indexOf(castedSource), 1);
                }
            }
            if (newAbilityIsPassiveSkill) {
                this.passiveSkills.push(newAbility);
            }
            else {
                var castedNewAbility = newAbility;
                this.abilities.push(castedNewAbility);
            }
        };
        Unit.prototype.drawBattleScene = function (SFXParams) {
            this.template.unitDrawingFN(this, SFXParams);
        };
        Unit.prototype.serialize = function (includeItems, includeFluff) {
            if (includeItems === void 0) { includeItems = true; }
            if (includeFluff === void 0) { includeFluff = true; }
            var itemsSaveData = {};
            if (includeItems) {
                for (var slot in this.items) {
                    if (this.items[slot]) {
                        itemsSaveData[slot] = this.items[slot].serialize();
                    }
                }
            }
            var battleStatsSavedData = {
                moveDelay: this.battleStats.moveDelay,
                side: this.battleStats.side,
                position: this.battleStats.position,
                currentActionPoints: this.battleStats.currentActionPoints,
                guardAmount: this.battleStats.guardAmount,
                guardCoverage: this.battleStats.guardCoverage,
                captureChance: this.battleStats.captureChance,
                statusEffects: this.battleStats.statusEffects.map(function (statusEffect) {
                    return statusEffect.clone();
                }),
                queuedAction: this.battleStats.queuedAction
            };
            var data = {
                templateType: this.template.type,
                id: this.id,
                name: this.name,
                maxHealth: this.maxHealth,
                currentHealth: this.currentHealth,
                currentMovePoints: this.currentMovePoints,
                maxMovePoints: this.maxMovePoints,
                timesActedThisTurn: this.timesActedThisTurn,
                baseAttributes: Rance.extendObject(this.baseAttributes),
                abilityTemplateTypes: this.abilities.map(function (ability) {
                    return ability.type;
                }),
                passiveSkillTemplateTypes: this.passiveSkills.map(function (passiveSkill) {
                    return passiveSkill.type;
                }),
                experienceForCurrentLevel: this.experienceForCurrentLevel,
                level: this.level,
                items: itemsSaveData,
                battleStats: battleStatsSavedData
            };
            if (this.fleet) {
                data.fleetId = this.fleet.id;
            }
            if (includeFluff) {
                data.portraitKey = this.portrait.key;
            }
            return data;
        };
        Unit.prototype.makeVirtualClone = function () {
            var data = this.serialize(true, false);
            var clone = new Unit(this.template, this.id, data);
            return clone;
        };
        return Unit;
    }());
    Rance.Unit = Unit;
})(Rance || (Rance = {}));
/// <reference path="../../../lib/tween.js.d.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.UnitStrength = React.createClass({
            displayName: "UnitStrength",
            getInitialState: function () {
                return ({
                    displayedStrength: this.props.currentHealth,
                    activeTween: null
                });
            },
            componentWillReceiveProps: function (newProps) {
                if (newProps.animateStrength &&
                    newProps.currentHealth !== this.props.currentHealth &&
                    (!newProps.maxHealth || newProps.maxHealth === this.props.maxHealth)) {
                    var animateDuration = newProps.animateDuration || 0;
                    this.animateDisplayedStrength(newProps.currentHealth, animateDuration);
                }
                else {
                    this.updateDisplayStrength(newProps.currentHealth);
                }
            },
            componentWillUnmount: function () {
                if (this.activeTween) {
                    this.activeTween.stop();
                }
            },
            updateDisplayStrength: function (newAmount) {
                this.setState({
                    displayedStrength: newAmount
                });
            },
            animateDisplayedStrength: function (newAmount, time) {
                var self = this;
                var stopped = false;
                var animateTween = function () {
                    if (stopped) {
                        cancelAnimationFrame(self.requestAnimFrame);
                        return;
                    }
                    TWEEN.update();
                    self.requestAnimFrame = window.requestAnimationFrame(animateTween);
                };
                var tween = new TWEEN.Tween({
                    health: self.state.displayedStrength
                }).to({
                    health: newAmount
                }, time).onUpdate(function () {
                    self.setState({
                        displayedStrength: this.health
                    });
                }).easing(TWEEN.Easing.Sinusoidal.Out);
                tween.onStop(function () {
                    stopped = true;
                    TWEEN.remove(tween);
                });
                this.activeTween = tween;
                tween.start();
                animateTween();
            },
            makeSquadronInfo: function () {
                return (React.DOM.div({ className: "unit-strength-container" }, this.makeStrengthText()));
            },
            makeCapitalInfo: function () {
                var text = this.makeStrengthText();
                var relativeHealth = this.state.displayedStrength / this.props.maxHealth;
                var bar = React.DOM.div({
                    className: "unit-strength-bar"
                }, React.DOM.div({
                    className: "unit-strength-bar-value",
                    style: {
                        width: "" + relativeHealth * 100 + "%"
                    }
                }));
                return (React.DOM.div({ className: "unit-strength-container" }, text, bar));
            },
            makeStrengthText: function () {
                var critThreshhold = 0.3;
                var currentStyle = {
                    className: "unit-strength-current"
                };
                var healthRatio = this.state.displayedStrength / this.props.maxHealth;
                if (!this.props.isNotDetected && healthRatio <= critThreshhold) {
                    currentStyle.className += " critical";
                }
                else if (!this.props.isNotDetected && this.state.displayedStrength < this.props.maxHealth) {
                    currentStyle.className += " wounded";
                }
                var containerProps = {
                    className: (this.props.isSquadron ? "unit-strength-amount" :
                        "unit-strength-amount-capital")
                };
                var displayed = this.props.isNotDetected ? "???" : "" + Math.ceil(this.state.displayedStrength);
                var max = this.props.isNotDetected ? "???" : "" + this.props.maxHealth;
                return (React.DOM.div(containerProps, React.DOM.span(currentStyle, displayed), React.DOM.span({ className: "unit-strength-max" }, "/" + max)));
            },
            render: function () {
                if (this.props.isSquadron) {
                    return this.makeSquadronInfo();
                }
                else {
                    return this.makeCapitalInfo();
                }
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="unitstrength.ts"/>
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.UnitActions = React.createClass({
            displayName: "UnitActions",
            render: function () {
                var availableSrc = "img\/icons\/availableAction.png";
                var hoveredSrc = "img\/icons\/spentAction.png";
                var spentSrc = "img\/icons\/spentAction.png";
                var icons = [];
                var availableCount = this.props.currentActionPoints - this.props.hoveredActionPointExpenditure;
                for (var i = 0; i < availableCount; i++) {
                    icons.push(React.DOM.img({
                        src: availableSrc,
                        className: "unit-action-point available-action-point",
                        key: "available" + i
                    }));
                }
                var hoveredCount = Math.min(this.props.hoveredActionPointExpenditure, this.props.currentActionPoints);
                for (var i = 0; i < hoveredCount; i++) {
                    icons.push(React.DOM.img({
                        src: hoveredSrc,
                        className: "unit-action-point hovered-action-point",
                        key: "hovered" + i
                    }));
                }
                var spentCount = this.props.maxActionPoints - this.props.currentActionPoints;
                for (var i = 0; i < spentCount; i++) {
                    icons.push(React.DOM.img({
                        src: spentSrc,
                        className: "unit-action-point spent-action-point",
                        key: "spent" + i
                    }));
                }
                return (React.DOM.div({ className: "unit-action-points" }, icons));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.UnitStatus = React.createClass({
            displayName: "UnitStatus",
            propTypes: {
                guardAmount: React.PropTypes.number,
                guardCoverage: React.PropTypes.number,
                isPreparing: React.PropTypes.bool
            },
            render: function () {
                var statusElement = null;
                if (this.props.guardAmount > 0) {
                    var guard = this.props.guardAmount;
                    var damageReduction = Math.min(50, guard / 2);
                    var guardText = "" + guard + "% chance to protect ";
                    guardText += (this.props.guardCoverage === Rance.GuardCoverage.all ? "all units." : " units in same row.");
                    guardText += "\n" + "This unit takes " + damageReduction + "% reduced damage from physical attacks.";
                    statusElement = React.DOM.div({
                        className: "status-container guard-meter-container"
                    }, React.DOM.div({
                        className: "guard-meter-value",
                        style: {
                            width: "" + Rance.clamp(guard, 0, 100) + "%"
                        }
                    }), React.DOM.div({
                        className: "status-inner-wrapper"
                    }, React.DOM.div({
                        className: "guard-text-container status-inner",
                        title: guardText
                    }, React.DOM.div({
                        className: "guard-text status-text"
                    }, "Guard"), React.DOM.div({
                        className: "guard-text-value status-text"
                    }, "" + guard + "%"))));
                }
                else if (this.props.isPreparing) {
                    statusElement = React.DOM.div({
                        className: "status-container preparation-container"
                    }, React.DOM.div({
                        className: "status-inner-wrapper"
                    }, React.DOM.div({
                        className: "preparation-text-container status-inner",
                        title: "Unit is preparing to use ability"
                    }, "Preparing")));
                }
                return (React.DOM.div({ className: "unit-status" }, statusElement));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="unitstrength.ts"/>
/// <reference path="unitactions.ts"/>
/// <reference path="unitstatus.ts"/>
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.UnitInfo = React.createClass({
            displayName: "UnitInfo",
            mixins: [React.addons.PureRenderMixin],
            propTypes: {
                name: React.PropTypes.string.isRequired,
                isSquadron: React.PropTypes.bool.isRequired,
                maxHealth: React.PropTypes.number.isRequired,
                currentHealth: React.PropTypes.number.isRequired,
                maxActionPoints: React.PropTypes.number.isRequired,
                currentActionPoints: React.PropTypes.number.isRequired,
                hoveredActionPointExpenditure: React.PropTypes.number.isRequired,
                isDead: React.PropTypes.bool,
                isCaptured: React.PropTypes.bool,
                guardAmount: React.PropTypes.number.isRequired,
                guardCoverage: React.PropTypes.number,
                isPreparing: React.PropTypes.bool,
                animateDuration: React.PropTypes.number
            },
            render: function () {
                var battleEndStatus = null;
                if (this.props.isDead) {
                    battleEndStatus = React.DOM.div({
                        className: "unit-battle-end-status-container"
                    }, React.DOM.div({
                        className: "unit-battle-end-status unit-battle-end-status-dead"
                    }, "Destroyed"));
                }
                else if (this.props.isCaptured) {
                    battleEndStatus = React.DOM.div({
                        className: "unit-battle-end-status-container"
                    }, React.DOM.div({
                        className: "unit-battle-end-status unit-battle-end-status-captured"
                    }, "Captured"));
                }
                return (React.DOM.div({ className: "unit-info" }, React.DOM.div({ className: "unit-info-name" }, this.props.name), React.DOM.div({ className: "unit-info-inner" }, UIComponents.UnitStatus({
                    guardAmount: this.props.guardAmount,
                    isPreparing: this.props.isPreparing
                }), UIComponents.UnitStrength({
                    maxHealth: this.props.maxHealth,
                    currentHealth: this.props.currentHealth,
                    isSquadron: this.props.isSquadron,
                    animateStrength: true,
                    animateDuration: this.props.animateDuration
                }), UIComponents.UnitActions({
                    maxActionPoints: this.props.maxActionPoints,
                    currentActionPoints: this.props.currentActionPoints,
                    hoveredActionPointExpenditure: this.props.hoveredActionPointExpenditure
                }), battleEndStatus)));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.UnitIcon = React.createClass({
            displayName: "UnitIcon",
            mixins: [React.addons.PureRenderMixin],
            render: function () {
                var unit = this.props.unit;
                var containerProps = {
                    className: "unit-icon-container"
                };
                var fillerProps = {
                    className: "unit-icon-filler"
                };
                if (this.props.isActiveUnit) {
                    fillerProps.className += " active-border";
                    containerProps.className += " active-border";
                }
                if (this.props.isAnnihilated) {
                    containerProps.className += " icon-annihilated-overlay";
                }
                if (this.props.facesLeft) {
                    fillerProps.className += " unit-border-right";
                    containerProps.className += " unit-border-no-right";
                }
                else {
                    fillerProps.className += " unit-border-left";
                    containerProps.className += " unit-border-no-left";
                }
                var iconImage = this.props.icon ?
                    React.DOM.img({
                        className: "unit-icon",
                        src: this.props.icon
                    }) :
                    null;
                return (React.DOM.div({ className: "unit-icon-wrapper" }, React.DOM.div(fillerProps), React.DOM.div(containerProps, iconImage), React.DOM.div(fillerProps)));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.UnitStatusEffects = React.createClass({
            displayName: "UnitStatusEffects",
            render: function () {
                var statusEffects = [];
                var withItems = this.props.unit.getAttributesWithItems();
                var withEffects = this.props.unit.getAttributesWithEffects();
                for (var attribute in withEffects) {
                    if (attribute === "maxActionPoints")
                        continue;
                    var ite = withItems[attribute];
                    var eff = withEffects[attribute];
                    if (ite === eff)
                        continue;
                    var polarityString = eff > ite ? "positive" : "negative";
                    var polaritySign = eff > ite ? " +" : " ";
                    var imageSrc = "img\/icons\/statusEffect_" + polarityString + "_" + attribute + ".png";
                    var titleString = "" + attribute + polaritySign + (eff - ite);
                    statusEffects.push(React.DOM.img({
                        className: "status-effect-icon" + " status-effect-icon-" + attribute,
                        src: imageSrc,
                        key: attribute,
                        title: titleString
                    }));
                }
                var passiveSkills = [];
                var passiveSkillsByPhase = this.props.unit.getPassiveSkillsByPhase();
                var phasesToCheck = this.props.isBattlePrep ? ["atBattleStart"] : ["beforeAbilityUse", "afterAbilityUse"];
                phasesToCheck.forEach(function (phase) {
                    if (passiveSkillsByPhase[phase]) {
                        for (var i = 0; i < passiveSkillsByPhase[phase].length; i++) {
                            var skill = passiveSkillsByPhase[phase][i];
                            if (!skill.isHidden) {
                                passiveSkills.push(skill);
                            }
                        }
                    }
                });
                var passiveSkillsElement = null;
                if (passiveSkills.length > 0) {
                    var passiveSkillsElementTitle = "";
                    for (var i = 0; i < passiveSkills.length; i++) {
                        passiveSkillsElementTitle += passiveSkills[i].displayName + ": " +
                            passiveSkills[i].description + "\n";
                    }
                    passiveSkillsElement = React.DOM.img({
                        className: "unit-status-effects-passive-skills",
                        src: "img\/icons\/availableAction.png",
                        title: passiveSkillsElementTitle
                    });
                }
                return (React.DOM.div({
                    className: "unit-status-effects-container"
                }, passiveSkillsElement, React.DOM.div({
                    className: "unit-status-effects-attributes"
                }, statusEffects)));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.UnitPortrait = React.createClass({
            displayName: "UnitPortrait",
            render: function () {
                var props = this.props;
                props.className = "unit-portrait " + (props.className || "");
                if (this.props.imageSrc) {
                    props.style =
                        {
                            backgroundImage: 'url("' + this.props.imageSrc + '")'
                        };
                }
                return (React.DOM.div(props, null));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../../../lib/react.d.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.Draggable = {
            getDefaultProps: function () {
                return ({
                    dragThreshhold: 5
                });
            },
            getInitialState: function () {
                return ({
                    dragging: false,
                    clone: null
                });
            },
            componentWillMount: function () {
                this.dragPos = {};
                this.mouseDown = false;
                this.dragOffset =
                    {
                        x: 0,
                        y: 0
                    };
                this.mouseDownPosition =
                    {
                        x: 0,
                        y: 0
                    };
                this.originPosition =
                    {
                        x: 0,
                        y: 0
                    };
            },
            componentDidMount: function () {
                this.DOMNode = this.getDOMNode();
                this.containerElement = document.body;
                if (this.props.containerElement) {
                    if (this.props.containerElement.getDOMNode) {
                        // React component
                        this.containerElement = this.props.containerElement.getDOMNode();
                    }
                    else
                        this.containerElement = this.props.containerElement;
                }
                this.setContainerRect();
                window.addEventListener("resize", this.setContainerRect, false);
            },
            componentWillUnmount: function () {
                this.removeEventListeners();
                window.removeEventListener("resize", this.setContainerRect);
            },
            handleMouseDown: function (e) {
                if (e.button)
                    return;
                if (this.props.containerDragOnly) {
                    var target = e.target;
                    if (!target.classList.contains("draggable-container")) {
                        return;
                    }
                }
                e.preventDefault();
                e.stopPropagation();
                if (this.state.dragging)
                    return;
                var clientRect = this.getDOMNode().getBoundingClientRect();
                // var e;
                // if (isFinite(e.clientX))
                // {
                //   e = e;
                // }
                // else
                // {
                //   e = e.touches[0];
                //   this.needsFirstTouchUpdate = true;
                //   this.touchEventTarget = e.target;
                // }
                this.addEventListeners();
                var dragOffset = this.props.forcedDragOffset || this.forcedDragOffset ||
                    {
                        x: e.clientX - clientRect.left,
                        y: e.clientY - clientRect.top
                    };
                this.mouseDown = true;
                this.dragOffset = dragOffset;
                this.mouseDownPosition =
                    {
                        x: e.pageX,
                        y: e.pageY
                    };
                this.originPosition =
                    {
                        x: clientRect.left + document.body.scrollLeft,
                        y: clientRect.top + document.body.scrollTop
                    };
                if (this.props.dragThreshhold <= 0) {
                    this.handleMouseMove(e);
                }
            },
            handleMouseMove: function (e) {
                if (e.preventDefault)
                    e.preventDefault();
                // var e = e.clientX ? e : e.touches[0];
                if (e.clientX === 0 && e.clientY === 0)
                    return;
                if (!this.state.dragging) {
                    var deltaX = Math.abs(e.pageX - this.mouseDownPosition.x);
                    var deltaY = Math.abs(e.pageY - this.mouseDownPosition.y);
                    var delta = deltaX + deltaY;
                    if (delta >= this.props.dragThreshhold) {
                        var ownNode = this.getDOMNode();
                        var stateObj = {
                            dragging: true
                        };
                        if (!this.props.preventAutoResize) {
                            this.dragPos.width = parseInt(ownNode.offsetWidth);
                            this.dragPos.height = parseInt(ownNode.offsetHeight);
                        }
                        if (this.props.makeClone) {
                            if (!this.makeDragClone) {
                                var nextSibling = ownNode.nextSibling;
                                var clone = ownNode.cloneNode(true);
                                Rance.recursiveRemoveAttribute(clone, "data-reactid");
                                ownNode.parentNode.insertBefore(clone, nextSibling);
                                stateObj.clone = clone;
                            }
                            else {
                                var clone = this.makeDragClone();
                                document.body.appendChild(clone);
                                stateObj.clone = clone;
                            }
                        }
                        this.setState(stateObj);
                        if (this.onDragStart) {
                            this.onDragStart(e);
                        }
                        if (this.onDragMove) {
                            this.onDragMove(e.pageX - this.dragOffset.x, e.pageY - this.dragOffset.y);
                        }
                    }
                }
                if (this.state.dragging) {
                    this.handleDrag(e);
                }
            },
            handleDrag: function (e) {
                var x = e.pageX - this.dragOffset.x;
                var y = e.pageY - this.dragOffset.y;
                var domWidth, domHeight;
                if (this.makeDragClone) {
                    domWidth = parseInt(this.state.clone.offsetWidth);
                    domHeight = parseInt(this.state.clone.offsetHeight);
                }
                else {
                    domWidth = parseInt(this.getDOMNode().offsetWidth);
                    domHeight = parseInt(this.getDOMNode().offsetHeight);
                }
                var minX = this.containerRect.left;
                var maxX = this.containerRect.right;
                var minY = this.containerRect.top;
                var maxY = this.containerRect.bottom;
                var x2 = x + domWidth;
                var y2 = y + domHeight;
                if (x < minX) {
                    x = minX;
                }
                else if (x2 > maxX) {
                    x = this.containerRect.width - domWidth;
                }
                ;
                if (y < minY) {
                    y = minY;
                }
                else if (y2 > maxY) {
                    y = this.containerRect.height - domHeight;
                }
                ;
                if (this.onDragMove) {
                    this.onDragMove(x, y);
                }
                else {
                    this.dragPos.top = y;
                    this.dragPos.left = x;
                    this.updateDOMNodeStyle();
                }
            },
            handleMouseUp: function (e) {
                // if (this.touchEventTarget)
                // {
                //   var touch = e.changedTouches[0];
                //   var dropTarget = getDropTargetAtLocation(touch.clientX, touch.clientY);
                //   console.log(dropTarget);
                //   if (dropTarget)
                //   {
                //     var reactid = dropTarget.getAttribute("data-reactid");
                //     eventManager.dispatchEvent("drop" + reactid);
                //   }
                // }
                this.mouseDown = false;
                this.mouseDownPosition =
                    {
                        x: 0,
                        y: 0
                    };
                if (this.state.dragging) {
                    this.handleDragEnd(e);
                }
                this.removeEventListeners();
            },
            handleDragEnd: function (e) {
                if (this.state.clone) {
                    this.state.clone.parentNode.removeChild(this.state.clone);
                }
                if (this.isMounted()) {
                    this.setState({
                        dragging: false,
                        clone: null
                    });
                    this.dragOffset =
                        {
                            x: 0,
                            y: 0
                        };
                    this.originPosition =
                        {
                            x: 0,
                            y: 0
                        };
                }
                if (this.onDragEnd) {
                    var endSuccesful = this.onDragEnd(e);
                }
            },
            addEventListeners: function () {
                var self = this;
                this.containerElement.addEventListener("mousemove", self.handleMouseMove);
                document.addEventListener("mouseup", self.handleMouseUp);
                if (this.touchEventTarget) {
                    this.touchEventTarget.addEventListener("touchmove", self.handleMouseMove);
                    this.touchEventTarget.addEventListener("touchend", self.handleMouseUp);
                }
            },
            removeEventListeners: function () {
                var self = this;
                this.containerElement.removeEventListener("mousemove", self.handleMouseMove);
                document.removeEventListener("mouseup", self.handleMouseUp);
                if (this.touchEventTarget) {
                    this.touchEventTarget.removeEventListener("touchmove", self.handleMouseMove);
                    this.touchEventTarget.removeEventListener("touchend", self.handleMouseUp);
                    this.touchEventTarget = null;
                }
            },
            setContainerRect: function () {
                this.containerRect = this.containerElement.getBoundingClientRect();
            },
            updateDOMNodeStyle: function () {
                if (this.state.clone) {
                    var s = this.state.clone.style;
                    s.top = "" + this.dragPos.top + "px";
                    s.left = "" + this.dragPos.left + "px";
                }
                else {
                    var s = this.DOMNode.style;
                    for (var key in this.dragPos) {
                        s[key] = "" + this.dragPos[key] + "px";
                    }
                }
            }
        };
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="unitinfo.ts"/>
/// <reference path="uniticon.ts"/>
/// <reference path="unitstatuseffects.ts" />
/// <reference path="unitportrait.ts" />
/// <reference path="../mixins/draggable.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.Unit = React.createClass({
            displayName: "Unit",
            mixins: [UIComponents.Draggable, React.addons.PureRenderMixin],
            getInitialState: function () {
                return ({
                    hasPopup: false,
                    popupElement: null
                });
            },
            onDragStart: function () {
                this.props.onDragStart(this.props.unit);
            },
            onDragEnd: function () {
                this.props.onDragEnd();
            },
            handleClick: function () {
                this.props.onUnitClick(this.props.unit);
            },
            handleMouseEnter: function () {
                if (!this.props.handleMouseEnterUnit)
                    return;
                if (this.props.unit.currentHealth <= 0)
                    return;
                this.props.handleMouseEnterUnit(this.props.unit);
            },
            handleMouseLeave: function (e) {
                if (!this.props.handleMouseLeaveUnit)
                    return;
                this.props.handleMouseLeaveUnit(e);
            },
            render: function () {
                var unit = this.props.unit;
                unit.uiDisplayIsDirty = false;
                var containerProps = {
                    className: "unit-container",
                    id: "unit-id_" + unit.id,
                    key: "container"
                };
                var wrapperProps = {
                    className: "unit"
                };
                wrapperProps.onMouseEnter = this.handleMouseEnter;
                wrapperProps.onMouseLeave = this.handleMouseLeave;
                if (this.props.isDraggable) {
                    wrapperProps.className += " draggable";
                    wrapperProps.onMouseDown = wrapperProps.onTouchStart = this.handleMouseDown;
                }
                if (this.state.dragging) {
                    wrapperProps.style = this.dragPos;
                    wrapperProps.className += " dragging";
                }
                if (this.props.onUnitClick) {
                    wrapperProps.onClick = this.handleClick;
                }
                if (this.props.facesLeft) {
                    wrapperProps.className += " enemy-unit";
                }
                else {
                    wrapperProps.className += " friendly-unit";
                }
                var isActiveUnit = (this.props.activeUnit &&
                    unit.id === this.props.activeUnit.id);
                if (isActiveUnit) {
                    wrapperProps.className += " active-unit";
                }
                var isInPotentialTargetArea = (this.props.targetsInPotentialArea &&
                    this.props.targetsInPotentialArea.indexOf(unit) >= 0);
                if (isInPotentialTargetArea) {
                    wrapperProps.className += " target-unit";
                }
                if (this.props.hoveredUnit && this.props.hoveredUnit.id === unit.id) {
                    wrapperProps.className += " hovered-unit";
                }
                var hoveredActionPointExpenditure = 0;
                if (isActiveUnit && this.props.hoveredAbility) {
                    hoveredActionPointExpenditure = this.props.hoveredAbility.actionsUse;
                }
                var infoProps = {
                    key: "info",
                    name: unit.name,
                    guardAmount: unit.battleStats.guardAmount,
                    guardCoverage: unit.battleStats.guardCoverage,
                    isPreparing: unit.battleStats.queuedAction,
                    maxHealth: unit.maxHealth,
                    currentHealth: unit.currentHealth,
                    isSquadron: unit.isSquadron,
                    maxActionPoints: unit.attributes.maxActionPoints,
                    currentActionPoints: unit.battleStats.currentActionPoints,
                    hoveredActionPointExpenditure: hoveredActionPointExpenditure,
                    isDead: this.props.isDead,
                    isCaptured: this.props.isCaptured,
                    animateDuration: unit.sfxDuration
                };
                var containerElements = [
                    React.DOM.div({
                        className: "unit-left-container",
                        key: "leftContainer"
                    }, UIComponents.UnitPortrait({
                        imageSrc: (unit.portrait ? unit.portrait.imageSrc : "")
                    }), UIComponents.UnitStatusEffects({
                        unit: unit,
                        isBattlePrep: !this.props.battle
                    })),
                    UIComponents.UnitInfo(infoProps),
                ];
                if (this.props.facesLeft) {
                    containerElements = containerElements.reverse();
                }
                if (unit.displayFlags.isAnnihilated) {
                    containerElements.push(React.DOM.div({ key: "overlay", className: "unit-annihilated-overlay" }, "Unit annihilated"));
                }
                var allElements = [
                    React.DOM.div(containerProps, containerElements),
                    UIComponents.UnitIcon({
                        icon: unit.template.icon,
                        facesLeft: this.props.facesLeft,
                        key: "icon",
                        isActiveUnit: isActiveUnit,
                        isAnnihilated: unit.displayFlags.isAnnihilated
                    })
                ];
                if (this.props.facesLeft) {
                    allElements = allElements.reverse();
                }
                return (React.DOM.div(wrapperProps, allElements));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.EmptyUnit = React.createClass({
            displayName: "EmptyUnit",
            shouldComponentUpdate: function (newProps) {
                return newProps.facesLeft === this.props.facesLeft;
            },
            render: function () {
                var wrapperProps = {
                    className: "unit empty-unit"
                };
                var containerProps = {
                    className: "unit-container",
                    key: "container"
                };
                if (this.props.facesLeft) {
                    wrapperProps.className += " enemy-unit";
                }
                else {
                    wrapperProps.className += " friendly-unit";
                }
                var allElements = [
                    React.DOM.div(containerProps, null),
                    UIComponents.UnitIcon({
                        icon: null,
                        facesLeft: this.props.facesLeft,
                        key: "icon"
                    })
                ];
                if (this.props.facesLeft) {
                    allElements = allElements.reverse();
                }
                return (React.DOM.div(wrapperProps, allElements));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
// used to register event listeners for manually firing drop events because touch events suck
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.DropTarget = {
            componentDidMount: function () {
                if (!this.handleMouseUp)
                    console.warn("No mouseUp handler on drop target", this);
                Rance.eventManager.addEventListener("drop" + this._rootNodeID, this.handleMouseUp);
            },
            componentWillUnmount: function () {
                Rance.eventManager.removeEventListener("drop" + this._rootNodeID, this.handleMouseUp);
            }
        };
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../mixins/droptarget.ts"/>
/// <reference path="uniticon.ts"/>
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.UnitWrapper = React.createClass({
            displayName: "UnitWrapper",
            mixins: [UIComponents.DropTarget],
            shouldComponentUpdate: function (newProps) {
                if (!this.props.unit && !newProps.unit)
                    return false;
                if (newProps.unit && newProps.unit.uiDisplayIsDirty)
                    return true;
                var targetedProps = {
                    activeUnit: true,
                    hoveredUnit: true,
                    targetsInPotentialArea: true,
                    activeEffectUnits: true
                };
                for (var prop in newProps) {
                    if (!targetedProps[prop] && prop !== "position") {
                        if (newProps[prop] !== this.props[prop]) {
                            return true;
                        }
                    }
                }
                for (var prop in targetedProps) {
                    var unit = newProps.unit;
                    var oldValue = this.props[prop];
                    var newValue = newProps[prop];
                    if (!newValue && !oldValue)
                        continue;
                    if (prop === "targetsInPotentialArea" || prop === "activeEffectUnits") {
                        if (!oldValue) {
                            if (newValue.indexOf(unit) >= 0)
                                return true;
                            else {
                                continue;
                            }
                        }
                        if ((oldValue.indexOf(unit) >= 0) !==
                            (newValue.indexOf(unit) >= 0)) {
                            return true;
                        }
                    }
                    else if (newValue !== oldValue &&
                        (oldValue === unit || newValue === unit)) {
                        return true;
                    }
                }
                if (newProps.battle && newProps.battle.ended) {
                    return true;
                }
                return false;
            },
            handleMouseUp: function () {
                console.log("unitMouseUp", this.props.position);
                this.props.onMouseUp(this.props.position);
            },
            render: function () {
                var allElements = [];
                var wrapperProps = {
                    className: "unit-wrapper drop-target"
                };
                if (this.props.onMouseUp) {
                    wrapperProps.onMouseUp = wrapperProps.onTouchEnd = this.handleMouseUp;
                }
                ;
                if (this.props.activeEffectUnits) {
                    if (this.props.activeEffectUnits.indexOf(this.props.unit) >= 0) {
                        wrapperProps.className += " active-effect-unit";
                    }
                }
                var empty = UIComponents.EmptyUnit({
                    facesLeft: this.props.facesLeft,
                    key: "empty_" + this.props.key,
                    position: this.props.position
                });
                allElements.push(empty);
                if (this.props.unit) {
                    var isDead = false;
                    if (this.props.battle &&
                        this.props.battle.deadUnits && this.props.battle.deadUnits.length > 0) {
                        if (this.props.battle.deadUnits.indexOf(this.props.unit) >= 0) {
                            this.props.isDead = true;
                        }
                    }
                    var isCaptured = false;
                    if (this.props.battle &&
                        this.props.battle.capturedUnits && this.props.battle.capturedUnits.length > 0) {
                        if (this.props.battle.capturedUnits.indexOf(this.props.unit) >= 0) {
                            this.props.isCaptured = true;
                        }
                    }
                    var unit = UIComponents.Unit(this.props);
                    allElements.push(unit);
                }
                return (React.DOM.div(wrapperProps, allElements));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../../unit.ts" />
/// <reference path="../../battle.ts" />
/// <reference path="../unit/unit.ts"/>
/// <reference path="../unit/emptyunit.ts"/>
/// <reference path="../unit/unitwrapper.ts"/>
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.FormationRow = React.createClass({
            displayName: "FormationRow",
            propTypes: {
                row: React.PropTypes.arrayOf(React.PropTypes.instanceOf(Rance.Unit)).isRequired,
                rowIndexInOwnFormation: React.PropTypes.number.isRequired,
                battle: React.PropTypes.instanceOf(Rance.Battle),
                facesLeft: React.PropTypes.bool.isRequired,
                activeUnit: React.PropTypes.instanceOf(Rance.Unit),
                activeTargets: React.PropTypes.object,
                hoveredUnit: React.PropTypes.instanceOf(Rance.Unit),
                hoveredAbility: React.PropTypes.object,
                handleMouseLeaveUnit: React.PropTypes.func,
                handleMouseEnterUnit: React.PropTypes.func,
                targetsInPotentialArea: React.PropTypes.arrayOf(React.PropTypes.instanceOf(Rance.Unit)),
                activeEffectUnits: React.PropTypes.arrayOf(React.PropTypes.instanceOf(Rance.Unit)),
                onMouseUp: React.PropTypes.func,
                onUnitClick: React.PropTypes.func,
                isDraggable: React.PropTypes.bool,
                onDragStart: React.PropTypes.func,
                onDragEnd: React.PropTypes.func
            },
            render: function () {
                var row = this.props.row;
                var side = this.props.facesLeft ? "side2" : "side1";
                var absoluteRowIndex = side === "side1" ?
                    this.props.rowIndexInOwnFormation :
                    this.props.rowIndexInOwnFormation + app.moduleData.ruleSet.battle.rowsPerFormation;
                var units = [];
                for (var i = 0; i < row.length; i++) {
                    var data = {};
                    data.key = i;
                    data.unit = row[i];
                    data.position = [absoluteRowIndex, i];
                    data.battle = this.props.battle;
                    data.facesLeft = this.props.facesLeft;
                    data.activeUnit = this.props.activeUnit;
                    data.activeTargets = this.props.activeTargets;
                    data.hoveredUnit = this.props.hoveredUnit;
                    data.hoveredAbility = this.props.hoveredAbility;
                    data.handleMouseLeaveUnit = this.props.handleMouseLeaveUnit;
                    data.handleMouseEnterUnit = this.props.handleMouseEnterUnit;
                    data.targetsInPotentialArea = this.props.targetsInPotentialArea;
                    data.activeEffectUnits = this.props.activeEffectUnits;
                    data.onMouseUp = this.props.onMouseUp;
                    data.onUnitClick = this.props.onUnitClick;
                    data.isDraggable = this.props.isDraggable;
                    data.onDragStart = this.props.onDragStart;
                    data.onDragEnd = this.props.onDragEnd;
                    units.push(UIComponents.UnitWrapper(data));
                }
                return (React.DOM.div({ className: "battle-formation-row" }, units));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../../unit.ts" />
/// <reference path="../../battle.ts" />
/// <reference path="formationrow.ts"/>
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.Formation = React.createClass({
            displayName: "Formation",
            propTypes: {
                formation: React.PropTypes.arrayOf(React.PropTypes.arrayOf(React.PropTypes.instanceOf(Rance.Unit))).isRequired,
                battle: React.PropTypes.instanceOf(Rance.Battle),
                facesLeft: React.PropTypes.bool.isRequired,
                activeUnit: React.PropTypes.instanceOf(Rance.Unit),
                activeTargets: React.PropTypes.object,
                hoveredUnit: React.PropTypes.instanceOf(Rance.Unit),
                hoveredAbility: React.PropTypes.object,
                handleMouseLeaveUnit: React.PropTypes.func,
                handleMouseEnterUnit: React.PropTypes.func,
                targetsInPotentialArea: React.PropTypes.arrayOf(React.PropTypes.instanceOf(Rance.Unit)),
                activeEffectUnits: React.PropTypes.arrayOf(React.PropTypes.instanceOf(Rance.Unit)),
                onMouseUp: React.PropTypes.func,
                onUnitClick: React.PropTypes.func,
                isDraggable: React.PropTypes.bool,
                onDragStart: React.PropTypes.func,
                onDragEnd: React.PropTypes.func
            },
            render: function () {
                var formation = this.props.formation;
                var formationRows = [];
                for (var i = 0; i < formation.length; i++) {
                    formationRows.push(UIComponents.FormationRow({
                        key: i,
                        row: formation[i],
                        rowIndexInOwnFormation: i,
                        battle: this.props.battle,
                        facesLeft: this.props.facesLeft,
                        activeUnit: this.props.activeUnit,
                        hoveredUnit: this.props.hoveredUnit,
                        hoveredAbility: this.props.hoveredAbility,
                        handleMouseEnterUnit: this.props.handleMouseEnterUnit,
                        handleMouseLeaveUnit: this.props.handleMouseLeaveUnit,
                        targetsInPotentialArea: this.props.targetsInPotentialArea,
                        activeEffectUnits: this.props.activeEffectUnits,
                        onMouseUp: this.props.onMouseUp,
                        onUnitClick: this.props.onUnitClick,
                        isDraggable: this.props.isDraggable,
                        onDragStart: this.props.onDragStart,
                        onDragEnd: this.props.onDragEnd
                    }));
                }
                return (React.DOM.div({ className: "battle-formation" }, formationRows));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.TurnCounter = React.createClass({
            displayName: "TurnCounter",
            mixins: [React.addons.PureRenderMixin],
            render: function () {
                var turnsLeft = this.props.turnsLeft;
                var turns = [];
                var usedTurns = this.props.maxTurns - turnsLeft;
                for (var i = 0; i < usedTurns; i++) {
                    turns.push(React.DOM.div({
                        key: "used" + i,
                        className: "turn-counter used-turn"
                    }));
                }
                for (var i = 0; i < turnsLeft; i++) {
                    turns.push(React.DOM.div({
                        key: "available" + i,
                        className: "turn-counter available-turn"
                    }));
                }
                return (React.DOM.div({
                    className: "turns-container",
                    title: "Turns left: " + turnsLeft
                }, turns));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.TurnOrder = React.createClass({
            displayName: "TurnOrder",
            getInitialState: function () {
                return ({
                    maxUnits: 7
                });
            },
            componentDidMount: function () {
                this.setMaxUnits();
                window.addEventListener("resize", this.setMaxUnits);
            },
            componentWillUnmount: function () {
                window.removeEventListener("resize", this.setMaxUnits);
            },
            setMaxUnits: function () {
                var minUnits = 7;
                var containerElement = this.getDOMNode();
                var containerWidth = containerElement.getBoundingClientRect().width;
                containerWidth -= 30;
                var unitElementWidth = 160;
                var ceil = Math.ceil(containerWidth / unitElementWidth);
                this.setState({
                    maxUnits: Math.max(ceil, minUnits)
                });
            },
            render: function () {
                var maxUnits = this.state.maxUnits;
                var turnOrder = this.props.turnOrder.slice(0);
                if (this.props.potentialDelay) {
                    var fake = {
                        isFake: true,
                        id: this.props.potentialDelay.id,
                        battleStats: {
                            moveDelay: this.props.potentialDelay.delay
                        }
                    };
                    turnOrder.push(fake);
                    turnOrder.sort(Rance.turnOrderSortFunction);
                }
                var maxUnitsWithFake = maxUnits;
                if (fake && turnOrder.indexOf(fake) <= maxUnits) {
                    maxUnitsWithFake++;
                }
                turnOrder = turnOrder.slice(0, maxUnitsWithFake);
                var toRender = [];
                for (var i = 0; i < turnOrder.length; i++) {
                    var unit = turnOrder[i];
                    if (unit.isFake) {
                        toRender.push(React.DOM.div({
                            className: "turn-order-arrow",
                            key: "" + i
                        }));
                        continue;
                    }
                    var data = {
                        key: "" + i,
                        className: "turn-order-unit",
                        title: "delay: " + unit.battleStats.moveDelay + "\n" +
                            "speed: " + unit.attributes.speed,
                        onMouseEnter: this.props.onMouseEnterUnit.bind(null, unit),
                        onMouseLeave: this.props.onMouseLeaveUnit
                    };
                    if (this.props.unitsBySide.side1.indexOf(unit) > -1) {
                        data.className += " turn-order-unit-friendly";
                    }
                    else if (this.props.unitsBySide.side2.indexOf(unit) > -1) {
                        data.className += " turn-order-unit-enemy";
                    }
                    if (this.props.hoveredUnit && unit.id === this.props.hoveredUnit.id) {
                        data.className += " turn-order-unit-hover";
                    }
                    toRender.push(React.DOM.div(data, unit.name));
                }
                if (this.props.turnOrder.length > maxUnits) {
                    toRender.push(React.DOM.div({
                        className: "turn-order-more",
                        key: "more"
                    }, "..."));
                }
                return (React.DOM.div({ className: "turn-order-container" }, toRender));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.AbilityTooltip = React.createClass({
            displayName: "AbilityTooltip",
            shouldComponentUpdate: function (newProps) {
                for (var prop in newProps) {
                    if (prop !== "activeTargets") {
                        if (this.props[prop] !== newProps[prop]) {
                            return true;
                        }
                    }
                }
                return false;
            },
            render: function () {
                var abilities = this.props.activeTargets[this.props.targetUnit.id];
                var abilityElements = [];
                var containerProps = {
                    className: "ability-tooltip",
                    onMouseLeave: this.props.handleMouseLeave
                };
                var parentRect = this.props.parentElement.getBoundingClientRect();
                containerProps.style =
                    {
                        position: "fixed",
                        top: parentRect.top
                    };
                if (this.props.facesLeft) {
                    containerProps.className += " ability-tooltip-faces-left";
                    containerProps.style.left = parentRect.left;
                }
                else {
                    containerProps.className += " ability-tooltip-faces-right";
                    // aligning right to right doesnt work for some reason
                    containerProps.style.left = parentRect.right - 128;
                }
                for (var i = 0; i < abilities.length; i++) {
                    var ability = abilities[i];
                    var data = {};
                    data.className = "ability-tooltip-ability";
                    data.key = i;
                    data.onClick = this.props.handleAbilityUse.bind(null, ability, this.props.targetUnit);
                    data.onMouseEnter = this.props.handleMouseEnterAbility.bind(null, ability);
                    data.onMouseLeave = this.props.handleMouseLeaveAbility;
                    if (ability.description) {
                        data.title = ability.description;
                    }
                    abilityElements.push(React.DOM.div(data, ability.displayName));
                }
                return (React.DOM.div(containerProps, abilityElements));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../../flag.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.BattleSceneFlag = React.createClass({
            displayName: "BattleSceneFlag",
            flagCanvas: null,
            propTypes: {
                flag: React.PropTypes.instanceOf(Rance.Flag).isRequired,
                facingRight: React.PropTypes.bool.isRequired
            },
            componentDidMount: function () {
                this.setFlag();
                window.addEventListener("resize", this.handleResize, false);
            },
            componentWillUnmount: function () {
                window.removeEventListener("resize", this.handleResize);
            },
            handleResize: function () {
                this.setFlag();
            },
            setFlag: function () {
                var DOMNode = this.getDOMNode();
                if (this.flagCanvas) {
                    DOMNode.removeChild(this.flagCanvas);
                }
                this.flagCanvas = this.drawFlag();
                this.getDOMNode().appendChild(this.flagCanvas);
            },
            drawFlag: function () {
                var bounds = this.getDOMNode().getBoundingClientRect();
                var width = bounds.width;
                var canvas = this.props.flag.getCanvas(width, bounds.height, true, false);
                var context = canvas.getContext("2d");
                context.globalCompositeOperation = "destination-out";
                var gradient;
                if (this.props.facingRight) {
                    gradient = context.createLinearGradient(0, 0, width, 0);
                }
                else {
                    gradient = context.createLinearGradient(width, 0, 0, 0);
                }
                gradient.addColorStop(0.0, "rgba(255, 255, 255, 0.3)");
                gradient.addColorStop(0.6, "rgba(255, 255, 255, 0.5)");
                gradient.addColorStop(0.8, "rgba(255, 255, 255, 0.8)");
                gradient.addColorStop(1.0, "rgba(255, 255, 255, 1.0)");
                context.fillStyle = gradient;
                context.fillRect(0, 0, width, bounds.height);
                canvas.classList.add("battle-scene-start-player-flag");
                return canvas;
            },
            render: function () {
                return (React.DOM.div({
                    className: "battle-scene-flag-container"
                }, null));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../../player.ts" />
/// <reference path="../../unit.ts" />
/// <reference path="battlesceneflag.ts" />
var bs;
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.BattleScene = React.createClass({
            displayName: "BattleScene",
            battleScene: null,
            propTypes: {
                battleState: React.PropTypes.string.isRequired,
                targetUnit: React.PropTypes.instanceOf(Rance.Unit),
                userUnit: React.PropTypes.instanceOf(Rance.Unit),
                activeUnit: React.PropTypes.instanceOf(Rance.Unit),
                hoveredUnit: React.PropTypes.instanceOf(Rance.Unit),
                activeSFX: React.PropTypes.object,
                afterAbilityFinishedCallback: React.PropTypes.func,
                triggerEffectCallback: React.PropTypes.func,
                humanPlayerWonBattle: React.PropTypes.bool,
                side1Player: React.PropTypes.instanceOf(Rance.Player),
                side2Player: React.PropTypes.instanceOf(Rance.Player)
            },
            shouldComponentUpdate: function (newProps) {
                var shouldTriggerUpdate = {
                    battleState: true
                };
                for (var key in newProps) {
                    if (shouldTriggerUpdate[key] && newProps[key] !== this.props[key]) {
                        return true;
                    }
                }
                return false;
            },
            componentWillReceiveProps: function (newProps) {
                bs = this;
                var self = this;
                if (this.props.battleState === "start" && newProps.battleState === "active") {
                    this.battleScene = new Rance.BattleScene(this.getDOMNode());
                    this.battleScene.resume();
                }
                else if (this.props.battleState === "active" && newProps.battleState === "finish") {
                    this.battleScene.destroy();
                    this.battleScene = null;
                }
                var battleScene = this.battleScene;
                if (battleScene) {
                    var activeSFXChanged = newProps.activeSFX !== this.props.activeSFX;
                    var shouldPlaySFX = Boolean(newProps.activeSFX &&
                        (activeSFXChanged ||
                            newProps.targetUnit !== this.props.targetUnit ||
                            newProps.userUnit !== this.props.userUnit));
                    if (shouldPlaySFX) {
                        battleScene.handleAbilityUse({
                            user: newProps.userUnit,
                            target: newProps.targetUnit,
                            SFXTemplate: newProps.activeSFX,
                            afterFinishedCallback: newProps.afterAbilityFinishedCallback,
                            triggerEffectCallback: newProps.triggerEffectCallback
                        });
                    }
                    else if (activeSFXChanged) {
                        battleScene.clearActiveSFX();
                    }
                    var unitsHaveUpdated = false;
                    [
                        "targetUnit",
                        "userUnit",
                        "activeUnit",
                        "hoveredUnit"
                    ].forEach(function (unitKey) {
                        if (battleScene[unitKey] !== newProps[unitKey]) {
                            unitsHaveUpdated = true;
                        }
                        battleScene[unitKey] = newProps[unitKey];
                    });
                    if (unitsHaveUpdated && !shouldPlaySFX && !newProps.activeSFX) {
                        battleScene.updateUnits();
                    }
                }
            },
            render: function () {
                var componentToRender;
                switch (this.props.battleState) {
                    case "start":
                        {
                            componentToRender = React.DOM.div({
                                className: "battle-scene-flags-container"
                            }, UIComponents.BattleSceneFlag({
                                flag: this.props.side1Player.flag,
                                facingRight: true
                            }), UIComponents.BattleSceneFlag({
                                flag: this.props.side2Player.flag,
                                facingRight: false
                            }));
                            break;
                        }
                    case "active":
                        {
                            componentToRender = null;
                            break;
                        }
                    case "finish":
                        {
                            componentToRender = React.DOM.div({
                                className: "battle-scene-finish-container"
                            }, React.DOM.h1({
                                className: "battle-scene-finish-header"
                            }, this.props.humanPlayerWonBattle ? "You win" : "You lose"), React.DOM.h3({
                                className: "battle-scene-finish-subheader"
                            }, "Click to continue"));
                            break;
                        }
                }
                return (React.DOM.div({
                    className: "battle-scene"
                }, componentToRender));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.PlayerFlag = React.createClass({
            displayName: "PlayerFlag",
            mixins: [React.addons.PureRenderMixin],
            canUseDataURL: function () {
                var uaString = navigator.userAgent.toLowerCase();
                var isIE = uaString.indexOf("msie") !== -1 || uaString.indexOf("trident/") !== -1;
                return !isIE;
            },
            componentDidMount: function () {
                if (this.refs.container && !this.props.isMutable) {
                    var canvas = this.props.flag.getCanvas(this.props.width, this.props.height, this.props.stretch, false);
                    canvas.style.maxWidth = "100%";
                    canvas.style.maxHeight = "100%";
                    this.refs.container.getDOMNode().appendChild(canvas);
                }
            },
            componentDidUpdate: function () {
                if (this.refs.container && this.props.isMutable) {
                    var containerNode = this.refs.container.getDOMNode();
                    if (containerNode.firstChild) {
                        containerNode.removeChild(containerNode.firstChild);
                    }
                    var canvas = this.props.flag.getCanvas(this.props.width, this.props.height, this.props.stretch, false);
                    canvas.style.maxWidth = "100%";
                    canvas.style.maxHeight = "100%";
                    containerNode.appendChild(canvas);
                }
            },
            render: function () {
                var props = this.props.props;
                if (this.canUseDataURL()) {
                    var flag = this.props.flag;
                    props.src = flag.getCanvas(this.props.width, this.props.height, this.props.stretch, !this.props.isMutable).toDataURL();
                    return (React.DOM.img(props, null));
                }
                else {
                    props.ref = "container";
                    return (React.DOM.div(props, null));
                }
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../playerflag.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.BattleScore = React.createClass({
            displayName: "BattleScore",
            lastEvaluation: undefined,
            shouldComponentUpdate: function (newProps) {
                var oldEvaluation = this.lastEvaluation;
                this.lastEvaluation = newProps.battle.getEvaluation();
                return this.lastEvaluation !== oldEvaluation;
            },
            componentWillMount: function () {
                this.lastEvaluation = this.props.battle.getEvaluation();
            },
            render: function () {
                var battle = this.props.battle;
                var evaluation = this.lastEvaluation;
                var evaluationPercentage = 50 + evaluation * 50;
                return (React.DOM.div({
                    className: "battle-score-wrapper"
                }, React.DOM.div({
                    className: "battle-score-container"
                }, React.DOM.img({
                    className: "battle-score-mid-point",
                    src: "img\/icons\/battleScoreMidPoint.png"
                }, null), UIComponents.PlayerFlag({
                    props: {
                        className: "battle-score-flag"
                    },
                    flag: battle.side1Player.flag
                }), React.DOM.div({
                    className: "battle-score-bar-container"
                }, React.DOM.div({
                    className: "battle-score-bar-value battle-score-bar-side1",
                    style: {
                        width: "" + evaluationPercentage + "%",
                        backgroundColor: "#" + Rance.hexToString(battle.side1Player.color),
                        borderColor: "#" + Rance.hexToString(battle.side1Player.secondaryColor)
                    }
                }), React.DOM.div({
                    className: "battle-score-bar-value battle-score-bar-side2",
                    style: {
                        width: "" + (100 - evaluationPercentage) + "%",
                        backgroundColor: "#" + Rance.hexToString(battle.side2Player.color),
                        borderColor: "#" + Rance.hexToString(battle.side2Player.secondaryColor)
                    }
                })), UIComponents.PlayerFlag({
                    props: {
                        className: "battle-score-flag"
                    },
                    flag: battle.side2Player.flag
                }))));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.BattleDisplayStrength = React.createClass({
            displayName: "BattleDisplayStrength",
            getInitialState: function () {
                return ({
                    displayedStrength: this.props.from,
                    activeTween: null
                });
            },
            componentDidMount: function () {
                this.animateDisplayedStrength(this.props.from, this.props.to, this.props.delay);
            },
            componentWillUnmount: function () {
                if (this.activeTween) {
                    this.activeTween.stop();
                }
            },
            updateDisplayStrength: function (newAmount) {
                this.setState({
                    displayedStrength: newAmount
                });
            },
            animateDisplayedStrength: function (from, newAmount, time) {
                var self = this;
                var stopped = false;
                if (this.activeTween) {
                    this.activeTween.stop();
                }
                if (from === newAmount)
                    return;
                var animateTween = function () {
                    if (stopped) {
                        return;
                    }
                    TWEEN.update();
                    self.requestAnimFrame = window.requestAnimationFrame(animateTween);
                };
                var tween = new TWEEN.Tween({
                    health: from
                }).to({
                    health: newAmount
                }, time).onUpdate(function () {
                    self.setState({
                        displayedStrength: this.health
                    });
                }).easing(TWEEN.Easing.Sinusoidal.Out);
                tween.onStop(function () {
                    cancelAnimationFrame(self.requestAnimFrame);
                    stopped = true;
                    TWEEN.remove(tween);
                });
                this.activeTween = tween;
                tween.start();
                animateTween();
            },
            render: function () {
                return (React.DOM.div({ className: "unit-strength-battle-display" }, Math.ceil(this.state.displayedStrength)));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        /*
        props
    
          renderer
          backgroundSeed
          getBlurAreaFN()
         */
        UIComponents.BattleBackground = React.createClass({
            displayName: "BattleBackground",
            handleResize: function () {
                // TODO this seems to trigger before any breakpoints, leading to 1 px immediately after
                // breakpoint where blurArea isnt correctly determined
                var blurArea = this.props.getBlurArea();
                this.props.renderer.blurProps =
                    [
                        blurArea.left,
                        blurArea.top,
                        blurArea.width,
                        blurArea.height,
                        this.props.backgroundSeed
                    ];
            },
            componentDidMount: function () {
                this.props.renderer.isBattleBackground = true;
                this.handleResize();
                this.props.renderer.bindRendererView(this.refs.pixiContainer.getDOMNode());
                window.addEventListener("resize", this.handleResize, false);
            },
            componentWillUnmount: function () {
                window.removeEventListener("resize", this.handleResize);
                this.props.renderer.removeRendererView();
            },
            render: function () {
                return (React.DOM.div({
                    className: "battle-pixi-container",
                    ref: "pixiContainer"
                }, this.props.children));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="formation.ts"/>
/// <reference path="turncounter.ts"/>
/// <reference path="turnorder.ts"/>
/// <reference path="abilitytooltip.ts"/>
/// <reference path="battlescene.ts"/>
/// <reference path="battlescore.ts"/>
/// <reference path="battledisplaystrength.ts"/>
/// <reference path="battlebackground.ts"/>
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        // TODO refactor
        // should have separate non-react class for battle logic
        UIComponents.Battle = React.createClass({
            displayName: "Battle",
            // set as a property of the class instead of its state
            // as its not used for trigger updates
            // and needs to be changed synchronously
            tempHoveredUnit: null,
            idGenerator: 0,
            MCTree: null,
            battleStartStartTime: undefined,
            battleEndStartTime: undefined,
            getInitialState: function () {
                return ({
                    abilityTooltip: {
                        parentElement: null,
                        facesLeft: null
                    },
                    targetsInPotentialArea: [],
                    potentialDelay: null,
                    hoveredAbility: null,
                    targetUnit: null,
                    userUnit: null,
                    activeUnit: null,
                    hoveredUnit: null,
                    highlightedUnit: null,
                    battleSceneUnit1StartingStrength: null,
                    battleSceneUnit2StartingStrength: null,
                    battleSceneUnit1: null,
                    battleSceneUnit2: null,
                    playingBattleEffect: false,
                    battleEffectId: undefined,
                    battleEffectDuration: null,
                    battleEffectSFX: null,
                    afterAbilityFinishedCallback: null,
                    triggerEffectCallback: null,
                    battleIsStarting: true
                });
            },
            componentDidMount: function () {
                this.battleStartStartTime = Date.now();
            },
            endBattleStart: function () {
                if (Date.now() < this.battleStartStartTime + 1000)
                    return;
                this.setState({
                    battleIsStarting: false
                }, this.setBattleSceneUnits(this.state.hoveredUnit));
                if (this.props.battle.getActivePlayer() !== this.props.humanPlayer) {
                    this.useAIAbility();
                }
            },
            getBlurArea: function () {
                return this.refs.formationsContainer.getDOMNode().getBoundingClientRect();
            },
            clearHoveredUnit: function () {
                this.tempHoveredUnit = null;
                this.setState({
                    hoveredUnit: null,
                    highlightedUnit: null,
                    abilityTooltip: {
                        parentElement: null
                    },
                    hoveredAbility: null,
                    potentialDelay: null,
                    targetsInPotentialArea: []
                });
                this.setBattleSceneUnits(null);
            },
            handleMouseLeaveUnit: function (e) {
                if (!this.state.hoveredUnit || this.state.playingBattleEffect) {
                    this.tempHoveredUnit = null;
                    return;
                }
                var nativeEvent = e.nativeEvent;
                var toElement = nativeEvent.toElement || nativeEvent.relatedTarget;
                if (!toElement) {
                    this.clearHoveredUnit();
                    return;
                }
                if (!this.refs.abilityTooltip) {
                    this.clearHoveredUnit();
                    return;
                }
                var tooltipElement = this.refs.abilityTooltip.getDOMNode();
                if (toElement !== this.state.abilityTooltip.parentElement &&
                    (this.refs.abilityTooltip && toElement !== tooltipElement) &&
                    toElement.parentElement !== tooltipElement) {
                    this.clearHoveredUnit();
                }
            },
            handleMouseEnterUnit: function (unit) {
                this.tempHoveredUnit = unit;
                if (this.props.battle.ended || this.state.playingBattleEffect)
                    return;
                var facesLeft = unit.battleStats.side === "side2";
                var parentElement = this.getUnitElement(unit);
                this.setState({
                    abilityTooltip: {
                        parentElement: parentElement,
                        facesLeft: facesLeft
                    },
                    hoveredUnit: unit,
                    highlightedUnit: unit
                });
                this.setBattleSceneUnits(unit);
            },
            getUnitElement: function (unit) {
                return document.getElementById("unit-id_" + unit.id);
            },
            setBattleSceneUnits: function (hoveredUnit) {
                if (this.state.playingBattleEffect)
                    return;
                var activeUnit = this.props.battle.activeUnit;
                if (!activeUnit) {
                    this.setState({
                        battleSceneUnit1: null,
                        battleSceneUnit2: null
                    });
                    return;
                }
                var shouldDisplayHovered = (hoveredUnit &&
                    hoveredUnit.battleStats.side !== activeUnit.battleStats.side);
                var unit1, unit2;
                if (activeUnit.battleStats.side === "side1") {
                    unit1 = activeUnit;
                    unit2 = shouldDisplayHovered ? hoveredUnit : null;
                }
                else {
                    unit1 = shouldDisplayHovered ? hoveredUnit : null;
                    unit2 = activeUnit;
                }
                this.setState({
                    battleSceneUnit1: unit1,
                    battleSceneUnit2: unit2
                });
            },
            handleAbilityUse: function (ability, target, wasByPlayer) {
                var abilityData = Rance.getAbilityUseData(this.props.battle, this.props.battle.activeUnit, ability, target);
                for (var i = 0; i < abilityData.beforeUse.length; i++) {
                    abilityData.beforeUse[i]();
                }
                this.playBattleEffect(abilityData, 0);
                if (wasByPlayer && this.MCTree) {
                    this.MCTree.advanceMove({
                        ability: ability,
                        targetId: "" + abilityData.actualTarget.id
                    });
                }
            },
            // TODO battleSFX
            // need to either force BattleScene to play animation as soon as it starts
            // or have this wait for battle scene units to finish animating.
            // battleSFX animation can trigger at the earliest after animationTiming.unitEnter, but
            // actual effect always gets triggered after animationTiming.beforeUse
            playBattleEffect: function (abilityData, i) {
                var self = this;
                var effectData = abilityData.effectsToCall;
                if (!effectData[i]) {
                    for (var i = 0; i < abilityData.afterUse.length; i++) {
                        abilityData.afterUse[i]();
                    }
                    this.clearBattleEffect(abilityData);
                    this.handleTurnEnd();
                    return;
                }
                ;
                effectData[i].user.sfxDuration = null;
                effectData[i].target.sfxDuration = null;
                if (effectData[i].trigger && !effectData[i].trigger(effectData[i].user, effectData[i].target)) {
                    return this.playBattleEffect(abilityData, i + 1);
                }
                var side1Unit = null;
                var side2Unit = null;
                [effectData[i].user, effectData[i].target].forEach(function (unit) {
                    if (unit.battleStats.side === "side1" && !side1Unit) {
                        side1Unit = unit;
                    }
                    else if (unit.battleStats.side === "side2" && !side2Unit) {
                        side2Unit = unit;
                    }
                });
                var previousUnit1Strength = side1Unit ? side1Unit.currentHealth : null;
                var previousUnit2Strength = side2Unit ? side2Unit.currentHealth : null;
                var hasSFX = effectData[i].sfx;
                var shouldDeferCallingEffects = false;
                var effectDuration = 0;
                if (hasSFX) {
                    effectDuration = effectData[i].sfx.duration * Rance.Options.battleAnimationTiming.effectDuration;
                    shouldDeferCallingEffects = Boolean(effectData[i].sfx.SFXWillTriggerEffect);
                }
                effectData[i].user.sfxDuration = effectDuration;
                effectData[i].target.sfxDuration = effectDuration;
                var finishEffectFN = this.playBattleEffect.bind(this, abilityData, i + 1);
                var callEffectsFN = function (forceUpdate) {
                    if (forceUpdate === void 0) { forceUpdate = true; }
                    for (var j = 0; j < effectData[i].effects.length; j++) {
                        effectData[i].effects[j]();
                    }
                    if (forceUpdate) {
                        self.forceUpdate();
                    }
                };
                if (!shouldDeferCallingEffects) {
                    callEffectsFN(false);
                }
                this.setState({
                    battleSceneUnit1StartingStrength: previousUnit1Strength,
                    battleSceneUnit2StartingStrength: previousUnit2Strength,
                    battleSceneUnit1: side1Unit,
                    battleSceneUnit2: side2Unit,
                    playingBattleEffect: true,
                    hoveredUnit: null,
                    highlightedUnit: abilityData.originalTarget,
                    userUnit: effectData[i].user,
                    targetUnit: effectData[i].target,
                    battleEffectId: hasSFX ? this.idGenerator++ : null,
                    battleEffectDuration: effectDuration,
                    battleEffectSFX: effectData[i].sfx,
                    afterAbilityFinishedCallback: finishEffectFN,
                    triggerEffectCallback: callEffectsFN,
                    abilityTooltip: {
                        parentElement: null
                    },
                    hoveredAbility: null,
                    potentialDelay: null,
                    targetsInPotentialArea: []
                });
            },
            clearBattleEffect: function () {
                var newHoveredUnit = null;
                if (this.tempHoveredUnit && this.tempHoveredUnit.isActiveInBattle()) {
                    newHoveredUnit = this.tempHoveredUnit;
                    this.tempHoveredUnit = null;
                }
                var afterStateUpdateCallback = newHoveredUnit ?
                    this.handleMouseEnterUnit.bind(this, newHoveredUnit) : this.clearHoveredUnit;
                this.setState({
                    playingBattleEffect: false,
                    battleEffectId: undefined,
                    battleEffectDuration: null,
                    battleEffectSFX: null,
                    afterAbilityFinishedCallback: null,
                    triggerEffectCallback: null,
                    hoveredUnit: null,
                    highlightedUnit: null,
                    targetUnit: null,
                    userUnit: null
                }, afterStateUpdateCallback);
            },
            handleTurnEnd: function () {
                if (this.state.hoveredUnit && this.state.hoveredUnit.isTargetable()) {
                    this.forceUpdate();
                }
                else {
                    this.clearHoveredUnit();
                }
                this.props.battle.endTurn();
                this.setBattleSceneUnits(this.state.hoveredUnit);
                if (this.props.battle.activeUnit && this.props.battle.activeUnit.battleStats.queuedAction) {
                    this.usePreparedAbility();
                }
                else if (this.props.battle.getActivePlayer() !== this.props.humanPlayer) {
                    this.useAIAbility();
                }
            },
            usePreparedAbility: function () {
                var unit = this.props.battle.activeUnit;
                var action = unit.battleStats.queuedAction;
                var target = this.props.battle.unitsById[action.targetId];
                var userIsHuman = this.props.battle.getActivePlayer() === this.props.humanPlayer;
                this.handleAbilityUse(action.ability, target, userIsHuman);
            },
            usePlayerAbility: function (ability, target) {
                this.handleAbilityUse(ability, target, true);
            },
            useAIAbility: function () {
                if (!this.props.battle.activeUnit || this.props.battle.ended)
                    return;
                if (!this.MCTree)
                    this.MCTree = new Rance.MCTree(this.props.battle, this.props.battle.activeUnit.battleStats.side, false);
                var move = this.MCTree.getBestMoveAndAdvance(1000);
                var target = this.props.battle.unitsById[move.targetId];
                this.handleAbilityUse(move.ability, target, false);
            },
            finishBattle: function () {
                if (Date.now() < this.battleEndStartTime + 1000)
                    return;
                var battle = this.props.battle;
                if (!battle.ended)
                    throw new Error();
                battle.finishBattle();
            },
            handleMouseEnterAbility: function (ability) {
                var targetsInPotentialArea = Rance.getUnitsInAbilityArea(this.props.battle, this.props.battle.activeUnit, ability, this.state.hoveredUnit.battleStats.position);
                var abilityUseDelay = ability.preparation ?
                    ability.preparation.prepDelay * ability.preparation.turnsToPrep :
                    ability.moveDelay;
                this.setState({
                    hoveredAbility: ability,
                    potentialDelay: {
                        id: this.props.battle.activeUnit.id,
                        delay: this.props.battle.activeUnit.battleStats.moveDelay + abilityUseDelay
                    },
                    targetsInPotentialArea: targetsInPotentialArea
                });
            },
            handleMouseLeaveAbility: function () {
                this.setState({
                    hoveredAbility: null,
                    potentialDelay: null,
                    targetsInPotentialArea: []
                });
            },
            render: function () {
                var battle = this.props.battle;
                if (!battle.ended) {
                    var activeTargets = Rance.getTargetsForAllAbilities(battle, battle.activeUnit);
                }
                var abilityTooltip = null;
                if (!battle.ended &&
                    !this.state.playingBattleEffect &&
                    this.state.hoveredUnit &&
                    activeTargets[this.state.hoveredUnit.id]) {
                    abilityTooltip = UIComponents.AbilityTooltip({
                        handleAbilityUse: this.usePlayerAbility,
                        handleMouseLeave: this.handleMouseLeaveUnit,
                        handleMouseEnterAbility: this.handleMouseEnterAbility,
                        handleMouseLeaveAbility: this.handleMouseLeaveAbility,
                        activeUnit: battle.activeUnit,
                        targetUnit: this.state.hoveredUnit,
                        parentElement: this.state.abilityTooltip.parentElement,
                        facesLeft: this.state.abilityTooltip.facesLeft,
                        activeTargets: activeTargets,
                        ref: "abilityTooltip",
                        key: this.state.hoveredUnit.id
                    });
                }
                ;
                var activeEffectUnits = [];
                if (this.state.playingBattleEffect) {
                    activeEffectUnits = [this.state.battleSceneUnit1, this.state.battleSceneUnit2];
                }
                var upperFooterElement;
                if (this.state.battleIsStarting) {
                    upperFooterElement = null;
                }
                else if (!this.state.playingBattleEffect) {
                    upperFooterElement = UIComponents.TurnOrder({
                        key: "turnOrder",
                        turnOrder: battle.turnOrder,
                        unitsBySide: battle.unitsBySide,
                        potentialDelay: this.state.potentialDelay,
                        hoveredUnit: this.state.highlightedUnit,
                        onMouseEnterUnit: this.handleMouseEnterUnit,
                        onMouseLeaveUnit: this.handleMouseLeaveUnit
                    });
                }
                else {
                    upperFooterElement = React.DOM.div({
                        key: "battleDisplayStrength",
                        className: "battle-display-strength-container"
                    }, React.DOM.div({
                        className: "battle-display-strength battle-display-strength-side1"
                    }, this.state.battleSceneUnit1 ? UIComponents.BattleDisplayStrength({
                        key: "" + this.state.battleSceneUnit1.id + Date.now(),
                        delay: this.state.battleEffectDuration,
                        from: this.state.battleSceneUnit1StartingStrength,
                        to: this.state.battleSceneUnit1.currentHealth
                    }) : null), React.DOM.div({
                        className: "battle-display-strength battle-display-strength-side2"
                    }, this.state.battleSceneUnit2 ? UIComponents.BattleDisplayStrength({
                        key: "" + this.state.battleSceneUnit2.id + Date.now(),
                        delay: this.state.battleEffectDuration,
                        from: this.state.battleSceneUnit2StartingStrength,
                        to: this.state.battleSceneUnit2.currentHealth
                    }) : null));
                }
                // hack
                // 
                // transitiongroups dont work very well, especially in the older version
                // of react we're using. seems to be mostly fine on webkit & ie though
                // so just disable it on firefox for now
                var upperFooter = navigator.userAgent.indexOf("Firefox") === -1 ?
                    React.addons.CSSTransitionGroup({ transitionName: "battle-upper-footer" }, upperFooterElement) : upperFooterElement;
                var overlayContainer = null;
                var playerWonBattle = null;
                if (this.state.battleIsStarting) {
                    overlayContainer = React.DOM.div({
                        className: "battle-start-overlay",
                        onClick: this.endBattleStart
                    });
                }
                else if (battle.ended) {
                    if (!this.battleEndStartTime)
                        this.battleEndStartTime = Date.now();
                    overlayContainer = React.DOM.div({
                        className: "battle-start-overlay",
                        onClick: this.finishBattle
                    });
                    playerWonBattle = this.props.humanPlayer === battle.getVictor();
                }
                var battleState = null;
                if (this.state.battleIsStarting) {
                    battleState = "start";
                }
                else if (battle.ended) {
                    battleState = "finish";
                }
                else {
                    battleState = "active";
                }
                return (UIComponents.BattleBackground({
                    renderer: this.props.renderer,
                    backgroundSeed: this.props.battle.battleData.location.getSeed(),
                    getBlurArea: this.getBlurArea
                }, React.DOM.div({
                    className: "battle-container",
                    ref: "battleContainer"
                }, overlayContainer, React.DOM.div({
                    className: "battle-upper"
                }, UIComponents.BattleScore({
                    battle: battle
                }), upperFooter, UIComponents.BattleScene({
                    battleState: battleState,
                    targetUnit: this.state.targetUnit,
                    userUnit: this.state.userUnit,
                    activeUnit: battle.activeUnit,
                    hoveredUnit: this.state.hoveredUnit,
                    activeSFX: this.state.battleEffectSFX,
                    afterAbilityFinishedCallback: this.state.afterAbilityFinishedCallback,
                    triggerEffectCallback: this.state.triggerEffectCallback,
                    humanPlayerWonBattle: playerWonBattle,
                    side1Player: battle.side1Player,
                    side2Player: battle.side2Player
                })), React.DOM.div({
                    className: "formations-container",
                    ref: "formationsContainer"
                }, UIComponents.Formation({
                    battle: battle,
                    formation: battle.side1,
                    facesLeft: false,
                    activeUnit: battle.activeUnit,
                    hoveredUnit: this.state.highlightedUnit,
                    hoveredAbility: this.state.hoveredAbility,
                    activeTargets: activeTargets,
                    targetsInPotentialArea: this.state.targetsInPotentialArea,
                    handleMouseEnterUnit: this.handleMouseEnterUnit,
                    handleMouseLeaveUnit: this.handleMouseLeaveUnit,
                    activeEffectUnits: activeEffectUnits
                }), UIComponents.TurnCounter({
                    turnsLeft: battle.turnsLeft,
                    maxTurns: battle.maxTurns
                }), UIComponents.Formation({
                    battle: battle,
                    formation: battle.side2,
                    facesLeft: true,
                    activeUnit: battle.activeUnit,
                    hoveredUnit: this.state.highlightedUnit,
                    hoveredAbility: this.state.hoveredAbility,
                    activeTargets: activeTargets,
                    targetsInPotentialArea: this.state.targetsInPotentialArea,
                    handleMouseEnterUnit: this.handleMouseEnterUnit,
                    handleMouseLeaveUnit: this.handleMouseLeaveUnit,
                    activeEffectUnits: activeEffectUnits
                }), abilityTooltip, this.state.playingBattleEffect ?
                    React.DOM.div({ className: "battle-formations-darken" }, null) :
                    null))));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.SplitMultilineText = {
            splitMultilineText: function (text) {
                if (Array.isArray(text)) {
                    var returnArr = [];
                    for (var i = 0; i < text.length; i++) {
                        returnArr.push(text[i]);
                        returnArr.push(React.DOM.br({
                            key: "" + i
                        }));
                    }
                    return returnArr;
                }
                else {
                    return text;
                }
            }
        };
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../mixins/splitmultilinetext.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.List = React.createClass({
            displayName: "List",
            mixins: [UIComponents.SplitMultilineText],
            sortedItems: [],
            propTypes: {
                initialColumns: React.PropTypes.arrayOf(React.PropTypes.object).isRequired,
                listItems: React.PropTypes.arrayOf(React.PropTypes.object).isRequired,
                initialSortOrder: React.PropTypes.arrayOf(React.PropTypes.object),
                keyboardSelect: React.PropTypes.bool,
                initialSelected: React.PropTypes.object,
                tabIndex: React.PropTypes.number,
                noHeader: React.PropTypes.bool,
                addSpacer: React.PropTypes.bool,
                onRowChange: React.PropTypes.func,
                colStylingFN: React.PropTypes.func // (column: IListColumn, props: any) => any
            },
            getInitialState: function () {
                var initialColumn = this.props.initialSortOrder ?
                    this.props.initialSortOrder[0] :
                    this.props.initialColumns[0];
                return ({
                    columns: this.props.initialColumns,
                    selected: null,
                    selectedColumn: initialColumn,
                    sortingOrder: this.makeInitialSortingOrder(this.props.initialColumns, initialColumn)
                });
            },
            componentDidMount: function () {
                var self = this;
                window.addEventListener("resize", this.setDesiredHeight, false);
                Rance.eventManager.addEventListener("popupResized", this.setDesiredHeight);
                if (this.props.keyboardSelect) {
                    this.getDOMNode().addEventListener("keydown", function (event) {
                        switch (event.keyCode) {
                            case 40:
                                {
                                    self.shiftSelection(1);
                                    break;
                                }
                            case 38:
                                {
                                    self.shiftSelection(-1);
                                    break;
                                }
                            default:
                                {
                                    return;
                                }
                        }
                    });
                }
                if (this.props.initialSelected) {
                    this.handleSelectRow(this.props.initialSelected);
                }
                else if (this.props.autoSelect) {
                    this.handleSelectRow(this.sortedItems[0]);
                    this.getDOMNode().focus();
                }
                else {
                    this.setState({ selected: this.sortedItems[0] });
                }
            },
            componentWillUnmount: function () {
                window.removeEventListener("resize", this.setDesiredHeight);
                Rance.eventManager.removeEventListener("popupResized", this.setDesiredHeight);
            },
            componentDidUpdate: function () {
                this.setDesiredHeight();
            },
            setDesiredHeight: function () {
                var ownNode = this.getDOMNode();
                var innerNode = this.refs.inner.getDOMNode();
                ownNode.style.height = "auto";
                innerNode.style.height = "auto";
                var parentHeight = ownNode.parentNode.getBoundingClientRect().height;
                var ownRect = ownNode.getBoundingClientRect();
                var ownHeight = ownRect.height;
                var strippedOwnHeight = parseInt(getComputedStyle(ownNode).height);
                var extraHeight = ownHeight - strippedOwnHeight;
                var desiredHeight = parentHeight - extraHeight;
                var maxHeight = window.innerHeight - ownRect.top - extraHeight;
                desiredHeight = Math.min(desiredHeight, maxHeight);
                ownNode.style.height = "" + desiredHeight + "px";
                innerNode.style.height = "" + desiredHeight + "px";
            },
            handleScroll: function (e) {
                // scrolls header to match list contents
                var target = e.target;
                var header = this.refs.header.getDOMNode();
                var titles = header.getElementsByClassName("fixed-table-th-inner");
                var marginString = "-" + target.scrollLeft + "px";
                for (var i = 0; i < titles.length; i++) {
                    titles[i].style.marginLeft = marginString;
                }
            },
            makeInitialSortingOrder: function (columns, initialColumn) {
                var initialSortOrder = this.props.initialSortOrder;
                if (!initialSortOrder || initialSortOrder.length < 1) {
                    initialSortOrder = [initialColumn];
                }
                var order = initialSortOrder;
                for (var i = 0; i < columns.length; i++) {
                    if (!columns[i].order) {
                        columns[i].order = columns[i].defaultOrder;
                    }
                    if (initialSortOrder.indexOf(columns[i]) < 0) {
                        order.push(columns[i]);
                    }
                }
                return order;
            },
            getNewSortingOrder: function (newColumn) {
                var order = this.state.sortingOrder.slice(0);
                var current = order.indexOf(newColumn);
                if (current >= 0) {
                    order.splice(current);
                }
                order.unshift(newColumn);
                return order;
            },
            handleSelectColumn: function (column) {
                if (column.notSortable)
                    return;
                function getReverseOrder(order) {
                    return order === "desc" ? "asc" : "desc";
                }
                if (this.state.selectedColumn.key === column.key) {
                    column.order = getReverseOrder(column.order);
                    this.forceUpdate();
                }
                else {
                    column.order = column.defaultOrder;
                    this.setState({
                        selectedColumn: column,
                        sortingOrder: this.getNewSortingOrder(column)
                    });
                }
            },
            handleSelectRow: function (row) {
                if (this.props.onRowChange && row)
                    this.props.onRowChange.call(null, row);
                this.setState({
                    selected: row
                });
            },
            sort: function () {
                var itemsToSort = this.props.listItems;
                var columnsToTry = this.state.columns;
                var sortOrder = this.state.sortingOrder;
                var sortFunctions = {};
                function makeSortingFunction(column) {
                    if (column.sortingFunction)
                        return column.sortingFunction;
                    var propToSortBy = column.propToSortBy || column.key;
                    return (function (a, b) {
                        var a1 = a.data[propToSortBy];
                        var b1 = b.data[propToSortBy];
                        if (a1 > b1)
                            return 1;
                        else if (a1 < b1)
                            return -1;
                        else
                            return 0;
                    });
                }
                itemsToSort.sort(function (a, b) {
                    var result = 0;
                    for (var i = 0; i < sortOrder.length; i++) {
                        var columnToSortBy = sortOrder[i];
                        if (!sortFunctions[columnToSortBy.key]) {
                            sortFunctions[columnToSortBy.key] = makeSortingFunction(columnToSortBy);
                        }
                        var sortFunction = sortFunctions[columnToSortBy.key];
                        result = sortFunction(a, b);
                        if (columnToSortBy.order === "desc") {
                            result *= -1;
                        }
                        if (result)
                            return result;
                    }
                    return 0; // couldnt sort
                });
                this.sortedItems = itemsToSort;
            },
            shiftSelection: function (amountToShift) {
                var reverseIndexes = {};
                for (var i = 0; i < this.sortedItems.length; i++) {
                    reverseIndexes[this.sortedItems[i].key] = i;
                }
                ;
                var currSelectedIndex = reverseIndexes[this.state.selected.key];
                var nextIndex = (currSelectedIndex + amountToShift) % this.sortedItems.length;
                if (nextIndex < 0) {
                    nextIndex += this.sortedItems.length;
                }
                this.handleSelectRow(this.sortedItems[nextIndex]);
            },
            render: function () {
                var self = this;
                var columns = [];
                var headerLabels = [];
                this.state.columns.forEach(function (column) {
                    var colProps = {
                        key: column.key
                    };
                    if (self.props.colStylingFN) {
                        colProps = self.props.colStylingFN(column, colProps);
                    }
                    columns.push(React.DOM.col(colProps));
                    var sortStatus = "";
                    if (!column.notSortable)
                        sortStatus = " sortable";
                    if (self.state.selectedColumn.key === column.key) {
                        sortStatus += " sorted-" + column.order;
                    }
                    else if (!column.notSortable)
                        sortStatus += " unsorted";
                    headerLabels.push(React.DOM.th({
                        key: column.key
                    }, React.DOM.div({
                        className: "fixed-table-th-inner"
                    }, React.DOM.div({
                        className: "fixed-table-th-content" + sortStatus,
                        title: column.title || colProps.title || null,
                        onMouseDown: self.handleSelectColumn.bind(null, column),
                        onTouchStart: self.handleSelectColumn.bind(null, column),
                    }, column.label))));
                });
                this.sort();
                var sortedItems = this.sortedItems;
                var rows = [];
                sortedItems.forEach(function (item, i) {
                    item.data.key = item.key;
                    item.data.activeColumns = self.state.columns;
                    item.data.handleClick = self.handleSelectRow.bind(null, item);
                    var row = item.data.rowConstructor(item.data);
                    rows.push(row);
                    if (self.props.addSpacer && i < sortedItems.length - 1) {
                        rows.push(React.DOM.tr({
                            className: "list-spacer",
                            key: "spacer" + i
                        }, React.DOM.td({
                            colSpan: 20
                        }, null)));
                    }
                });
                return (React.DOM.div({
                    className: "fixed-table-container" + (this.props.noHeader ? " no-header" : ""),
                    tabIndex: isFinite(this.props.tabIndex) ? this.props.tabIndex : 1
                }, React.DOM.div({ className: "fixed-table-header-background" }), React.DOM.div({
                    className: "fixed-table-container-inner",
                    ref: "inner",
                    onScroll: this.handleScroll
                }, React.DOM.table({
                    className: "react-list"
                }, React.DOM.colgroup(null, columns), React.DOM.thead({ className: "fixed-table-actual-header", ref: "header" }, React.DOM.tr(null, headerLabels)), React.DOM.thead({ className: "fixed-table-hidden-header" }, React.DOM.tr(null, headerLabels)), React.DOM.tbody(null, rows)))));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../mixins/draggable.ts" />
/// <reference path="../unit/unitstrength.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.UnitListItem = React.createClass({
            displayName: "UnitListItem",
            mixins: [UIComponents.Draggable],
            componentDidMount: function () {
                if (!this.props.isDraggable)
                    return;
                var container = document.getElementsByClassName("unit-wrapper")[0];
                this.forcedDragOffset =
                    {
                        x: container.offsetWidth / 2,
                        y: container.offsetHeight / 2
                    };
            },
            componentDidUpdate: function () {
                if (this.needsFirstTouchUpdate && this.refs.dragClone) {
                    var node = this.refs.dragClone.getDOMNode();
                    node.classList.add("draggable");
                    node.classList.add("dragging");
                    var container = document.getElementsByClassName("unit-wrapper")[0];
                    node.style.width = "" + container.offsetWidth + "px";
                    node.style.height = "" + container.offsetHeight + "px";
                    this.needsFirstTouchUpdate = false;
                }
            },
            onDragStart: function () {
                this.props.onDragStart(this.props.unit);
            },
            onDragMove: function (x, y) {
                if (!this.refs.dragClone)
                    return;
                var node = this.refs.dragClone.getDOMNode();
                node.classList.add("draggable");
                node.classList.add("dragging");
                node.style.left = "" + x + "px";
                node.style.top = "" + y + "px";
                var container = document.getElementsByClassName("unit-wrapper")[0];
                node.style.width = "" + container.offsetWidth + "px";
                node.style.height = "" + container.offsetHeight + "px";
                this.forcedDragOffset =
                    {
                        x: container.offsetWidth / 2,
                        y: container.offsetHeight / 2
                    };
            },
            onDragEnd: function () {
                this.props.onDragEnd();
            },
            handleMouseEnter: function () {
                this.props.onMouseEnter(this.props.unit);
            },
            handleMouseLeave: function () {
                this.props.onMouseLeave();
            },
            makeCell: function (type) {
                var unit = this.props.unit;
                var cellProps = {};
                cellProps.key = type;
                cellProps.className = "unit-list-item-cell" + " unit-list-" + type;
                var cellContent;
                switch (type) {
                    case "strength":
                        {
                            cellContent = UIComponents.UnitStrength({
                                maxHealth: this.props.maxHealth,
                                currentHealth: this.props.currentHealth,
                                isSquadron: true
                            });
                            break;
                        }
                    case "attack":
                    case "defence":
                    case "intelligence":
                    case "speed":
                        {
                            cellContent = this.props[type];
                            if (unit.attributes[type] < unit.baseAttributes[type]) {
                                cellProps.className += " lowered-stat";
                            }
                            else if (unit.attributes[type] > unit.baseAttributes[type]) {
                                cellProps.className += " raised-stat";
                            }
                            break;
                        }
                    default:
                        {
                            cellContent = this.props[type];
                            break;
                        }
                }
                return (React.DOM.td(cellProps, cellContent));
            },
            render: function () {
                var unit = this.props.unit;
                var columns = this.props.activeColumns;
                if (this.state.dragging) {
                    return (UIComponents.Unit({
                        ref: "dragClone",
                        unit: unit
                    }));
                }
                var cells = [];
                for (var i = 0; i < columns.length; i++) {
                    var cell = this.makeCell(columns[i].key);
                    cells.push(cell);
                }
                var rowProps = {
                    className: "unit-list-item",
                    onClick: this.props.handleClick
                };
                if (this.props.isDraggable && !this.props.noActionsLeft) {
                    rowProps.className += " draggable";
                    rowProps.onTouchStart = rowProps.onMouseDown =
                        this.handleMouseDown;
                }
                if (this.props.isSelected) {
                    rowProps.className += " selected-unit";
                }
                ;
                if (this.props.isReserved) {
                    rowProps.className += " reserved-unit";
                }
                if (this.props.isHovered) {
                    rowProps.className += " unit-list-item-hovered";
                }
                if (this.props.noActionsLeft) {
                    rowProps.className += " no-actions-left";
                }
                else if (this.props.onMouseEnter) {
                    rowProps.onMouseEnter = this.handleMouseEnter;
                    rowProps.onMouseLeave = this.handleMouseLeave;
                }
                return (React.DOM.tr(rowProps, cells));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="list.ts" />
/// <reference path="unitlistitem.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.UnitList = React.createClass({
            displayName: "UnitList",
            render: function () {
                var rows = [];
                for (var id in this.props.units) {
                    var unit = this.props.units[id];
                    var data = {
                        unit: unit,
                        id: unit.id,
                        name: unit.name,
                        typeName: unit.template.displayName,
                        strength: "" + unit.currentHealth + " / " + unit.maxHealth,
                        currentHealth: unit.currentHealth,
                        maxHealth: unit.maxHealth,
                        maxActionPoints: unit.attributes.maxActionPoints,
                        attack: unit.attributes.attack,
                        defence: unit.attributes.defence,
                        intelligence: unit.attributes.intelligence,
                        speed: unit.attributes.speed,
                        rowConstructor: UIComponents.UnitListItem,
                        makeClone: true,
                        isReserved: (this.props.reservedUnits && this.props.reservedUnits[unit.id]),
                        noActionsLeft: (this.props.checkTimesActed && !unit.canActThisTurn()),
                        isSelected: (this.props.selectedUnit && this.props.selectedUnit.id === unit.id),
                        isHovered: (this.props.hoveredUnit && this.props.hoveredUnit.id === unit.id),
                        onMouseEnter: this.props.onMouseEnter,
                        onMouseLeave: this.props.onMouseLeave,
                        isDraggable: this.props.isDraggable,
                        onDragStart: this.props.onDragStart,
                        onDragEnd: this.props.onDragEnd
                    };
                    rows.push({
                        key: unit.id,
                        data: data
                    });
                }
                var columns = [
                    {
                        label: "Id",
                        key: "id",
                        defaultOrder: "asc"
                    },
                    {
                        label: "Type",
                        key: "typeName",
                        defaultOrder: "asc"
                    },
                    {
                        label: "Strength",
                        key: "strength",
                        defaultOrder: "desc",
                        sortingFunction: function (a, b) {
                            return a.data.currentHealth - b.data.currentHealth;
                        }
                    },
                    {
                        label: "Act",
                        key: "maxActionPoints",
                        defaultOrder: "desc"
                    },
                    {
                        label: "Atk",
                        key: "attack",
                        defaultOrder: "desc"
                    },
                    {
                        label: "Def",
                        key: "defence",
                        defaultOrder: "desc"
                    },
                    {
                        label: "Int",
                        key: "intelligence",
                        defaultOrder: "desc"
                    },
                    {
                        label: "Spd",
                        key: "speed",
                        defaultOrder: "desc"
                    }
                ];
                return (React.DOM.div({ className: "unit-list fixed-table-parent" }, UIComponents.List({
                    listItems: rows,
                    initialColumns: columns,
                    onRowChange: this.props.onRowChange,
                    autoSelect: this.props.autoSelect,
                    keyboardSelect: true
                })));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.ItemListItem = React.createClass({
            displayName: "ItemListItem",
            mixins: [UIComponents.Draggable],
            onDragStart: function () {
                console.log("onDragStart", this.props.item.template.displayName);
                this.props.onDragStart(this.props.item);
            },
            onDragEnd: function () {
                this.props.onDragEnd();
            },
            makeCell: function (type) {
                var cellProps = {};
                cellProps.key = type;
                cellProps.className = "item-list-item-cell" + " item-list-" + type;
                var cellContent;
                switch (type) {
                    case "abilityName":
                        {
                            if (this.props.ability) {
                                cellProps.title = this.props.ability.description;
                                if (this.props.abilityIsPassive) {
                                    cellProps.className += " passive-skill";
                                }
                            }
                        }
                    default:
                        {
                            cellContent = this.props[type];
                            if (isFinite(cellContent)) {
                                cellProps.className += " center-text";
                            }
                            break;
                        }
                }
                return (React.DOM.td(cellProps, cellContent));
            },
            makeDragClone: function () {
                var clone = new Image();
                clone.src = this.props.item.template.icon;
                clone.className = "item-icon-base draggable dragging";
                return clone;
            },
            render: function () {
                var item = this.props.item;
                var columns = this.props.activeColumns;
                if (this.state.dragging && this.state.clone) {
                    this.state.clone.style.left = "" + this.dragPos.left + "px";
                    this.state.clone.style.top = "" + this.dragPos.top + "px";
                }
                var cells = [];
                for (var i = 0; i < columns.length; i++) {
                    var cell = this.makeCell(columns[i].key);
                    cells.push(cell);
                }
                var rowProps = {
                    className: "item-list-item",
                    onClick: this.props.handleClick,
                    key: this.props.key
                };
                if (this.props.isDraggable) {
                    rowProps.className += " draggable";
                    rowProps.onTouchStart = rowProps.onMouseDown =
                        this.handleMouseDown;
                }
                if (this.props.isSelected) {
                    rowProps.className += " selected-item";
                }
                ;
                if (this.props.isReserved) {
                    rowProps.className += " reserved-item";
                }
                return (React.DOM.tr(rowProps, cells));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="list.ts" />
/// <reference path="itemlistitem.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.ItemList = React.createClass({
            displayName: "ItemList",
            getSlotIndex: function (slot) {
                if (slot === "high") {
                    return 2;
                }
                else if (slot === "mid") {
                    return 1;
                }
                else
                    return 0;
            },
            render: function () {
                var rows = [];
                var items = this.props.items;
                for (var i = 0; i < items.length; i++) {
                    var item = items[i];
                    var ability = null;
                    var abilityIsPassive = false;
                    if (item.template.ability) {
                        ability = item.template.ability;
                    }
                    else if (item.template.passiveSkill) {
                        ability = item.template.passiveSkill;
                        abilityIsPassive = true;
                    }
                    var data = {
                        item: item,
                        key: item.id,
                        id: item.id,
                        typeName: item.template.displayName,
                        slot: item.template.slot,
                        slotIndex: this.getSlotIndex(item.template.slot),
                        unit: item.unit ? item.unit : null,
                        unitName: item.unit ? item.unit.name : "",
                        techLevel: item.template.techLevel,
                        cost: item.template.buildCost,
                        ability: ability,
                        abilityName: ability ? ability.displayName : "",
                        abilityIsPassive: abilityIsPassive,
                        isReserved: Boolean(item.unit),
                        makeClone: true,
                        forcedDragOffset: { x: 32, y: 32 },
                        rowConstructor: UIComponents.ItemListItem,
                        isDraggable: this.props.isDraggable,
                        onDragStart: this.props.onDragStart,
                        onDragEnd: this.props.onDragEnd
                    };
                    ["maxActionPoints", "attack", "defence",
                        "intelligence", "speed"].forEach(function (stat) {
                        if (!item.template.attributes)
                            data[stat] = null;
                        else
                            data[stat] = item.template.attributes[stat] || null;
                    });
                    rows.push({
                        key: item.id,
                        data: data
                    });
                }
                var columns;
                if (this.props.isItemPurchaseList) {
                    columns =
                        [
                            {
                                label: "Type",
                                key: "typeName",
                                defaultOrder: "asc"
                            },
                            {
                                label: "Slot",
                                key: "slot",
                                propToSortBy: "slotIndex",
                                defaultOrder: "desc"
                            },
                            {
                                label: "Tech",
                                key: "techLevel",
                                defaultOrder: "asc"
                            },
                            {
                                label: "Cost",
                                key: "cost",
                                defaultOrder: "asc"
                            }
                        ];
                }
                else {
                    columns =
                        [
                            {
                                label: "Type",
                                key: "typeName",
                                defaultOrder: "asc"
                            },
                            {
                                label: "Slot",
                                key: "slot",
                                propToSortBy: "slotIndex",
                                defaultOrder: "desc"
                            },
                            {
                                label: "Unit",
                                key: "unitName",
                                defaultOrder: "desc"
                            },
                            {
                                label: "Act",
                                key: "maxActionPoints",
                                defaultOrder: "desc"
                            },
                            {
                                label: "Atk",
                                key: "attack",
                                defaultOrder: "desc"
                            },
                            {
                                label: "Def",
                                key: "defence",
                                defaultOrder: "desc"
                            },
                            {
                                label: "Int",
                                key: "intelligence",
                                defaultOrder: "desc"
                            },
                            {
                                label: "Spd",
                                key: "speed",
                                defaultOrder: "desc"
                            },
                            {
                                label: "Ability",
                                key: "abilityName",
                                defaultOrder: "desc"
                            }
                        ];
                }
                return (React.DOM.div({ className: "item-list fixed-table-parent" }, UIComponents.List({
                    listItems: rows,
                    initialColumns: columns,
                    initialSortOrder: [columns[1], columns[2]],
                    onRowChange: this.props.onRowChange,
                    tabIndex: 2,
                    keyboardSelect: true
                })));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.AbilityList = React.createClass({
            displayName: "AbilityList",
            render: function () {
                var abilities = this.props.abilities;
                var baseClassName = "unit-info-ability";
                if (abilities.length < 1)
                    return null;
                var abilityElements = [];
                var addedAbilityTypes = {};
                abilities.sort(function (_a, _b) {
                    if (_a.mainEffect && !_b.mainEffect)
                        return -1;
                    else if (_b.mainEffect && !_a.mainEffect)
                        return 1;
                    if (_a.type === "learnable")
                        return 1;
                    else if (_b.type === "learnable")
                        return -1;
                    var a = _a.displayName.toLowerCase();
                    var b = _b.displayName.toLowerCase();
                    if (a > b)
                        return 1;
                    else if (a < b)
                        return -1;
                    else
                        return 0;
                });
                for (var i = 0; i < abilities.length; i++) {
                    var ability = abilities[i];
                    if (ability.isHidden) {
                        continue;
                    }
                    if (!addedAbilityTypes[ability.type]) {
                        addedAbilityTypes[ability.type] = 0;
                    }
                    var className = "unit-info-ability";
                    var isPassiveSkill = !ability.mainEffect;
                    if (isPassiveSkill) {
                        className += " passive-skill";
                    }
                    else {
                        className += " active-skill";
                    }
                    if (addedAbilityTypes[ability.type] >= 1) {
                        className += " redundant-ability";
                    }
                    abilityElements.push(React.DOM.li({
                        className: className,
                        title: ability.description,
                        key: ability.type + addedAbilityTypes[ability.type],
                        onClick: (this.props.handleClick ? this.props.handleClick.bind(null, ability) : undefined)
                    }, "[" + ability.displayName + "]"));
                    addedAbilityTypes[ability.type]++;
                }
                return (React.DOM.ul({
                    className: "ability-list"
                }, abilityElements));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.UnitItem = React.createClass({
            displayName: "UnitItem",
            mixins: [UIComponents.Draggable],
            onDragStart: function () {
                this.props.onDragStart(this.props.item);
            },
            onDragEnd: function () {
                this.props.onDragEnd();
            },
            getTechIcon: function (techLevel) {
                switch (techLevel) {
                    case 2:
                        {
                            return "img\/icons\/t2icon.png";
                        }
                    case 3:
                        {
                            return "img\/icons\/t3icon.png";
                        }
                }
            },
            render: function () {
                if (!this.props.item) {
                    var emptyItemTitle = "Item slot: " + this.props.slot;
                    return (React.DOM.div({ className: "empty-unit-item", title: emptyItemTitle }));
                }
                var item = this.props.item;
                var divProps = {
                    className: "unit-item",
                    title: item.template.displayName
                };
                if (this.props.isDraggable) {
                    divProps.className += " draggable";
                    divProps.onMouseDown = divProps.onTouchStart =
                        this.handleMouseDown;
                }
                if (this.state.dragging) {
                    divProps.style = this.dragPos;
                    divProps.className += " dragging";
                }
                return (React.DOM.div(divProps, React.DOM.div({
                    className: "item-icon-container"
                }, React.DOM.img({
                    className: "item-icon-base",
                    src: item.template.icon
                }), item.template.techLevel > 1 ? React.DOM.img({
                    className: "item-icon-tech-level",
                    src: this.getTechIcon(item.template.techLevel)
                }) : null)));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../mixins/droptarget.ts"/>
/// <reference path="unititem.ts"/>
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.UnitItemWrapper = React.createClass({
            displayName: "UnitItemWrapper",
            mixins: [UIComponents.DropTarget],
            handleMouseUp: function () {
                this.props.onMouseUp(this.props.slot);
            },
            render: function () {
                var item = this.props.item;
                var wrapperProps = {
                    className: "unit-item-wrapper"
                };
                // if this is declared inside the conditional block
                // the component won't accept the first drop properly
                if (this.props.onMouseUp) {
                    wrapperProps.onMouseUp = this.handleMouseUp;
                }
                ;
                if (this.props.currentDragItem) {
                    var dragItem = this.props.currentDragItem;
                    if (dragItem.template.slot === this.props.slot) {
                        wrapperProps.className += " drop-target";
                    }
                    else {
                        wrapperProps.onMouseUp = null;
                        wrapperProps.className += " invalid-drop-target";
                    }
                }
                return (React.DOM.div(wrapperProps, UIComponents.UnitItem({
                    item: this.props.item,
                    slot: this.props.slot,
                    key: "item",
                    isDraggable: this.props.isDraggable,
                    onDragStart: this.props.onDragStart,
                    onDragEnd: this.props.onDragEnd
                })));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="abilitylist.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.UpgradeAbilities = React.createClass({
            displayName: "UpgradeAbilities",
            render: function () {
                if (this.props.abilities.length === 0) {
                    return null;
                }
                var headerText;
                if (this.props.learningNewability) {
                    headerText = "Learn ability";
                }
                else {
                    headerText = "Upgrade ability";
                    if (this.props.sourceAbility) {
                        headerText += " " + this.props.sourceAbility.displayName;
                    }
                }
                return (React.DOM.div({
                    className: "upgrade-abilities"
                }, React.DOM.div({
                    className: "upgrade-abilities-header"
                }, headerText), UIComponents.AbilityList({
                    abilities: this.props.abilities,
                    handleClick: this.props.handleClick
                })));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.UpgradeAttributes = React.createClass({
            displayName: "UpgradeAttributes",
            upgradeAttribute: function (attribute, e) {
                if (e.button)
                    return;
                this.props.handleClick(attribute);
            },
            render: function () {
                var unit = this.props.unit;
                var rows = [];
                for (var attribute in unit.baseAttributes) {
                    var maxAttribute = attribute === "maxActionPoints" ? 6 : 9;
                    if (unit.baseAttributes[attribute] < maxAttribute) {
                        rows.push(React.DOM.div({
                            className: "upgrade-attributes-attribute",
                            onClick: this.upgradeAttribute.bind(this, attribute),
                            key: attribute
                        }, attribute + ": " + unit.baseAttributes[attribute] + " -> " + (unit.baseAttributes[attribute] + 1)));
                    }
                }
                if (rows.length === 0) {
                    return null;
                }
                return (React.DOM.div({
                    className: "upgrade-attributes"
                }, React.DOM.div({
                    className: "upgrade-attributes-header"
                }, "Upgrade stats"), rows));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="upgradeabilities.ts" />
/// <reference path="upgradeattributes.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.UpgradeUnit = React.createClass({
            displayName: "UpgradeUnit",
            getInitialState: function () {
                return ({
                    upgradeData: this.props.unit.getAbilityUpgradeData(),
                    popupId: undefined
                });
            },
            upgradeAbility: function (source, newAbility) {
                var unit = this.props.unit;
                unit.upgradeAbility(source, newAbility);
                unit.handleLevelUp();
                this.setState({
                    upgradeData: unit.getAbilityUpgradeData()
                });
                this.closePopup();
                this.props.onUnitUpgrade();
            },
            upgradeAttribute: function (attribute) {
                var unit = this.props.unit;
                unit.baseAttributes[attribute] += 1;
                unit.attributesAreDirty = true;
                unit.handleLevelUp();
                this.props.onUnitUpgrade();
            },
            makeAbilityLearnPopup: function (ability) {
                var upgradeData = this.state.upgradeData[ability.type];
                var popupId = this.refs.popupManager.makePopup({
                    contentConstructor: UIComponents.TopMenuPopup,
                    contentProps: {
                        handleClose: this.closePopup,
                        contentConstructor: UIComponents.UpgradeAbilities,
                        contentProps: {
                            abilities: upgradeData.possibleUpgrades,
                            handleClick: this.upgradeAbility.bind(this, upgradeData.base),
                            sourceAbility: upgradeData.base,
                            learningNewability: !Boolean(upgradeData.base)
                        }
                    },
                    popupProps: {
                        preventAutoResize: true,
                        containerDragOnly: true
                    }
                });
                this.setState({
                    popupId: popupId
                });
            },
            closePopup: function () {
                this.refs.popupManager.closePopup(this.state.popupId);
                this.setState({
                    popupId: undefined
                });
            },
            render: function () {
                var unit = this.props.unit;
                var upgradableAbilities = [];
                for (var source in this.state.upgradeData) {
                    if (this.state.upgradeData[source].base) {
                        upgradableAbilities.push(this.state.upgradeData[source].base);
                    }
                    else {
                        upgradableAbilities.push({
                            type: source,
                            displayName: "** New ability **",
                            description: ""
                        });
                    }
                }
                return (React.DOM.div({
                    className: "upgrade-unit"
                }, UIComponents.PopupManager({
                    ref: "popupManager",
                    onlyAllowOne: true
                }), React.DOM.div({
                    className: "upgrade-unit-header"
                }, unit.name + "  " + "Level " + unit.level + " -> " + (unit.level + 1)), UIComponents.UpgradeAbilities({
                    abilities: upgradableAbilities,
                    handleClick: this.makeAbilityLearnPopup
                }), UIComponents.UpgradeAttributes({
                    unit: unit,
                    handleClick: this.upgradeAttribute
                })));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="upgradeunit.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.UnitExperience = React.createClass({
            displayName: "UnitExperience",
            getInitialState: function () {
                return ({
                    upgradePopupId: undefined
                });
            },
            makePopup: function () {
                var popupId = this.refs.popupManager.makePopup({
                    contentConstructor: UIComponents.TopMenuPopup,
                    contentProps: {
                        handleClose: this.closePopup,
                        contentConstructor: UIComponents.UpgradeUnit,
                        contentProps: {
                            unit: this.props.unit,
                            onUnitUpgrade: this.handleUnitUpgrade
                        }
                    },
                    popupProps: {
                        preventAutoResize: true,
                        containerDragOnly: true
                    }
                });
                this.setState({
                    upgradePopupId: popupId
                });
            },
            closePopup: function () {
                this.refs.popupManager.closePopup(this.state.upgradePopupId);
                this.setState({
                    upgradePopupId: undefined
                });
            },
            handleUnitUpgrade: function () {
                if (!this.props.unit.canLevelUp()) {
                    this.closePopup();
                }
                else {
                    this.refs.popupManager.forceUpdate();
                }
                this.props.onUnitUpgrade();
            },
            render: function () {
                var rows = [];
                var totalBars = Math.ceil(this.props.experienceToNextLevel) / 10;
                var filledBars = Math.ceil(this.props.experienceForCurrentLevel / 10);
                var lastBarWidth = (10 * (this.props.experienceForCurrentLevel % 10));
                for (var i = 0; i < totalBars; i++) {
                    var bgProps = {
                        className: "unit-experience-bar-point-background"
                    };
                    if (i < filledBars) {
                        bgProps.className += " filled";
                        if (i === filledBars - 1 && lastBarWidth !== 0) {
                            bgProps.style =
                                {
                                    width: "" + lastBarWidth + "%"
                                };
                        }
                    }
                    else {
                        bgProps.className += " empty";
                    }
                    rows.push(React.DOM.div({
                        className: "unit-experience-bar-point",
                        key: "" + i
                    }, React.DOM.div(bgProps, null)));
                }
                var isReadyToLevelUp = this.props.experienceForCurrentLevel >= this.props.experienceToNextLevel;
                var containerProps = {
                    className: "unit-experience-bar-container"
                };
                var barProps = {
                    className: "unit-experience-bar",
                    title: "" + this.props.experienceForCurrentLevel + "/" + this.props.experienceToNextLevel + " exp"
                };
                if (isReadyToLevelUp) {
                    containerProps.onClick = this.makePopup;
                    barProps.className += " ready-to-level-up";
                }
                return (React.DOM.div({
                    className: "unit-experience-wrapper"
                }, UIComponents.PopupManager({
                    ref: "popupManager",
                    onlyAllowOne: true
                }), React.DOM.div(containerProps, React.DOM.div(barProps, rows), !isReadyToLevelUp ? null : React.DOM.span({
                    className: "ready-to-level-up-message"
                }, "Click to level up"))));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="abilitylist.ts" />
/// <reference path="unititemwrapper.ts"/>
/// <reference path="unitexperience.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.MenuUnitInfo = React.createClass({
            displayName: "MenuUnitInfo",
            handleUnitUpgrade: function () {
                this.forceUpdate();
            },
            render: function () {
                var unit = this.props.unit;
                if (!unit)
                    return (React.DOM.div({ className: "menu-unit-info" }));
                var itemSlots = [];
                for (var slot in unit.items) {
                    itemSlots.push(UIComponents.UnitItemWrapper({
                        key: slot,
                        slot: slot,
                        item: unit.items[slot],
                        onMouseUp: this.props.onMouseUp,
                        isDraggable: this.props.isDraggable,
                        onDragStart: this.props.onDragStart,
                        onDragEnd: this.props.onDragEnd,
                        currentDragItem: this.props.currentDragItem
                    }));
                }
                var unitAbilities = unit.getAllAbilities();
                unitAbilities = unitAbilities.concat(unit.getAllPassiveSkills());
                return (React.DOM.div({
                    className: "menu-unit-info"
                }, React.DOM.div({
                    className: "menu-unit-info-name"
                }, unit.name), React.DOM.div({
                    className: "menu-unit-info-abilities"
                }, UIComponents.AbilityList({
                    abilities: unitAbilities
                })), UIComponents.UnitExperience({
                    experienceForCurrentLevel: unit.experienceForCurrentLevel,
                    experienceToNextLevel: unit.getExperienceToNextLevel(),
                    unit: unit,
                    onUnitUpgrade: this.handleUnitUpgrade
                }), React.DOM.div({
                    className: "menu-unit-info-items-wrapper"
                }, itemSlots)));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="itemlist.ts" />
/// <reference path="unitlist.ts" />
/// <reference path="menuunitinfo.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.ItemEquip = React.createClass({
            displayName: "ItemEquip",
            getInitialState: function () {
                return ({
                    selectedUnit: null,
                    currentDragItem: null
                });
            },
            handleSelectRow: function (row) {
                if (!row.data.unit)
                    return;
                this.setState({
                    selectedUnit: row.data.unit
                });
            },
            handleDragStart: function (item) {
                this.setState({
                    currentDragItem: item
                });
            },
            handleDragEnd: function (dropSuccesful) {
                if (dropSuccesful === void 0) { dropSuccesful = false; }
                if (!dropSuccesful && this.state.currentDragItem && this.state.selectedUnit) {
                    var item = this.state.currentDragItem;
                    if (this.state.selectedUnit.items[item.template.slot] === item) {
                        this.state.selectedUnit.removeItem(item);
                    }
                }
                this.setState({
                    currentDragItem: null
                });
            },
            handleDrop: function () {
                var item = this.state.currentDragItem;
                var unit = this.state.selectedUnit;
                if (unit && item) {
                    if (unit.items[item.template.slot]) {
                        unit.removeItemAtSlot(item.template.slot);
                    }
                    unit.addItem(item);
                }
                this.handleDragEnd(true);
            },
            render: function () {
                var player = this.props.player;
                return (React.DOM.div({ className: "item-equip" }, React.DOM.div({ className: "item-equip-left" }, UIComponents.MenuUnitInfo({
                    unit: this.state.selectedUnit,
                    onMouseUp: this.handleDrop,
                    isDraggable: true,
                    onDragStart: this.handleDragStart,
                    onDragEnd: this.handleDragEnd,
                    currentDragItem: this.state.currentDragItem
                }), UIComponents.ItemList({
                    items: player.items,
                    // only used to trigger updates
                    selectedUnit: this.state.selectedUnit,
                    isDraggable: true,
                    onDragStart: this.handleDragStart,
                    onDragEnd: this.handleDragEnd,
                    onRowChange: this.handleSelectRow
                })), UIComponents.UnitList({
                    units: player.units,
                    selectedUnit: this.state.selectedUnit,
                    isDraggable: false,
                    onRowChange: this.handleSelectRow,
                    autoSelect: true
                })));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../playerflag.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.DefenceBuilding = React.createClass({
            displayName: "DefenceBuilding",
            shouldComponentUpdate: function (newProps) {
                return newProps.building !== this.props.building;
            },
            render: function () {
                var building = this.props.building;
                var image = app.images[building.template.iconSrc];
                return (React.DOM.div({
                    className: "defence-building"
                }, React.DOM.img({
                    className: "defence-building-icon",
                    src: Rance.colorImageInPlayerColor(image, building.controller),
                    title: building.template.displayName
                }), UIComponents.PlayerFlag({
                    props: {
                        className: "defence-building-controller",
                        title: building.controller.name
                    },
                    key: "flag",
                    flag: building.controller.flag
                })));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="defencebuilding.ts"/>
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.DefenceBuildingList = React.createClass({
            displayName: "DefenceBuildingList",
            shouldComponentUpdate: function (newProps) {
                var newBuildings = newProps.buildings;
                var oldBuildings = this.props.buildings;
                if (newBuildings.length !== oldBuildings.length)
                    return true;
                else {
                    for (var i = 0; i < newBuildings.length; i++) {
                        if (oldBuildings.indexOf(newBuildings[i]) === -1)
                            return true;
                    }
                }
                return false;
            },
            render: function () {
                if (!this.props.buildings)
                    return null;
                var buildings = [];
                for (var i = 0; i < this.props.buildings.length; i++) {
                    buildings.push(UIComponents.DefenceBuilding({
                        key: this.props.buildings[i].id,
                        building: this.props.buildings[i]
                    }));
                }
                if (this.props.reverse) {
                    buildings.reverse();
                }
                return (React.DOM.div({
                    className: "defence-building-list"
                }, buildings));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../galaxymap/defencebuildinglist.ts"/>
/// <reference path="../playerflag.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.BattleInfo = React.createClass({
            displayName: "BattleInfo",
            render: function () {
                var battlePrep = this.props.battlePrep;
                var star = battlePrep.battleData.location;
                var isAttacker = battlePrep.humanPlayer === battlePrep.attacker;
                return (React.DOM.div({
                    className: "battle-info"
                }, React.DOM.div({
                    className: "battle-info-opponent"
                }, UIComponents.PlayerFlag({
                    flag: battlePrep.enemyPlayer.flag,
                    props: {
                        className: "battle-info-opponent-icon",
                    }
                }), React.DOM.div({
                    className: "battle-info-opponent-name"
                }, battlePrep.enemyPlayer.name)), React.DOM.div({
                    className: "battle-info-summary"
                }, star.name + ": " + (isAttacker ? "Attacking" : "Defending")), UIComponents.DefenceBuildingList({
                    buildings: star.buildings["defence"],
                    reverse: isAttacker
                })));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="battleinfo.ts"/>
/// <reference path="../unitlist/menuunitinfo.ts"/>
/// <reference path="../battle/formation.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.BattlePrep = React.createClass({
            displayName: "BattlePrep",
            getInitialState: function () {
                return ({
                    currentDragUnit: null,
                    hoveredUnit: null,
                    selectedUnit: null,
                    currentDragItem: null,
                    leftLowerElement: "playerFormation" // "playerFormation" || "enemyFormation" || "itemEquip"
                });
            },
            autoMakeFormation: function () {
                var battlePrep = this.props.battlePrep;
                battlePrep.clearPlayerFormation();
                battlePrep.playerFormation = battlePrep.makeAutoFormation(battlePrep.availableUnits, battlePrep.enemyUnits, battlePrep.humanPlayer);
                battlePrep.setupPlayerFormation(battlePrep.playerFormation);
                this.setLeftLowerElement("playerFormation");
                this.forceUpdate();
            },
            handleSelectRow: function (row) {
                if (!row.data.unit)
                    return;
                this.setSelectedUnit(row.data.unit);
            },
            clearSelectedUnit: function () {
                this.setState({
                    selectedUnit: null
                });
            },
            setSelectedUnit: function (unit) {
                if (unit === this.state.selectedUnit) {
                    this.clearSelectedUnit();
                    return;
                }
                this.setState({
                    selectedUnit: unit,
                    hoveredUnit: null
                });
            },
            handleMouseEnterUnit: function (unit) {
                this.setState({
                    hoveredUnit: unit
                });
            },
            handleMouseLeaveUnit: function () {
                this.setState({
                    hoveredUnit: null
                });
            },
            handleDragStart: function (unit) {
                this.setState({
                    currentDragUnit: unit
                });
            },
            handleDragEnd: function (dropSuccesful) {
                if (dropSuccesful === void 0) { dropSuccesful = false; }
                if (!dropSuccesful && this.state.currentDragUnit) {
                    this.props.battlePrep.removeUnit(this.state.currentDragUnit);
                }
                this.setState({
                    currentDragUnit: null,
                    hoveredUnit: null
                });
                return dropSuccesful;
            },
            handleDrop: function (position) {
                var battlePrep = this.props.battlePrep;
                if (this.state.currentDragUnit) {
                    var unitCurrentlyInPosition = battlePrep.getUnitAtPosition(position);
                    if (unitCurrentlyInPosition) {
                        battlePrep.swapUnits(this.state.currentDragUnit, unitCurrentlyInPosition);
                    }
                    else {
                        battlePrep.setUnit(this.state.currentDragUnit, position);
                    }
                }
                this.handleDragEnd(true);
            },
            handleItemDragStart: function (item) {
                this.setState({
                    currentDragItem: item
                });
            },
            setLeftLowerElement: function (newElement) {
                var oldElement = this.state.leftLowerElement;
                var newState = {
                    leftLowerElement: newElement
                };
                if (oldElement === "enemyFormation" || newElement === "enemyFormation") {
                    newState.selectedUnit = null;
                }
                this.setState(newState);
            },
            handleItemDragEnd: function (dropSuccesful) {
                if (dropSuccesful === void 0) { dropSuccesful = false; }
                if (!dropSuccesful && this.state.currentDragItem && this.state.selectedUnit) {
                    var item = this.state.currentDragItem;
                    if (this.state.selectedUnit.items[item.template.slot] === item) {
                        this.state.selectedUnit.removeItem(item);
                    }
                }
                this.setState({
                    currentDragItem: null
                });
            },
            handleItemDrop: function () {
                var item = this.state.currentDragItem;
                var unit = this.state.selectedUnit;
                if (unit && item) {
                    if (unit.items[item.template.slot]) {
                        unit.removeItemAtSlot(item.template.slot);
                    }
                    unit.addItem(item);
                }
                this.handleItemDragEnd(true);
            },
            getBackgroundBlurArea: function () {
                return this.refs.upper.getDOMNode().getBoundingClientRect();
            },
            render: function () {
                var battlePrep = this.props.battlePrep;
                var player = battlePrep.humanPlayer;
                var location = battlePrep.battleData.location;
                // priority: hovered unit > selected unit > battle info
                var leftUpperElement;
                var hoveredUnit = this.state.currentDragUnit || this.state.hoveredUnit;
                if (hoveredUnit) {
                    leftUpperElement = UIComponents.MenuUnitInfo({
                        unit: hoveredUnit
                    });
                }
                else if (this.state.selectedUnit) {
                    var selectedUnitIsFriendly = battlePrep.availableUnits.indexOf(this.state.selectedUnit) !== -1;
                    leftUpperElement = UIComponents.MenuUnitInfo({
                        unit: this.state.selectedUnit,
                        onMouseUp: this.handleItemDrop,
                        isDraggable: selectedUnitIsFriendly,
                        onDragStart: this.handleItemDragStart,
                        onDragEnd: this.handleItemDragEnd,
                        currentDragItem: this.state.currentDragItem
                    });
                }
                else {
                    leftUpperElement = UIComponents.BattleInfo({
                        battlePrep: battlePrep
                    });
                }
                var leftLowerElement;
                switch (this.state.leftLowerElement) {
                    case "playerFormation":
                        {
                            leftLowerElement = UIComponents.Formation({
                                key: "playerFormation",
                                formation: battlePrep.playerFormation.slice(0),
                                facesLeft: false,
                                hoveredUnit: this.state.hoveredUnit,
                                activeUnit: this.state.selectedUnit,
                                onMouseUp: this.handleDrop,
                                onUnitClick: this.setSelectedUnit,
                                isDraggable: true,
                                onDragStart: this.handleDragStart,
                                onDragEnd: this.handleDragEnd,
                                handleMouseEnterUnit: this.handleMouseEnterUnit,
                                handleMouseLeaveUnit: this.handleMouseLeaveUnit
                            });
                            break;
                        }
                    case "enemyFormation":
                        {
                            leftLowerElement = UIComponents.Formation({
                                key: "enemyFormation",
                                formation: battlePrep.enemyFormation,
                                facesLeft: true,
                                hoveredUnit: this.state.hoveredUnit,
                                activeUnit: this.state.selectedUnit,
                                onUnitClick: this.setSelectedUnit,
                                isDraggable: false,
                                handleMouseEnterUnit: this.handleMouseEnterUnit,
                                handleMouseLeaveUnit: this.handleMouseLeaveUnit
                            });
                            break;
                        }
                    case "itemEquip":
                        {
                            leftLowerElement = UIComponents.ItemList({
                                key: "itemEquip",
                                items: player.items,
                                isDraggable: true,
                                onDragStart: this.handleItemDragStart,
                                onDragEnd: this.handleItemDragEnd,
                                onRowChange: this.handleSelectRow
                            });
                            break;
                        }
                }
                ;
                var playerIsDefending = player === battlePrep.defender;
                var humanFormationIsValid = battlePrep.humanFormationIsValid();
                var canScout = player.starIsDetected(battlePrep.battleData.location);
                return (React.DOM.div({ className: "battle-prep" }, React.DOM.div({ className: "battle-prep-left" }, React.DOM.div({ className: "battle-prep-left-upper-wrapper", ref: "upper" }, UIComponents.BattleBackground({
                    renderer: this.props.renderer,
                    getBlurArea: this.getBackgroundBlurArea,
                    backgroundSeed: battlePrep.battleData.location.getSeed()
                }, React.DOM.div({ className: "battle-prep-left-upper-inner" }, leftUpperElement))), React.DOM.div({ className: "battle-prep-left-controls" }, React.DOM.button({
                    className: "battle-prep-controls-button",
                    onClick: this.setLeftLowerElement.bind(this, "itemEquip"),
                    disabled: this.state.leftLowerElement === "itemEquip"
                }, "Equip"), React.DOM.button({
                    className: "battle-prep-controls-button",
                    onClick: this.setLeftLowerElement.bind(this, "playerFormation"),
                    disabled: this.state.leftLowerElement === "playerFormation"
                }, "Own"), React.DOM.button({
                    className: "battle-prep-controls-button",
                    onClick: this.setLeftLowerElement.bind(this, "enemyFormation"),
                    disabled: this.state.leftLowerElement === "enemyFormation" || !canScout,
                    title: canScout ? null : "Can't inspect enemy formation" +
                        " as star is not in detection radius"
                }, "Enemy"), React.DOM.button({
                    onClick: this.autoMakeFormation
                }, "Auto formation"), React.DOM.button({
                    onClick: function () {
                        app.reactUI.switchScene("galaxyMap");
                    },
                    disabled: playerIsDefending
                }, "Cancel"), React.DOM.button({
                    className: "battle-prep-controls-button",
                    disabled: !humanFormationIsValid,
                    onClick: function () {
                        var battle = battlePrep.makeBattle();
                        app.reactUI.battle = battle;
                        app.reactUI.switchScene("battle");
                    }.bind(this)
                }, "Start battle"), !Rance.Options.debugMode ? null : React.DOM.button({
                    className: "battle-prep-controls-button",
                    onClick: function () {
                        var battle = battlePrep.makeBattle();
                        var simulator = new Rance.BattleSimulator(battle);
                        simulator.simulateBattle();
                        simulator.finishBattle();
                        Rance.eventManager.dispatchEvent("setCameraToCenterOn", battle.battleData.location);
                        Rance.eventManager.dispatchEvent("switchScene", "galaxyMap");
                    }.bind(this)
                }, "Simulate battle")), React.DOM.div({ className: "battle-prep-left-lower" }, leftLowerElement)), UIComponents.UnitList({
                    units: battlePrep.availableUnits,
                    selectedUnit: this.state.selectedUnit,
                    reservedUnits: battlePrep.alreadyPlaced,
                    hoveredUnit: this.state.hoveredUnit,
                    checkTimesActed: true,
                    isDraggable: this.state.leftLowerElement === "playerFormation",
                    onDragStart: this.handleDragStart,
                    onDragEnd: this.handleDragEnd,
                    onRowChange: this.handleSelectRow,
                    onMouseEnter: this.handleMouseEnterUnit,
                    onMouseLeave: this.handleMouseLeaveUnit
                })));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../mixins/draggable.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.PopupResizeHandle = React.createClass({
            displayName: "PopupResizeHandle",
            mixins: [UIComponents.Draggable],
            // originBottom: undefined,
            // originRight: undefined,
            // onDragStart: function()
            // {
            //   var rect = this.getDOMNode().getBoundingClientRect();
            //   this.originBottom = rect.bottom;
            //   this.originRight = rect.right;
            // },
            onDragMove: function (x, y) {
                var rect = this.getDOMNode().getBoundingClientRect();
                this.props.handleResize(x + rect.width, y + rect.height);
            },
            render: function () {
                return (React.DOM.img({
                    className: "popup-resize-handle",
                    src: "img\/icons\/resizeHandle.png",
                    onTouchStart: this.handleMouseDown,
                    onMouseDown: this.handleMouseDown
                }));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../mixins/draggable.ts" />
/// <reference path="resizehandle.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.Popup = React.createClass({
            displayName: "Popup",
            mixins: [UIComponents.Draggable],
            propTypes: {
                initialPosition: React.PropTypes.object,
                minWidth: React.PropTypes.number,
                maxWidth: React.PropTypes.number,
                minHeight: React.PropTypes.number,
                maxHeight: React.PropTypes.number,
                contentConstructor: React.PropTypes.any.isRequired,
                contentProps: React.PropTypes.object.isRequired,
                closePopup: React.PropTypes.func.isRequired,
                incrementZIndex: React.PropTypes.func.isRequired,
                getInitialPosition: React.PropTypes.func.isRequired,
                finishedMountingCallback: React.PropTypes.func
            },
            getInitialState: function () {
                return ({
                    zIndex: -1
                });
            },
            componentDidMount: function () {
                this.setInitialPosition();
            },
            onMouseDown: function (e) {
                this.handleMouseDown(e);
                var newZIndex = this.props.incrementZIndex(this.state.zIndex);
                if (this.state.zIndex !== newZIndex) {
                    this.setState({
                        zIndex: this.props.incrementZIndex(this.state.zIndex)
                    });
                }
            },
            setInitialPosition: function () {
                var domRect = this.getDOMNode().getBoundingClientRect();
                var rect = {
                    top: domRect.top,
                    left: domRect.left,
                    width: domRect.width,
                    height: domRect.height
                };
                var left;
                var top;
                var container = this.containerElement; // set in draggable mixin
                if (this.props.initialPosition) {
                    rect.top = this.props.initialPosition.top || rect.top;
                    rect.left = this.props.initialPosition.left || rect.left;
                    if (this.props.initialPosition.width) {
                        rect.width = Math.min(this.props.initialPosition.width, container.offsetWidth);
                    }
                    if (this.props.initialPosition.height) {
                        rect.height = Math.min(this.props.initialPosition.height, container.offsetHeight);
                    }
                    if (rect.left || rect.top) {
                        left = rect.left;
                        top = rect.top;
                    }
                }
                if (!left && !top) {
                    var position = this.props.getInitialPosition(rect, container);
                    left = position.left;
                    top = position.top;
                }
                left = Rance.clamp(left, 0, container.offsetWidth - rect.width);
                top = Rance.clamp(top, 0, container.offsetHeight - rect.height);
                this.dragPos.top = top;
                this.dragPos.left = left;
                this.dragPos.width = Math.min(window.innerWidth, rect.width);
                this.dragPos.height = Math.min(window.innerHeight, rect.height);
                this.setState({
                    zIndex: this.props.incrementZIndex(this.state.zIndex)
                }, this.props.finishedMountingCallback);
            },
            handleResizeMove: function (x, y) {
                var minWidth = this.props.minWidth || 0;
                var maxWidth = this.props.maxWidth || window.innerWidth;
                var minHeight = this.props.minHeight || 0;
                var maxHeight = this.props.maxHeight || window.innerHeight;
                this.dragPos.width = Rance.clamp(x + 5 - this.dragPos.left, minWidth, maxWidth);
                this.dragPos.height = Rance.clamp(y + 5 - this.dragPos.top, minHeight, maxHeight);
                this.updateDOMNodeStyle();
                Rance.eventManager.dispatchEvent("popupResized");
            },
            render: function () {
                var divProps = {
                    className: "popup draggable-container",
                    onTouchStart: this.onMouseDown,
                    onMouseDown: this.onMouseDown,
                    style: {
                        top: this.dragPos ? this.dragPos.top : 0,
                        left: this.dragPos ? this.dragPos.left : 0,
                        width: this.dragPos.width,
                        height: this.dragPos.height,
                        zIndex: this.state.zIndex,
                        minWidth: this.props.minWidth,
                        minHeight: this.props.minHeight
                    }
                };
                if (this.state.dragging) {
                    divProps.className += " dragging";
                }
                var contentProps = this.props.contentProps;
                contentProps.closePopup = this.props.closePopup;
                contentProps.ref = "content";
                var resizeHandle = !this.props.resizable ? null : UIComponents.PopupResizeHandle({
                    handleResize: this.handleResizeMove
                });
                return (React.DOM.div(divProps, this.props.contentConstructor(contentProps), resizeHandle));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.ConfirmPopup = React.createClass({
            displayName: "ConfirmPopup",
            mixins: [UIComponents.SplitMultilineText],
            componentDidMount: function () {
                this.refs.okButton.getDOMNode().focus();
            },
            handleOk: function () {
                if (!this.props.handleOk) {
                    this.handleClose();
                    return;
                }
                var callbackSuccesful = this.props.handleOk();
                if (callbackSuccesful !== false) {
                    this.handleClose();
                }
            },
            handleClose: function () {
                if (this.props.handleClose) {
                    this.props.handleClose();
                }
                this.props.closePopup();
            },
            render: function () {
                var content;
                if (this.props.contentText) {
                    content = this.splitMultilineText(this.props.contentText);
                }
                else if (this.props.contentConstructor) {
                    content = this.props.contentConstructor(this.props.contentProps);
                }
                else {
                    throw new Error("Confirm popup has no content");
                }
                return (React.DOM.div({
                    className: "confirm-popup draggable-container"
                }, React.DOM.div({
                    className: "confirm-popup-content"
                }, content), React.DOM.div({
                    className: "popup-buttons draggable-container"
                }, React.DOM.button({
                    className: "popup-button",
                    onClick: this.handleOk,
                    ref: "okButton"
                }, this.props.okText || "Confirm"), this.props.extraButtons, React.DOM.button({
                    className: "popup-button",
                    onClick: this.handleClose
                }, this.props.cancelText || "Cancel"))));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="popup.ts"/>
/// <reference path="confirmpopup.ts"/>
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.PopupManager = React.createClass({
            displayName: "PopupManager",
            popupId: 0,
            propTypes: {
                onlyAllowOne: React.PropTypes.bool
            },
            componentWillMount: function () {
                this.listeners = {};
                var self = this;
                this.listeners["makePopup"] =
                    Rance.eventManager.addEventListener("makePopup", function (data) {
                        self.makePopup(data);
                    });
                this.listeners["closePopup"] =
                    Rance.eventManager.addEventListener("closePopup", function (popupId) {
                        self.closePopup(popupId);
                    });
                this.listeners["setPopupContent"] =
                    Rance.eventManager.addEventListener("setPopupContent", function (data) {
                        self.setPopupContent(data.id, data.content);
                    });
            },
            componentWillUnmount: function () {
                for (var listenerId in this.listeners) {
                    Rance.eventManager.removeEventListener(listenerId, this.listeners[listenerId]);
                }
            },
            getInitialState: function () {
                return ({
                    popups: []
                });
            },
            getHighestZIndexPopup: function () {
                if (this.state.popups.length === 0)
                    return null;
                var popups = [];
                for (var ref in this.refs) {
                    popups.push(this.refs[ref]);
                }
                return popups.sort(function (a, b) {
                    return b.state.zIndex - a.state.zIndex;
                })[0];
            },
            getInitialPosition: function (rect, container) {
                if (this.state.popups.length === 1) {
                    return ({
                        left: container.offsetWidth / 2.5 - rect.width / 2,
                        top: container.offsetHeight / 2.5 - rect.height / 2
                    });
                }
                else {
                    var highestZPosition = this.getHighestZIndexPopup().dragPos;
                    return ({
                        left: highestZPosition.left + 20,
                        top: highestZPosition.top + 20
                    });
                }
            },
            incrementZIndex: function (childZIndex) {
                if (!this.currentZIndex)
                    this.currentZIndex = 0;
                if (childZIndex === this.currentZIndex) {
                    return this.currentZIndex;
                }
                else {
                    return ++this.currentZIndex;
                }
            },
            getPopupId: function () {
                return this.popupId++;
            },
            getPopup: function (id) {
                for (var i = 0; i < this.state.popups.length; i++) {
                    if (this.state.popups[i].id === id)
                        return this.state.popups[i];
                }
                return null;
            },
            hasPopup: function (id) {
                for (var i = 0; i < this.state.popups.length; i++) {
                    if (this.state.popups[i].id === id)
                        return true;
                }
                return false;
            },
            closePopup: function (id) {
                if (!this.hasPopup(id))
                    throw new Error("No such popup");
                var newPopups = [];
                for (var i = 0; i < this.state.popups.length; i++) {
                    if (this.state.popups[i].id !== id) {
                        newPopups.push(this.state.popups[i]);
                    }
                }
                this.setState({ popups: newPopups });
            },
            makePopup: function (props) {
                var id = this.getPopupId();
                var popupProps = props.popupProps ? Rance.extendObject(props.popupProps) : {};
                popupProps.contentConstructor = props.contentConstructor;
                popupProps.contentProps = props.contentProps;
                popupProps.id = id;
                popupProps.key = id;
                popupProps.ref = id;
                popupProps.incrementZIndex = this.incrementZIndex;
                popupProps.closePopup = this.closePopup.bind(this, id);
                popupProps.getInitialPosition = this.getInitialPosition;
                if (this.props.onlyAllowOne) {
                    this.setState({
                        popups: [popupProps]
                    });
                }
                else {
                    var popups = this.state.popups.concat(popupProps);
                    this.setState({
                        popups: popups
                    });
                }
                return id;
            },
            setPopupContent: function (popupId, newContent) {
                var popup = this.getPopup(popupId);
                if (!popup)
                    throw new Error();
                popup.contentProps = Rance.extendObject(newContent, popup.contentProps);
                this.forceUpdate();
            },
            render: function () {
                var popups = this.state.popups;
                var toRender = [];
                for (var i = 0; i < popups.length; i++) {
                    var popup = popups[i];
                    var popupProps = Rance.extendObject(popup);
                    popupProps.activePopupsCount = popups.length;
                    toRender.push(UIComponents.Popup(popupProps));
                }
                if (toRender.length < 1) {
                    return null;
                }
                return (React.DOM.div({
                    className: "popup-container"
                }, toRender));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.SaveListItem = React.createClass({
            displayName: "SaveListItem",
            handleDelete: function (e) {
                e.stopPropagation();
                this.props.handleDelete();
            },
            handleUndoDelete: function (e) {
                e.stopPropagation();
                this.props.handleUndoDelete();
            },
            makeCell: function (type) {
                var cellProps = {};
                cellProps.key = type;
                cellProps.className = "save-list-item-cell" + " save-list-" + type;
                var cellContent;
                switch (type) {
                    case "delete":
                        {
                            if (this.props.isMarkedForDeletion) {
                                cellContent = "";
                                cellProps.className += " undo-delete-button";
                                cellProps.onClick = this.handleUndoDelete;
                            }
                            else {
                                cellContent = "X";
                                cellProps.onClick = this.handleDelete;
                            }
                            break;
                        }
                    default:
                        {
                            cellContent = this.props[type];
                            break;
                        }
                }
                return (React.DOM.td(cellProps, cellContent));
            },
            render: function () {
                var columns = this.props.activeColumns;
                var cells = [];
                for (var i = 0; i < columns.length; i++) {
                    var cell = this.makeCell(columns[i].key);
                    cells.push(cell);
                }
                var rowProps = {
                    className: "save-list-item",
                    onClick: this.props.handleClick
                };
                if (this.props.isMarkedForDeletion) {
                    rowProps.className += " marked-for-deletion";
                }
                return (React.DOM.tr(rowProps, cells));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="savelistitem.ts"/>
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.SaveList = React.createClass({
            displayName: "SaveList",
            render: function () {
                var rows = [];
                var selected;
                var allKeys = Object.keys(localStorage);
                var saveKeys = allKeys.filter(function (key) {
                    return (key.indexOf("Rance.Save") > -1);
                });
                for (var i = 0; i < saveKeys.length; i++) {
                    var saveData = JSON.parse(localStorage.getItem(saveKeys[i]));
                    var date = new Date(saveData.date);
                    var isMarkedForDeletion = false;
                    if (this.props.saveKeysToDelete) {
                        if (this.props.saveKeysToDelete.indexOf(saveKeys[i]) !== -1) {
                            isMarkedForDeletion = true;
                        }
                    }
                    var row = {
                        key: saveKeys[i],
                        data: {
                            storageKey: saveKeys[i],
                            name: saveData.name,
                            date: Rance.prettifyDate(date),
                            accurateDate: saveData.date,
                            rowConstructor: UIComponents.SaveListItem,
                            isMarkedForDeletion: isMarkedForDeletion,
                            handleDelete: this.props.onDelete ?
                                this.props.onDelete.bind(null, saveKeys[i]) :
                                null,
                            handleUndoDelete: this.props.onUndoDelete ?
                                this.props.onUndoDelete.bind(null, saveKeys[i]) :
                                null
                        }
                    };
                    rows.push(row);
                    if (this.props.selectedKey === saveKeys[i]) {
                        selected = row;
                    }
                }
                var columns = [
                    {
                        label: "Name",
                        key: "name",
                        defaultOrder: "asc"
                    },
                    {
                        label: "Date",
                        key: "date",
                        defaultOrder: "desc",
                        propToSortBy: "accurateDate"
                    }
                ];
                if (this.props.allowDelete) {
                    columns.push({
                        label: "Del",
                        key: "delete",
                        notSortable: true
                    });
                }
                return (React.DOM.div({ className: "save-list fixed-table-parent" }, UIComponents.List({
                    listItems: rows,
                    initialColumns: columns,
                    initialSortOrder: [columns[1]],
                    onRowChange: this.props.onRowChange,
                    autoSelect: selected ? false : this.props.autoSelect,
                    initialSelected: selected,
                    keyboardSelect: true,
                    addSpacer: true
                })));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../popups/popupmanager.ts"/>
/// <reference path="savelist.ts"/>
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.SaveGame = React.createClass({
            displayName: "SaveGame",
            componentDidMount: function () {
                if (app.game.gameStorageKey) {
                    this.refs.okButton.getDOMNode().focus();
                }
                else {
                    this.refs.saveName.getDOMNode().focus();
                }
            },
            setInputText: function (newText) {
                this.refs.saveName.getDOMNode().value = newText;
            },
            handleRowChange: function (row) {
                this.setInputText(row.data.name);
            },
            handleSave: function () {
                var saveName = this.refs.saveName.getDOMNode().value;
                var saveKey = "Rance.Save." + saveName;
                if (localStorage[saveKey]) {
                    this.makeConfirmOverWritePopup(saveName);
                }
                else {
                    this.saveGame();
                }
            },
            saveGame: function () {
                app.game.save(this.refs.saveName.getDOMNode().value);
                this.handleClose();
            },
            handleClose: function () {
                this.props.handleClose();
            },
            makeConfirmOverWritePopup: function (saveName) {
                var confirmProps = {
                    handleOk: this.saveGame,
                    contentText: "Are you sure you want to overwrite " +
                        saveName.replace("Rance.Save.", "") + "?"
                };
                this.refs.popupManager.makePopup({
                    contentConstructor: UIComponents.ConfirmPopup,
                    contentProps: confirmProps
                });
            },
            render: function () {
                return (React.DOM.div({
                    className: "save-game"
                }, UIComponents.PopupManager({
                    ref: "popupManager",
                    onlyAllowOne: true
                }), UIComponents.SaveList({
                    onRowChange: this.handleRowChange,
                    selectedKey: app.game.gameStorageKey,
                    autoSelect: false
                }), React.DOM.input({
                    className: "save-game-name",
                    ref: "saveName",
                    type: "text",
                    maxLength: 64
                }), React.DOM.div({
                    className: "save-game-buttons-container"
                }, React.DOM.button({
                    className: "save-game-button",
                    onClick: this.handleSave,
                    ref: "okButton"
                }, "Save"), React.DOM.button({
                    className: "save-game-button",
                    onClick: this.handleClose
                }, "Cancel"))));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../popups/popupmanager.ts"/>
/// <reference path="savelist.ts"/>
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.LoadGame = React.createClass({
            displayName: "LoadGame",
            popupId: undefined,
            getInitialState: function () {
                return ({
                    saveKeysToDelete: [],
                    saveKey: null
                });
            },
            componentDidMount: function () {
                this.refs.okButton.getDOMNode().focus();
            },
            handleRowChange: function (row) {
                this.setState({
                    saveKey: row.data.storageKey
                });
                this.handleUndoDelete(row.data.storageKey);
            },
            handleLoad: function () {
                var saveKey = this.state.saveKey;
                var afterConfirmFN = function () {
                    // https://github.com/facebook/react/issues/2988
                    // https://github.com/facebook/react/issues/2605#issuecomment-118398797
                    // without this react will keep a reference to this element causing a big memory leak
                    this.refs.okButton.getDOMNode().blur();
                    window.setTimeout(function () {
                        app.load(saveKey);
                    }, 5);
                }.bind(this);
                if (this.state.saveKeysToDelete.indexOf(saveKey) !== -1) {
                    var boundClose = this.handleClose.bind(this, true, afterConfirmFN);
                    this.handleUndoDelete(saveKey, boundClose);
                }
                else {
                    this.handleClose(true, afterConfirmFN);
                }
            },
            deleteSelectedKeys: function () {
                this.popupId = this.refs.popupManager.makePopup({
                    contentConstructor: UIComponents.ConfirmPopup,
                    contentProps: this.getClosePopupContent(null, false, false)
                });
            },
            getClosePopupContent: function (afterCloseCallback, shouldCloseParent, shouldUndoAll) {
                if (shouldCloseParent === void 0) { shouldCloseParent = true; }
                if (shouldUndoAll === void 0) { shouldUndoAll = false; }
                var deleteFN = function () {
                    for (var i = 0; i < this.state.saveKeysToDelete.length; i++) {
                        localStorage.removeItem(this.state.saveKeysToDelete[i]);
                    }
                    this.setState({
                        saveKeysToDelete: []
                    });
                }.bind(this);
                var closeFN = function () {
                    this.popupId = undefined;
                    if (shouldCloseParent) {
                        this.props.handleClose();
                    }
                    if (shouldUndoAll) {
                        this.setState({
                            saveKeysToDelete: []
                        });
                    }
                    if (afterCloseCallback)
                        afterCloseCallback();
                }.bind(this);
                var confirmText = ["Are you sure you want to delete the following saves?"];
                confirmText = confirmText.concat(this.state.saveKeysToDelete.map(function (saveKey) {
                    return saveKey.replace("Rance.Save.", "");
                }));
                return ({
                    handleOk: deleteFN,
                    handleClose: closeFN,
                    contentText: confirmText
                });
            },
            updateClosePopup: function () {
                if (isFinite(this.popupId)) {
                    this.refs.popupManager.setPopupContent(this.popupId, { contentText: this.getClosePopupContent().contentText });
                }
                else if (this.state.saveKeysToDelete.length < 1) {
                    if (isFinite(this.popupID))
                        this.refs.popupManager.closePopup(this.popupId);
                    this.popupId = undefined;
                }
            },
            handleClose: function (deleteSaves, afterCloseCallback) {
                if (deleteSaves === void 0) { deleteSaves = true; }
                if (!deleteSaves || this.state.saveKeysToDelete.length < 1) {
                    this.props.handleClose();
                    if (afterCloseCallback)
                        afterCloseCallback();
                    return;
                }
                this.popupId = this.refs.popupManager.makePopup({
                    contentConstructor: UIComponents.ConfirmPopup,
                    contentProps: this.getClosePopupContent(afterCloseCallback, true, true)
                });
            },
            handleDelete: function (saveKey) {
                this.setState({
                    saveKeysToDelete: this.state.saveKeysToDelete.concat(saveKey)
                }, this.updateClosePopup);
            },
            handleUndoDelete: function (saveKey, callback) {
                var afterDeleteFN = function () {
                    this.updateClosePopup();
                    if (callback)
                        callback();
                };
                var i = this.state.saveKeysToDelete.indexOf(saveKey);
                if (i !== -1) {
                    var newsaveKeysToDelete = this.state.saveKeysToDelete.slice(0);
                    newsaveKeysToDelete.splice(i, 1);
                    this.setState({
                        saveKeysToDelete: newsaveKeysToDelete
                    }, afterDeleteFN);
                }
            },
            overRideLightBoxClose: function () {
                this.handleClose();
            },
            render: function () {
                return (React.DOM.div({
                    className: "save-game"
                }, UIComponents.PopupManager({
                    ref: "popupManager",
                    onlyAllowOne: true
                }), UIComponents.SaveList({
                    onRowChange: this.handleRowChange,
                    autoSelect: !Boolean(app.game.gameStorageKey),
                    selectedKey: app.game.gameStorageKey,
                    allowDelete: true,
                    onDelete: this.handleDelete,
                    onUndoDelete: this.handleUndoDelete,
                    saveKeysToDelete: this.state.saveKeysToDelete
                }), React.DOM.input({
                    className: "save-game-name",
                    type: "text",
                    value: this.state.saveKey ? this.state.saveKey.replace("Rance.Save.", "") : "",
                    readOnly: true
                }), React.DOM.div({
                    className: "save-game-buttons-container"
                }, React.DOM.button({
                    className: "save-game-button",
                    onClick: this.handleLoad,
                    ref: "okButton"
                }, "Load"), React.DOM.button({
                    className: "save-game-button",
                    onClick: this.handleClose.bind(this, true, null)
                }, "Cancel"), React.DOM.button({
                    className: "save-game-button",
                    onClick: this.deleteSelectedKeys,
                    disabled: this.state.saveKeysToDelete.length < 1
                }, "Delete"))));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="player.ts" />
var Rance;
(function (Rance) {
    var Trade = (function () {
        function Trade(player) {
            this.stagedItems = {};
            this.player = player;
            this.setAllTradeableItems();
        }
        Trade.prototype.setAllTradeableItems = function () {
            this.allItems =
                {
                    money: {
                        key: "money",
                        amount: this.player.money
                    }
                };
        };
        Trade.prototype.getItemsAvailableForTrade = function () {
            var available = {};
            for (var key in this.allItems) {
                var stagedAmount = this.stagedItems[key] ? this.stagedItems[key].amount : 0;
                available[key] =
                    {
                        key: key,
                        amount: this.allItems[key].amount - stagedAmount
                    };
            }
            return available;
        };
        Trade.prototype.removeStagedItem = function (key) {
            this.stagedItems[key] = null;
            delete this.stagedItems[key];
        };
        Trade.prototype.removeAllStagedItems = function () {
            for (var key in this.stagedItems) {
                this.removeStagedItem(key);
            }
        };
        Trade.prototype.stageItem = function (key, amount) {
            if (!this.stagedItems[key]) {
                this.stagedItems[key] =
                    {
                        key: key,
                        amount: amount
                    };
            }
            else {
                this.stagedItems[key].amount += amount;
                if (this.stagedItems[key].amount <= 0) {
                    this.removeStagedItem(key);
                }
            }
        };
        Trade.prototype.setStagedItemAmount = function (key, newAmount) {
            if (newAmount <= 0) {
                this.removeStagedItem(key);
            }
            else {
                var clamped = Math.min(this.allItems[key].amount, newAmount);
                this.stagedItems[key].amount = clamped;
            }
        };
        Trade.prototype.handleTradeOfItem = function (key, amount, targetPlayer) {
            switch (key) {
                case "money":
                    {
                        this.player.money -= amount;
                        targetPlayer.money += amount;
                    }
            }
        };
        Trade.prototype.executeAllStagedTrades = function (targetPlayer) {
            for (var key in this.stagedItems) {
                this.handleTradeOfItem(key, this.stagedItems[key].amount, targetPlayer);
            }
        };
        Trade.prototype.updateAfterExecutedTrade = function () {
            this.setAllTradeableItems();
            this.removeAllStagedItems();
        };
        return Trade;
    }());
    Rance.Trade = Trade;
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.TradeMoney = React.createClass({
            displayName: "TradeMoney",
            mixins: [UIComponents.Draggable],
            propTypes: {
                key: React.PropTypes.string.isRequired,
                moneyAmount: React.PropTypes.number.isRequired,
                title: React.PropTypes.string.isRequired,
                maxMoneyAvailable: React.PropTypes.number,
                onDragStart: React.PropTypes.func,
                onDragEnd: React.PropTypes.func,
                onClick: React.PropTypes.func,
                adjustItemAmount: React.PropTypes.func
            },
            onDragStart: function () {
                this.props.onDragStart(this.props.key);
            },
            onDragEnd: function () {
                this.props.onDragEnd();
            },
            handleClick: function () {
                this.props.onClick(this.props.key);
            },
            handleMoneyAmountChange: function (e) {
                var target = e.target;
                var value = parseInt(target.value);
                this.props.adjustItemAmount(this.props.key, value);
            },
            captureEvent: function (e) {
                e.stopPropagation();
            },
            render: function () {
                var rowProps = {
                    className: "tradeable-items-list-item"
                };
                if (this.props.onDragStart) {
                    rowProps.className += " draggable";
                    rowProps.onMouseDown = rowProps.onTouchStart = this.handleMouseDown;
                }
                if (this.state.dragging) {
                    rowProps.style = this.dragPos;
                    rowProps.className += " dragging";
                }
                else if (this.props.onClick) {
                    rowProps.onClick = this.handleClick;
                }
                var moneyElement;
                if (this.props.adjustItemAmount) {
                    var moneyProps = {
                        className: "trade-money-money-available trade-item-adjust",
                        type: "number",
                        min: 0,
                        max: this.props.maxMoneyAvailable,
                        step: 1,
                        value: this.props.moneyAmount,
                        onChange: this.handleMoneyAmountChange,
                        onClick: this.captureEvent,
                        onMouseDown: this.captureEvent,
                        onTouchStart: this.captureEvent
                    };
                    moneyElement = React.DOM.input(moneyProps);
                }
                else {
                    moneyElement = React.DOM.span({
                        className: "trade-money-money-available"
                    }, this.props.moneyAmount);
                }
                return (React.DOM.tr(rowProps, React.DOM.td(null, React.DOM.span({
                    className: "trade-money-title"
                }, this.props.title), moneyElement)));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../unitlist/list.ts" />
/// <reference path="trademoney.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.TradeableItemsList = React.createClass({
            displayName: "TradeableItemsList",
            propTypes: {
                tradeableItems: React.PropTypes.object,
                availableItems: React.PropTypes.object,
                noListHeader: React.PropTypes.bool,
                onDragStart: React.PropTypes.func,
                onDragEnd: React.PropTypes.func,
                onItemClick: React.PropTypes.func,
                adjustItemAmount: React.PropTypes.func
            },
            makeRowForTradeableItem: function (item) {
                switch (item.key) {
                    case "money":
                        {
                            return ({
                                key: "money",
                                data: {
                                    key: "money",
                                    rowConstructor: UIComponents.TradeMoney,
                                    title: "Money",
                                    moneyAmount: item.amount,
                                    sortOrder: 0,
                                    onDragStart: this.props.onDragStart,
                                    onDragEnd: this.props.onDragEnd,
                                    onClick: this.props.onItemClick,
                                    adjustItemAmount: this.props.adjustItemAmount,
                                    maxMoneyAvailable: (this.props.availableItems && this.props.availableItems["money"]) ?
                                        this.props.availableItems["money"].amount : undefined
                                }
                            });
                        }
                    default:
                        {
                            return ({
                                key: item.key,
                                data: {
                                    rowConstructor: UIComponents.TradeMoney,
                                    title: item.key,
                                    moneyAmount: item.amount,
                                    sortOrder: 1
                                }
                            });
                        }
                }
            },
            render: function () {
                var tradeableItems = this.props.tradeableItems;
                var rows = [];
                for (var key in tradeableItems) {
                    rows.push(this.makeRowForTradeableItem(tradeableItems[key]));
                }
                var columns = [
                    {
                        label: "Item",
                        key: "item",
                        defaultOrder: "asc",
                        propToSortBy: "sortOrder"
                    }
                ];
                return (React.DOM.div({
                    className: "tradeable-items-list fixed-table-parent"
                }, UIComponents.List({
                    listItems: rows,
                    initialColumns: columns,
                    initialSortOrder: [columns[0]],
                    noHeader: this.props.noListHeader
                })));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../../player.ts" />
/// <reference path="tradeableitemslist.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.TradeableItems = React.createClass({
            displayName: "TradeableItems",
            mixins: [UIComponents.DropTarget],
            propTypes: {
                tradeableItems: React.PropTypes.object.isRequired,
                availableItems: React.PropTypes.object,
                header: React.PropTypes.string,
                noListHeader: React.PropTypes.bool,
                onMouseUp: React.PropTypes.func,
                onDragStart: React.PropTypes.func,
                onDragEnd: React.PropTypes.func,
                hasDragItem: React.PropTypes.bool,
                isInvalidDropTarget: React.PropTypes.bool,
                onItemClick: React.PropTypes.func,
                adjustItemAmount: React.PropTypes.func
            },
            handleMouseUp: function () {
                this.props.onMouseUp();
            },
            render: function () {
                var divProps = {
                    className: "tradeable-items"
                };
                if (this.props.onMouseUp) {
                    divProps.onMouseUp = this.handleMouseUp;
                }
                if (this.props.isInvalidDropTarget) {
                    divProps.className += " invalid-drop-target";
                }
                return (React.DOM.div(divProps, !this.props.header ? null : React.DOM.div({
                    className: "tradeable-items-header"
                }, this.props.header), UIComponents.TradeableItemsList({
                    tradeableItems: this.props.tradeableItems,
                    availableItems: this.props.availableItems,
                    noListHeader: this.props.noListHeader,
                    onDragStart: this.props.onDragStart,
                    onDragEnd: this.props.onDragEnd,
                    onItemClick: this.props.onItemClick,
                    adjustItemAmount: this.props.adjustItemAmount
                })));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../../player.ts" />
/// <reference path="../../trade.ts" />
/// <reference path="tradeableitems.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.TradeOverview = React.createClass({
            displayName: "TradeOverview",
            selfPlayerTrade: undefined,
            otherPlayerTrade: undefined,
            propTypes: {
                selfPlayer: React.PropTypes.instanceOf(Rance.Player).isRequired,
                otherPlayer: React.PropTypes.instanceOf(Rance.Player).isRequired,
                handleClose: React.PropTypes.func.isRequired
            },
            componentWillMount: function () {
                this.selfPlayerTrade = new Rance.Trade(this.props.selfPlayer);
                this.otherPlayerTrade = new Rance.Trade(this.props.otherPlayer);
            },
            getInitialState: function () {
                return ({
                    currentAvailableItemDragKey: undefined,
                    currentStagingItemDragKey: undefined,
                    currentDragItemPlayer: undefined
                });
            },
            handleCancel: function () {
                this.props.handleClose();
            },
            handleOk: function () {
                this.selfPlayerTrade.executeAllStagedTrades(this.props.otherPlayer);
                this.otherPlayerTrade.executeAllStagedTrades(this.props.selfPlayer);
                this.selfPlayerTrade.updateAfterExecutedTrade();
                this.otherPlayerTrade.updateAfterExecutedTrade();
                this.forceUpdate();
            },
            getActiveTrade: function (player) {
                var playerStringToUse = player || this.state.currentDragItemPlayer;
                if (playerStringToUse === "self") {
                    return this.selfPlayerTrade;
                }
                else if (playerStringToUse === "other") {
                    return this.otherPlayerTrade;
                }
                else
                    return null;
            },
            handleStageItem: function (player, key) {
                var activeTrade = this.getActiveTrade(player);
                var availableItems = activeTrade.getItemsAvailableForTrade();
                var availableAmount = availableItems[key].amount;
                if (availableAmount === 1) {
                    activeTrade.stageItem(key, 1);
                }
                else {
                    // TODO trade TODO ai | don't allow player to stage ai items
                    activeTrade.stageItem(key, availableAmount);
                }
                if (!this.state.currentDragItemPlayer) {
                    this.forceUpdate();
                }
            },
            handleAdjustStagedItemAmount: function (player, key, newAmount) {
                var activeTrade = this.getActiveTrade(player);
                {
                    activeTrade.setStagedItemAmount(key, newAmount);
                }
                this.forceUpdate();
            },
            handleRemoveStagedItem: function (player, key) {
                var activeTrade = this.getActiveTrade(player);
                activeTrade.removeStagedItem(key);
                if (!this.state.currentDragItemPlayer) {
                    this.forceUpdate();
                }
            },
            handleAvailableDragStart: function (player, key) {
                this.setState({
                    currentAvailableItemDragKey: key,
                    currentDragItemPlayer: player
                });
            },
            handleStagingDragStart: function (player, key) {
                this.setState({
                    currentStagingItemDragKey: key,
                    currentDragItemPlayer: player
                });
            },
            handleDragEnd: function () {
                this.setState({
                    currentAvailableItemDragKey: undefined,
                    currentStagingItemDragKey: undefined,
                    currentDragItemPlayer: undefined
                });
            },
            handleAvailableMouseUp: function () {
                if (this.state.currentStagingItemDragKey) {
                    this.handleRemoveStagedItem(null, this.state.currentStagingItemDragKey);
                }
            },
            handleStagingAreaMouseUp: function () {
                if (this.state.currentAvailableItemDragKey) {
                    this.handleStageItem(null, this.state.currentAvailableItemDragKey);
                }
            },
            render: function () {
                var hasDragItem = Boolean(this.state.currentDragItemPlayer);
                var selfPlayerAcceptsDrop = this.state.currentDragItemPlayer === "self";
                var otherPlayerAcceptsDrop = this.state.currentDragItemPlayer === "other";
                var selfAvailableItems = this.selfPlayerTrade.getItemsAvailableForTrade();
                var otherAvailableItems = this.otherPlayerTrade.getItemsAvailableForTrade();
                return (React.DOM.div({
                    className: "trade-overview"
                }, React.DOM.div({
                    className: "tradeable-items-container available-items-container"
                }, UIComponents.TradeableItems({
                    header: "tradeable items " + this.props.selfPlayer.name,
                    tradeableItems: selfAvailableItems,
                    noListHeader: true,
                    isInvalidDropTarget: hasDragItem && !selfPlayerAcceptsDrop,
                    onDragStart: this.handleAvailableDragStart.bind(this, "self"),
                    onDragEnd: this.handleDragEnd,
                    onMouseUp: this.handleAvailableMouseUp,
                    onItemClick: this.handleStageItem.bind(this, "self")
                }), UIComponents.TradeableItems({
                    header: "tradeable items " + this.props.otherPlayer.name,
                    tradeableItems: otherAvailableItems,
                    noListHeader: true,
                    isInvalidDropTarget: hasDragItem && !otherPlayerAcceptsDrop,
                    onDragStart: this.handleAvailableDragStart.bind(this, "other"),
                    onDragEnd: this.handleDragEnd,
                    onMouseUp: this.handleAvailableMouseUp,
                    onItemClick: this.handleStageItem.bind(this, "other")
                })), React.DOM.div({
                    className: "tradeable-items-container trade-staging-areas-container"
                }, UIComponents.TradeableItems({
                    tradeableItems: this.selfPlayerTrade.stagedItems,
                    availableItems: this.selfPlayerTrade.allItems,
                    noListHeader: true,
                    isInvalidDropTarget: hasDragItem && !selfPlayerAcceptsDrop,
                    onDragStart: this.handleStagingDragStart.bind(this, "self"),
                    onDragEnd: this.handleDragEnd,
                    onMouseUp: this.handleStagingAreaMouseUp,
                    onItemClick: this.handleRemoveStagedItem.bind(this, "self"),
                    adjustItemAmount: this.handleAdjustStagedItemAmount.bind(this, "self")
                }), UIComponents.TradeableItems({
                    tradeableItems: this.otherPlayerTrade.stagedItems,
                    availableItems: this.otherPlayerTrade.allItems,
                    noListHeader: true,
                    isInvalidDropTarget: hasDragItem && !otherPlayerAcceptsDrop,
                    onDragStart: this.handleStagingDragStart.bind(this, "other"),
                    onDragEnd: this.handleDragEnd,
                    onMouseUp: this.handleStagingAreaMouseUp,
                    onItemClick: this.handleRemoveStagedItem.bind(this, "other"),
                    adjustItemAmount: this.handleAdjustStagedItemAmount.bind(this, "other")
                })), React.DOM.div({
                    className: "trade-buttons-container"
                }, React.DOM.button({
                    className: "trade-button",
                    onClick: this.handleCancel
                }, "Cancel"), React.DOM.button({
                    className: "trade-button trade-button-ok",
                    onClick: this.handleOk
                }, "Ok"))));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../../player.ts" />
/// <reference path="../trade/tradeoverview.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.DiplomacyActions = React.createClass({
            displayName: "DiplomacyActions",
            propTypes: {
                player: React.PropTypes.instanceOf(Rance.Player).isRequired,
                targetPlayer: React.PropTypes.instanceOf(Rance.Player).isRequired,
                onUpdate: React.PropTypes.func.isRequired
            },
            getInitialState: function () {
                return ({
                    trade: undefined
                });
            },
            closePopup: function (popupType) {
                this.refs.popupManager.closePopup(this.state[popupType]);
                var stateObj = {};
                stateObj[popupType] = undefined;
                this.setState(stateObj);
            },
            makePopup: function (popupType) {
                var contentConstructor;
                var contentProps;
                var popupProps = {
                    resizable: true,
                    containerDragOnly: true,
                    minWidth: 150,
                    minHeight: 50,
                    preventAutoResize: true
                };
                switch (popupType) {
                    case "trade":
                        {
                            contentConstructor = UIComponents.TradeOverview;
                            contentProps =
                                {
                                    selfPlayer: this.props.player,
                                    otherPlayer: this.props.targetPlayer,
                                    handleClose: this.closePopup.bind(this, popupType)
                                };
                            break;
                        }
                }
                var id = this.refs.popupManager.makePopup({
                    contentConstructor: UIComponents.TopMenuPopup,
                    contentProps: {
                        contentConstructor: contentConstructor,
                        contentProps: contentProps,
                        handleClose: this.closePopup.bind(this, popupType)
                    },
                    popupProps: popupProps
                });
                var stateObj = {};
                stateObj[popupType] = id;
                this.setState(stateObj);
            },
            togglePopup: function (popupType) {
                if (isFinite(this.state[popupType])) {
                    this.closePopup(popupType);
                }
                else {
                    this.makePopup(popupType);
                }
            },
            handleDeclareWar: function () {
                this.props.player.diplomacyStatus.declareWarOn(this.props.targetPlayer);
                this.props.onUpdate();
            },
            handleMakePeace: function () {
                this.props.player.diplomacyStatus.makePeaceWith(this.props.targetPlayer);
                this.props.onUpdate();
            },
            render: function () {
                var player = this.props.player;
                var targetPlayer = this.props.targetPlayer;
                var declareWarProps = {
                    className: "diplomacy-action-button"
                };
                if (player.diplomacyStatus.canDeclareWarOn(targetPlayer)) {
                    declareWarProps.onClick = this.handleDeclareWar;
                }
                else {
                    declareWarProps.disabled = true;
                    declareWarProps.className += " disabled";
                }
                var makePeaceProps = {
                    className: "diplomacy-action-button"
                };
                if (player.diplomacyStatus.canMakePeaceWith(targetPlayer)) {
                    makePeaceProps.onClick = this.handleMakePeace;
                }
                else {
                    makePeaceProps.disabled = true;
                    makePeaceProps.className += " disabled";
                }
                return (React.DOM.div({
                    className: "diplomacy-actions-container draggable-container"
                }, UIComponents.PopupManager({
                    ref: "popupManager",
                    onlyAllowOne: true
                }), React.DOM.button({
                    className: "light-box-close",
                    onClick: this.props.closePopup
                }, "X"), React.DOM.div({
                    className: "diplomacy-actions"
                }, React.DOM.div({
                    className: "diplomacy-actions-header"
                }, targetPlayer.name), React.DOM.button(declareWarProps, "Declare war"), React.DOM.button(makePeaceProps, "Make peace"), React.DOM.button({
                    className: "diplomacy-action-button",
                    onClick: this.togglePopup.bind(this, "trade")
                }, "Trade"))));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.AutoPosition = {
            componentDidMount: function () {
                if (this.props.autoPosition) {
                    this.setAutoPosition();
                }
            },
            componentDidUpdate: function () {
                if (this.props.autoPosition) {
                    this.setAutoPosition();
                }
            },
            flipSide: function (side) {
                switch (side) {
                    case "top":
                        {
                            return "bottom";
                        }
                    case "bottom":
                        {
                            return "top";
                        }
                    case "left":
                        {
                            return "right";
                        }
                    case "right":
                        {
                            return "left";
                        }
                    default:
                        {
                            throw new Error("Invalid side");
                        }
                }
            },
            elementFitsYSide: function (side, ownRect, parentRect) {
                switch (side) {
                    case "top":
                        {
                            return parentRect.top - ownRect.height >= 0;
                        }
                    case "bottom":
                        {
                            return parentRect.bottom + ownRect.height < window.innerHeight;
                        }
                    default:
                        {
                            throw new Error("Invalid side");
                        }
                }
            },
            elementFitsXSide: function (side, ownRect, parentRect) {
                switch (side) {
                    case "left":
                        {
                            return parentRect.left + ownRect.width < window.innerWidth;
                        }
                    case "right":
                        {
                            return parentRect.right - ownRect.width >= 0;
                        }
                    default:
                        {
                            throw new Error("Invalid side");
                        }
                }
            },
            setAutoPosition: function () {
                /*
                try to fit prefered y
                  flip if doesnt fit
                try to fit prefered x alignment
                  flip if doesnt fit
                 */
                var parentRect = this.props.getParentNode().getBoundingClientRect();
                var ownNode = this.getDOMNode();
                var rect = ownNode.getBoundingClientRect();
                var ySide = this.props.ySide || "top";
                var xSide = this.props.xSide || "right";
                var yMargin = this.props.yMargin || 0;
                var xMargin = this.props.xMargin || 0;
                var fitsY = this.elementFitsYSide(ySide, rect, parentRect);
                if (!fitsY) {
                    ySide = this.flipSide(ySide);
                }
                var fitsX = this.elementFitsXSide(xSide, rect, parentRect);
                if (!fitsX) {
                    xSide = this.flipSide(xSide);
                }
                var top = null;
                var left = null;
                if (ySide === "top") {
                    top = parentRect.top - rect.height - yMargin;
                }
                else {
                    top = parentRect.bottom + yMargin;
                }
                if (xSide === "left") {
                    left = parentRect.left - xMargin;
                }
                else {
                    left = parentRect.right - rect.width + xMargin;
                }
                ownNode.style.left = "" + left + "px";
                ownNode.style.top = "" + top + "px";
            }
        };
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.AttitudeModifierInfo = React.createClass({
            displayName: "AttitudeModifierInfo",
            makeCell: function (type) {
                var cellProps = {};
                cellProps.key = type;
                cellProps.className = "attitude-modifier-info-cell" +
                    " attitude-modifier-info-" + type;
                var cellContent;
                switch (type) {
                    case "endTurn":
                        {
                            if (this.props.endTurn < 0) {
                                cellContent = null;
                                return;
                            }
                        }
                    case "strength":
                        {
                            var relativeValue = Rance.getRelativeValue(this.props.strength, -20, 20);
                            relativeValue = Rance.clamp(relativeValue, 0, 1);
                            var deviation = Math.abs(0.5 - relativeValue) * 2;
                            var hue = 110 * relativeValue;
                            var saturation = 0 + 50 * deviation;
                            if (deviation > 0.3)
                                saturation += 40;
                            var lightness = 70 - 20 * deviation;
                            cellProps.style =
                                {
                                    color: "hsl(" +
                                        hue + "," +
                                        saturation + "%," +
                                        lightness + "%)"
                                };
                        }
                    default:
                        {
                            cellContent = this.props[type];
                            if (isFinite(cellContent)) {
                                cellProps.className += " center-text";
                            }
                            break;
                        }
                }
                return (React.DOM.td(cellProps, cellContent));
            },
            render: function () {
                var columns = this.props.activeColumns;
                var cells = [];
                for (var i = 0; i < columns.length; i++) {
                    var cell = this.makeCell(columns[i].key);
                    cells.push(cell);
                }
                var rowProps = {
                    className: "diplomatic-status-player",
                    onClick: this.props.handleClick
                };
                return (React.DOM.tr(rowProps, cells));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../mixins/autoposition.ts" />
/// <reference path="attitudemodifierinfo.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.AttitudeModifierList = React.createClass({
            displayName: "AttitudeModifierList",
            mixins: [UIComponents.AutoPosition],
            render: function () {
                var modifiers = this.props.attitudeModifiers;
                var rows = [];
                rows.push({
                    key: "baseOpinion",
                    data: {
                        name: "AI Personality",
                        strength: this.props.baseOpinion,
                        endTurn: -1,
                        sortOrder: -1,
                        rowConstructor: UIComponents.AttitudeModifierInfo
                    }
                });
                for (var i = 0; i < modifiers.length; i++) {
                    var modifier = modifiers[i];
                    if (modifier.isOverRidden)
                        continue;
                    rows.push({
                        key: modifier.template.type,
                        data: {
                            name: modifier.template.displayName,
                            strength: modifier.getAdjustedStrength(),
                            endTurn: modifier.endTurn,
                            sortOrder: 0,
                            rowConstructor: UIComponents.AttitudeModifierInfo
                        }
                    });
                }
                var columns = [
                    {
                        label: "Name",
                        key: "name",
                        defaultOrder: "asc",
                        propToSortBy: "sortOrder"
                    },
                    {
                        label: "Effect",
                        key: "strength",
                        defaultOrder: "asc"
                    },
                    {
                        label: "Ends on",
                        key: "endTurn",
                        defaultOrder: "desc"
                    }
                ];
                return (React.DOM.div({ className: "attitude-modifier-list auto-position fixed-table-parent" }, UIComponents.List({
                    listItems: rows,
                    initialColumns: columns,
                    initialSortOrder: [columns[0], columns[1], columns[2]]
                })));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="attitudemodifierlist.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.Opinion = React.createClass({
            displayName: "Opinion",
            getInitialState: function () {
                return ({
                    hasAttitudeModifierTootlip: false
                });
            },
            setTooltip: function () {
                this.setState({ hasAttitudeModifierTootlip: true });
            },
            clearTooltip: function () {
                this.setState({ hasAttitudeModifierTootlip: false });
            },
            getOpinionTextNode: function () {
                return this.getDOMNode().firstChild;
            },
            getColor: function () {
                var relativeValue = Rance.getRelativeValue(this.props.opinion, -30, 30);
                relativeValue = Rance.clamp(relativeValue, 0, 1);
                var deviation = Math.abs(0.5 - relativeValue) * 2;
                var hue = 110 * relativeValue;
                var saturation = 0 + 50 * deviation;
                if (deviation > 0.3)
                    saturation += 40;
                var lightness = 70 - 20 * deviation;
                return ("hsl(" +
                    hue + "," +
                    saturation + "%," +
                    lightness + "%)");
            },
            render: function () {
                var tooltip = null;
                if (this.state.hasAttitudeModifierTootlip) {
                    tooltip = UIComponents.AttitudeModifierList({
                        attitudeModifiers: this.props.attitudeModifiers,
                        baseOpinion: this.props.baseOpinion,
                        onLeave: this.clearTooltip,
                        getParentNode: this.getOpinionTextNode,
                        autoPosition: true,
                        ySide: "top",
                        xSide: "right",
                        yMargin: 10
                    });
                }
                return (React.DOM.div({
                    className: "player-opinion",
                    onMouseEnter: this.setTooltip,
                    onMouseLeave: this.clearTooltip
                }, React.DOM.span({
                    style: {
                        color: this.getColor()
                    }
                }, this.props.opinion), tooltip));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../playerflag.ts" />
/// <reference path="opinion.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.DiplomaticStatusPlayer = React.createClass({
            displayName: "DiplomaticStatusPlayer",
            getInitialState: function () {
                return ({
                    hasAttitudeModifierTootlip: false
                });
            },
            makeCell: function (type) {
                var className = "diplomatic-status-player-cell" + " diplomatic-status-" + type;
                if (type === "flag") {
                    if (!this.props.player) {
                        return (React.DOM.td({
                            key: type,
                            className: className
                        }, null));
                    }
                    return (React.DOM.td({
                        key: type,
                        className: className
                    }, UIComponents.PlayerFlag({
                        flag: this.props.player.flag,
                        props: {
                            className: "diplomacy-status-player-icon"
                        }
                    })));
                }
                if (type === "opinion") {
                    return (React.DOM.td({
                        key: type,
                        className: className
                    }, UIComponents.Opinion({
                        attitudeModifiers: this.props.attitudeModifiers,
                        opinion: this.props.opinion,
                        baseOpinion: this.props.baseOpinion
                    })));
                }
                if (type === "player") {
                    className += " player-name";
                }
                return (React.DOM.td({
                    key: type,
                    className: className
                }, this.props[type]));
            },
            render: function () {
                var columns = this.props.activeColumns;
                var cells = [];
                for (var i = 0; i < columns.length; i++) {
                    var cell = this.makeCell(columns[i].key);
                    cells.push(cell);
                }
                var rowProps = {
                    className: "diplomatic-status-player",
                    onClick: this.props.handleClick
                };
                return (React.DOM.tr(rowProps, cells));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="diplomacyactions.ts" />
/// <reference path="diplomaticstatusplayer.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.DiplomacyOverview = React.createClass({
            displayName: "DiplomacyOverview",
            makeDiplomacyActionsPopup: function (rowItem) {
                var player = rowItem.data.player;
                if (!player)
                    return;
                this.refs.popupManager.makePopup({
                    contentConstructor: UIComponents.DiplomacyActions,
                    contentProps: {
                        player: this.props.player,
                        targetPlayer: player,
                        onUpdate: this.forceUpdate.bind(this)
                    },
                    popupProps: {
                        preventAutoResize: true,
                        containerDragOnly: true
                    }
                });
            },
            render: function () {
                var unmetPlayerCount = this.props.totalPlayerCount -
                    Object.keys(this.props.metPlayers).length - 1;
                var rows = [];
                for (var playerId in this.props.statusByPlayer) {
                    var player = this.props.metPlayers[playerId];
                    var status = this.props.player.diplomacyStatus.statusByPlayer[playerId];
                    rows.push({
                        key: player.id,
                        data: {
                            player: player,
                            name: player.name,
                            baseOpinion: player.diplomacyStatus.getBaseOpinion(),
                            status: Rance.DiplomaticState[status],
                            statusEnum: status,
                            opinion: player.diplomacyStatus.getOpinionOf(this.props.player),
                            attitudeModifiers: player.diplomacyStatus.attitudeModifiersByPlayer[this.props.player.id],
                            rowConstructor: UIComponents.DiplomaticStatusPlayer
                        }
                    });
                }
                for (var i = 0; i < unmetPlayerCount; i++) {
                    rows.push({
                        key: "unmet" + i,
                        data: {
                            name: "?????",
                            status: "unmet",
                            statusEnum: 99999 + i,
                            opinion: null,
                            rowConstructor: UIComponents.DiplomaticStatusPlayer
                        }
                    });
                }
                var columns = [
                    {
                        label: "",
                        key: "flag",
                        defaultOrder: "asc",
                        propToSortBy: "name"
                    },
                    {
                        label: "Name",
                        key: "name",
                        defaultOrder: "asc"
                    },
                    {
                        label: "Status",
                        key: "status",
                        defaultOrder: "asc",
                        propToSortBy: "statusEnum"
                    },
                    {
                        label: "Opinion",
                        key: "opinion",
                        defaultOrder: "desc"
                    }
                ];
                return (React.DOM.div({ className: "diplomacy-overview" }, UIComponents.PopupManager({
                    ref: "popupManager",
                    onlyAllowOne: true
                }), React.DOM.div({ className: "diplomacy-status-list fixed-table-parent" }, UIComponents.List({
                    listItems: rows,
                    initialColumns: columns,
                    initialSortOrder: [columns[0]],
                    onRowChange: this.makeDiplomacyActionsPopup
                }))));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.EconomySummaryItem = React.createClass({
            displayName: "EconomySummaryItem",
            makeCell: function (type) {
                var cellProps = {};
                cellProps.key = type;
                cellProps.className = "economy-summary-item-cell" + " economy-summary-" + type;
                var cellContent;
                switch (type) {
                    default:
                        {
                            cellContent = this.props[type];
                            break;
                        }
                }
                return (React.DOM.td(cellProps, cellContent));
            },
            render: function () {
                var columns = this.props.activeColumns;
                var cells = [];
                for (var i = 0; i < columns.length; i++) {
                    var cell = this.makeCell(columns[i].key);
                    cells.push(cell);
                }
                var rowProps = {
                    className: "economy-summary-item",
                    onClick: this.props.handleClick
                };
                if (this.props.isSelected) {
                    rowProps.className += " selected";
                }
                ;
                return (React.DOM.tr(rowProps, cells));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../unitlist/list.ts"/>
/// <reference path="economysummaryitem.ts"/>
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.EconomySummary = React.createClass({
            displayName: "EconomySummary",
            render: function () {
                var rows = [];
                var player = this.props.player;
                for (var i = 0; i < player.controlledLocations.length; i++) {
                    var star = player.controlledLocations[i];
                    var data = {
                        star: star,
                        id: star.id,
                        name: star.name,
                        income: star.getIncome(),
                        rowConstructor: UIComponents.EconomySummaryItem
                    };
                    rows.push({
                        key: star.id,
                        data: data
                    });
                }
                var columns = [
                    {
                        label: "Id",
                        key: "id",
                        defaultOrder: "asc"
                    },
                    {
                        label: "Name",
                        key: "name",
                        defaultOrder: "asc"
                    },
                    {
                        label: "Income",
                        key: "income",
                        defaultOrder: "desc"
                    }
                ];
                return (React.DOM.div({ className: "economy-summary-list fixed-table-parent" }, UIComponents.List({
                    listItems: rows,
                    initialColumns: columns,
                    initialSortOrder: [columns[2]]
                })));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.OptionsGroup = React.createClass({
            displayName: "OptionsGroup",
            propTypes: {
                isCollapsedInitially: React.PropTypes.bool,
                resetFN: React.PropTypes.func,
                header: React.PropTypes.string,
                options: React.PropTypes.arrayOf(React.PropTypes.object).isRequired
            },
            getInitialState: function () {
                return ({
                    isCollapsed: this.props.isCollapsedInitially || false
                });
            },
            toggleCollapse: function () {
                this.setState({
                    isCollapsed: !this.state.isCollapsed
                });
            },
            render: function () {
                var rows = [];
                if (!this.state.isCollapsed) {
                    for (var i = 0; i < this.props.options.length; i++) {
                        var option = this.props.options[i];
                        rows.push(React.DOM.div({
                            className: "option-container",
                            key: option.key
                        }, option.content));
                    }
                }
                var resetButton = null;
                if (this.props.resetFN) {
                    resetButton = React.DOM.button({
                        className: "reset-options-button",
                        onClick: this.props.resetFN
                    }, "reset");
                }
                var header = this.props.header || resetButton ?
                    React.DOM.div({
                        className: "option-group-header"
                    }, React.DOM.div({
                        className: "option-group-header-title collapsible" + (this.state.isCollapsed ? " collapsed" : ""),
                        onClick: this.toggleCollapse
                    }, this.props.header), resetButton) :
                    null;
                return (React.DOM.div({ className: "option-group" }, header, rows));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.NotificationFilterListItem = React.createClass({
            displayName: "NotificationFilterListItem",
            propTypes: {
                displayName: React.PropTypes.string.isRequired,
                filterState: React.PropTypes.arrayOf(React.PropTypes.number).isRequired,
                key: React.PropTypes.string.isRequired,
                filter: React.PropTypes.instanceOf(Rance.NotificationFilter).isRequired,
                isHighlighted: React.PropTypes.bool.isRequired
            },
            getInitialState: function () {
                return ({
                    filterState: this.props.filterState
                });
            },
            componentWillReceiveProps: function (newProps) {
                this.setState({
                    filterState: newProps.filterState
                });
            },
            handleChangeState: function (state) {
                var filter = this.props.filter;
                filter.handleFilterStateChange(this.props.key, state);
                filter.save();
                this.setState({
                    filterState: filter.filters[this.props.key]
                });
                Rance.eventManager.dispatchEvent("updateNotificationLog");
            },
            render: function () {
                var inputElements = [];
                var filterState = this.state.filterState;
                for (var state in Rance.NotificationFilterState) {
                    var numericState = parseInt(state);
                    if (!isFinite(numericState))
                        continue;
                    var stateIsActive = filterState.indexOf(numericState) !== -1;
                    inputElements.push(React.DOM.input({
                        className: "notification-filter-list-item-filter",
                        type: "checkbox",
                        id: this.props.key,
                        key: state,
                        checked: stateIsActive,
                        onChange: this.handleChangeState.bind(this, numericState),
                        title: Rance.NotificationFilterState[numericState]
                    }));
                }
                return (React.DOM.div({
                    className: "notification-filter-list-item" + (this.props.isHighlighted ? " highlighted" : "")
                }, React.DOM.label({
                    className: "notification-filter-list-item-label",
                    htmlFor: this.props.key
                }, this.props.displayName), React.DOM.div({
                    className: "notification-filter-list-item-filters"
                }, inputElements)));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../galaxymap/optionsgroup.ts" />
/// <reference path="notificationfilterlistitem.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.NotificationFilterList = React.createClass({
            displayName: "NotificationFilterList",
            propTypes: {
                filter: React.PropTypes.instanceOf(Rance.NotificationFilter).isRequired,
                highlightedOptionKey: React.PropTypes.string
            },
            handleResetCategory: function (category) {
                var filter = this.props.filter;
                filter.setDefaultFilterStatesForCategory(category);
                filter.save();
                this.forceUpdate();
                Rance.eventManager.dispatchEvent("updateNotificationLog");
            },
            scrollToHighlighted: function () {
                if (this.props.highlightedOptionKey) {
                    var domNode = this.refs["body"].getDOMNode();
                    var highlightedNode = domNode.getElementsByClassName("highlighted")[0];
                    domNode.scrollTop = highlightedNode.offsetTop + domNode.scrollHeight / 3;
                }
            },
            render: function () {
                var filter = this.props.filter;
                var filtersByCategory = filter.getFiltersByCategory();
                var filterGroupElements = [];
                for (var category in filtersByCategory) {
                    var filtersForCategory = filtersByCategory[category];
                    var filterElementsForCategory = [];
                    for (var i = 0; i < filtersForCategory.length; i++) {
                        var notificationTemplate = filtersForCategory[i].notificationTemplate;
                        var isHighlighted = Boolean(this.props.highlightedOptionKey &&
                            this.props.highlightedOptionKey === notificationTemplate.key);
                        filterElementsForCategory.push({
                            key: notificationTemplate.key,
                            content: UIComponents.NotificationFilterListItem({
                                displayName: notificationTemplate.displayName,
                                filter: filter,
                                filterState: filtersForCategory[i].filterState,
                                key: notificationTemplate.key,
                                isHighlighted: isHighlighted
                            })
                        });
                    }
                    filterGroupElements.push(UIComponents.OptionsGroup({
                        header: category,
                        options: filterElementsForCategory,
                        key: category,
                        resetFN: this.handleResetCategory.bind(this, category)
                    }));
                }
                return (React.DOM.div({
                    className: "notification-filter-list"
                }, React.DOM.div({
                    className: "notification-filter-list-header"
                }, React.DOM.div({
                    className: "notification-filter-list-item-label"
                }, "Show"), React.DOM.div({
                    className: "notification-filter-list-item-filters"
                }, "Always", "Involved", "Never")), React.DOM.div({
                    className: "notification-filter-list-body",
                    ref: "body"
                }, filterGroupElements)));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../../notificationfilter.ts" />
/// <reference path="notificationfilterlist.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.NotificationFilterButton = React.createClass({
            displayName: "NotificationFilterButton",
            propTypes: {
                filter: React.PropTypes.instanceOf(Rance.NotificationFilter).isRequired,
                text: React.PropTypes.string.isRequired,
                highlightedOptionKey: React.PropTypes.string
            },
            getInitialState: function () {
                return ({
                    notificationFilterPopup: undefined
                });
            },
            makePopup: function () {
                var scrollToHighlightedFN = function () {
                    var popup = this.refs[this.popupId - 1];
                    var content = popup.refs["content"].refs["content"];
                    content.scrollToHighlighted();
                }.bind(this.refs.popupManager);
                var popupId = this.refs.popupManager.makePopup({
                    contentConstructor: UIComponents.TopMenuPopup,
                    contentProps: {
                        contentConstructor: UIComponents.NotificationFilterList,
                        contentProps: {
                            filter: this.props.filter,
                            highlightedOptionKey: this.props.highlightedOptionKey
                        },
                        handleClose: this.closePopup
                    },
                    popupProps: {
                        containerDragOnly: true,
                        preventAutoResize: true,
                        resizable: true,
                        minWidth: 440,
                        minHeight: 150,
                        finishedMountingCallback: scrollToHighlightedFN
                    }
                });
                this.setState({
                    notificationFilterPopup: popupId
                });
            },
            closePopup: function () {
                this.refs.popupManager.closePopup(this.state.notificationFilterPopup);
                this.setState({
                    notificationFilterPopup: undefined
                });
            },
            togglePopup: function () {
                if (isFinite(this.state.notificationFilterPopup)) {
                    this.closePopup();
                }
                else {
                    this.makePopup();
                }
            },
            render: function () {
                return (React.DOM.div({
                    className: "notification-filter-button-container"
                }, React.DOM.button({
                    className: "notification-filter-button",
                    onClick: this.togglePopup
                }, this.props.text), UIComponents.PopupManager({
                    ref: "popupManager",
                    onlyAllowOne: true
                })));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.OptionsCheckbox = React.createClass({
            displayName: "OptionsCheckbox",
            render: function () {
                var key = "options-checkbox-" + this.props.label;
                return (React.DOM.div({
                    className: "options-checkbox-container"
                }, React.DOM.input({
                    type: "checkbox",
                    id: key,
                    checked: this.props.isChecked,
                    onChange: this.props.onChangeFN
                }), React.DOM.label({
                    htmlFor: key
                }, this.props.label)));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.OptionsNumericField = React.createClass({
            displayName: "OptionsNumericField",
            propTypes: {
                onChangeFN: React.PropTypes.func.isRequired,
                label: React.PropTypes.string.isRequired,
                id: React.PropTypes.string.isRequired,
                value: React.PropTypes.number.isRequired,
                min: React.PropTypes.number.isRequired,
                max: React.PropTypes.number.isRequired,
                step: React.PropTypes.number.isRequired,
            },
            getInitialState: function () {
                return ({
                    value: this.props.value
                });
            },
            componentWillReceiveProps: function (newProps) {
                if (newProps.value !== this.state.value) {
                    this.setState({ value: newProps.value });
                }
            },
            triggerOnChangeFN: function () {
                this.props.onChangeFN(this.state.value);
            },
            handleChange: function (e) {
                var target = e.target;
                var value = parseFloat(target.value);
                if (!isFinite(value)) {
                    return;
                }
                value = Rance.clamp(value, parseFloat(target.min), parseFloat(target.max));
                this.setState({
                    value: value
                }, this.triggerOnChangeFN);
            },
            render: function () {
                var inputId = "" + this.props.id + "-input";
                return (React.DOM.div({
                    className: "options-numeric-field-container",
                    id: this.props.id
                }, React.DOM.input({
                    className: "options-numeric-field-input",
                    type: "number",
                    id: inputId,
                    value: this.state.value,
                    min: this.props.min,
                    max: this.props.max,
                    step: this.props.step,
                    onChange: this.handleChange
                }, null), React.DOM.label({
                    className: "options-numeric-field-label",
                    htmlFor: inputId
                }, this.props.label)));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../popups/popupmanager.ts"/>
/// <reference path="../notifications/notificationfilterbutton.ts" />
/// <reference path="optionsgroup.ts"/>
/// <reference path="optionscheckbox.ts" />
/// <reference path="optionsnumericfield.ts" />
/// <reference path="../../notificationlog.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.OptionsList = React.createClass({
            displayName: "OptionsList",
            propTypes: {
                log: React.PropTypes.instanceOf(Rance.NotificationLog).isRequired,
            },
            handleResetAllOptions: function () {
                var resetFN = function () {
                    var shouldToggleDebug = (Rance.Options.debugMode !== Rance.defaultOptions.debugMode);
                    var shouldRenderMap = Rance.Options.display.borderWidth !== Rance.defaultOptions.display.borderWidth;
                    Rance.Options = Rance.extendObject(Rance.defaultOptions);
                    this.forceUpdate();
                    if (shouldToggleDebug) {
                        app.reactUI.render();
                    }
                    if (shouldRenderMap) {
                        Rance.eventManager.dispatchEvent("renderMap");
                    }
                }.bind(this);
                var confirmProps = {
                    handleOk: resetFN,
                    contentText: "Are you sure you want to reset all options?"
                };
                this.refs.popupManager.makePopup({
                    contentConstructor: UIComponents.ConfirmPopup,
                    contentProps: confirmProps,
                    popupProps: {
                        containerDragOnly: true,
                        preventAutoResize: true
                    }
                });
            },
            render: function () {
                var allOptions = [];
                // battle animation timing
                var battleAnimationOptions = [];
                var battleAnimationStages = [
                    {
                        stage: "before",
                        displayName: "Before ability (ms)",
                        min: 0,
                        max: 5000,
                        step: 50
                    },
                    {
                        stage: "effectDuration",
                        displayName: "Ability effect duration (*)",
                        min: 0,
                        max: 10,
                        step: 0.1
                    },
                    {
                        stage: "after",
                        displayName: "After ability (ms)",
                        min: 0,
                        max: 5000,
                        step: 50
                    },
                    {
                        stage: "unitEnter",
                        displayName: "Unit enter (ms)",
                        min: 0,
                        max: 1000,
                        step: 10
                    },
                    {
                        stage: "unitExit",
                        displayName: "Unit exit (ms)",
                        min: 0,
                        max: 1000,
                        step: 10
                    }
                ];
                for (var i = 0; i < battleAnimationStages.length; i++) {
                    var props = battleAnimationStages[i];
                    var stage = props.stage;
                    battleAnimationOptions.push({
                        key: stage,
                        content: UIComponents.OptionsNumericField({
                            label: props.displayName,
                            id: "options-battle-animation-" + stage,
                            value: Rance.Options.battleAnimationTiming[stage],
                            min: props.min,
                            max: props.max,
                            step: props.step,
                            onChangeFN: function (stage, value) {
                                Rance.Options.battleAnimationTiming[stage] = value;
                            }.bind(null, stage)
                        })
                    });
                }
                allOptions.push(UIComponents.OptionsGroup({
                    key: "battleAnimationOptions",
                    header: "Battle animation timing",
                    options: battleAnimationOptions,
                    resetFN: function () {
                        Rance.extendObject(Rance.defaultOptions.battleAnimationTiming, Rance.Options.battleAnimationTiming);
                        this.forceUpdate();
                    }.bind(this)
                }));
                var debugOptions = [];
                debugOptions.push({
                    key: "debugMode",
                    content: UIComponents.OptionsCheckbox({
                        isChecked: Rance.Options.debugMode,
                        label: "Debug mode",
                        onChangeFN: function () {
                            Rance.Options.debugMode = !Rance.Options.debugMode;
                            this.forceUpdate();
                            app.reactUI.render();
                        }.bind(this)
                    })
                });
                if (Rance.Options.debugMode) {
                    debugOptions.push({
                        key: "battleSimulationDepth",
                        content: React.DOM.div({}, React.DOM.input({
                            type: "number",
                            id: "battle-simulation-depth-input",
                            value: Rance.Options.debugOptions.battleSimulationDepth,
                            min: 1,
                            max: 500,
                            step: 1,
                            onChange: function (e) {
                                var target = e.target;
                                var value = parseInt(target.value);
                                if (!isFinite(value)) {
                                    return;
                                }
                                value = Rance.clamp(value, parseFloat(target.min), parseFloat(target.max));
                                Rance.Options.debugOptions.battleSimulationDepth = value;
                                this.forceUpdate();
                            }.bind(this)
                        }), React.DOM.label({
                            htmlFor: "battle-simulation-depth-input"
                        }, "AI vs. AI Battle simulation depth"))
                    });
                }
                allOptions.push(UIComponents.OptionsGroup({
                    key: "debug",
                    header: "Debug",
                    options: debugOptions,
                    resetFN: function () {
                        Rance.extendObject(Rance.defaultOptions.debugOptions, Rance.Options.debugOptions);
                        if (Rance.Options.debugMode !== Rance.defaultOptions.debugMode) {
                            Rance.Options.debugMode = !Rance.Options.debugMode;
                            this.forceUpdate();
                            app.reactUI.render();
                        }
                    }.bind(this)
                }));
                var uiOptions = [];
                uiOptions.push({
                    key: "noHamburger",
                    content: UIComponents.OptionsCheckbox({
                        isChecked: Rance.Options.ui.noHamburger,
                        label: "Always expand top right menu on low resolution",
                        onChangeFN: function () {
                            Rance.Options.ui.noHamburger = !Rance.Options.ui.noHamburger;
                            Rance.eventManager.dispatchEvent("updateHamburgerMenu");
                            this.forceUpdate();
                        }.bind(this)
                    })
                });
                uiOptions.push({
                    key: "notificationLogFilter",
                    content: UIComponents.NotificationFilterButton({
                        filter: this.props.log.notificationFilter,
                        text: "Message settings",
                        highlightedOptionKey: null
                    })
                });
                uiOptions.push({
                    key: "resetTutorials",
                    content: React.DOM.button({
                        className: "reset-tutorials-button",
                        onClick: Rance.resetTutorialState
                    }, "Reset tutorials")
                });
                allOptions.push(UIComponents.OptionsGroup({
                    key: "ui",
                    header: "UI",
                    options: uiOptions,
                    resetFN: function () {
                        Rance.extendObject(Rance.defaultOptions.ui, Rance.Options.ui);
                        this.forceUpdate();
                    }.bind(this)
                }));
                var displayOptions = [];
                displayOptions.push({
                    key: "borderWidth",
                    content: UIComponents.OptionsNumericField({
                        label: "Border width",
                        id: "options-border-width",
                        min: 0,
                        max: 50,
                        step: 1,
                        value: Rance.Options.display.borderWidth,
                        onChangeFN: function (value) {
                            Rance.Options.display.borderWidth = value;
                            Rance.eventManager.dispatchEvent("renderMap");
                        }
                    })
                });
                allOptions.push(UIComponents.OptionsGroup({
                    key: "display",
                    header: "Display",
                    options: displayOptions,
                    resetFN: function () {
                        Rance.extendObject(Rance.defaultOptions.display, Rance.Options.display);
                        Rance.eventManager.dispatchEvent("renderMap");
                        this.forceUpdate();
                    }.bind(this)
                }));
                return (React.DOM.div({ className: "options" }, UIComponents.PopupManager({
                    ref: "popupManager",
                    onlyAllowOne: true
                }), React.DOM.div({ className: "options-header" }, "Options", React.DOM.button({
                    className: "reset-options-button reset-all-options-button",
                    onClick: this.handleResetAllOptions
                }, "Reset all options")), allOptions));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../../playertechnology.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.TechnologyPrioritySlider = React.createClass({
            displayName: "TechnologyPrioritySlider",
            propTypes: {
                playerTechnology: React.PropTypes.instanceOf(Rance.PlayerTechnology).isRequired,
                technology: React.PropTypes.object.isRequired,
                researchPoints: React.PropTypes.number.isRequired
            },
            getInitialState: function () {
                return ({
                    priority: this.getPlayerPriority()
                });
            },
            componentDidMount: function () {
                Rance.eventManager.addEventListener("technologyPrioritiesUpdated", this.updatePriority);
            },
            componentWillUnmount: function () {
                Rance.eventManager.removeEventListener("technologyPrioritiesUpdated", this.updatePriority);
            },
            getPlayerPriority: function () {
                return this.props.playerTechnology.technologies[this.props.technology.key].priority;
            },
            updatePriority: function () {
                this.setState({
                    priority: this.getPlayerPriority()
                });
            },
            handlePriorityChange: function (e) {
                if (this.props.playerTechnology.technologies[this.props.technology.key].priorityIsLocked) {
                    return;
                }
                var target = e.target;
                this.props.playerTechnology.setTechnologyPriority(this.props.technology, parseFloat(target.value));
            },
            render: function () {
                return (React.DOM.div({
                    className: "technology-progress-bar-priority-container"
                }, React.DOM.span({
                    className: "technology-progress-bar-predicted-research"
                }, "+" + (this.props.researchPoints * this.state.priority).toFixed(1)), React.DOM.input({
                    className: "technology-progress-bar-priority",
                    type: "range",
                    min: 0,
                    max: 1,
                    step: 0.01,
                    value: this.state.priority,
                    onChange: this.handlePriorityChange,
                    disabled: this.props.technology.priorityIsLocked
                })));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../../playertechnology.ts" />
/// <reference path="technologypriorityslider.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.Technology = React.createClass({
            displayName: "Technology",
            propTypes: {
                playerTechnology: React.PropTypes.instanceOf(Rance.PlayerTechnology).isRequired,
                technology: React.PropTypes.object.isRequired,
                researchPoints: React.PropTypes.number.isRequired
            },
            togglePriorityLock: function () {
                var pt = this.props.playerTechnology;
                var technology = this.props.technology;
                pt.technologies[technology.key].priorityIsLocked = !pt.technologies[technology.key].priorityIsLocked;
                this.forceUpdate();
            },
            render: function () {
                var technology = this.props.technology;
                var isAtMaxLevel = false;
                var playerTechnology = this.props.playerTechnology;
                var techData = playerTechnology.technologies[technology.key];
                var forCurrentLevel = playerTechnology.getResearchNeededForTechnologyLevel(techData.level);
                var forNextLevel = playerTechnology.getResearchNeededForTechnologyLevel(techData.level + 1);
                var progressForLevel = techData.totalResearch - forCurrentLevel;
                var neededToProgressLevel = forNextLevel - forCurrentLevel;
                var relativeProgress;
                if (techData.level === technology.maxLevel) {
                    relativeProgress = 1;
                    progressForLevel =
                        techData.totalResearch - playerTechnology.getResearchNeededForTechnologyLevel(techData.level - 1);
                    neededToProgressLevel = progressForLevel;
                    isAtMaxLevel = true;
                }
                else {
                    relativeProgress = progressForLevel / neededToProgressLevel;
                }
                return (React.DOM.div({
                    className: "technology-listing"
                }, React.DOM.div({
                    className: "technology-name"
                }, technology.displayName), React.DOM.div({
                    className: "technology-level"
                }, "Level " + techData.level), React.DOM.div({
                    className: "technology-progress-bar-container"
                }, React.DOM.div({
                    className: "technology-progress-bar" +
                        (isAtMaxLevel ? " technology-progress-bar-max-level" : ""),
                    style: {
                        width: "" + (relativeProgress * 100) + "%"
                    }
                }), React.DOM.div({
                    className: "technology-progress-bar-value"
                }, "" + progressForLevel.toFixed(1) + " / " + Math.ceil(neededToProgressLevel)), UIComponents.TechnologyPrioritySlider({
                    playerTechnology: this.props.playerTechnology,
                    technology: this.props.technology,
                    researchPoints: this.props.researchPoints
                })), React.DOM.button({
                    className: "technology-toggle-priority-lock" + (techData.priorityIsLocked ? " locked" : " unlocked"),
                    onClick: this.togglePriorityLock,
                    disabled: isAtMaxLevel
                }, null)));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../../playertechnology.ts" />
/// <reference path="technology.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.TechnologiesList = React.createClass({
            displayName: "TechnologiesList",
            updateListener: undefined,
            propTypes: {
                playerTechnology: React.PropTypes.instanceOf(Rance.PlayerTechnology).isRequired
            },
            componentDidMount: function () {
                this.updateListener = Rance.eventManager.addEventListener("builtBuildingWithEffect_research", this.forceUpdate.bind(this));
            },
            componentWillUnmount: function () {
                Rance.eventManager.removeEventListener("builtBuildingWithEffect_research", this.updateListener);
            },
            render: function () {
                var playerTechnology = this.props.playerTechnology;
                var researchSpeed = playerTechnology.getResearchSpeed();
                var rows = [];
                for (var key in playerTechnology.technologies) {
                    rows.push(UIComponents.Technology({
                        playerTechnology: playerTechnology,
                        technology: playerTechnology.technologies[key].technology,
                        researchPoints: researchSpeed,
                        key: key
                    }));
                }
                return (React.DOM.div({
                    className: "technologies-list-container"
                }, React.DOM.div({
                    className: "technologies-list"
                }, rows), React.DOM.div({
                    className: "technologies-list-research-speed"
                }, "Research speed: " + researchSpeed + " per turn")));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../../star.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.ManufactoryStarsListItem = React.createClass({
            displayName: "ManufactoryStarsListItem",
            propTypes: {
                star: React.PropTypes.instanceOf(Rance.Star).isRequired,
                isHighlighted: React.PropTypes.bool.isRequired,
                usedCapacity: React.PropTypes.number.isRequired,
                totalCapacity: React.PropTypes.number.isRequired,
                onClick: React.PropTypes.func.isRequired
            },
            handleClick: function () {
                var star = this.props.star;
                this.props.onClick(star);
            },
            render: function () {
                var star = this.props.star;
                var isHighlighted = this.props.isHighlighted;
                var usedCapacity = this.props.usedCapacity;
                var totalCapacity = this.props.totalCapacity;
                var hasManufcatory = Boolean(totalCapacity);
                var hasCapacity = hasManufcatory && usedCapacity < totalCapacity;
                return (React.DOM.div({
                    className: "manufactory-stars-list-item" +
                        (!hasManufcatory ? " no-manufactory" : "") +
                        (isHighlighted ? " highlighted" : ""),
                    onClick: this.handleClick
                }, React.DOM.div({
                    className: "manufactory-stars-list-item-star-name"
                }, star.name), !hasManufcatory ? null : React.DOM.div({
                    className: "manufactory-stars-list-item-capacity" + (!hasCapacity ? " no-capacity" : "")
                }, "" + usedCapacity + "/" + totalCapacity)));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="manufactorystarslistitem.ts" />
/// <reference path="../../star.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.ManufactoryStarsList = React.createClass({
            displayName: "ManufactoryStarsList",
            propTypes: {
                starsWithManufactories: React.PropTypes.arrayOf(React.PropTypes.instanceOf(Rance.Star)).isRequired,
                starsWithoutManufactories: React.PropTypes.arrayOf(React.PropTypes.instanceOf(Rance.Star)).isRequired,
                highlightedStars: React.PropTypes.arrayOf(React.PropTypes.instanceOf(Rance.Star)).isRequired,
                handleStarSelect: React.PropTypes.func.isRequired
            },
            render: function () {
                var starsWithManufactories = this.props.starsWithManufactories;
                var starsWithoutManufactories = this.props.starsWithoutManufactories;
                var highlightedStars = this.props.highlightedStars;
                var handleStarSelect = this.props.handleStarSelect;
                var rows = [];
                starsWithManufactories.sort(Rance.sortByManufactoryCapacityFN);
                starsWithoutManufactories.sort(Rance.sortByManufactoryCapacityFN);
                for (var i = 0; i < starsWithManufactories.length; i++) {
                    var star = starsWithManufactories[i];
                    var manufactory = star.manufactory;
                    var isHighlighted = highlightedStars.indexOf(star) !== -1;
                    rows.push(UIComponents.ManufactoryStarsListItem({
                        key: star.id,
                        star: star,
                        isHighlighted: isHighlighted,
                        usedCapacity: manufactory.buildQueue.length,
                        totalCapacity: manufactory.capacity,
                        onClick: handleStarSelect
                    }));
                }
                for (var i = 0; i < starsWithoutManufactories.length; i++) {
                    var star = starsWithoutManufactories[i];
                    var isHighlighted = highlightedStars.indexOf(star) !== -1;
                    rows.push(UIComponents.ManufactoryStarsListItem({
                        key: star.id,
                        star: star,
                        isHighlighted: isHighlighted,
                        usedCapacity: 0,
                        totalCapacity: 0,
                        onClick: handleStarSelect
                    }));
                }
                return (React.DOM.div({
                    className: "manufactory-stars-list"
                }, rows));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.ManufacturableThingsListItem = React.createClass({
            displayName: "ManufacturableThingsListItem",
            propTypes: {
                template: React.PropTypes.any.isRequired,
                parentIndex: React.PropTypes.number.isRequired,
                onClick: React.PropTypes.func,
                showCost: React.PropTypes.bool.isRequired,
                money: React.PropTypes.number
            },
            getInitialState: function () {
                return ({
                    canAfford: this.props.money >= this.props.template.buildCost,
                    isDisabled: !this.props.onClick
                });
            },
            componentWillReceiveProps: function (newProps) {
                this.setState({
                    canAfford: newProps.money >= newProps.template.buildCost,
                    isDisabled: !newProps.onClick
                });
            },
            handleClick: function () {
                if (this.props.onClick) {
                    this.props.onClick(this.props.template, this.props.parentIndex);
                }
            },
            render: function () {
                var template = this.props.template;
                var isDisabled = this.state.isDisabled;
                if (this.props.showCost) {
                    isDisabled = isDisabled || !this.state.canAfford;
                }
                return (React.DOM.li({
                    className: "manufacturable-things-list-item" + (isDisabled ? " disabled" : ""),
                    onClick: (isDisabled ? null : this.handleClick),
                    disabled: isDisabled,
                    title: template.description
                }, React.DOM.div({
                    className: "manufacturable-things-list-item-name"
                }, template.displayName), !this.props.showCost ? null : React.DOM.div({
                    className: "manufacturable-things-list-item-cost money-style" +
                        (this.state.canAfford ? "" : " negative")
                }, template.buildCost)));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="manufacturablethingslistitem.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.ManufacturableThingsList = React.createClass({
            displayName: "ManufacturableThingsList",
            mixins: [React.addons.PureRenderMixin],
            propTypes: {
                manufacturableThings: React.PropTypes.array.isRequired,
                onClick: React.PropTypes.func,
                showCost: React.PropTypes.bool.isRequired,
                money: React.PropTypes.number
            },
            render: function () {
                var manufacturableThings = this.props.manufacturableThings;
                var items = [];
                var keyByTemplateType = {};
                for (var i = 0; i < manufacturableThings.length; i++) {
                    var templateType = manufacturableThings[i].type;
                    if (!keyByTemplateType[templateType]) {
                        keyByTemplateType[templateType] = 0;
                    }
                    items.push(UIComponents.ManufacturableThingsListItem({
                        template: manufacturableThings[i],
                        key: templateType + keyByTemplateType[templateType]++,
                        parentIndex: i,
                        onClick: this.props.onClick,
                        money: this.props.money,
                        showCost: this.props.showCost
                    }));
                }
                return (React.DOM.ol({
                    className: "manufacturable-things-list"
                }, items));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.ManufactoryUpgradeButton = React.createClass({
            displayName: "ManufactoryUpgradeButton",
            propTypes: {
                money: React.PropTypes.number.isRequired,
                upgradeCost: React.PropTypes.number.isRequired,
                onClick: React.PropTypes.func.isRequired,
                actionString: React.PropTypes.string.isRequired,
                currentLevel: React.PropTypes.number.isRequired,
                maxLevel: React.PropTypes.number.isRequired,
                levelDecimalPoints: React.PropTypes.number.isRequired,
                title: React.PropTypes.string
            },
            getInitialState: function () {
                return ({
                    canAffordUpgrade: this.props.money >= this.props.upgradeCost,
                    isDisabled: this.props.currentLevel >= this.props.maxLevel
                });
            },
            componentWillReceiveProps: function (newProps) {
                this.setState({
                    canAffordUpgrade: newProps.money >= newProps.upgradeCost,
                    isDisabled: newProps.currentLevel >= newProps.maxLevel
                });
            },
            render: function () {
                var unitUpgradeButtonBaseClassName = "manufactory-upgrade-button";
                var unitUpgradeCostBaseClassName = "manufactory-upgrade-button-cost";
                var isDisabled = this.state.isDisabled || !this.state.canAffordUpgrade;
                if (isDisabled) {
                    unitUpgradeButtonBaseClassName += " disabled";
                }
                if (!this.state.canAffordUpgrade) {
                    unitUpgradeCostBaseClassName += " negative";
                }
                return (React.DOM.button({
                    className: unitUpgradeButtonBaseClassName + " manufactory-units-upgrade-health-button",
                    onClick: (isDisabled ? null : this.props.onClick),
                    disabled: isDisabled,
                    title: this.props.title
                }, React.DOM.span({
                    className: "manufactory-upgrade-button-action"
                }, this.props.actionString), React.DOM.br(), React.DOM.span({
                    className: "manufactory-upgrade-button-level"
                }, "" + this.props.currentLevel.toFixed(this.props.levelDecimalPoints) + "/" +
                    this.props.maxLevel.toFixed(this.props.levelDecimalPoints)), React.DOM.span({
                    className: unitUpgradeCostBaseClassName
                }, this.props.upgradeCost)));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="manufacturablethingslist.ts" />
/// <reference path="manufactoryupgradebutton.ts" />
/// <reference path="../../manufactory.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.BuildQueue = React.createClass({
            displayName: "BuildQueue",
            propTypes: {
                manufactory: React.PropTypes.instanceOf(Rance.Manufactory).isRequired,
                triggerUpdate: React.PropTypes.func.isRequired,
                money: React.PropTypes.number.isRequired
            },
            removeItem: function (template, parentIndex) {
                var manufactory = this.props.manufactory;
                manufactory.removeThingAtIndex(parentIndex);
                this.props.triggerUpdate();
            },
            upgradeCapacity: function () {
                var manufactory = this.props.manufactory;
                manufactory.upgradeCapacity(1);
                this.props.triggerUpdate();
            },
            render: function () {
                var manufactory = this.props.manufactory;
                var convertedBuildQueue = [];
                for (var i = 0; i < manufactory.buildQueue.length; i++) {
                    convertedBuildQueue.push(manufactory.buildQueue[i].template);
                }
                var canUpgradeCapacity = manufactory.capacity < manufactory.maxCapacity;
                return (React.DOM.div({
                    className: "build-queue"
                }, React.DOM.div({
                    className: "manufactory-upgrade-buttons-container"
                }, UIComponents.ManufactoryUpgradeButton({
                    money: this.props.money,
                    upgradeCost: manufactory.getCapacityUpgradeCost(),
                    onClick: this.upgradeCapacity,
                    actionString: "Upgrade capacity",
                    currentLevel: manufactory.capacity,
                    maxLevel: manufactory.maxCapacity,
                    levelDecimalPoints: 0,
                    title: "Increase amount of things this manufactory can build per turn"
                })), UIComponents.ManufacturableThingsList({
                    manufacturableThings: convertedBuildQueue,
                    onClick: this.removeItem,
                    showCost: false
                })));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="manufacturablethingslist.ts" />
/// <reference path="manufactoryupgradebutton.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.ManufacturableUnits = React.createClass({
            displayName: "ManufacturableUnits",
            propTypes: {
                selectedStar: React.PropTypes.instanceOf(Rance.Star),
                consolidateLocations: React.PropTypes.bool.isRequired,
                manufacturableThings: React.PropTypes.array.isRequired,
                triggerUpdate: React.PropTypes.func.isRequired,
                canBuild: React.PropTypes.bool.isRequired,
                money: React.PropTypes.number.isRequired
            },
            shouldComponentUpdate: function (newProps) {
                if (this.props.selectedStar !== newProps.selectedStar) {
                    return true;
                }
                if (this.props.manufacturableThings.length !== newProps.manufacturableThings.length) {
                    return true;
                }
                else {
                }
                if (this.props.canBuild !== newProps.canBuild) {
                    return true;
                }
                if (this.props.money !== newProps.money) {
                    return true;
                }
                return false;
            },
            addUnitToBuildQueue: function (template) {
                var manufactory = this.props.selectedStar.manufactory;
                manufactory.addThingToQueue(template, "unit");
                this.props.triggerUpdate();
            },
            upgradeHealth: function () {
                var manufactory = this.props.selectedStar.manufactory;
                manufactory.upgradeUnitHealthModifier(0.1);
                this.props.triggerUpdate();
            },
            upgradeStats: function () {
                var manufactory = this.props.selectedStar.manufactory;
                manufactory.upgradeUnitStatsModifier(0.1);
                this.props.triggerUpdate();
            },
            render: function () {
                if (this.props.selectedStar && this.props.selectedStar.manufactory) {
                    var manufactory = this.props.selectedStar.manufactory;
                    var unitUpgradeCost = manufactory.getUnitUpgradeCost();
                    var canAffordUnitUpgrade = this.props.money >= unitUpgradeCost;
                    var unitUpgradeButtonBaseClassName = "manufactory-upgrade-button";
                    var unitUpgradeCostBaseClassName = "manufactory-upgrade-button-cost";
                    if (!canAffordUnitUpgrade) {
                        unitUpgradeButtonBaseClassName += " disabled";
                        unitUpgradeCostBaseClassName += " negative";
                    }
                }
                return (React.DOM.div({
                    className: "manufacturable-units"
                }, (!this.props.selectedStar || !this.props.selectedStar.manufactory) ? null : React.DOM.div({
                    className: "manufactory-upgrade-buttons-container"
                }, UIComponents.ManufactoryUpgradeButton({
                    money: this.props.money,
                    upgradeCost: unitUpgradeCost,
                    actionString: "Upgrade health",
                    currentLevel: manufactory.unitHealthModifier,
                    maxLevel: 5.0,
                    levelDecimalPoints: 1,
                    onClick: this.upgradeHealth,
                    title: "Increase base health of units built here"
                }), UIComponents.ManufactoryUpgradeButton({
                    money: this.props.money,
                    upgradeCost: unitUpgradeCost,
                    actionString: "Upgrade stats",
                    currentLevel: manufactory.unitStatsModifier,
                    maxLevel: 5.0,
                    levelDecimalPoints: 1,
                    onClick: this.upgradeStats,
                    title: "Increase base stats of units built here"
                })), UIComponents.ManufacturableThingsList({
                    manufacturableThings: this.props.manufacturableThings,
                    onClick: (this.props.canBuild ? this.addUnitToBuildQueue : null),
                    showCost: true,
                    money: this.props.money
                })));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="manufactoryupgradebutton.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.ManufacturableItems = React.createClass({
            displayName: "ManufacturableItems",
            propTypes: {
                selectedStar: React.PropTypes.instanceOf(Rance.Star),
                consolidateLocations: React.PropTypes.bool.isRequired,
                manufacturableThings: React.PropTypes.array.isRequired,
                triggerUpdate: React.PropTypes.func.isRequired,
                canBuild: React.PropTypes.bool.isRequired,
                money: React.PropTypes.number.isRequired
            },
            shouldComponentUpdate: function (newProps) {
                if (this.props.selectedStar !== newProps.selectedStar) {
                    return true;
                }
                if (this.props.manufacturableThings.length !== newProps.manufacturableThings.length) {
                    return true;
                }
                else {
                }
                if (this.props.canBuild !== newProps.canBuild) {
                    return true;
                }
                if (this.props.money !== newProps.money) {
                    return true;
                }
                return false;
            },
            addItemToBuildQueue: function (template) {
                var manufactory = this.props.selectedStar.manufactory;
                manufactory.addThingToQueue(template, "item");
                this.props.triggerUpdate();
            },
            upgradeItems: function () {
            },
            render: function () {
                return (React.DOM.div({
                    className: "manufacturable-items"
                }, (!this.props.selectedStar || !this.props.selectedStar.manufactory) ? null : React.DOM.div({
                    className: "manufactory-upgrade-buttons-container"
                }, UIComponents.ManufactoryUpgradeButton({
                    money: this.props.money,
                    upgradeCost: 0,
                    actionString: "Upgrade items",
                    currentLevel: 0,
                    maxLevel: 0,
                    levelDecimalPoints: 0,
                    onClick: this.upgradeItems
                })), UIComponents.ManufacturableThingsList({
                    manufacturableThings: this.props.manufacturableThings,
                    onClick: (this.props.canBuild ? this.addItemToBuildQueue : null),
                    showCost: true,
                    money: this.props.money
                })));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="manufacturableunits.ts" />
/// <reference path="manufacturableitems.ts" />
/// <reference path="../../star.ts" />
/// <reference path="../../manufactory.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.ManufacturableThings = React.createClass({
            displayName: "ManufacturableThings",
            propTypes: {
                selectedStar: React.PropTypes.instanceOf(Rance.Star),
                player: React.PropTypes.instanceOf(Rance.Player).isRequired,
                triggerUpdate: React.PropTypes.func.isRequired,
                money: React.PropTypes.number.isRequired
            },
            getInitialState: function () {
                return ({
                    activeTab: "units"
                });
            },
            selectTab: function (key) {
                if (this.state.activeTab === key)
                    return;
                this.setState({
                    activeTab: key
                });
            },
            makeTabButton: function (key) {
                var displayString;
                switch (key) {
                    case "units":
                        {
                            displayString = "Units";
                            break;
                        }
                    case "items":
                        {
                            displayString = "Items";
                            break;
                        }
                }
                return (React.DOM.button({
                    key: key,
                    className: "manufacturable-things-tab-button" +
                        (this.state.activeTab === key ? " active-tab" : ""),
                    onClick: this.selectTab.bind(this, key)
                }, displayString));
            },
            getManufacturableThings: function (key) {
                var manufacturableThings = [];
                var selectedStar = this.props.selectedStar;
                var player = this.props.player;
                switch (key) {
                    case "units":
                        {
                            manufacturableThings = manufacturableThings.concat(player.getGloballyBuildableUnits());
                            if (selectedStar) {
                                if (selectedStar.manufactory) {
                                    manufacturableThings = manufacturableThings.concat(selectedStar.manufactory.getLocalUnitTypes().manufacturable);
                                }
                            }
                            break;
                        }
                    case "items":
                        {
                            manufacturableThings = manufacturableThings.concat(player.getGloballyBuildableItems());
                            if (selectedStar) {
                                if (selectedStar.manufactory) {
                                    manufacturableThings = manufacturableThings.concat(selectedStar.manufactory.getLocalItemTypes().manufacturable);
                                }
                            }
                            break;
                        }
                }
                return manufacturableThings;
            },
            makeTab: function (key) {
                var props = {
                    key: key,
                    selectedStar: this.props.selectedStar,
                    manufacturableThings: this.getManufacturableThings(key),
                    consolidateLocations: false,
                    triggerUpdate: this.props.triggerUpdate,
                    canBuild: Boolean(this.props.selectedStar && this.props.selectedStar.manufactory),
                    money: this.props.money
                };
                switch (key) {
                    case "units":
                        {
                            return (UIComponents.ManufacturableUnits(props));
                        }
                    case "items":
                        {
                            props.consolidateLocations = true;
                            return (UIComponents.ManufacturableItems(props));
                        }
                }
            },
            render: function () {
                return (React.DOM.div({
                    className: "manufacturable-things"
                }, React.DOM.div({
                    className: "manufacturable-things-tab-buttons"
                }, this.makeTabButton("units"), this.makeTabButton("items")), React.DOM.div({
                    className: "manufacturable-things-active-tab"
                }, this.makeTab(this.state.activeTab))));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../../star.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.ConstructManufactory = React.createClass({
            displayName: "ConstructManufactory",
            mixins: [React.addons.PureRenderMixin],
            propTypes: {
                star: React.PropTypes.instanceOf(Rance.Star).isRequired,
                player: React.PropTypes.instanceOf(Rance.Player).isRequired,
                triggerUpdate: React.PropTypes.func.isRequired,
                money: React.PropTypes.number.isRequired
            },
            getInitialState: function () {
                return ({
                    canAfford: this.props.money >= app.moduleData.ruleSet.manufactory.buildCost
                });
            },
            componentWillReceiveProps: function (newProps) {
                this.setState({
                    canAfford: newProps.money >= app.moduleData.ruleSet.manufactory.buildCost
                });
            },
            handleConstruct: function () {
                var star = this.props.star;
                var player = this.props.player;
                star.buildManufactory();
                player.money -= app.moduleData.ruleSet.manufactory.buildCost;
                this.props.triggerUpdate();
            },
            render: function () {
                return (React.DOM.div({
                    className: "construct-manufactory-container"
                }, React.DOM.button({
                    className: "construct-manufactory-button" + (this.state.canAfford ? "" : " disabled"),
                    onClick: this.state.canAfford ? this.handleConstruct : null,
                    disabled: !this.state.canAfford
                }, React.DOM.span({
                    className: "construct-manufactory-action"
                }, "Construct manufactory"), React.DOM.span({
                    className: "construct-manufactory-cost money-style" +
                        (this.state.canAfford ? "" : " negative")
                }, app.moduleData.ruleSet.manufactory.buildCost))));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../../../lib/react.d.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.UpdateWhenMoneyChanges = {
            handleMoneyChange: function () {
                if (this.overrideHandleMoneyChange) {
                    this.overrideHandleMoneyChange();
                }
                else {
                    this.setState({
                        money: this.props.player.money
                    });
                }
            },
            componentDidMount: function () {
                Rance.eventManager.addEventListener("playerMoneyUpdated", this.handleMoneyChange);
            },
            componentWillUnmount: function () {
                Rance.eventManager.removeEventListener("playerMoneyUpdated", this.handleMoneyChange);
            },
        };
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="manufactorystarslist.ts" />
/// <reference path="buildqueue.ts" />
/// <reference path="manufacturablethings.ts" />
/// <reference path="constructmanufactory.ts" />
/// <reference path="../mixins/updatewhenmoneychanges.ts" />
/// <reference path="../../player.ts" />
/// <reference path="../../star.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.ProductionOverview = React.createClass({
            displayName: "ProductionOverview",
            mixins: [UIComponents.UpdateWhenMoneyChanges],
            propTypes: {
                player: React.PropTypes.instanceOf(Rance.Player).isRequired
            },
            getInitialState: function () {
                var initialSelected = null;
                var player = this.props.player;
                var starsByManufactoryPresence = this.getStarsWithAndWithoutManufactories();
                if (starsByManufactoryPresence.withManufactories.length > 0) {
                    starsByManufactoryPresence.withManufactories.sort(Rance.sortByManufactoryCapacityFN);
                    initialSelected = starsByManufactoryPresence.withManufactories[0];
                }
                else if (starsByManufactoryPresence.withoutManufactories.length > 0) {
                    starsByManufactoryPresence.withoutManufactories.sort(Rance.sortByManufactoryCapacityFN);
                    initialSelected = starsByManufactoryPresence.withoutManufactories[0];
                }
                return ({
                    selectedStar: initialSelected,
                    highlightedStars: [initialSelected],
                    money: player.money
                });
            },
            triggerUpdate: function () {
                this.forceUpdate();
            },
            componentDidMount: function () {
                Rance.eventManager.addEventListener("playerManufactoryBuiltThings", this.triggerUpdate);
            },
            componentWillUnmount: function () {
                Rance.eventManager.removeEventListener("playerManufactoryBuiltThings", this.triggerUpdate);
            },
            getStarsWithAndWithoutManufactories: function () {
                var player = this.props.player;
                var starsWithManufactories = [];
                var starsWithoutManufactories = [];
                for (var i = 0; i < player.controlledLocations.length; i++) {
                    var star = player.controlledLocations[i];
                    if (star.manufactory) {
                        starsWithManufactories.push(star);
                    }
                    else {
                        starsWithoutManufactories.push(star);
                    }
                }
                return ({
                    withManufactories: starsWithManufactories,
                    withoutManufactories: starsWithoutManufactories
                });
            },
            handleStarSelect: function (star) {
                if (this.state.selectedStar === star) {
                    this.clearSelection();
                }
                else {
                    this.setState({
                        selectedStar: star,
                        highlightedStars: [star]
                    });
                }
            },
            clearSelection: function () {
                this.setState({
                    selectedStar: undefined,
                    highlightedStars: []
                });
            },
            render: function () {
                var player = this.props.player;
                var selectedStar = this.state.selectedStar;
                var starsByManufactoryPresence = this.getStarsWithAndWithoutManufactories();
                var queueElement = null;
                if (selectedStar) {
                    if (selectedStar.manufactory) {
                        queueElement = UIComponents.BuildQueue({
                            manufactory: selectedStar.manufactory,
                            triggerUpdate: this.triggerUpdate,
                            money: this.state.money
                        });
                    }
                    else {
                        queueElement = UIComponents.ConstructManufactory({
                            star: selectedStar,
                            player: player,
                            money: this.state.money,
                            triggerUpdate: this.triggerUpdate
                        });
                    }
                }
                return (React.DOM.div({
                    className: "production-overview"
                }, UIComponents.ManufactoryStarsList({
                    starsWithManufactories: starsByManufactoryPresence.withManufactories,
                    starsWithoutManufactories: starsByManufactoryPresence.withoutManufactories,
                    highlightedStars: this.state.highlightedStars,
                    handleStarSelect: this.handleStarSelect
                }), React.DOM.div({
                    className: "production-overview-contents"
                }, queueElement, UIComponents.ManufacturableThings({
                    selectedStar: selectedStar,
                    player: player,
                    money: this.state.money,
                    triggerUpdate: this.triggerUpdate
                }))));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.TopMenuPopup = React.createClass({
            displayName: "TopMenuPopup",
            render: function () {
                var contentProps = this.props.contentProps;
                contentProps.ref = "content";
                return (React.DOM.div({
                    className: "top-menu-popup-container draggable-container"
                }, React.DOM.button({
                    className: "light-box-close",
                    onClick: this.props.handleClose
                }, "X"), React.DOM.div({
                    className: "light-box-content"
                }, this.props.contentConstructor(contentProps))));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../saves/savegame.ts"/>
/// <reference path="../saves/loadgame.ts"/>
/// <reference path="../unitlist/itemequip.ts"/>
/// <reference path="../diplomacy/diplomacyoverview.ts"/>
/// <reference path="economysummary.ts"/>
/// <reference path="optionslist.ts"/>
/// <reference path="../technologies/technologieslist.ts" />
/// <reference path="../production/productionoverview.ts" />
/// <reference path="../popups/topmenupopup.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.TopMenuPopups = React.createClass({
            displayName: "TopMenuPopups",
            cachedPopupRects: {},
            propTypes: {
                player: React.PropTypes.instanceOf(Rance.Player).isRequired,
                game: React.PropTypes.instanceOf(Rance.Game).isRequired
            },
            getInitialState: function () {
                return ({
                    production: undefined,
                    equipItems: undefined,
                    economySummary: undefined,
                    saveGame: undefined,
                    loadGame: undefined,
                    options: undefined,
                    diplomacy: undefined,
                    technologies: undefined
                });
            },
            closePopup: function (popupType) {
                var popupNode = this.refs.popupManager.refs[this.state[popupType]].getDOMNode();
                this.cachedPopupRects[popupType] = popupNode.getBoundingClientRect();
                this.refs.popupManager.closePopup(this.state[popupType]);
                var stateObj = {};
                stateObj[popupType] = undefined;
                this.setState(stateObj);
                if (popupType === "options") {
                    Rance.saveOptions();
                }
            },
            makePopup: function (popupType) {
                if (!this.cachedPopupRects[popupType]) {
                    this.cachedPopupRects[popupType] = {};
                }
                var contentConstructor;
                var contentProps;
                var popupProps = {
                    resizable: true,
                    containerDragOnly: true,
                    minWidth: 150,
                    minHeight: 50,
                    initialPosition: this.cachedPopupRects[popupType],
                    preventAutoResize: true
                };
                switch (popupType) {
                    case "production":
                        {
                            contentConstructor = UIComponents.ProductionOverview;
                            contentProps =
                                {
                                    player: this.props.player
                                };
                            if (!popupProps.initialPosition.width) {
                                popupProps.initialPosition.width = 600;
                                popupProps.initialPosition.height = 300;
                            }
                            break;
                        }
                    case "equipItems":
                        {
                            contentConstructor = UIComponents.ItemEquip;
                            contentProps =
                                {
                                    player: this.props.player
                                };
                            popupProps.minWidth = 440;
                            break;
                        }
                    case "economySummary":
                        {
                            contentConstructor = UIComponents.EconomySummary;
                            contentProps =
                                {
                                    player: this.props.player
                                };
                            break;
                        }
                    case "saveGame":
                        {
                            contentConstructor = UIComponents.SaveGame;
                            contentProps =
                                {
                                    handleClose: this.closePopup.bind(this, "saveGame")
                                };
                            break;
                        }
                    case "loadGame":
                        {
                            contentConstructor = UIComponents.LoadGame;
                            contentProps =
                                {
                                    handleClose: this.closePopup.bind(this, "loadGame")
                                };
                            break;
                        }
                    case "options":
                        {
                            contentConstructor = UIComponents.OptionsList;
                            contentProps =
                                {
                                    log: this.props.game.notificationLog
                                };
                            break;
                        }
                    case "diplomacy":
                        {
                            contentConstructor = UIComponents.DiplomacyOverview;
                            contentProps =
                                {
                                    player: this.props.player,
                                    totalPlayerCount: this.props.game.playerOrder.length,
                                    metPlayers: this.props.player.diplomacyStatus.metPlayers,
                                    statusByPlayer: this.props.player.diplomacyStatus.statusByPlayer
                                };
                            break;
                        }
                    case "technologies":
                        {
                            contentConstructor = UIComponents.TechnologiesList;
                            contentProps =
                                {
                                    playerTechnology: this.props.player.playerTechnology
                                };
                            popupProps.minWidth = 430;
                            break;
                        }
                }
                var id = this.refs.popupManager.makePopup({
                    contentConstructor: UIComponents.TopMenuPopup,
                    contentProps: {
                        contentConstructor: contentConstructor,
                        contentProps: contentProps,
                        handleClose: this.closePopup.bind(this, popupType)
                    },
                    popupProps: popupProps
                });
                var stateObj = {};
                stateObj[popupType] = id;
                this.setState(stateObj);
            },
            togglePopup: function (popupType) {
                if (isFinite(this.state[popupType])) {
                    this.closePopup(popupType);
                }
                else {
                    this.makePopup(popupType);
                }
            },
            render: function () {
                return (UIComponents.PopupManager({
                    ref: "popupManager"
                }));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="topmenupopups.ts" />
/// <reference path="../../player.ts" />
/// <reference path="../../game.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.TopMenu = React.createClass({
            displayName: "TopMenu",
            mixins: [React.addons.PureRenderMixin],
            cachedTopMenuWidth: undefined,
            cachedButtonWidths: [],
            cachedMenuButtonWidth: 37,
            propTypes: {
                player: React.PropTypes.instanceOf(Rance.Player).isRequired,
                game: React.PropTypes.instanceOf(Rance.Game).isRequired
            },
            getInitialState: function () {
                return ({
                    hasCondensedMenu: false,
                    buttonsToPlace: 999,
                    condensedMenuOpened: Rance.Options.ui.noHamburger
                });
            },
            componentDidMount: function () {
                window.addEventListener("resize", this.handleResize, false);
                Rance.eventManager.addEventListener("playerControlUpdated", this.delayedResize);
                Rance.eventManager.addEventListener("updateHamburgerMenu", this.handleToggleHamburger);
                this.handleResize();
            },
            componentWillUnmount: function () {
                window.removeEventListener("resize", this.handleResize);
                Rance.eventManager.removeEventListener("playerControlUpdated", this.delayedResize);
                Rance.eventManager.removeEventListener("updateHamburgerMenu", this.handleToggleHamburger);
            },
            handleToggleHamburger: function () {
                this.handleResize();
                this.forceUpdate();
            },
            delayedResize: function () {
                window.setTimeout(this.handleResize, 0);
            },
            handleResize: function () {
                if (!this.cachedTopMenuWidth) {
                    this.cachedTopMenuWidth = this.refs.topMenu.getDOMNode().getBoundingClientRect().width;
                    var buttons = this.refs.topMenuItems.getDOMNode().children;
                    var margin = parseInt(window.getComputedStyle(buttons[0]).margin) * 2;
                    for (var i = 0; i < buttons.length; i++) {
                        var buttonWidth = buttons[i].getBoundingClientRect().width + margin;
                        this.cachedButtonWidths.push(buttonWidth);
                    }
                }
                var topMenuHeight = window.innerHeight > 600 ? 50 : 32;
                var topBar = document.getElementsByClassName("top-bar-info")[0];
                var topBarRect = topBar.getBoundingClientRect();
                var rightmostElement = topBar;
                var rightmostRect = topBarRect;
                var fleetContainer = document.getElementsByClassName("fleet-selection")[0];
                if (fleetContainer) {
                    var fleetElementToCheckAgainst;
                    var firstChild = fleetContainer.firstChild;
                    if (firstChild.classList.contains("fleet-selection-controls")) {
                        fleetElementToCheckAgainst = document.getElementsByClassName("fleet-selection-selected-wrapper")[0];
                    }
                    else {
                        fleetElementToCheckAgainst = firstChild;
                    }
                    if (fleetElementToCheckAgainst) {
                        var fleetRect = fleetElementToCheckAgainst.getBoundingClientRect();
                        if (fleetRect.top < topMenuHeight && fleetRect.right > topBarRect.right) {
                            rightmostElement = fleetElementToCheckAgainst;
                            rightmostRect = fleetRect;
                        }
                    }
                }
                var spaceAvailable = window.innerWidth - rightmostRect.right;
                var hasCondensedMenu = spaceAvailable < this.cachedTopMenuWidth;
                var amountOfButtonsToPlace = 0;
                if (hasCondensedMenu) {
                    if (!Rance.Options.ui.noHamburger) {
                        spaceAvailable -= this.cachedMenuButtonWidth;
                    }
                    var padding = window.innerHeight > 600 ? 25 : 0;
                    for (var i = 0; i < this.cachedButtonWidths.length; i++) {
                        var buttonWidthToCheck = this.cachedButtonWidths[i];
                        if (spaceAvailable > buttonWidthToCheck + padding) {
                            amountOfButtonsToPlace++;
                            spaceAvailable -= buttonWidthToCheck;
                        }
                        else {
                            break;
                        }
                    }
                }
                else {
                    amountOfButtonsToPlace = this.cachedButtonWidths.length;
                }
                this.setState({
                    hasCondensedMenu: hasCondensedMenu,
                    buttonsToPlace: amountOfButtonsToPlace
                });
            },
            togglePopup: function (popupType) {
                this.refs.popups.togglePopup(popupType);
                this.forceUpdate();
            },
            toggleCondensedMenu: function () {
                this.setState({
                    condensedMenuOpened: !this.state.condensedMenuOpened
                });
            },
            render: function () {
                var menuItemTabIndex = this.state.opened ? -1 : 0;
                var topMenuButtons = [
                    React.DOM.button({
                        className: "top-menu-items-button top-menu-items-button-production",
                        key: "production",
                        onClick: this.togglePopup.bind(this, "production"),
                        tabIndex: menuItemTabIndex
                    }, "Production"),
                    React.DOM.button({
                        className: "top-menu-items-button top-menu-items-button-equip",
                        key: "equipItems",
                        onClick: this.togglePopup.bind(this, "equipItems"),
                        tabIndex: menuItemTabIndex
                    }, "Equip"),
                    /*
                    React.DOM.button(
                    {
                      className: "top-menu-items-button top-menu-items-button-economy",
                      key: "economySummary",
                      onClick: this.togglePopup.bind(this, "economySummary"),
                      tabIndex: menuItemTabIndex
                    }, "Economy"),
                    */
                    React.DOM.button({
                        className: "top-menu-items-button top-menu-items-button-diplomacy",
                        key: "diplomacy",
                        onClick: this.togglePopup.bind(this, "diplomacy"),
                        tabIndex: menuItemTabIndex
                    }, "Diplomacy"),
                    React.DOM.button({
                        className: "top-menu-items-button top-menu-items-button-technology",
                        key: "technologies",
                        onClick: this.togglePopup.bind(this, "technologies"),
                        tabIndex: menuItemTabIndex
                    }, "Technology"),
                    React.DOM.button({
                        className: "top-menu-items-button top-menu-items-button-load",
                        key: "loadGame",
                        onClick: this.togglePopup.bind(this, "loadGame"),
                        tabIndex: menuItemTabIndex
                    }, "Load"),
                    React.DOM.button({
                        className: "top-menu-items-button top-menu-items-button-save",
                        key: "saveGame",
                        onClick: this.togglePopup.bind(this, "saveGame"),
                        tabIndex: menuItemTabIndex
                    }, "Save"),
                    React.DOM.button({
                        className: "top-menu-items-button top-menu-items-button-options",
                        key: "options",
                        onClick: this.togglePopup.bind(this, "options"),
                        tabIndex: menuItemTabIndex
                    }, "Options")
                ];
                var topMenuItems = topMenuButtons.slice(0, this.state.buttonsToPlace);
                var leftoverButtons = topMenuButtons.slice(this.state.buttonsToPlace);
                if (this.state.hasCondensedMenu && !Rance.Options.ui.noHamburger) {
                    topMenuItems.push(React.DOM.button({
                        className: "top-menu-items-button top-menu-open-condensed-button",
                        key: "openCondensedMenu",
                        onClick: this.toggleCondensedMenu,
                        tabIndex: menuItemTabIndex
                    }));
                }
                var openedCondensedMenu = null;
                if ((this.state.condensedMenuOpened || Rance.Options.ui.noHamburger) && leftoverButtons.length > 0) {
                    openedCondensedMenu = React.DOM.div({
                        className: "top-menu-opened-condensed-menu"
                    }, leftoverButtons);
                }
                ;
                return (React.DOM.div({
                    className: "top-menu-wrapper"
                }, React.DOM.div({
                    className: "top-menu",
                    ref: "topMenu"
                }, React.DOM.div({
                    className: "top-menu-items",
                    ref: "topMenuItems"
                }, topMenuItems)), openedCondensedMenu, UIComponents.TopMenuPopups({
                    ref: "popups",
                    player: this.props.player,
                    game: this.props.game
                })));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../../player.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.PlayerMoney = React.createClass({
            displayName: "PlayerMoney",
            lastAmountRendered: undefined,
            propTypes: {
                player: React.PropTypes.instanceOf(Rance.Player)
            },
            componentDidMount: function () {
                Rance.eventManager.addEventListener("playerMoneyUpdated", this.handlePlayerMoneyUpdated);
            },
            componentWillUnmount: function () {
                Rance.eventManager.removeEventListener("playerMoneyUpdated", this.handlePlayerMoneyUpdated);
            },
            handlePlayerMoneyUpdated: function () {
                if (this.props.player.money !== this.lastAmountRendered) {
                    this.forceUpdate();
                }
            },
            render: function () {
                this.lastAmountRendered = this.props.player.money;
                return (React.DOM.div({
                    className: "player-money"
                }, "Money: " + this.props.player.money));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.Resource = React.createClass({
            displayName: "Resource",
            render: function () {
                var sign = this.props.income < 0 ? "-" : "+";
                return (React.DOM.div({
                    className: "resource",
                    title: this.props.resource.displayName + ""
                }, React.DOM.img({
                    className: "resource-icon",
                    src: this.props.resource.icon
                }, null), React.DOM.div({
                    className: "resource-amount"
                }, "" + this.props.amount + " (" + sign + this.props.income + ")")));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="resource.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.TopBarResources = React.createClass({
            displayName: "TopBarResources",
            updateListener: undefined,
            componentDidMount: function () {
                this.updateListener = Rance.eventManager.addEventListener("builtBuildingWithEffect_resourceIncome", this.forceUpdate.bind(this));
            },
            componentWillUnmount: function () {
                Rance.eventManager.removeEventListener("builtBuildingWithEffect_resourceIncome", this.updateListener);
            },
            render: function () {
                var player = this.props.player;
                var resources = [];
                var resourceIncome = player.getResourceIncome();
                var resourceTypes = Object.keys(player.resources);
                for (var _resourceType in resourceIncome) {
                    if (resourceTypes.indexOf(_resourceType) === -1) {
                        resourceTypes.push(_resourceType);
                    }
                }
                for (var i = 0; i < resourceTypes.length; i++) {
                    var resourceType = resourceTypes[i];
                    var amount = player.resources[resourceType] || 0;
                    var income = resourceIncome[resourceType].amount || 0;
                    if (amount === 0 && income === 0)
                        continue;
                    var resourceData = {
                        resource: app.moduleData.Templates.Resources[resourceType],
                        amount: amount,
                        income: income,
                        key: resourceType
                    };
                    resources.push(UIComponents.Resource(resourceData));
                }
                return (React.DOM.div({
                    className: "top-bar-resources"
                }, resources));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="playermoney.ts" />
/// <reference path="topbarresources.ts" />
/// <reference path="../playerflag.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.TopBar = React.createClass({
            displayName: "TopBar",
            updateListener: undefined,
            componentDidMount: function () {
                this.updateListener = Rance.eventManager.addEventListener("builtBuildingWithEffect_income", this.forceUpdate.bind(this));
            },
            componentWillUnmount: function () {
                Rance.eventManager.removeEventListener("builtBuildingWithEffect_income", this.updateListener);
            },
            render: function () {
                var player = this.props.player;
                var income = player.getIncome();
                var incomeClass = "top-bar-money-income";
                if (income < 0)
                    incomeClass += " negative";
                return (React.DOM.div({
                    className: "top-bar"
                }, React.DOM.div({
                    className: "top-bar-info"
                }, React.DOM.div({
                    className: "top-bar-player"
                }, UIComponents.PlayerFlag({
                    props: {
                        className: "top-bar-player-icon"
                    },
                    flag: player.flag
                }), React.DOM.div({
                    className: "top-bar-turn-number"
                }, "Turn " + this.props.game.turnNumber)), React.DOM.div({
                    className: "top-bar-money"
                }, UIComponents.PlayerMoney({
                    player: player
                }), React.DOM.div({
                    className: incomeClass
                }, "(+" + player.getIncome() + ")")), UIComponents.TopBarResources({
                    player: player
                }))));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../../fleet.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.FleetControls = React.createClass({
            displayName: "FleetControls",
            propTypes: {
                fleet: React.PropTypes.instanceOf(Rance.Fleet).isRequired,
                isInspecting: React.PropTypes.bool,
                hasMultipleSelected: React.PropTypes.bool
            },
            deselectFleet: function () {
                Rance.eventManager.dispatchEvent("deselectFleet", this.props.fleet);
            },
            selectFleet: function () {
                Rance.eventManager.dispatchEvent("selectFleets", [this.props.fleet]);
            },
            splitFleet: function () {
                Rance.eventManager.dispatchEvent("splitFleet", this.props.fleet);
            },
            render: function () {
                var fleet = this.props.fleet;
                var splitButtonProps = {
                    className: "fleet-controls-split"
                };
                if (fleet.units.length > 1 && !this.props.isInspecting) {
                    splitButtonProps.onClick = this.splitFleet;
                }
                else {
                    splitButtonProps.className += " disabled";
                    splitButtonProps.disabled = true;
                }
                return (React.DOM.div({
                    className: "fleet-controls"
                }, React.DOM.button(splitButtonProps, "split"), React.DOM.button({
                    className: "fleet-controls-deselect",
                    onClick: this.deselectFleet
                }, "deselect"), !this.props.hasMultipleSelected ? null : React.DOM.button({
                    className: "fleet-controls-select",
                    onClick: this.selectFleet
                }, "select")));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="fleetcontrols.ts"/>
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.FleetInfo = React.createClass({
            displayName: "FleetInfo",
            setFleetName: function (e) {
                var target = e.target;
                this.props.fleet.name = target.value;
                this.forceUpdate();
            },
            render: function () {
                var fleet = this.props.fleet;
                if (!fleet)
                    return null;
                var totalHealth = fleet.getTotalHealth();
                var isNotDetected = this.props.isNotDetected;
                var healthRatio = totalHealth.current / totalHealth.max;
                var critThreshhold = 0.3;
                var healthStatus = "";
                if (!isNotDetected && healthRatio <= critThreshhold) {
                    healthStatus += " critical";
                }
                else if (!isNotDetected && totalHealth.current < totalHealth.max) {
                    healthStatus += " wounded";
                }
                return (React.DOM.div({
                    className: "fleet-info" + (fleet.isStealthy ? " stealthy" : "")
                }, React.DOM.div({
                    className: "fleet-info-header"
                }, React.DOM.input({
                    className: "fleet-info-name",
                    value: isNotDetected ? "Unidentified fleet" : fleet.name,
                    onChange: isNotDetected ? null : this.setFleetName,
                    readOnly: isNotDetected
                }), React.DOM.div({
                    className: "fleet-info-strength"
                }, React.DOM.span({
                    className: "fleet-info-strength-current" + healthStatus
                }, isNotDetected ? "???" : totalHealth.current), React.DOM.span({
                    className: "fleet-info-strength-max"
                }, isNotDetected ? "/???" : "/" + totalHealth.max)), UIComponents.FleetControls({
                    fleet: fleet,
                    hasMultipleSelected: this.props.hasMultipleSelected,
                    isInspecting: this.props.isInspecting
                })), React.DOM.div({
                    className: "fleet-info-move-points"
                }, isNotDetected ? "Moves: ?/?" : "Moves: " + fleet.getMinCurrentMovePoints() + "/" +
                    fleet.getMinMaxMovePoints())));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../../unit.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.FleetUnitInfoName = React.createClass({
            displayName: "FleetUnitInfoName",
            propTypes: {
                unit: React.PropTypes.instanceOf(Rance.Unit).isRequired,
                isNotDetected: React.PropTypes.bool.isRequired
            },
            getInitialState: function () {
                return ({
                    value: this.props.unit.name
                });
            },
            onChange: function (e) {
                var target = e.target;
                this.setState({ value: target.value });
                this.props.unit.name = target.value;
            },
            render: function () {
                return (React.DOM.input({
                    className: "fleet-unit-info-name",
                    value: this.props.isNotDetected ? "Unidentified ship" : this.state.value,
                    onChange: this.props.isNotDetected ? null : this.onChange,
                    readOnly: this.props.isNotDetected
                }));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../unit/unitstrength.ts"/>
/// <reference path="fleetunitinfoname.ts"/>
/// <reference path="../../unit.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.FleetUnitInfo = React.createClass({
            displayName: "FleetUnitInfo",
            mixins: [UIComponents.Draggable],
            propTypes: {
                unit: React.PropTypes.instanceOf(Rance.Unit),
                isIdentified: React.PropTypes.bool.isRequired,
                isDraggable: React.PropTypes.bool.isRequired,
                onDragStart: React.PropTypes.func,
                onDragEnd: React.PropTypes.func
            },
            onDragStart: function () {
                this.props.onDragStart(this.props.unit);
            },
            onDragEnd: function (e) {
                this.props.onDragEnd(e);
            },
            render: function () {
                var unit = this.props.unit;
                var isNotDetected = !this.props.isIdentified;
                var divProps = {
                    className: "fleet-unit-info"
                };
                if (this.props.isDraggable) {
                    divProps.className += " draggable";
                    divProps.onTouchStart = this.handleMouseDown;
                    divProps.onMouseDown = this.handleMouseDown;
                    if (this.state.dragging) {
                        divProps.style = this.dragPos;
                        divProps.className += " dragging";
                    }
                }
                return (React.DOM.div(divProps, React.DOM.div({
                    className: "fleet-unit-info-icon-container"
                }, React.DOM.img({
                    className: "fleet-unit-info-icon",
                    src: isNotDetected ? "img\/icons\/unDetected.png" : unit.template.icon
                })), React.DOM.div({
                    className: "fleet-unit-info-info"
                }, UIComponents.FleetUnitInfoName({
                    unit: unit,
                    isNotDetected: isNotDetected
                }), React.DOM.div({
                    className: "fleet-unit-info-type"
                }, isNotDetected ? "???" : unit.template.displayName)), UIComponents.UnitStrength({
                    maxHealth: unit.maxHealth,
                    currentHealth: unit.currentHealth,
                    isSquadron: true,
                    isNotDetected: isNotDetected
                })));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="fleetunitinfo.ts"/>
/// <reference path="../../fleet.ts" />
/// <reference path="../../player.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.FleetContents = React.createClass({
            displayName: "FleetContents",
            propTypes: {
                fleet: React.PropTypes.instanceOf(Rance.Fleet).isRequired,
                player: React.PropTypes.instanceOf(Rance.Player).isRequired,
                onMouseUp: React.PropTypes.func,
                onDragStart: React.PropTypes.func,
                onDragEnd: React.PropTypes.func,
                onDragMove: React.PropTypes.func,
            },
            handleMouseUp: function () {
                if (!this.props.onMouseUp)
                    return;
                this.props.onMouseUp(this.props.fleet);
            },
            render: function () {
                var fleetUnitInfos = [];
                var fleet = this.props.fleet;
                var hasDraggableContent = Boolean(this.props.onDragStart ||
                    this.props.onDragEnd);
                for (var i = 0; i < fleet.units.length; i++) {
                    var unit = fleet.units[i];
                    fleetUnitInfos.push(UIComponents.FleetUnitInfo({
                        key: unit.id,
                        unit: unit,
                        isDraggable: hasDraggableContent,
                        onDragStart: this.props.onDragStart,
                        onDragMove: this.props.onDragMove,
                        onDragEnd: this.props.onDragEnd,
                        isIdentified: this.props.player.unitIsIdentified(unit)
                    }));
                }
                if (hasDraggableContent) {
                    fleetUnitInfos.push(React.DOM.div({
                        className: "fleet-contents-dummy-unit",
                        key: "dummy"
                    }));
                }
                return (React.DOM.div({
                    className: "fleet-contents",
                    onMouseUp: this.handleMouseUp
                }, fleetUnitInfos));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="fleetcontents.ts"/>
/// <reference path="../../fleet.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.FleetReorganization = React.createClass({
            displayName: "FleetReorganization",
            propTypes: {
                closeReorganization: React.PropTypes.func,
                fleets: React.PropTypes.arrayOf(React.PropTypes.instanceOf(Rance.Fleet))
            },
            getInitialState: function () {
                return ({
                    currentDragUnit: null
                });
            },
            handleDragStart: function (unit) {
                this.setState({
                    currentDragUnit: unit
                });
            },
            handleDragEnd: function (dropSuccesful) {
                if (dropSuccesful === void 0) { dropSuccesful = false; }
                this.setState({
                    currentDragUnit: null
                });
            },
            handleDrop: function (fleet) {
                var draggingUnit = this.state.currentDragUnit;
                if (draggingUnit) {
                    var oldFleet = draggingUnit.fleet;
                    oldFleet.transferUnit(fleet, draggingUnit);
                    Rance.eventManager.dispatchEvent("playerControlUpdated", null);
                }
                this.handleDragEnd(true);
            },
            handleClose: function () {
                this.hasClosed = true;
                this.props.closeReorganization();
            },
            componentWillUnmount: function () {
                if (this.hasClosed)
                    return;
                Rance.eventManager.dispatchEvent("endReorganizingFleets");
            },
            render: function () {
                var selectedFleets = this.props.fleets;
                if (!selectedFleets || selectedFleets.length < 1) {
                    return null;
                }
                return (React.DOM.div({
                    className: "fleet-reorganization"
                }, React.DOM.div({
                    className: "fleet-reorganization-header"
                }, "Reorganize fleets"), React.DOM.div({
                    className: "fleet-reorganization-subheader"
                }, React.DOM.div({
                    className: "fleet-reorganization-subheader-fleet-name" +
                        " fleet-reorganization-subheader-fleet-name-left",
                }, selectedFleets[0].name), React.DOM.div({
                    className: "fleet-reorganization-subheader-center"
                }, null), React.DOM.div({
                    className: "fleet-reorganization-subheader-fleet-name" +
                        " fleet-reorganization-subheader-fleet-name-right",
                }, selectedFleets[1].name)), React.DOM.div({
                    className: "fleet-reorganization-contents"
                }, UIComponents.FleetContents({
                    fleet: selectedFleets[0],
                    onMouseUp: this.handleDrop,
                    onDragStart: this.handleDragStart,
                    onDragEnd: this.handleDragEnd,
                    player: selectedFleets[0].player
                }), React.DOM.div({
                    className: "fleet-reorganization-contents-divider"
                }, null), UIComponents.FleetContents({
                    fleet: selectedFleets[1],
                    onMouseUp: this.handleDrop,
                    onDragStart: this.handleDragStart,
                    onDragEnd: this.handleDragEnd,
                    player: selectedFleets[0].player
                })), React.DOM.div({
                    className: "fleet-reorganization-footer"
                }, React.DOM.button({
                    className: "close-reorganization",
                    onClick: this.handleClose
                }, "Close"))));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="fleetinfo.ts"/>
/// <reference path="fleetcontents.ts"/>
/// <reference path="fleetreorganization.ts"/>
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.FleetSelection = React.createClass({
            displayName: "FleetSelection",
            mergeFleets: function () {
                Rance.eventManager.dispatchEvent("mergeFleets", null);
            },
            reorganizeFleets: function () {
                Rance.eventManager.dispatchEvent("startReorganizingFleets", this.props.selectedFleets);
            },
            setElementPosition: function () {
                if (!this.refs.selected)
                    return;
                var domNode = this.refs.selected.getDOMNode();
                if (!this.props.selectedStar) {
                    domNode.style.left = 0;
                }
                else {
                    var containerNode = document.getElementsByClassName("galaxy-map-ui-bottom-left")[0];
                    var actionsNode = containerNode.firstChild.firstChild;
                    var actionsRect = actionsNode.getBoundingClientRect();
                    var rightMostNode = (containerNode.childElementCount > 1 ?
                        containerNode.lastChild.lastChild :
                        containerNode.lastChild);
                    var rightMostRect = rightMostNode.getBoundingClientRect();
                    var ownBottom = domNode.getBoundingClientRect().bottom;
                    var first = this.refs.main.getDOMNode().firstChild;
                    if (ownBottom > actionsRect.top) {
                        var styleString = "" + (rightMostRect.right) + "px";
                        domNode.style.left = styleString;
                        first.style.left = styleString;
                        first.classList.add("fleet-selection-displaced");
                    }
                    else {
                        domNode.style.left = 0;
                        first.style.left = 0;
                        first.classList.remove("fleet-selection-displaced");
                    }
                }
            },
            componentDidMount: function () {
                this.setElementPosition();
                Rance.eventManager.addEventListener("possibleActionsUpdated", this.setElementPosition);
                window.addEventListener("resize", this.setElementPosition, false);
            },
            componentDidUpdate: function () {
                this.setElementPosition();
            },
            componentWillUnmount: function () {
                Rance.eventManager.removeEventListener("possibleActionsUpdated", this.setElementPosition);
                window.removeEventListener("resize", this.setElementPosition);
            },
            render: function () {
                var selectedFleets = this.props.selectedFleets;
                if (!selectedFleets || selectedFleets.length <= 0) {
                    return null;
                }
                var allFleetsInSameLocation = true;
                var hasMultipleSelected = selectedFleets.length >= 2;
                for (var i = 1; i < selectedFleets.length; i++) {
                    if (selectedFleets[i].location !== selectedFleets[i - 1].location) {
                        allFleetsInSameLocation = false;
                        break;
                    }
                }
                var fleetInfos = [];
                for (var i = 0; i < selectedFleets.length; i++) {
                    var fleet = selectedFleets[i];
                    var infoProps = {
                        key: fleet.id,
                        fleet: fleet,
                        hasMultipleSelected: hasMultipleSelected,
                        isInspecting: this.props.isInspecting,
                        isNotDetected: this.props.isInspecting && !this.props.player.fleetIsFullyIdentified(fleet)
                    };
                    fleetInfos.push(UIComponents.FleetInfo(infoProps));
                }
                var fleetSelectionControls = null;
                if (hasMultipleSelected) {
                    var fleetStealthsAreClashing = selectedFleets.length === 2 && selectedFleets[0].isStealthy !== selectedFleets[1].isStealthy;
                    var mergeProps = {
                        className: "fleet-selection-controls-merge"
                    };
                    if (allFleetsInSameLocation && !this.props.isInspecting && !fleetStealthsAreClashing) {
                        mergeProps.onClick = this.mergeFleets;
                    }
                    else {
                        mergeProps.disabled = true;
                        mergeProps.className += " disabled";
                    }
                    var reorganizeProps = {
                        className: "fleet-selection-controls-reorganize"
                    };
                    if (allFleetsInSameLocation && selectedFleets.length === 2 && !this.props.isInspecting &&
                        !fleetStealthsAreClashing) {
                        reorganizeProps.onClick = this.reorganizeFleets;
                    }
                    else {
                        reorganizeProps.disabled = true;
                        reorganizeProps.className += " disabled";
                    }
                    fleetSelectionControls = React.DOM.div({
                        className: "fleet-selection-controls"
                    }, React.DOM.button(reorganizeProps, "reorganize"), React.DOM.button(mergeProps, "merge"));
                }
                var fleetContents = null;
                if (!hasMultipleSelected) {
                    fleetContents = UIComponents.FleetContents({
                        fleet: selectedFleets[0],
                        player: this.props.player
                    });
                }
                var isReorganizing = this.props.currentlyReorganizing.length > 0;
                var reorganizeElement = null;
                if (isReorganizing) {
                    reorganizeElement = UIComponents.FleetReorganization({
                        fleets: this.props.currentlyReorganizing,
                        closeReorganization: this.props.closeReorganization
                    });
                }
                return (React.DOM.div({
                    className: "fleet-selection",
                    ref: "main"
                }, fleetSelectionControls, hasMultipleSelected ? null : fleetInfos, React.DOM.div({
                    className: "fleet-selection-selected-wrapper"
                }, React.DOM.div({
                    className: "fleet-selection-selected" + (isReorganizing ? " reorganizing" : ""),
                    ref: "selected"
                }, hasMultipleSelected ? fleetInfos : null, fleetContents), reorganizeElement)));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="defencebuildinglist.ts"/>
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.StarInfo = React.createClass({
            displayName: "StarInfo",
            shouldComponentUpdate: function (newProps) {
                return this.props.selectedStar !== newProps.selectedStar;
            },
            render: function () {
                var star = this.props.selectedStar;
                if (!star)
                    return null;
                var dumpDebugInfoButton = null;
                if (Rance.Options.debugMode) {
                    dumpDebugInfoButton = React.DOM.button({
                        className: "star-info-dump-debug-button",
                        onClick: function (e) {
                            console.log(star);
                            console.log(star.mapGenData);
                        }
                    }, "Debug");
                }
                return (React.DOM.div({
                    className: "star-info"
                }, React.DOM.div({
                    className: "star-info-name"
                }, star.name), React.DOM.div({
                    className: "star-info-owner"
                }, star.owner ? star.owner.name : null), dumpDebugInfoButton, React.DOM.div({
                    className: "star-info-location"
                }, "x: " + star.x.toFixed() +
                    " y: " + star.y.toFixed()), React.DOM.div({
                    className: "star-info-income"
                }, "Income: " + star.getIncome()), UIComponents.DefenceBuildingList({
                    buildings: star.buildings["defence"]
                })));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../playerflag.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.AttackTarget = React.createClass({
            displayName: "AttackTarget",
            handleAttack: function () {
                Rance.eventManager.dispatchEvent("attackTarget", this.props.attackTarget);
            },
            render: function () {
                var target = this.props.attackTarget;
                return (React.DOM.div({
                    className: "attack-target",
                    onClick: this.handleAttack
                }, React.DOM.div({
                    className: "attack-target-type"
                }, target.type), UIComponents.PlayerFlag({
                    flag: target.enemy.flag,
                    props: {
                        className: "attack-target-player-icon"
                    }
                })));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../mixins/updatewhenmoneychanges.ts" />
/// <reference path="../../player.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.BuildableBuilding = React.createClass({
            displayName: "BuildableBuilding",
            mixins: [UIComponents.UpdateWhenMoneyChanges],
            propTypes: {
                template: React.PropTypes.object.isRequired,
                player: React.PropTypes.instanceOf(Rance.Player).isRequired,
                buildCost: React.PropTypes.number.isRequired,
                handleClick: React.PropTypes.func.isRequired
            },
            getInitialState: function () {
                return ({
                    canAfford: this.props.player.money >= this.props.buildCost
                });
            },
            overrideHandleMoneyChange: function () {
                this.setState({
                    canAfford: this.props.player.money >= this.props.buildCost
                });
            },
            makeCell: function (type) {
                var cellProps = {};
                cellProps.key = type;
                cellProps.className = "buildable-building-list-item-cell " + type;
                var cellContent;
                switch (type) {
                    case ("buildCost"):
                        {
                            if (!this.state.canAfford) {
                                cellProps.className += " negative";
                            }
                        }
                    default:
                        {
                            cellContent = this.props[type];
                            break;
                        }
                }
                return (React.DOM.td(cellProps, cellContent));
            },
            render: function () {
                var template = this.props.template;
                var cells = [];
                var columns = this.props.activeColumns;
                for (var i = 0; i < columns.length; i++) {
                    cells.push(this.makeCell(columns[i].key));
                }
                var props = {
                    className: "buildable-item buildable-building",
                    onClick: this.props.handleClick,
                    title: template.description
                };
                if (!this.state.canAfford) {
                    props.onClick = null;
                    props.disabled = true;
                    props.className += " disabled";
                }
                return (React.DOM.tr(props, cells));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../unitlist/list.ts" />
/// <reference path="buildablebuilding.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.BuildableBuildingList = React.createClass({
            displayName: "BuildableBuildingList",
            getInitialState: function () {
                return ({
                    buildingTemplates: this.props.star.getBuildableBuildings()
                });
            },
            updateBuildings: function () {
                var buildingTemplates = this.props.star.getBuildableBuildings();
                this.setState({
                    buildingTemplates: buildingTemplates
                });
                if (buildingTemplates.length < 1) {
                    this.props.clearExpandedAction();
                }
            },
            buildBuilding: function (rowItem) {
                var template = rowItem.data.template;
                var building = new Rance.Building({
                    template: template,
                    location: this.props.star
                });
                if (!building.controller)
                    building.controller = this.props.humanPlayer;
                this.props.star.addBuilding(building);
                building.controller.money -= template.buildCost;
                this.updateBuildings();
            },
            render: function () {
                if (this.state.buildingTemplates.length < 1)
                    return null;
                var rows = [];
                for (var i = 0; i < this.state.buildingTemplates.length; i++) {
                    var template = this.state.buildingTemplates[i];
                    var data = {
                        template: template,
                        typeName: template.displayName,
                        buildCost: template.buildCost,
                        player: this.props.player,
                        rowConstructor: UIComponents.BuildableBuilding
                    };
                    rows.push({
                        key: i,
                        data: data
                    });
                }
                var columns = [
                    {
                        label: "Name",
                        key: "typeName",
                        defaultOrder: "asc"
                    },
                    {
                        label: "Cost",
                        key: "buildCost",
                        defaultOrder: "desc"
                    }
                ];
                return (React.DOM.div({ className: "buildable-item-list buildable-building-list fixed-table-parent" }, UIComponents.List({
                    listItems: rows,
                    initialColumns: columns,
                    onRowChange: this.buildBuilding,
                    addSpacer: true
                })));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../../player.ts" />
/// <reference path="../mixins/updatewhenmoneychanges.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.BuildingUpgradeListItem = React.createClass({
            displayName: "BuildingUpgradeListItem",
            mixins: [UIComponents.UpdateWhenMoneyChanges],
            propTypes: {
                player: React.PropTypes.instanceOf(Rance.Player).isRequired,
                handleUpgrade: React.PropTypes.func.isRequired,
                upgradeData: React.PropTypes.object.isRequired
            },
            getInitialState: function () {
                return ({
                    canAfford: this.props.player.money >= this.props.upgradeData.cost
                });
            },
            overrideHandleMoneyChange: function () {
                this.setState({
                    canAfford: this.props.player.money >= this.props.upgradeData.cost
                });
            },
            handleClick: function () {
                this.props.handleUpgrade(this.props.upgradeData);
            },
            render: function () {
                var upgradeData = this.props.upgradeData;
                var rowProps = {
                    key: upgradeData.template.type,
                    className: "building-upgrade-list-item",
                    onClick: this.handleClick,
                    title: upgradeData.template.description
                };
                var costProps = {
                    key: "cost",
                    className: "building-upgrade-list-item-cost"
                };
                if (!this.state.canAfford) {
                    rowProps.onClick = null;
                    rowProps.disabled = true;
                    rowProps.className += " disabled";
                    costProps.className += " negative";
                }
                return (React.DOM.tr(rowProps, React.DOM.td({
                    key: "name",
                    className: "building-upgrade-list-item-name"
                }, upgradeData.template.displayName + " " + (upgradeData.level > 1 ? upgradeData.level : "")), React.DOM.td(costProps, upgradeData.cost)));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../../player.ts" />
/// <reference path="../../star.ts" />
/// <reference path="buildingupgradelistitem.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.BuildingUpgradeList = React.createClass({
            displayName: "BuildingUpgradeList",
            propTypes: {
                star: React.PropTypes.instanceOf(Rance.Star).isRequired,
                player: React.PropTypes.instanceOf(Rance.Player).isRequired,
                clearExpandedAction: React.PropTypes.func.isRequired
            },
            hasAvailableUpgrades: function () {
                var possibleUpgrades = this.props.star.getBuildingUpgrades();
                return Object.keys(possibleUpgrades).length > 0;
            },
            upgradeBuilding: function (upgradeData) {
                var star = upgradeData.parentBuilding.location;
                var newBuilding = new Rance.Building({
                    template: upgradeData.template,
                    location: star,
                    controller: upgradeData.parentBuilding.controller,
                    upgradeLevel: upgradeData.level,
                    totalCost: upgradeData.parentBuilding.totalCost + upgradeData.cost
                });
                star.removeBuilding(upgradeData.parentBuilding);
                star.addBuilding(newBuilding);
                upgradeData.parentBuilding.controller.money -= upgradeData.cost;
                if (!this.hasAvailableUpgrades()) {
                    this.props.clearExpandedAction();
                }
                else {
                    this.forceUpdate();
                }
            },
            render: function () {
                if (!this.hasAvailableUpgrades())
                    return null;
                var upgradeGroups = [];
                var possibleUpgrades = this.props.star.getBuildingUpgrades();
                var sortedParentBuildings = Object.keys(possibleUpgrades).sort(function (aId, bId) {
                    var a = possibleUpgrades[aId][0].parentBuilding.template.displayName;
                    var b = possibleUpgrades[bId][0].parentBuilding.template.displayName;
                    if (a < b)
                        return -1;
                    else if (a > b)
                        return 1;
                    else
                        return 0;
                });
                for (var i = 0; i < sortedParentBuildings.length; i++) {
                    var parentBuildingId = sortedParentBuildings[i];
                    var upgrades = possibleUpgrades[parentBuildingId];
                    var parentBuilding = upgrades[0].parentBuilding;
                    var upgradeElements = [];
                    for (var j = 0; j < upgrades.length; j++) {
                        if (j > 0) {
                            upgradeElements.push(React.DOM.tr({
                                className: "list-spacer",
                                key: "spacer" + i + j
                            }, React.DOM.td({
                                colSpan: 20
                            }, null)));
                        }
                        ;
                        upgradeElements.push(UIComponents.BuildingUpgradeListItem({
                            key: upgrades[j].template.type,
                            player: this.props.player,
                            handleUpgrade: this.upgradeBuilding,
                            upgradeData: upgrades[j]
                        }));
                    }
                    var parentElement = React.DOM.div({
                        key: "" + parentBuilding.id,
                        className: "building-upgrade-group"
                    }, React.DOM.div({
                        className: "building-upgrade-group-header"
                    }, parentBuilding.template.displayName), React.DOM.table({
                        className: "buildable-item-list"
                    }, React.DOM.tbody({}, upgradeElements)));
                    upgradeGroups.push(parentElement);
                }
                return (React.DOM.ul({
                    className: "building-upgrade-list"
                }, upgradeGroups));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../../star.ts" />
/// <reference path="attacktarget.ts"/>
/// <reference path="buildablebuildinglist.ts"/>
/// <reference path="buildingupgradelist.ts"/>
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.PossibleActions = React.createClass({
            displayName: "PossibleActions",
            propTypes: {
                player: React.PropTypes.instanceOf(Rance.Player).isRequired,
                setExpandedActionElementOnParent: React.PropTypes.func.isRequired,
                selectedStar: React.PropTypes.instanceOf(Rance.Star),
                attackTargets: React.PropTypes.arrayOf(React.PropTypes.object)
            },
            getInitialState: function () {
                return ({
                    expandedAction: null,
                    expandedActionElement: null,
                    canUpgradeBuildings: this.canUpgradeBuildings(this.props.selectedStar)
                });
            },
            componentWillReceiveProps: function (newProps) {
                if (this.props.selectedStar !== newProps.selectedStar) {
                    var newState = {};
                    var afterStateSetCallback = null;
                    newState.canUpgradeBuildings = this.canUpgradeBuildings(newProps.selectedStar);
                    if (this.state.expandedActionElement) {
                        newState.expandedAction = null;
                        newState.expandedActionElement = null;
                        afterStateSetCallback = this.updateActions;
                    }
                    this.setState(newState, afterStateSetCallback);
                }
            },
            componentDidMount: function () {
                var self = this;
                Rance.eventManager.addEventListener("clearPossibleActions", this.clearExpandedAction);
                Rance.eventManager.addEventListener("humanPlayerBuiltBuilding", this.handlePlayerBuiltBuilding);
            },
            componentWillUnmount: function () {
                Rance.eventManager.removeAllListeners("clearPossibleActions");
                Rance.eventManager.removeEventListener("humanPlayerBuiltBuilding", this.handlePlayerBuiltBuilding);
            },
            canUpgradeBuildings: function (star) {
                return star && Object.keys(star.getBuildingUpgrades()).length > 0;
            },
            handlePlayerBuiltBuilding: function () {
                this.setState({
                    canUpgradeBuildings: this.canUpgradeBuildings(this.props.selectedStar)
                });
            },
            updateActions: function () {
                this.props.setExpandedActionElementOnParent(this.state.expandedActionElement);
                Rance.eventManager.dispatchEvent("possibleActionsUpdated");
            },
            clearExpandedAction: function () {
                this.setState({
                    expandedAction: null,
                    expandedActionElement: null
                }, this.updateActions);
            },
            buildBuildings: function () {
                if (!this.props.selectedStar ||
                    this.state.expandedAction === "buildBuildings") {
                    this.clearExpandedAction();
                }
                else {
                    var element = React.DOM.div({
                        className: "expanded-action"
                    }, UIComponents.BuildableBuildingList({
                        player: this.props.player,
                        star: this.props.selectedStar,
                        clearExpandedAction: this.clearExpandedAction
                    }));
                    this.setState({
                        expandedAction: "buildBuildings",
                        expandedActionElement: element
                    }, this.updateActions);
                }
            },
            upgradeBuildings: function () {
                if (!this.props.selectedStar ||
                    this.state.expandedAction === "upgradeBuildings") {
                    this.clearExpandedAction();
                }
                else {
                    var element = React.DOM.div({
                        className: "expanded-action"
                    }, UIComponents.BuildingUpgradeList({
                        player: this.props.player,
                        star: this.props.selectedStar,
                        clearExpandedAction: this.clearExpandedAction
                    }));
                    this.setState({
                        expandedAction: "upgradeBuildings",
                        expandedActionElement: element
                    }, this.updateActions);
                }
            },
            render: function () {
                var allActions = [];
                var attackTargets = this.props.attackTargets;
                if (attackTargets && attackTargets.length > 0) {
                    var attackTargetComponents = [];
                    for (var i = 0; i < attackTargets.length; i++) {
                        var props = {
                            key: i,
                            attackTarget: attackTargets[i]
                        };
                        attackTargetComponents.push(UIComponents.AttackTarget(props));
                    }
                    allActions.push(React.DOM.div({
                        className: "possible-action",
                        key: "attackActions"
                    }, React.DOM.div({ className: "possible-action-title" }, "attack"), attackTargetComponents));
                }
                var star = this.props.selectedStar;
                if (star) {
                    if (star.owner === this.props.player) {
                        if (star.getBuildableBuildings().length > 0) {
                            allActions.push(React.DOM.div({
                                className: "possible-action",
                                onClick: this.buildBuildings,
                                key: "buildActions"
                            }, "construct"));
                        }
                        if (this.state.canUpgradeBuildings) {
                            allActions.push(React.DOM.div({
                                className: "possible-action",
                                onClick: this.upgradeBuildings,
                                key: "upgradeActions"
                            }, "upgrade"));
                        }
                    }
                }
                if (allActions.length < 1) {
                    return null;
                }
                var possibleActions = React.DOM.div({
                    className: "possible-actions"
                }, allActions);
                return (React.DOM.div({
                    className: "possible-actions-wrapper"
                }, React.DOM.div({
                    className: "possible-actions-container" +
                        (this.state.expandedAction ? " has-expanded-action" : "")
                }, possibleActions)));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../lib/pixi.d.ts" />
/// <reference path="galaxymap.ts" />
/// <reference path="templateinterfaces/imaprendererlayertemplate.d.ts" />
var Rance;
(function (Rance) {
    var MapRendererLayer = (function () {
        function MapRendererLayer(template) {
            this.isDirty = true;
            this.template = template;
            this.container = new PIXI.Container();
            this.container.interactiveChildren = template.interactive;
            this.alpha = template.alpha || 1;
        }
        Object.defineProperty(MapRendererLayer.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (newAlpha) {
                this._alpha = newAlpha;
                this.container.alpha = newAlpha;
            },
            enumerable: true,
            configurable: true
        });
        MapRendererLayer.prototype.resetAlpha = function () {
            this.alpha = this.template.alpha || 1;
        };
        MapRendererLayer.prototype.draw = function (map, mapRenderer) {
            if (!this.isDirty)
                return;
            this.container.removeChildren();
            this.container.addChild(this.template.drawingFunction.call(mapRenderer, map));
            this.isDirty = false;
        };
        return MapRendererLayer;
    }());
    Rance.MapRendererLayer = MapRendererLayer;
})(Rance || (Rance = {}));
/// <reference path="templateinterfaces/imaprenderermapmodetemplate.d.ts" />
/// <reference path="maprendererlayer.ts" />
var Rance;
(function (Rance) {
    var MapRendererMapMode = (function () {
        function MapRendererMapMode(template) {
            this.layers = [];
            this.activeLayers = {};
            this.template = template;
            this.displayName = template.displayName;
        }
        MapRendererMapMode.prototype.addLayer = function (layer, isActive) {
            if (isActive === void 0) { isActive = true; }
            if (this.hasLayer(layer)) {
                throw new Error("Tried to add duplicate layer " + layer.template.key);
            }
            this.layers.push(layer);
            this.activeLayers[layer.template.key] = isActive;
        };
        MapRendererMapMode.prototype.getLayerIndex = function (layer) {
            for (var i = 0; i < this.layers.length; i++) {
                if (this.layers[i] === layer)
                    return i;
            }
            return -1;
        };
        MapRendererMapMode.prototype.hasLayer = function (layer) {
            return this.getLayerIndex(layer) !== -1;
        };
        MapRendererMapMode.prototype.getLayerIndexInContainer = function (layer) {
            var index = -1;
            for (var i = 0; i < this.layers.length; i++) {
                if (this.activeLayers[this.layers[i].template.key]) {
                    index++;
                }
                if (this.layers[i] === layer)
                    return index;
            }
            throw new Error("Map mode doesn't have layer " + layer.template.key);
        };
        MapRendererMapMode.prototype.toggleLayer = function (layer) {
            this.activeLayers[layer.template.key] = !this.activeLayers[layer.template.key];
            if (!this.hasLayer(layer)) {
                this.addLayer(layer);
            }
        };
        MapRendererMapMode.prototype.setLayerIndex = function (layer, newIndex) {
            var prevIndex = this.getLayerIndex(layer);
            var spliced = this.layers.splice(prevIndex, 1)[0];
            this.layers.splice(newIndex, 0, spliced);
        };
        MapRendererMapMode.prototype.insertLayerNextToLayer = function (toInsert, target, position) {
            var indexAdjust = (position === "top" ? -1 : 0);
            var newIndex = this.getLayerIndex(target) + indexAdjust;
            this.setLayerIndex(toInsert, newIndex);
        };
        MapRendererMapMode.prototype.getActiveLayers = function () {
            var self = this;
            return (this.layers.filter(function (layer) {
                return self.activeLayers[layer.template.key];
            }));
        };
        MapRendererMapMode.prototype.resetLayers = function () {
            var layersByKey = {};
            var newLayers = [];
            var newActive = {};
            var layersInTemplate = [];
            var layersNotInTemplate = [];
            for (var i = 0; i < this.layers.length; i++) {
                var layer = this.layers[i];
                layersByKey[layer.template.key] = layer;
            }
            for (var i = 0; i < this.template.layers.length; i++) {
                var layerTemplate = this.template.layers[i];
                var layer = layersByKey[layerTemplate.key];
                newLayers.push(layer);
                newActive[layerTemplate.key] = true;
                delete layersByKey[layerTemplate.key];
            }
            for (var key in layersByKey) {
                var layer = layersByKey[key];
                newLayers.push(layer);
                newActive[key] = false;
            }
            this.layers = newLayers;
            this.activeLayers = newActive;
            for (var i = 0; i < this.layers.length; i++) {
                this.layers[i].resetAlpha();
            }
        };
        return MapRendererMapMode;
    }());
    Rance.MapRendererMapMode = MapRendererMapMode;
})(Rance || (Rance = {}));
/// <reference path="../lib/offset.d.ts" />
// some problems with this as well as pixi polyogn rendering can lead to silly behavior sometimes.
// overlapping lines, acute angles etc etc.
// probably have to make a shader based version later but this could still be useful for canvas fallback.
var Rance;
(function (Rance) {
    function starsOnlyShareNarrowBorder(a, b) {
        var minBorderWidth = Rance.Options.display.borderWidth * 2;
        var edge = a.getEdgeWith(b);
        if (!edge) {
            return false;
        }
        var edgeLength = Math.abs(edge.va.x - edge.vb.x) + Math.abs(edge.va.y - edge.vb.y);
        if (edgeLength < minBorderWidth) {
            var sharedNeighbors = a.getSharedNeighborsWith(b);
            var sharedOwnedNeighbors = sharedNeighbors.filter(function (sharedNeighbor) {
                return sharedNeighbor.owner === a.owner;
            });
            return sharedOwnedNeighbors.length === 0;
        }
        else {
            return false;
        }
    }
    Rance.starsOnlyShareNarrowBorder = starsOnlyShareNarrowBorder;
    function getBorderingHalfEdges(stars) {
        var borderingHalfEdges = [];
        function getHalfEdgeOppositeSite(halfEdge) {
            return halfEdge.edge.lSite === halfEdge.site ?
                halfEdge.edge.rSite : halfEdge.edge.lSite;
        }
        function halfEdgeIsBorder(halfEdge) {
            var oppositeSite = getHalfEdgeOppositeSite(halfEdge);
            var isBorderWithOtherOwner = !oppositeSite || !oppositeSite.owner || (oppositeSite.owner !== halfEdge.site.owner);
            var isBorderWithSameOwner = false;
            if (!isBorderWithOtherOwner) {
                isBorderWithSameOwner = starsOnlyShareNarrowBorder(halfEdge.site, oppositeSite) ||
                    halfEdge.site.getDistanceToStar(oppositeSite) > 3;
            }
            return isBorderWithOtherOwner || isBorderWithSameOwner;
        }
        function halfEdgeSharesOwner(halfEdge) {
            var oppositeSite = getHalfEdgeOppositeSite(halfEdge);
            var sharesOwner = Boolean(oppositeSite) && Boolean(oppositeSite.owner) &&
                (oppositeSite.owner === halfEdge.site.owner);
            return sharesOwner && !starsOnlyShareNarrowBorder(halfEdge.site, oppositeSite);
        }
        function getContiguousHalfEdgeBetweenSharedSites(sharedEdge) {
            var contiguousEdgeEndPoint = sharedEdge.getStartpoint();
            var oppositeSite = getHalfEdgeOppositeSite(sharedEdge);
            for (var i = 0; i < oppositeSite.voronoiCell.halfedges.length; i++) {
                var halfEdge = oppositeSite.voronoiCell.halfedges[i];
                if (halfEdge.getStartpoint() === contiguousEdgeEndPoint) {
                    return halfEdge;
                }
            }
            return false;
        }
        var startEdge;
        var star;
        for (var i = 0; i < stars.length; i++) {
            if (star)
                break;
            for (var j = 0; j < stars[i].voronoiCell.halfedges.length; j++) {
                var halfEdge = stars[i].voronoiCell.halfedges[j];
                if (halfEdgeIsBorder(halfEdge)) {
                    star = stars[i];
                    startEdge = halfEdge;
                    break;
                }
            }
        }
        if (!star)
            throw new Error("Couldn't find starting location for border polygon");
        var hasProcessedStartEdge = false;
        var contiguousEdge = null;
        // just a precaution to make sure we don't get into an infinite loop
        // should always return earlier unless somethings wrong
        for (var j = 0; j < stars.length * 40; j++) {
            var indexShift = 0;
            for (var _i = 0; _i < star.voronoiCell.halfedges.length; _i++) {
                if (!hasProcessedStartEdge) {
                    contiguousEdge = startEdge;
                }
                if (contiguousEdge) {
                    indexShift = star.voronoiCell.halfedges.indexOf(contiguousEdge);
                    contiguousEdge = null;
                }
                var i = (_i + indexShift) % (star.voronoiCell.halfedges.length);
                var halfEdge = star.voronoiCell.halfedges[i];
                if (halfEdgeIsBorder(halfEdge)) {
                    borderingHalfEdges.push({
                        star: star,
                        halfEdge: halfEdge
                    });
                    if (!startEdge) {
                        startEdge = halfEdge;
                    }
                    else if (halfEdge === startEdge) {
                        if (!hasProcessedStartEdge) {
                            hasProcessedStartEdge = true;
                        }
                        else {
                            return borderingHalfEdges;
                        }
                    }
                }
                else if (halfEdgeSharesOwner(halfEdge)) {
                    contiguousEdge = getContiguousHalfEdgeBetweenSharedSites(halfEdge);
                    star = contiguousEdge.site;
                    break;
                }
            }
        }
        throw new Error("getHalfEdgesConnectingStars got stuck in infinite loop when star id = " + star.id);
    }
    Rance.getBorderingHalfEdges = getBorderingHalfEdges;
    function joinPointsWithin(points, maxDistance) {
        for (var i = points.length - 2; i >= 0; i--) {
            var x1 = points[i].x;
            var y1 = points[i].y;
            var x2 = points[i + 1].x;
            var y2 = points[i + 1].y;
            if (Math.abs(x1 - x2) + Math.abs(y1 - y2) < maxDistance) {
                var newPoint = {
                    x: (x1 + x2) / 2,
                    y: (y1 + y2) / 2
                };
                points.splice(i, 2, newPoint);
            }
        }
    }
    Rance.joinPointsWithin = joinPointsWithin;
    function convertHalfEdgeDataToOffset(halfEdgeData) {
        var convertedToPoints = halfEdgeData.map(function (data) {
            var v1 = data.halfEdge.getStartpoint();
            return ({
                x: v1.x,
                y: v1.y
            });
        });
        joinPointsWithin(convertedToPoints, Rance.Options.display.borderWidth / 2);
        var offset = new Offset();
        offset.arcSegments(0);
        var convertedToOffset = offset.data(convertedToPoints).padding(Rance.Options.display.borderWidth / 2);
        return convertedToOffset;
    }
    Rance.convertHalfEdgeDataToOffset = convertHalfEdgeDataToOffset;
    function getRevealedBorderEdges(revealedStars, voronoiInfo) {
        var polyLines = [];
        var processedStarsById = {};
        for (var ii = 0; ii < revealedStars.length; ii++) {
            var star = revealedStars[ii];
            if (processedStarsById[star.id]) {
                continue;
            }
            if (!star.owner.isIndependent) {
                var ownedIsland = star.getIslandForQualifier(function (a, b) {
                    // don't count stars if the only shared border between them is smaller than 10px
                    return (a.owner === b.owner && !starsOnlyShareNarrowBorder(a, b));
                });
                var currentPolyLine = [];
                var halfEdgesDataForIsland = getBorderingHalfEdges(ownedIsland);
                var offsetted = convertHalfEdgeDataToOffset(halfEdgesDataForIsland);
                // set stars
                for (var j = 0; j < offsetted.length; j++) {
                    var point = offsetted[j];
                    var nextPoint = offsetted[(j + 1) % offsetted.length];
                    // offset library can't handle acute angles properly. can lead to crashes if
                    // angle is at map edge due to points going off the map. clamping should fix crashes at least
                    var edgeCenter = {
                        x: Rance.clamp((point.x + nextPoint.x) / 2, voronoiInfo.bounds.x1, voronoiInfo.bounds.x2),
                        y: Rance.clamp((point.y + nextPoint.y) / 2, voronoiInfo.bounds.y1, voronoiInfo.bounds.y2)
                    };
                    var pointStar = point.star || voronoiInfo.getStarAtPoint(edgeCenter);
                    if (!pointStar) {
                        pointStar = voronoiInfo.getStarAtPoint(point);
                        if (!pointStar) {
                            pointStar = voronoiInfo.getStarAtPoint(nextPoint);
                        }
                    }
                    processedStarsById[pointStar.id] = true;
                    point.star = pointStar;
                }
                // find first point in revealed star preceded by unrevealed star
                // set that point as start of polygon
                var startIndex = 0; // default = all stars of polygon are revealed
                for (var j = 0; j < offsetted.length; j++) {
                    var currPoint = offsetted[j];
                    var prevPoint = offsetted[(j === 0 ? offsetted.length - 1 : j - 1)];
                    if (revealedStars.indexOf(currPoint.star) !== -1 && revealedStars.indexOf(prevPoint.star) === -1) {
                        startIndex = j;
                    }
                }
                // get polylines
                for (var _j = startIndex; _j < offsetted.length + startIndex; _j++) {
                    var j = _j % offsetted.length;
                    var point = offsetted[j];
                    if (revealedStars.indexOf(point.star) === -1) {
                        if (currentPolyLine.length > 1) {
                            currentPolyLine.push(point);
                            polyLines.push(currentPolyLine);
                            currentPolyLine = [];
                        }
                    }
                    else {
                        currentPolyLine.push(point);
                    }
                }
                if (currentPolyLine.length > 1) {
                    polyLines.push(currentPolyLine);
                }
            }
        }
        var polyLinesData = [];
        for (var i = 0; i < polyLines.length; i++) {
            var polyLine = polyLines[i];
            var isClosed = Rance.MapGenCore.pointsEqual(polyLine[0], polyLine[polyLine.length - 1]);
            if (isClosed)
                polyLine.pop();
            for (var j = 0; j < polyLine.length; j++) {
                // stupid hack to fix pixi bug with drawing polygons
                // without this consecutive edges with the same angle disappear
                polyLine[j].x += (j % 2) * 0.1;
                polyLine[j].y += (j % 2) * 0.1;
            }
            polyLinesData.push({
                points: polyLine,
                isClosed: isClosed
            });
        }
        return polyLinesData;
    }
    Rance.getRevealedBorderEdges = getRevealedBorderEdges;
})(Rance || (Rance = {}));
/// <reference path="../lib/pixi.d.ts" />
/// <reference path="maprenderermapmode.ts" />
/// <reference path="maprendererlayer.ts" />
/// <reference path="eventmanager.ts"/>
/// <reference path="utility.ts"/>
/// <reference path="color.ts"/>
/// <reference path="borderpolygon.ts"/>
/// <reference path="galaxymap.ts" />
/// <reference path="star.ts" />
/// <reference path="fleet.ts" />
/// <reference path="player.ts" />
var Rance;
(function (Rance) {
    var MapRenderer = (function () {
        function MapRenderer(map, player) {
            this.occupationShaders = {};
            this.layers = {};
            this.mapModes = {};
            this.fowSpriteCache = {};
            this.fleetTextTextureCache = {};
            this.isDirty = true;
            this.preventRender = false;
            this.listeners = {};
            this.container = new PIXI.Container();
            this.galaxyMap = map;
            this.player = player;
        }
        MapRenderer.prototype.destroy = function () {
            this.preventRender = true;
            this.container.renderable = false;
            for (var name in this.listeners) {
                Rance.eventManager.removeEventListener(name, this.listeners[name]);
            }
            this.container.removeChildren();
            this.parent.removeChild(this.container);
            this.player = null;
            this.container = null;
            this.parent = null;
            this.occupationShaders = null;
            for (var starId in this.fowSpriteCache) {
                var sprite = this.fowSpriteCache[starId];
                sprite.renderable = false;
                sprite.texture.destroy(true);
                this.fowSpriteCache[starId] = null;
            }
            for (var fleetSize in this.fleetTextTextureCache) {
                var texture = this.fleetTextTextureCache[fleetSize];
                texture.destroy(true);
            }
        };
        MapRenderer.prototype.init = function () {
            this.makeFowSprite();
            this.initLayers();
            this.initMapModes();
            this.addEventListeners();
        };
        MapRenderer.prototype.addEventListeners = function () {
            var self = this;
            this.listeners["renderMap"] =
                Rance.eventManager.addEventListener("renderMap", this.setAllLayersAsDirty.bind(this));
            this.listeners["renderLayer"] =
                Rance.eventManager.addEventListener("renderLayer", function (layerName, star) {
                    var passesStarVisibilityCheck = true;
                    if (star) {
                        switch (layerName) {
                            case "fleets":
                                {
                                    passesStarVisibilityCheck = self.player.starIsVisible(star);
                                    break;
                                }
                            default:
                                {
                                    passesStarVisibilityCheck = self.player.starIsRevealed(star);
                                    break;
                                }
                        }
                    }
                    if (passesStarVisibilityCheck || Rance.Options.debugMode) {
                        self.setLayerAsDirty(layerName);
                    }
                });
            var boundUpdateOffsets = this.updateShaderOffsets.bind(this);
            var boundUpdateZoom = this.updateShaderZoom.bind(this);
            this.listeners["registerOnMoveCallback"] =
                Rance.eventManager.addEventListener("registerOnMoveCallback", function (callbacks) {
                    callbacks.push(boundUpdateOffsets);
                });
            this.listeners["registerOnZoomCallback"] =
                Rance.eventManager.addEventListener("registerOnZoomCallback", function (callbacks) {
                    callbacks.push(boundUpdateZoom);
                });
        };
        MapRenderer.prototype.setPlayer = function (player) {
            this.player = player;
            this.setAllLayersAsDirty();
        };
        MapRenderer.prototype.updateShaderOffsets = function (x, y) {
            for (var owner in this.occupationShaders) {
                for (var occupier in this.occupationShaders[owner]) {
                    var shader = this.occupationShaders[owner][occupier];
                    shader.uniforms.offset.value = [-x, y];
                }
            }
        };
        MapRenderer.prototype.updateShaderZoom = function (zoom) {
            for (var owner in this.occupationShaders) {
                for (var occupier in this.occupationShaders[owner]) {
                    var shader = this.occupationShaders[owner][occupier];
                    shader.uniforms.zoom.value = zoom;
                }
            }
        };
        MapRenderer.prototype.makeFowSprite = function () {
            if (!this.fowTilingSprite) {
                var fowTexture = PIXI.Texture.fromFrame("img\/fowTexture.png");
                var w = this.galaxyMap.width;
                var h = this.galaxyMap.height;
                this.fowTilingSprite = new PIXI.extras.TilingSprite(fowTexture, w, h);
            }
        };
        MapRenderer.prototype.getFowSpriteForStar = function (star) {
            // silly hack to make sure first texture gets created properly
            if (!this.fowSpriteCache[star.id] ||
                Object.keys(this.fowSpriteCache).length < 4) {
                var poly = new PIXI.Polygon(star.voronoiCell.vertices);
                var gfx = new PIXI.Graphics();
                gfx.isMask = true;
                gfx.beginFill(0);
                gfx.drawShape(poly);
                gfx.endFill();
                this.fowTilingSprite.removeChildren();
                this.fowTilingSprite.mask = gfx;
                this.fowTilingSprite.addChild(gfx);
                // triggers bounds update that gets skipped if we just call generateTexture()
                var bounds = this.fowTilingSprite.getBounds();
                var rendered = this.fowTilingSprite.generateTexture(app.renderer.renderer, PIXI.SCALE_MODES.DEFAULT, 1, bounds);
                var sprite = new PIXI.Sprite(rendered);
                this.fowSpriteCache[star.id] = sprite;
                this.fowTilingSprite.mask = null;
            }
            return this.fowSpriteCache[star.id];
        };
        MapRenderer.prototype.getOccupationShader = function (owner, occupier) {
            if (!this.occupationShaders[owner.id]) {
                this.occupationShaders[owner.id] = {};
            }
            if (!this.occupationShaders[owner.id][occupier.id]) {
                var baseColor = PIXI.utils.hex2rgb(owner.color);
                baseColor.push(1.0);
                var occupierColor = PIXI.utils.hex2rgb(occupier.color);
                occupierColor.push(1.0);
                var uniforms = {
                    baseColor: { type: "4fv", value: baseColor },
                    lineColor: { type: "4fv", value: occupierColor },
                    gapSize: { type: "1f", value: 3.0 },
                    offset: { type: "2f", value: [0.0, 0.0] },
                    zoom: { type: "1f", value: 1.0 }
                };
                this.occupationShaders[owner.id][occupier.id] = new Rance.OccupationFilter(uniforms);
            }
            return this.occupationShaders[owner.id][occupier.id];
        };
        MapRenderer.prototype.getFleetTextTexture = function (fleet) {
            var fleetSize = fleet.units.length;
            if (!this.fleetTextTextureCache[fleetSize]) {
                var text = new PIXI.Text("" + fleetSize, {
                    fill: "#FFFFFF",
                    stroke: "#000000",
                    strokeThickness: 3
                });
                // triggers bounds update that gets skipped if we just call generateTexture()
                text.getBounds();
                this.fleetTextTextureCache[fleetSize] = text.generateTexture(app.renderer.renderer);
                window.setTimeout(function () {
                    text.texture.destroy(true);
                }, 0);
            }
            return this.fleetTextTextureCache[fleetSize];
        };
        MapRenderer.prototype.initLayers = function () {
            for (var layerKey in app.moduleData.Templates.MapRendererLayers) {
                var template = app.moduleData.Templates.MapRendererLayers[layerKey];
                var layer = new Rance.MapRendererLayer(template);
                this.layers[layerKey] = layer;
            }
        };
        MapRenderer.prototype.initMapModes = function () {
            var buildMapMode = function (template) {
                var alreadyAdded = {};
                var mapMode = new Rance.MapRendererMapMode(template);
                for (var i = 0; i < template.layers.length; i++) {
                    var layer = template.layers[i];
                    mapMode.addLayer(this.layers[layer.key], true);
                    alreadyAdded[layer.key] = true;
                }
                for (var layerKey in this.layers) {
                    if (!alreadyAdded[layerKey]) {
                        mapMode.addLayer(this.layers[layerKey], false);
                        alreadyAdded[layerKey] = true;
                    }
                }
                this.mapModes[mapModeKey] = mapMode;
            }.bind(this);
            for (var mapModeKey in app.moduleData.Templates.MapRendererMapModes) {
                var template = app.moduleData.Templates.MapRendererMapModes[mapModeKey];
                buildMapMode(template);
            }
            // var customMapModeTemplate: IMapRendererMapModeTemplate =
            // {
            //   key: "custom",
            //   displayName: "Custom",
            //   layers: this.mapModes[Object.keys(this.mapModes)[0]].template.layers
            // };
            // buildMapMode(customMapModeTemplate);
        };
        MapRenderer.prototype.setParent = function (newParent) {
            var oldParent = this.parent;
            if (oldParent) {
                oldParent.removeChild(this.container);
            }
            this.parent = newParent;
            newParent.addChild(this.container);
        };
        MapRenderer.prototype.resetContainer = function () {
            this.container.removeChildren();
        };
        MapRenderer.prototype.setLayerAsDirty = function (layerName) {
            var layer = this.layers[layerName];
            layer.isDirty = true;
            this.isDirty = true;
            // TODO performance
            this.render();
        };
        MapRenderer.prototype.setAllLayersAsDirty = function () {
            for (var i = 0; i < this.currentMapMode.layers.length; i++) {
                this.currentMapMode.layers[i].isDirty = true;
            }
            this.isDirty = true;
            // TODO performance
            this.render();
        };
        MapRenderer.prototype.updateMapModeLayers = function (updatedLayers) {
            for (var i = 0; i < updatedLayers.length; i++) {
                var layer = updatedLayers[i];
                var childIndex = this.container.getChildIndex(layer.container);
                var mapModeLayerIndex = this.currentMapMode.getLayerIndexInContainer(layer);
                if (childIndex === -1) {
                    this.container.addChildAt(layer.container, mapModeLayerIndex);
                }
                else {
                    this.container.removeChildAt(mapModeLayerIndex + 1);
                }
                this.setLayerAsDirty(layer.template.key);
            }
        };
        MapRenderer.prototype.resetMapModeLayersPosition = function () {
            this.resetContainer();
            var layerData = this.currentMapMode.getActiveLayers();
            for (var i = 0; i < layerData.length; i++) {
                var layer = layerData[i];
                this.container.addChild(layer.container);
            }
        };
        MapRenderer.prototype.setMapModeByKey = function (key) {
            this.setMapMode(this.mapModes[key]);
        };
        MapRenderer.prototype.setMapMode = function (newMapMode) {
            if (!this.mapModes[newMapMode.template.key]) {
                throw new Error("Invalid mapmode " + newMapMode.template.key);
            }
            if (this.currentMapMode && this.currentMapMode === newMapMode) {
                return;
            }
            this.currentMapMode = newMapMode;
            this.resetContainer();
            var layerData = this.currentMapMode.getActiveLayers();
            for (var i = 0; i < layerData.length; i++) {
                var layer = layerData[i];
                this.container.addChild(layer.container);
            }
            this.setAllLayersAsDirty();
        };
        MapRenderer.prototype.render = function () {
            if (this.preventRender || !this.isDirty)
                return;
            var layerData = this.currentMapMode.getActiveLayers();
            for (var i = 0; i < layerData.length; i++) {
                var layer = layerData[i];
                layer.draw(this.galaxyMap, this);
            }
            this.isDirty = false;
        };
        return MapRenderer;
    }());
    Rance.MapRenderer = MapRenderer;
})(Rance || (Rance = {}));
/// <reference path="../../maprenderer.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.MapModeSelector = React.createClass({
            displayName: "MapModeSelector",
            propTypes: {
                mapRenderer: React.PropTypes.instanceOf(Rance.MapRenderer).isRequired,
                onUpdate: React.PropTypes.func
            },
            handleChange: function (e) {
                var target = e.target;
                var value = target.value;
                this.props.mapRenderer.setMapModeByKey(value);
                if (this.props.onUpdate) {
                    this.props.onUpdate();
                }
            },
            makeOptions: function () {
                var mapRenderer = this.props.mapRenderer;
                var options = [];
                for (var key in mapRenderer.mapModes) {
                    var mapMode = mapRenderer.mapModes[key];
                    options.push(React.DOM.option({
                        value: key,
                        key: key
                    }, mapMode.displayName));
                }
                return options;
            },
            render: function () {
                var mapRenderer = this.props.mapRenderer;
                return (React.DOM.select({
                    className: "map-mode-selector",
                    value: mapRenderer.currentMapMode.template.key,
                    onChange: this.handleChange
                }, this.makeOptions()));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.MapRendererLayersListItem = React.createClass({
            displayName: "MapRendererLayersListItem",
            mixins: [UIComponents.Draggable, UIComponents.DropTarget, React.addons.PureRenderMixin],
            cachedMidPoint: undefined,
            getInitialState: function () {
                return ({
                    hoverSide: null
                });
            },
            componentWillReceiveProps: function (newProps) {
                if (newProps.listItemIsDragging !== this.props.listItemIsDragging) {
                    this.cachedMidPoint = undefined;
                    this.clearHover();
                }
            },
            onDragStart: function () {
                this.props.onDragStart(this.props.layer);
            },
            onDragEnd: function () {
                this.props.onDragEnd();
            },
            handleHover: function (e) {
                if (!this.cachedMidPoint) {
                    var rect = this.getDOMNode().getBoundingClientRect();
                    this.cachedMidPoint = rect.top + rect.height / 2;
                }
                var isAbove = e.clientY < this.cachedMidPoint;
                this.setState({
                    hoverSide: (isAbove ? "top" : "bottom")
                });
                this.props.setHoverPosition(this.props.layer, isAbove);
            },
            clearHover: function () {
                this.setState({
                    hoverSide: null
                });
            },
            setLayerAlpha: function (e) {
                var target = e.target;
                var value = parseFloat(target.value);
                if (isFinite(value)) {
                    this.props.updateLayer(this.props.layer);
                    this.props.layer.alpha = value;
                }
                this.forceUpdate();
            },
            render: function () {
                var divProps = {
                    className: "map-renderer-layers-list-item draggable draggable-container",
                    onMouseDown: this.handleMouseDown,
                    onTouchStart: this.handleMouseDown
                };
                if (this.state.dragging) {
                    divProps.style = this.dragPos;
                    divProps.className += " dragging";
                }
                if (this.props.listItemIsDragging) {
                    divProps.onMouseMove = this.handleHover;
                    divProps.onMouseLeave = this.clearHover;
                    if (this.state.hoverSide) {
                        divProps.className += " insert-" + this.state.hoverSide;
                    }
                }
                return (React.DOM.li(divProps, React.DOM.input({
                    type: "checkbox",
                    className: "map-renderer-layers-list-item-checkbox",
                    checked: this.props.isActive,
                    onChange: this.props.toggleActive
                }), React.DOM.span({
                    className: "map-renderer-layers-list-item-name draggable-container"
                }, this.props.layerName), React.DOM.input({
                    className: "map-renderer-layers-list-item-alpha",
                    type: "number",
                    min: 0,
                    max: 1,
                    step: 0.05,
                    value: this.props.layer.alpha,
                    onChange: this.setLayerAlpha
                })));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="maprendererlayerslistitem.ts" />
/// <reference path="../../maprenderer.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.MapRendererLayersList = React.createClass({
            displayName: "MapRendererLayersList",
            mixins: [React.addons.PureRenderMixin],
            propTypes: {
                mapRenderer: React.PropTypes.instanceOf(Rance.MapRenderer).isRequired,
                currentMapMode: React.PropTypes.instanceOf(Rance.MapRendererMapMode).isRequired
            },
            getInitialState: function () {
                return ({
                    currentDraggingLayer: null,
                    indexToSwapInto: undefined,
                    layerKeyToInsertNextTo: null,
                    insertPosition: null
                });
            },
            handleDragStart: function (layer) {
                this.setState({
                    currentDraggingLayer: layer
                });
            },
            handleDragEnd: function () {
                var mapRenderer = this.props.mapRenderer;
                var toInsert = this.state.currentDraggingLayer;
                var insertTarget = mapRenderer.layers[this.state.layerKeyToInsertNextTo];
                mapRenderer.currentMapMode.insertLayerNextToLayer(toInsert, insertTarget, this.state.insertPosition);
                mapRenderer.resetMapModeLayersPosition();
                this.setState({
                    currentDraggingLayer: null,
                    indexToSwapInto: undefined,
                    layerKeyToInsertNextTo: null,
                    insertPosition: null
                });
            },
            handleToggleActive: function (layer) {
                var mapRenderer = this.props.mapRenderer;
                mapRenderer.currentMapMode.toggleLayer(layer);
                mapRenderer.updateMapModeLayers([layer]);
                this.forceUpdate();
            },
            handleSetHoverPosition: function (layer, position) {
                this.setState({
                    layerKeyToInsertNextTo: layer.template.key,
                    insertPosition: position
                });
            },
            updateLayer: function (layer) {
                var mapRenderer = this.props.mapRenderer;
                mapRenderer.setLayerAsDirty(layer.template.key);
            },
            render: function () {
                var mapRenderer = this.props.mapRenderer;
                var mapMode = this.props.currentMapMode;
                if (!mapMode)
                    return null;
                var layersData = mapMode.layers;
                var activeLayers = mapMode.getActiveLayers();
                var listItems = [];
                for (var i = 0; i < layersData.length; i++) {
                    var layer = layersData[i];
                    var layerKey = layer.template.key;
                    listItems.push(UIComponents.MapRendererLayersListItem({
                        layer: layer,
                        layerName: layer.template.displayName,
                        isActive: mapMode.activeLayers[layerKey],
                        key: layerKey,
                        toggleActive: this.handleToggleActive.bind(this, layer),
                        listItemIsDragging: Boolean(this.state.currentDraggingLayer),
                        onDragStart: this.handleDragStart,
                        onDragEnd: this.handleDragEnd,
                        setHoverPosition: this.handleSetHoverPosition,
                        updateLayer: this.updateLayer,
                        containerDragOnly: true,
                        containerElement: this
                    }));
                }
                return (React.DOM.ol({
                    className: "map-renderer-layers-list"
                }, listItems));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="mapmodeselector.ts" />
/// <reference path="maprendererlayerslist.ts" />
/// <reference path="../../maprenderer.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.MapModeSettings = React.createClass({
            displayName: "MapModeSettings",
            propTypes: {
                mapRenderer: React.PropTypes.instanceOf(Rance.MapRenderer).isRequired
            },
            handleReset: function () {
                var mapRenderer = this.props.mapRenderer;
                mapRenderer.currentMapMode.resetLayers();
                mapRenderer.resetMapModeLayersPosition();
                mapRenderer.setAllLayersAsDirty();
                this.refs.layersList.forceUpdate();
            },
            render: function () {
                return (React.DOM.div({
                    className: "map-mode-settings"
                }, UIComponents.MapModeSelector({
                    mapRenderer: this.props.mapRenderer,
                    onUpdate: this.forceUpdate.bind(this),
                    ref: "selector"
                }), React.DOM.button({
                    className: "reset-map-mode-button",
                    onClick: this.handleReset
                }, "Reset"), UIComponents.MapRendererLayersList({
                    mapRenderer: this.props.mapRenderer,
                    currentMapMode: this.props.mapRenderer.currentMapMode,
                    ref: "layersList"
                })));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.Notification = React.createClass({
            displayName: "Notification",
            handleClose: function () {
                this.props.markAsRead(this.props.notification);
            },
            handleClick: function () {
                this.props.togglePopup(this.props.notification);
            },
            handleRightClick: function (e) {
                e.preventDefault();
                e.stopPropagation();
                this.handleClose();
            },
            render: function () {
                var notification = this.props.notification;
                return (React.DOM.li({
                    className: "notification",
                    onClick: this.handleClick,
                    onContextMenu: this.handleRightClick
                }, React.DOM.img({
                    className: "notification-image",
                    src: notification.template.iconSrc
                }), React.DOM.span({
                    className: "notification-message"
                }, notification.makeMessage())));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../../notificationlog.ts" />
/// <reference path="notification.ts" />
/// <reference path="notificationfilterbutton.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.NotificationLog = React.createClass({
            displayName: "NotificationLog",
            mixins: [React.addons.PureRenderMixin],
            updateListener: undefined,
            propTypes: {
                log: React.PropTypes.instanceOf(Rance.NotificationLog).isRequired,
                currentTurn: React.PropTypes.number.isRequired
            },
            getInitialState: function () {
                return ({});
            },
            componentWillReceiveProps: function (newProps) {
                if (newProps.currentTurn !== this.props.currentTurn) {
                    this.scrollTop = undefined;
                }
            },
            componentDidMount: function () {
                this.updateListener = Rance.eventManager.addEventListener("updateNotificationLog", this.forceUpdate.bind(this));
            },
            componentWillUnmount: function () {
                Rance.eventManager.removeEventListener("updateNotificationLog", this.updateListener);
            },
            componentDidUpdate: function () {
                var domNode = this.getDOMNode();
                if (!isFinite(this.scrollTop)) {
                    this.scrollTop = domNode.scrollTop;
                }
                domNode.scrollTop = domNode.scrollHeight;
            },
            getNotificationKey: function (notification) {
                return "" + notification.turn + this.props.log.byTurn[notification.turn].indexOf(notification);
            },
            handleMarkAsRead: function (notification) {
                this.props.log.markAsRead(notification);
                var notificationKey = this.getNotificationKey(notification);
                if (isFinite(this.state[notificationKey])) {
                    this.closePopup(notificationKey);
                }
                else {
                    this.forceUpdate();
                }
            },
            makePopup: function (notification, key) {
                var log = this.props.log;
                var popupId = this.refs.popupManager.makePopup({
                    contentConstructor: UIComponents.ConfirmPopup,
                    contentProps: {
                        contentConstructor: notification.template.contentConstructor,
                        contentProps: {
                            notification: notification
                        },
                        handleOk: this.handleMarkAsRead.bind(this, notification),
                        handleClose: this.closePopup.bind(this, key),
                        okText: "Mark as read",
                        cancelText: "Close",
                        extraButtons: [
                            UIComponents.NotificationFilterButton({
                                key: "notificationFilter",
                                filter: log.notificationFilter,
                                text: "Filter",
                                highlightedOptionKey: notification.template.key
                            })
                        ]
                    },
                    popupProps: {
                        containerDragOnly: true,
                        preventAutoResize: true
                    }
                });
                var stateObj = {};
                stateObj[key] = popupId;
                this.setState(stateObj);
            },
            closePopup: function (key) {
                this.refs.popupManager.closePopup(this.state[key]);
                var stateObj = {};
                stateObj[key] = undefined;
                this.setState(stateObj);
            },
            togglePopup: function (notification) {
                var key = this.getNotificationKey(notification);
                if (isFinite(this.state[key])) {
                    this.closePopup(key);
                }
                else {
                    this.makePopup(notification, key);
                }
            },
            render: function () {
                var log = this.props.log;
                var notifications = log.filterNotifications(log.unread);
                var items = [];
                for (var i = 0; i < notifications.length; i++) {
                    items.push(UIComponents.Notification({
                        notification: notifications[i],
                        key: this.getNotificationKey(notifications[i]),
                        markAsRead: this.handleMarkAsRead,
                        togglePopup: this.togglePopup
                    }));
                }
                return (React.DOM.div({
                    className: "notification-log-container"
                }, React.DOM.ol({
                    className: "notification-log"
                }, items.reverse()), UIComponents.PopupManager({
                    ref: "popupManager"
                })));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../../notificationlog.ts" />
/// <reference path="notificationlog.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.Notifications = React.createClass({
            displayName: "Notifications",
            propTypes: {
                log: React.PropTypes.instanceOf(Rance.NotificationLog).isRequired,
                currentTurn: React.PropTypes.number.isRequired
            },
            render: function () {
                return (React.DOM.div({
                    className: "notifications-container"
                }, UIComponents.NotificationLog({
                    log: this.props.log,
                    currentTurn: this.props.currentTurn,
                    key: "log"
                })));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="tutorial.d.ts"/>
var Rance;
(function (Rance) {
    var Tutorials;
    (function (Tutorials) {
        Tutorials.introTutorial = {
            pages: [
                {
                    content: [
                        "Thanks for checking out spacegame!",
                        "",
                        "This game is still heavily in development. Many things are unfinished or unimplemented, including a proper tutorial."
                    ]
                },
                {
                    content: [
                        "To get started, click on \"Production\" in the top menu. ",
                        "",
                        "Click on a ship type on the right of the production window to add it to your build queue. ",
                        "Units in the queue are built at the end of each turn. ",
                        "",
                        "You can end your turn by clicking the \"End turn\" button at the bottom right of the main window."
                    ]
                },
                {
                    content: [
                        "Built units are assigned to fleets on the map. ",
                        "",
                        "To select fleets, drag a rectangle over them on the map or click on the fleet icon. ",
                        "Selected fleets can be moved by right-clicking.",
                        "",
                        "To move the camera, drag the map while holding down middle mouse button or while holding down ctrl/cmd + right click.",
                        "Touchscreen devices aren't supported yet, sorry."
                    ]
                },
                {
                    content: [
                        "To start a battle, move your fleet to a star containing hostile fleets and click on \"attack\" button in the bottom left of the main window.",
                        "",
                        "In the battle setup screen, drag units from the unit list on the right into the formation on the bottom left or click the \"Auto formation\" button.",
                        "",
                        "To use abilities in battle, hover over the unit you want to target and select the ability to use."
                    ]
                }
            ]
        };
    })(Tutorials = Rance.Tutorials || (Rance.Tutorials = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    (function (tutorialStatus) {
        tutorialStatus[tutorialStatus["neverShow"] = -1] = "neverShow";
        tutorialStatus[tutorialStatus["dontShowThisSession"] = 0] = "dontShowThisSession";
        tutorialStatus[tutorialStatus["show"] = 1] = "show";
    })(Rance.tutorialStatus || (Rance.tutorialStatus = {}));
    var tutorialStatus = Rance.tutorialStatus;
    function saveTutorialState() {
        localStorage.setItem("Rance.TutorialState", JSON.stringify(Rance.TutorialState));
    }
    Rance.saveTutorialState = saveTutorialState;
    function loadTutorialState() {
        if (localStorage["Rance.TutorialState"]) {
            var parsedData = JSON.parse(localStorage.getItem("Rance.TutorialState"));
            Rance.TutorialState = Rance.extendObject(parsedData, Rance.TutorialState, true);
            for (var tutorialId in Rance.TutorialState) {
                if (Rance.TutorialState[tutorialId] === tutorialStatus.dontShowThisSession) {
                    Rance.TutorialState[tutorialId] = Rance.tutorialStatus.show;
                }
            }
        }
    }
    Rance.loadTutorialState = loadTutorialState;
    function resetTutorialState() {
        localStorage.removeItem("Rance.TutorialState");
        Rance.TutorialState = Rance.extendObject(Rance.defaultTutorialState);
    }
    Rance.resetTutorialState = resetTutorialState;
    Rance.defaultTutorialState = {
        introTutorial: tutorialStatus.show
    };
})(Rance || (Rance = {}));
/// <reference path="../../tutorials/tutorialstatus.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.DontShowAgain = React.createClass({
            displayName: "DontShowAgain",
            propTypes: {
                tutorialId: React.PropTypes.string.isRequired
            },
            getInitialState: function () {
                return ({
                    isChecked: this.getTutorialState() === Rance.tutorialStatus.neverShow
                });
            },
            getTutorialState: function () {
                return Rance.TutorialState[this.props.tutorialId];
            },
            toggleState: function () {
                if (this.state.isChecked) {
                    Rance.TutorialState[this.props.tutorialId] = Rance.tutorialStatus.show;
                }
                else {
                    Rance.TutorialState[this.props.tutorialId] = Rance.tutorialStatus.neverShow;
                }
                Rance.saveTutorialState();
                this.setState({
                    isChecked: !this.state.isChecked
                });
            },
            render: function () {
                return (React.DOM.div({
                    className: "dont-show-again-wrapper"
                }, React.DOM.label(null, React.DOM.input({
                    type: "checkBox",
                    ref: "dontShowAgain",
                    className: "dont-show-again",
                    checked: this.state.isChecked,
                    onChange: this.toggleState
                }), "Don't show again")));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../mixins/splitmultilinetext.ts" />
/// <reference path="dontshowagain.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.Tutorial = React.createClass({
            displayName: "Tutorial",
            mixins: [UIComponents.SplitMultilineText],
            propTypes: {
                pages: React.PropTypes.arrayOf(React.PropTypes.any).isRequired,
                tutorialId: React.PropTypes.string.isRequired
            },
            getInitialState: function () {
                return ({
                    currentPage: 0
                });
            },
            componentDidMount: function () {
                this.handleEnterPage(this.props.pages[this.state.currentPage]);
            },
            componentWillUnmount: function () {
                this.handleLeavePage(this.props.pages[this.state.currentPage]);
                this.handleClose();
            },
            handleEnterPage: function (page) {
                if (page.onOpen) {
                    page.onOpen();
                }
                if (page.desiredSize) {
                }
            },
            handleLeavePage: function (page) {
                if (page.onClose) {
                    page.onClose();
                }
                if (page.desiredSize) {
                }
            },
            flipPage: function (amount) {
                var lastPage = this.props.pages.length - 1;
                var newPage = this.state.currentPage + amount;
                newPage = Rance.clamp(newPage, 0, lastPage);
                this.handleLeavePage(this.props.pages[this.state.currentPage]);
                this.setState({
                    currentPage: newPage
                }, this.handleEnterPage.bind(this, this.props.pages[newPage]));
            },
            handleClose: function () {
                if (Rance.TutorialState[this.props.tutorialId] === Rance.tutorialStatus.show) {
                    Rance.TutorialState[this.props.tutorialId] = Rance.tutorialStatus.dontShowThisSession;
                }
            },
            render: function () {
                var hasBackArrow = this.state.currentPage > 0;
                var backElement;
                if (hasBackArrow) {
                    backElement = React.DOM.div({
                        className: "tutorial-flip-page tutorial-flip-page-back",
                        onClick: this.flipPage.bind(this, -1)
                    }, "<");
                }
                else {
                    backElement = React.DOM.div({
                        className: "tutorial-flip-page disabled"
                    });
                }
                var hasForwardArrow = this.state.currentPage < this.props.pages.length - 1;
                var forwardElement;
                if (hasForwardArrow) {
                    forwardElement = React.DOM.div({
                        className: "tutorial-flip-page tutorial-flip-page-forward",
                        onClick: this.flipPage.bind(this, 1)
                    }, ">");
                }
                else {
                    forwardElement = React.DOM.div({
                        className: "tutorial-flip-page disabled"
                    });
                }
                return (React.DOM.div({
                    className: "tutorial"
                }, React.DOM.div({
                    className: "tutorial-inner"
                }, backElement, React.DOM.div({
                    className: "tutorial-content"
                }, this.splitMultilineText(this.props.pages[this.state.currentPage].content)), forwardElement), UIComponents.DontShowAgain({
                    tutorialId: this.props.tutorialId
                })));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../popups/popupmanager.ts" />
/// <reference path="../popups/topmenupopup.ts" />
/// <reference path="../../tutorials/introtutorial.ts" />
/// <reference path="tutorial.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.IntroTutorial = React.createClass({
            displayName: "IntroTutorial",
            popupId: null,
            getInitialState: function () {
                return ({
                    show: Rance.TutorialState["introTutorial"] === Rance.tutorialStatus.show
                });
            },
            componentDidMount: function () {
                if (!this.state.show) {
                    return;
                }
                this.popupId = this.refs.popupManager.makePopup({
                    contentConstructor: UIComponents.TopMenuPopup,
                    contentProps: {
                        handleClose: this.closePopup,
                        contentConstructor: UIComponents.Tutorial,
                        contentProps: {
                            pages: Rance.Tutorials.introTutorial.pages,
                            tutorialId: "introTutorial"
                        }
                    },
                    popupProps: {
                        resizable: true,
                        containerDragOnly: true,
                        initialPosition: {
                            width: 600,
                            height: 350
                        },
                        minWidth: 300,
                        minHeight: 250
                    }
                });
            },
            componentWillUnmount: function () {
                if (this.popupId) {
                    this.closePopup();
                }
            },
            closePopup: function () {
                this.refs.popupManager.closePopup(this.popupId);
                this.popupId = null;
            },
            render: function () {
                if (!this.state.show) {
                    return null;
                }
                return (UIComponents.PopupManager({
                    ref: "popupManager",
                    onlyAllowOne: true
                }));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="topmenu.ts"/>
/// <reference path="topbar.ts"/>
/// <reference path="fleetselection.ts"/>
/// <reference path="starinfo.ts"/>
/// <reference path="../possibleactions/possibleactions.ts"/>
/// <reference path="../mapmodes/mapmodesettings.ts" />
/// <reference path="../notifications/notifications.ts" />
/// <reference path="../tutorials/introtutorial.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.GalaxyMapUI = React.createClass({
            displayName: "GalaxyMapUI",
            getInitialState: function () {
                var pc = this.props.playerControl;
                return ({
                    selectedFleets: pc.selectedFleets,
                    inspectedFleets: pc.inspectedFleets,
                    currentlyReorganizing: pc.currentlyReorganizing,
                    selectedStar: pc.selectedStar,
                    attackTargets: pc.currentAttackTargets,
                    isPlayerTurn: !this.props.game.playerOrder[0].isAI,
                    expandedActionElement: null,
                    hasMapModeSettingsExpanded: false
                });
            },
            componentWillMount: function () {
                Rance.eventManager.addEventListener("playerControlUpdated", this.updateSelection);
                Rance.eventManager.addEventListener("endTurn", this.setPlayerTurn);
            },
            componentWillUnmount: function () {
                Rance.eventManager.removeEventListener("playerControlUpdated", this.updateSelection);
                Rance.eventManager.removeEventListener("endTurn", this.setPlayerTurn);
            },
            componentDidUpdate: function () {
                this.clampExpandedActionElement();
            },
            clampExpandedActionElement: function () {
                if (!this.state.expandedActionElement)
                    return;
                var maxHeight = this.refs.leftColumnContent.getDOMNode().getBoundingClientRect().height;
                var listElement = this.refs.expandedActionElementContainer.getDOMNode().firstChild.firstChild;
                listElement.style.maxHeight = "" + (maxHeight - 10) + "px";
            },
            endTurn: function () {
                this.props.game.endTurn();
            },
            setPlayerTurn: function () {
                this.setState({
                    isPlayerTurn: !this.props.game.activePlayer.isAI
                });
            },
            setExpandedActionElement: function (element) {
                this.setState({
                    expandedActionElement: element
                });
            },
            toggleMapModeSettingsExpanded: function () {
                this.setState({ hasMapModeSettingsExpanded: !this.state.hasMapModeSettingsExpanded });
            },
            updateSelection: function () {
                var pc = this.props.playerControl;
                var star = null;
                if (pc.selectedStar)
                    star = pc.selectedStar;
                else if (pc.areAllFleetsInSameLocation()) {
                    star = pc.selectedFleets[0].location;
                }
                ;
                this.setState({
                    selectedFleets: pc.selectedFleets,
                    inspectedFleets: pc.inspectedFleets,
                    currentlyReorganizing: pc.currentlyReorganizing,
                    selectedStar: star,
                    attackTargets: pc.currentAttackTargets
                });
            },
            closeReorganization: function () {
                Rance.eventManager.dispatchEvent("endReorganizingFleets");
                this.updateSelection();
            },
            render: function () {
                var endTurnButtonProps = {
                    className: "end-turn-button",
                    onClick: this.endTurn,
                    tabIndex: -1
                };
                if (!this.state.isPlayerTurn) {
                    endTurnButtonProps.className += " disabled";
                    endTurnButtonProps.disabled = true;
                }
                var selectionContainerClassName = "fleet-selection-container";
                if (this.state.currentlyReorganizing.length > 0) {
                    selectionContainerClassName += " reorganizing";
                }
                var isInspecting = this.state.inspectedFleets.length > 0;
                var expandedActionElement = null;
                if (this.state.expandedActionElement) {
                    expandedActionElement = React.DOM.div({
                        className: "galaxy-map-ui-bottom-left-column",
                        ref: "expandedActionElementContainer"
                    }, this.state.expandedActionElement);
                }
                return (React.DOM.div({
                    className: "galaxy-map-ui"
                }, UIComponents.IntroTutorial(), React.DOM.div({
                    className: "galaxy-map-ui-top"
                }, UIComponents.TopBar({
                    player: this.props.player,
                    game: this.props.game
                }), UIComponents.TopMenu({
                    player: this.props.player,
                    game: this.props.game,
                    log: this.props.game.notificationLog,
                    currentTurn: this.props.game.turnNumber
                }), React.DOM.div({
                    className: selectionContainerClassName
                }, UIComponents.FleetSelection({
                    selectedFleets: (isInspecting ?
                        this.state.inspectedFleets : this.state.selectedFleets),
                    isInspecting: isInspecting,
                    selectedStar: this.state.selectedStar,
                    currentlyReorganizing: this.state.currentlyReorganizing,
                    closeReorganization: this.closeReorganization,
                    player: this.props.player
                }))), React.DOM.div({
                    className: "galaxy-map-ui-bottom-left",
                    key: "bottomLeft"
                }, React.DOM.div({
                    className: "galaxy-map-ui-bottom-left-column align-bottom",
                    key: "bottomLeftColumn"
                }, React.DOM.div({
                    className: "galaxy-map-ui-bottom-left-leftmost-column-wrapper",
                    ref: "leftColumnContent",
                    key: "leftColumnContent"
                }, UIComponents.PossibleActions({
                    attackTargets: this.state.attackTargets,
                    selectedStar: this.state.selectedStar,
                    player: this.props.player,
                    setExpandedActionElementOnParent: this.setExpandedActionElement,
                    key: "possibleActions"
                }), UIComponents.StarInfo({
                    selectedStar: this.state.selectedStar,
                    key: "starInfo"
                }))), expandedActionElement), React.DOM.div({
                    className: "galaxy-map-ui-bottom-right",
                    key: "bottomRight"
                }, !this.state.hasMapModeSettingsExpanded ? null : UIComponents.MapModeSettings({
                    mapRenderer: this.props.mapRenderer,
                    key: "mapRendererLayersList"
                }), React.DOM.button({
                    className: "toggle-map-mode-settings-button",
                    tabIndex: -1,
                    onClick: this.toggleMapModeSettingsExpanded
                }, "Map mode"), UIComponents.Notifications({
                    log: this.props.game.notificationLog,
                    currentTurn: this.props.game.turnNumber,
                    key: "notifications"
                }), React.DOM.button(endTurnButtonProps, "End turn"))));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="galaxymapui.ts"/>
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.GalaxyMap = React.createClass({
            displayName: "GalaxyMap",
            changeScene: function (e) {
                var target = e.target;
                app.reactUI.switchScene(target.value);
            },
            render: function () {
                var mapModeOptions = [];
                for (var mapModeName in this.props.mapRenderer.mapModes) {
                    mapModeOptions.push(React.DOM.option({
                        value: mapModeName,
                        key: mapModeName
                    }, this.props.mapRenderer.mapModes[mapModeName].template.displayName));
                }
                return (React.DOM.div({
                    className: "galaxy-map"
                }, React.DOM.div({
                    ref: "pixiContainer",
                    id: "pixi-container"
                }, UIComponents.GalaxyMapUI({
                    playerControl: this.props.playerControl,
                    player: this.props.player,
                    game: this.props.game,
                    mapRenderer: this.props.mapRenderer,
                    key: "galaxyMapUI"
                })), !Rance.Options.debugMode ? null : React.DOM.div({
                    className: "galaxy-map-debug debug"
                }, React.DOM.select({
                    className: "reactui-selector debug",
                    ref: "sceneSelector",
                    value: app.reactUI.currentScene,
                    onChange: this.changeScene
                }, React.DOM.option({ value: "galaxyMap" }, "map"), React.DOM.option({ value: "flagMaker" }, "make flags"), React.DOM.option({ value: "setupGame" }, "setup game"), React.DOM.option({ value: "battleSceneTester" }, "battle scene test")), React.DOM.button({
                    className: "debug",
                    onClick: function (e) {
                        // https://github.com/facebook/react/issues/2988
                        // https://github.com/facebook/react/issues/2605#issuecomment-118398797
                        // without this react will keep a reference to this element causing a big memory leak
                        e.target.blur();
                        window.setTimeout(function () {
                            var position = Rance.extendObject(app.renderer.camera.container.position);
                            var zoom = app.renderer.camera.currZoom;
                            app.destroy();
                            app.initUI();
                            app.game = app.makeGame();
                            app.initGame();
                            app.initDisplay();
                            app.hookUI();
                            app.reactUI.switchScene("galaxyMap");
                            app.renderer.camera.zoom(zoom);
                            app.renderer.camera.container.position = position;
                        }, 5);
                    }
                }, "Reset app"))));
            },
            componentDidMount: function () {
                this.props.renderer.isBattleBackground = false;
                this.props.renderer.bindRendererView(this.refs.pixiContainer.getDOMNode());
                this.props.mapRenderer.setMapModeByKey("defaultMapMode");
                this.props.renderer.resume();
                // hack. transparency isn't properly rendered without this
                this.props.mapRenderer.setAllLayersAsDirty();
                var centerLocation = this.props.renderer.camera.toCenterOn ||
                    this.props.toCenterOn ||
                    this.props.player.controlledLocations[0];
                this.props.renderer.camera.centerOnPosition(centerLocation);
            },
            componentWillUnmount: function () {
                this.props.renderer.pause();
                this.props.renderer.removeRendererView();
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../../../lib/react.d.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.FocusTimer = {
            componentDidMount: function () {
                this.setFocusTimer();
            },
            registerFocusTimerListener: function () {
                window.addEventListener("focus", this.setFocusTimer, false);
            },
            clearFocusTimerListener: function () {
                window.removeEventListener("focus", this.setFocusTimer);
            },
            setFocusTimer: function () {
                this.lastFocusTime = Date.now();
            }
        };
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../../color.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.ColorPicker = React.createClass({
            displayName: "ColorPicker",
            onChangeTimeout: null,
            getInitialState: function () {
                var hexColor = this.props.hexColor || 0xFFFFFF;
                var hexString = "#" + Rance.hexToString(hexColor);
                var hsvColor = Rance.colorFromScalars(Rance.hexToHsv(hexColor));
                return ({
                    hexColor: hexColor,
                    hexString: hexString,
                    lastValidHexString: hexString,
                    hue: hsvColor[0],
                    sat: hsvColor[1],
                    val: hsvColor[2],
                    isNull: true
                });
            },
            componentDidMount: function () {
                window.addEventListener("resize", this.setPosition);
                this.setPosition();
            },
            componentWillUnmount: function () {
                window.removeEventListener("resize", this.setPosition);
            },
            setPosition: function () {
                var parentRect = this.props.getParentPosition();
                var domNode = this.getDOMNode();
                domNode.style.top = "" + parentRect.bottom + "px";
                domNode.style.left = "" + parentRect.left + "px";
            },
            triggerParentOnChange: function (color, isNull) {
                if (this.onChangeTimeout) {
                    window.clearTimeout(this.onChangeTimeout);
                    this.onChangeTimeout = null;
                }
                this.onChangeTimeout = window.setTimeout(this.props.onChange.bind(null, color, isNull), 50);
            },
            updateFromHsv: function (hue, sat, val, e) {
                var hsvColor = [hue, sat, val];
                var hexColor = Math.round(Rance.hsvToHex.apply(null, Rance.scalarsFromColor(hsvColor)));
                var hexString = "#" + Rance.hexToString(hexColor);
                this.setState({
                    hexColor: hexColor,
                    hexString: hexString,
                    lastValidHexString: hexString,
                    isNull: false
                });
                if (this.props.onChange) {
                    var target = e.target;
                    // prevent onchange events from constantly having to render custom image
                    if (!this.props.limitUpdates ||
                        (!this.props.flagHasCustomImage ||
                            target.type !== "range" ||
                            e.type !== "input")) {
                        this.triggerParentOnChange(hexColor, false);
                    }
                }
            },
            updateFromHex: function (hexColor) {
                var hsvColor = Rance.colorFromScalars(Rance.hexToHsv(hexColor));
                this.setState({
                    hue: Math.round(hsvColor[0]),
                    sat: Math.round(hsvColor[1]),
                    val: Math.round(hsvColor[2])
                });
                if (this.props.onChange) {
                    this.triggerParentOnChange(hexColor, false);
                }
            },
            setHex: function (e) {
                e.stopPropagation();
                e.preventDefault();
                var target = e.target;
                var hexString;
                if (e.type === "paste") {
                    var e2 = e;
                    hexString = e2.clipboardData.getData("text");
                }
                else {
                    hexString = target.value;
                }
                if (hexString[0] !== "#") {
                    hexString = "#" + hexString;
                }
                var isValid = /^#[0-9A-F]{6}$/i.test(hexString);
                var hexColor = Rance.stringToHex(hexString);
                this.setState({
                    hexString: hexString,
                    lastValidHexString: isValid ? hexString : this.state.lastValidHexString,
                    hexColor: isValid ? hexColor : this.state.hexColor,
                    isNull: !isValid
                });
                if (isValid) {
                    this.updateFromHex(hexColor);
                }
            },
            setHue: function (e) {
                var target = e.target;
                var hue = Math.round(parseInt(target.value) % 361);
                if (hue < 0)
                    hue = 360;
                this.setState({ hue: hue });
                this.updateFromHsv(hue, this.state.sat, this.state.val, e);
            },
            setSat: function (e) {
                var target = e.target;
                var sat = Math.round(parseInt(target.value) % 101);
                if (sat < 0)
                    sat = 100;
                this.setState({ sat: sat });
                this.updateFromHsv(this.state.hue, sat, this.state.val, e);
            },
            setVal: function (e) {
                var target = e.target;
                var val = Math.round(parseInt(target.value) % 101);
                if (val < 0)
                    val = 100;
                this.setState({ val: val });
                this.updateFromHsv(this.state.hue, this.state.sat, val, e);
            },
            autoGenerateColor: function () {
                var hexColor = this.props.generateColor();
                var hexString = "#" + Rance.hexToString(hexColor);
                this.setState({
                    hexString: hexString,
                    lastValidHexString: hexString,
                    hexColor: hexColor
                });
                this.updateFromHex(hexColor);
            },
            nullifyColor: function () {
                this.setState({ isNull: true });
                if (this.props.onChange) {
                    this.triggerParentOnChange(this.state.hexColor, true);
                }
            },
            getHueGradientString: function () {
                if (this.hueGradientString)
                    return this.hueGradientString;
                var steps = 10;
                var gradeStep = 100 / (steps - 1);
                var hueStep = 360 / steps;
                var gradientString = "linear-gradient(to right, ";
                for (var i = 0; i < steps; i++) {
                    var hue = hueStep * i;
                    var grade = gradeStep * i;
                    var colorString = "hsl(" + hue + ", 100%, 50%) " + grade + "%";
                    if (i < steps - 1) {
                        colorString += ",";
                    }
                    else {
                        colorString += ")";
                    }
                    gradientString += colorString;
                }
                this.hueGradientString = gradientString;
                return gradientString;
            },
            makeGradientString: function (min, max) {
                return ("linear-gradient(to right, " +
                    min + " 0%, " +
                    max + " 100%)");
            },
            makeGradientStyle: function (type) {
                var hue = this.state.hue;
                var sat = this.state.sat;
                var val = this.state.val;
                switch (type) {
                    case "hue":
                        {
                            return ({
                                background: this.getHueGradientString()
                            });
                        }
                    case "sat":
                        {
                            var min = "#" + Rance.hexToString(Rance.hsvToHex.apply(null, Rance.scalarsFromColor([hue, 0, val])));
                            var max = "#" + Rance.hexToString(Rance.hsvToHex.apply(null, Rance.scalarsFromColor([hue, 100, val])));
                            return ({
                                background: this.makeGradientString(min, max)
                            });
                        }
                    case "val":
                        {
                            var min = "#" + Rance.hexToString(Rance.hsvToHex.apply(null, Rance.scalarsFromColor([hue, sat, 0])));
                            var max = "#" + Rance.hexToString(Rance.hsvToHex.apply(null, Rance.scalarsFromColor([hue, sat, 100])));
                            return ({
                                background: this.makeGradientString(min, max)
                            });
                        }
                    default:
                        {
                            return null;
                        }
                }
            },
            makeHsvInputs: function (type) {
                var rootId = this._rootNodeID;
                var label = "" + type[0].toUpperCase() + ":";
                var max = type === "hue" ? 360 : 100;
                var updateFunctions = {
                    hue: this.setHue,
                    sat: this.setSat,
                    val: this.setVal
                };
                return (React.DOM.div({ className: "color-picker-input-container", key: type }, React.DOM.label({ className: "color-picker-label", htmlFor: "" + rootId + type }, label), React.DOM.div({
                    className: "color-picker-slider-background",
                    style: this.makeGradientStyle(type)
                }, React.DOM.input({
                    className: "color-picker-slider",
                    id: "" + rootId + type,
                    ref: type,
                    type: "range",
                    min: 0,
                    max: max,
                    step: 1,
                    value: this.state[type],
                    onChange: updateFunctions[type],
                    onMouseUp: updateFunctions[type],
                    onTouchEnd: updateFunctions[type]
                })), React.DOM.input({
                    className: "color-picker-input",
                    type: "number",
                    step: 1,
                    value: Math.round(this.state[type]),
                    onChange: updateFunctions[type]
                })));
            },
            render: function () {
                var rootId = this._rootNodeID;
                return (React.DOM.div({ className: "color-picker" }, React.DOM.div({ className: "color-picker-hsv" }, this.makeHsvInputs("hue"), this.makeHsvInputs("sat"), this.makeHsvInputs("val")), React.DOM.div({ className: "color-picker-input-container", key: "hex" }, React.DOM.label({ className: "color-picker-label", htmlFor: "" + rootId + "hex" }, "Hex:"), 
                /*React.DOM.input(
                {
                  className: "color-picker-slider",
                  id: "" + rootId + "hex",
                  ref: "hex",
                  type: "color",
                  step: 1,
                  value: this.state.lastValidHexString,
                  onChange: this.setHex
                }),*/
                !this.props.generateColor ? null :
                    React.DOM.button({
                        className: "color-picker-button",
                        onClick: this.autoGenerateColor
                    }, "Auto"), React.DOM.button({
                    className: "color-picker-button",
                    onClick: this.nullifyColor
                }, "Clear"), React.DOM.input({
                    className: "color-picker-input color-picker-input-hex",
                    ref: "hex",
                    type: "string",
                    step: 1,
                    value: this.state.hexString,
                    onChange: this.setHex,
                    onPaste: this.setHex
                }))));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../mixins/focustimer.ts" />
/// <reference path="colorpicker.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.ColorSetter = React.createClass({
            displayName: "ColorSetter",
            mixins: [UIComponents.FocusTimer],
            getInitialState: function () {
                return ({
                    hexColor: this.props.color || 0xFFFFFF,
                    isNull: true,
                    active: false
                });
            },
            componentWillUnmount: function () {
                document.removeEventListener("click", this.handleClick);
                this.clearFocusTimerListener();
            },
            componentWillReceiveProps: function (newProps) {
                if (newProps.color !== this.state.hexColor) {
                    this.setState({
                        hexColor: newProps.color,
                        isNull: newProps.color === null
                    });
                }
            },
            handleClick: function (e) {
                var focusGraceTime = 500;
                if (Date.now() - this.lastFocusTime <= focusGraceTime)
                    return;
                var node = this.refs.main.getDOMNode();
                if (e.target === node || node.contains(e.target)) {
                    return;
                }
                else {
                    this.setAsInactive();
                }
            },
            toggleActive: function () {
                if (this.state.isActive) {
                    this.setAsInactive();
                }
                else {
                    if (this.props.setActiveColorPicker) {
                        this.props.setActiveColorPicker(this);
                    }
                    this.setState({ isActive: true });
                    document.addEventListener("click", this.handleClick, false);
                    this.registerFocusTimerListener();
                }
            },
            setAsInactive: function () {
                if (this.isMounted() && this.state.isActive) {
                    this.setState({ isActive: false });
                    document.removeEventListener("click", this.handleClick);
                    this.clearFocusTimerListener();
                }
            },
            updateColor: function (hexColor, isNull) {
                if (isNull) {
                    this.setState({ isNull: isNull });
                }
                else {
                    this.setState({ hexColor: hexColor, isNull: isNull });
                }
                if (this.props.onChange) {
                    this.props.onChange(hexColor, isNull);
                }
            },
            getClientRect: function () {
                return this.getDOMNode().firstChild.getBoundingClientRect();
            },
            render: function () {
                var displayElement = this.state.isNull ?
                    React.DOM.img({
                        className: "color-setter-display",
                        src: "img\/icons\/nullcolor.png",
                        onClick: this.toggleActive
                    }) :
                    React.DOM.div({
                        className: "color-setter-display",
                        style: {
                            backgroundColor: "#" + Rance.hexToString(this.state.hexColor)
                        },
                        onClick: this.toggleActive
                    });
                return (React.DOM.div({ className: "color-setter", ref: "main" }, displayElement, this.props.isActive || this.state.isActive ?
                    UIComponents.ColorPicker({
                        hexColor: this.state.hexColor,
                        generateColor: this.props.generateColor,
                        onChange: this.updateColor,
                        setAsInactive: this.setAsInactive,
                        flagHasCustomImage: this.props.flagHasCustomImage,
                        getParentPosition: this.getClientRect
                    }) : null));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.FlagPicker = React.createClass({
            displayName: "FlagPicker",
            getInitialState: function () {
                var initialEmblem = null;
                if (this.props.flag.foregroundEmblem) {
                    initialEmblem = this.props.flag.foregroundEmblem.inner;
                }
                return ({
                    selectedEmblem: initialEmblem
                });
            },
            handleSelectEmblem: function (emblemTemplate) {
                if (this.state.selectedEmblem === emblemTemplate && emblemTemplate !== null) {
                    this.clearSelectedEmblem();
                    return;
                }
                this.refs.imageUploader.getDOMNode().value = null;
                this.props.handleSelectEmblem(emblemTemplate);
                this.setState({ selectedEmblem: emblemTemplate });
            },
            clearSelectedEmblem: function () {
                this.handleSelectEmblem(null);
            },
            handleUpload: function () {
                if (!this.props.uploadFiles)
                    throw new Error();
                var files = this.refs.imageUploader.getDOMNode().files;
                this.props.uploadFiles(files);
            },
            makeEmblemElement: function (template) {
                var className = "emblem-picker-image";
                if (this.state.selectedEmblem &&
                    this.state.selectedEmblem.key === template.key) {
                    className += " selected-emblem";
                }
                return (React.DOM.div({
                    className: "emblem-picker-container",
                    key: template.key,
                    onClick: this.handleSelectEmblem.bind(this, template)
                }, React.DOM.img({
                    className: className,
                    src: app.images[template.src].src
                })));
            },
            render: function () {
                var emblems = [];
                for (var emblemType in app.moduleData.Templates.SubEmblems) {
                    var template = app.moduleData.Templates.SubEmblems[emblemType];
                    emblems.push(this.makeEmblemElement(template));
                }
                var imageInfoMessage;
                if (this.props.hasImageFailMessage) {
                    imageInfoMessage =
                        React.DOM.div({ className: "image-info-message image-loading-fail-message" }, "Linked image failed to load. Try saving it to your own computer " +
                            "and uploading it.");
                }
                else {
                    imageInfoMessage =
                        React.DOM.div({ className: "image-info-message" }, "Upload or drag image here to set it as your flag");
                }
                return (React.DOM.div({
                    className: "flag-picker"
                }, React.DOM.div({
                    className: "flag-image-uploader"
                }, React.DOM.div({ className: "flag-picker-title" }, "Upload image"), React.DOM.div({
                    className: "flag-image-uploader-content"
                }, React.DOM.input({
                    className: "flag-image-upload-button",
                    type: "file",
                    ref: "imageUploader",
                    onChange: this.handleUpload
                }), imageInfoMessage)), React.DOM.div({
                    className: "emblem-picker"
                }, React.DOM.div({ className: "flag-picker-title" }, "Emblems"), React.DOM.div({ className: "emblem-picker-emblem-list" }, emblems))));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../mixins/focustimer.ts" />
/// <reference path="../playerflag.ts" />
/// <reference path="flagpicker.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.FlagSetter = React.createClass({
            displayName: "FlagSetter",
            mixins: [UIComponents.FocusTimer],
            getInitialState: function () {
                var flag = new Rance.Flag({
                    width: 46,
                    mainColor: this.props.mainColor,
                    secondaryColor: this.props.subColor,
                    tetriaryColor: this.props.tetriaryColor
                });
                return ({
                    flag: flag,
                    hasImageFailMessage: false,
                    active: false
                });
            },
            componentWillUnmount: function () {
                window.clearTimeout(this.imageLoadingFailTimeout);
                document.removeEventListener("click", this.handleClick);
                this.clearFocusTimerListener();
            },
            displayImageLoadingFailMessage: function () {
                this.setState({ hasImageFailMessage: true });
                this.imageLoadingFailTimeout = window.setTimeout(function () {
                    this.setState({ hasImageFailMessage: false });
                }.bind(this), 10000);
            },
            clearImageLoadingFailMessage: function () {
                if (this.imageLoadingFailTimeout) {
                    window.clearTimeout(this.imageLoadingFailTimeout);
                }
                this.setState({ hasImageFailMessage: false });
            },
            handleClick: function (e) {
                var focusGraceTime = 500;
                if (Date.now() - this.lastFocusTime <= focusGraceTime)
                    return;
                var node = this.refs.main.getDOMNode();
                if (e.target === node || node.contains(e.target)) {
                    return;
                }
                else {
                    this.setAsInactive();
                }
            },
            toggleActive: function () {
                if (this.state.isActive) {
                    this.setAsInactive();
                }
                else {
                    if (this.props.setActiveColorPicker) {
                        this.props.setActiveColorPicker(this);
                    }
                    this.setState({ isActive: true });
                    document.addEventListener("click", this.handleClick, false);
                    this.registerFocusTimerListener();
                }
            },
            setAsInactive: function () {
                if (this.isMounted() && this.state.isActive) {
                    this.setState({ isActive: false });
                    document.removeEventListener("click", this.handleClick);
                    this.clearFocusTimerListener();
                }
            },
            setForegroundEmblem: function (emblemTemplate) {
                var shouldUpdate = emblemTemplate || this.state.flag.foregroundEmblem;
                var emblem = null;
                if (emblemTemplate) {
                    emblem = new Rance.Emblem(undefined, 1, emblemTemplate);
                }
                this.state.flag.setForegroundEmblem(emblem);
                if (shouldUpdate) {
                    this.handleUpdate();
                }
            },
            stopEvent: function (e) {
                e.stopPropagation();
                e.preventDefault();
            },
            handleDrop: function (e) {
                if (e.dataTransfer) {
                    this.stopEvent(e);
                    var files = e.dataTransfer.files;
                    var image = this.getFirstValidImageFromFiles(files);
                    if (!image) {
                        // try to get image from any html img element dropped
                        var htmlContent = e.dataTransfer.getData("text\/html");
                        var imageSource = htmlContent.match(/src\s*=\s*"(.+?)"/)[1];
                        if (!imageSource) {
                            console.error("None of the files provided are valid images");
                            return;
                        }
                        else {
                            var getImageDataUrl = function (image) {
                                var canvas = document.createElement("canvas");
                                var ctx = canvas.getContext("2d");
                                canvas.width = image.width;
                                canvas.height = image.height;
                                ctx.drawImage(image, 0, 0);
                                return canvas.toDataURL();
                            };
                            var img = new Image();
                            img.crossOrigin = "Anonymous";
                            img.onload = function (e) {
                                this.state.flag.setCustomImage(getImageDataUrl(img));
                                this.handleUpdate();
                            }.bind(this);
                            img.onerror = function (e) {
                                this.displayImageLoadingFailMessage();
                            }.bind(this);
                            img.src = imageSource;
                            // image was cached
                            if (img.complete || img.complete === undefined) {
                                this.state.flag.setCustomImage(getImageDataUrl(img));
                                this.handleUpdate();
                            }
                        }
                    }
                    else {
                        this.setCustomImageFromFile(image);
                    }
                }
            },
            handleUpload: function (files) {
                var image = this.getFirstValidImageFromFiles(files);
                if (!image)
                    return false;
                this.setCustomImageFromFile(image);
                return true;
            },
            getFirstValidImageFromFiles: function (files) {
                var image;
                for (var i = 0; i < files.length; i++) {
                    var file = files[i];
                    if (file.type.indexOf("image") !== -1) {
                        image = file;
                        break;
                    }
                }
                return image;
            },
            setCustomImageFromFile: function (file) {
                var setImageFN = function (file) {
                    var reader = new FileReader();
                    reader.onloadend = function () {
                        this.state.flag.setCustomImage(reader.result);
                        this.handleUpdate();
                    }.bind(this);
                    reader.readAsDataURL(file);
                }.bind(this, file);
                var fileSizeInMegaBytes = file.size / 1024 / 1024;
                if (fileSizeInMegaBytes > 20) {
                    if (window.confirm("Are you sure you want to load an image that is " +
                        fileSizeInMegaBytes.toFixed(2) + "MB in size?\n" +
                        "(The image won't be stored online, " +
                        "but processing it might take a while)")) {
                        setImageFN();
                    }
                }
                else {
                    setImageFN();
                }
            },
            componentWillReceiveProps: function (newProps) {
                var oldProps = this.props;
                this.state.flag.setColorScheme(newProps.mainColor, newProps.subColor, newProps.tetriaryColor);
                // if (!this.state.flag.customImage)
                // {
                //   this.handleUpdate();
                // }
                var colorHasUpdated;
                ["mainColor", "subColor", "tetriaryColor"].forEach(function (prop) {
                    if (oldProps[prop] !== newProps[prop]) {
                        colorHasUpdated = true;
                        return;
                    }
                });
                if (colorHasUpdated) {
                    this.handleUpdate(true);
                    return;
                }
            },
            handleUpdate: function (dontTriggerParentUpdates) {
                this.clearImageLoadingFailMessage();
                if (this.state.flag.customImage) {
                    if (this.refs.flagPicker) {
                        this.refs.flagPicker.clearSelectedEmblem();
                    }
                }
                if (!dontTriggerParentUpdates) {
                    this.props.toggleCustomImage(this.state.flag.customImage);
                }
                this.forceUpdate();
            },
            render: function () {
                return (React.DOM.div({
                    className: "flag-setter",
                    ref: "main",
                    onDragEnter: this.stopEvent,
                    onDragOver: this.stopEvent,
                    onDrop: this.handleDrop
                }, UIComponents.PlayerFlag({
                    flag: this.state.flag,
                    isMutable: true,
                    props: {
                        className: "flag-setter-display",
                        onClick: this.toggleActive
                    }
                }), this.props.isActive || this.state.isActive ?
                    UIComponents.FlagPicker({
                        ref: "flagPicker",
                        flag: this.state.flag,
                        handleSelectEmblem: this.setForegroundEmblem,
                        hasImageFailMessage: this.state.hasImageFailMessage,
                        onChange: this.handleUpdate,
                        uploadFiles: this.handleUpload
                    }) : null));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="colorsetter.ts" />
/// <reference path="flagsetter.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.PlayerSetup = React.createClass({
            displayName: "PlayerSetup",
            getInitialState: function () {
                return ({
                    name: this.props.initialName,
                    mainColor: null,
                    subColor: null,
                    flagHasCustomImage: false
                });
            },
            generateMainColor: function (subColor) {
                if (subColor === void 0) { subColor = this.state.subColor; }
                if (subColor === null) {
                    return Rance.generateMainColor();
                }
                else {
                    return Rance.generateSecondaryColor(subColor);
                }
            },
            generateSubColor: function (mainColor) {
                if (mainColor === void 0) { mainColor = this.state.mainColor; }
                if (mainColor === null) {
                    return Rance.generateMainColor();
                }
                else {
                    return Rance.generateSecondaryColor(mainColor);
                }
            },
            handleSetHuman: function () {
                this.props.setHuman(this.props.key);
            },
            handleNameChange: function (e) {
                var target = e.target;
                this.setState({ name: target.value });
            },
            setMainColor: function (color, isNull) {
                this.setState({ mainColor: isNull ? null : color });
            },
            setSubColor: function (color, isNull) {
                this.setState({ subColor: isNull ? null : color });
            },
            handleRemove: function () {
                this.props.removePlayers([this.props.key]);
            },
            handleSetCustomImage: function (image) {
                this.setState({ flagHasCustomImage: Boolean(image) });
            },
            randomize: function () {
                if (!this.state.flagHasCustomImage) {
                    this.refs.flagSetter.state.flag.generateRandom();
                }
                var mainColor = Rance.generateMainColor();
                this.setState({
                    mainColor: mainColor,
                    subColor: Rance.generateSecondaryColor(mainColor)
                });
            },
            makePlayer: function () {
                var player = new Rance.Player(!this.props.isHuman);
                player.initTechnologies();
                player.name = this.state.name;
                player.color = this.state.mainColor === null ?
                    this.generateMainColor() : this.state.mainColor;
                player.secondaryColor = this.state.subColor === null ?
                    this.generateSubColor(player.color) : this.state.subColor;
                var flag = this.refs.flagSetter.state.flag;
                player.flag = flag;
                player.flag.setColorScheme(player.color, player.secondaryColor, flag.tetriaryColor);
                if (this.state.mainColor === null && this.state.subColor === null &&
                    !flag.customImage && !flag.foregroundEmblem) {
                    flag.generateRandom();
                }
                this.setState({
                    mainColor: player.color,
                    subColor: player.secondaryColor
                });
                return player;
            },
            render: function () {
                return (React.DOM.div({
                    className: "player-setup" + (this.props.isHuman ? " human-player-setup" : "")
                }, React.DOM.input({
                    ref: "isHuman",
                    className: "player-setup-is-human",
                    type: "checkbox",
                    checked: this.props.isHuman,
                    onChange: this.handleSetHuman
                }), React.DOM.input({
                    className: "player-setup-name",
                    value: this.state.name,
                    onChange: this.handleNameChange
                }), UIComponents.ColorSetter({
                    ref: "mainColor",
                    onChange: this.setMainColor,
                    setActiveColorPicker: this.props.setActiveColorPicker,
                    generateColor: this.generateMainColor,
                    flagHasCustomImage: this.state.flagHasCustomImage,
                    color: this.state.mainColor
                }), UIComponents.ColorSetter({
                    ref: "subColor",
                    onChange: this.setSubColor,
                    setActiveColorPicker: this.props.setActiveColorPicker,
                    generateColor: this.generateSubColor,
                    flagHasCustomImage: this.state.flagHasCustomImage,
                    color: this.state.subColor
                }), UIComponents.FlagSetter({
                    ref: "flagSetter",
                    mainColor: this.state.mainColor,
                    subColor: this.state.subColor,
                    setActiveColorPicker: this.props.setActiveColorPicker,
                    toggleCustomImage: this.handleSetCustomImage
                }), React.DOM.button({
                    className: "player-setup-remove-player",
                    onClick: this.handleRemove
                }, "X")));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="playersetup.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.SetupGamePlayers = React.createClass({
            displayName: "SetupGamePlayers",
            getInitialState: function () {
                this.newPlayerId = 0;
                var players = [];
                for (var i = 0; i < this.props.maxPlayers; i++) {
                    players.push(this.newPlayerId++);
                }
                return ({
                    players: players,
                    activeColorPicker: null
                });
            },
            componentWillReceiveProps: function (newProps) {
                if (newProps.minPlayers > this.state.players.length) {
                    this.makeNewPlayers(newProps.minPlayers - this.state.players.length);
                }
                else if (newProps.maxPlayers < this.state.players.length) {
                    var overflowCount = this.state.players.length - newProps.maxPlayers;
                    this.removePlayers(this.state.players.slice(-overflowCount));
                }
            },
            makeNewPlayers: function (amountToMake) {
                if (amountToMake === void 0) { amountToMake = 1; }
                if (this.state.players.length >= this.props.maxPlayers) {
                    return;
                }
                var newIds = [];
                for (var i = 0; i < amountToMake; i++) {
                    newIds.push(this.newPlayerId++);
                }
                this.setState({
                    players: this.state.players.concat(newIds)
                });
            },
            setHumanPlayer: function (playerId) {
                var index = this.state.players.indexOf(playerId);
                var newPlayerOrder = this.state.players.slice(0);
                newPlayerOrder.unshift(newPlayerOrder.splice(index, 1)[0]);
                this.setState({ players: newPlayerOrder });
            },
            removePlayers: function (toRemove) {
                if (this.state.players.length <= this.props.minPlayers) {
                    return;
                }
                this.setState({
                    players: this.state.players.filter(function (playerId) {
                        return toRemove.indexOf(playerId) === -1;
                    })
                });
            },
            setActiveColorPicker: function (colorPicker) {
                if (this.state.activeColorPicker) {
                    this.state.activeColorPicker.setAsInactive();
                }
                this.setState({ activeColorPicker: colorPicker });
            },
            randomizeAllPlayers: function () {
                for (var id in this.refs) {
                    var player = this.refs[id];
                    player.randomize();
                }
            },
            makeAllPlayers: function () {
                var players = [];
                for (var id in this.refs) {
                    players.push(this.refs[id].makePlayer());
                }
                return players;
            },
            render: function () {
                var playerSetups = [];
                for (var i = 0; i < this.state.players.length; i++) {
                    playerSetups.push(UIComponents.PlayerSetup({
                        key: this.state.players[i],
                        ref: this.state.players[i],
                        removePlayers: this.removePlayers,
                        setActiveColorPicker: this.setActiveColorPicker,
                        initialName: "Player " + this.state.players[i],
                        isHuman: i === 0,
                        setHuman: this.setHumanPlayer
                    }));
                }
                var canAddPlayers = this.state.players.length < this.props.maxPlayers;
                return (React.DOM.div({ className: "setup-game-players" }, React.DOM.div({
                    className: "player-setup setup-game-players-header"
                }, React.DOM.div({
                    className: "player-setup-is-human"
                }), React.DOM.div({
                    className: "player-setup-name"
                }, "Name"), React.DOM.div({
                    className: "color-setter"
                }, "Color 1"), React.DOM.div({
                    className: "color-setter"
                }, "Color 2"), React.DOM.div({
                    className: "flag-setter"
                }, "Flag"), React.DOM.div({
                    className: "player-setup-remove-player"
                }, "Remove")), React.DOM.div({
                    className: "player-setup-players-list"
                }, playerSetups), React.DOM.div({
                    className: "setup-game-players-buttons"
                }, React.DOM.button({
                    className: "setup-game-button",
                    onClick: this.randomizeAllPlayers
                }, "Randomize"), React.DOM.button({
                    className: "setup-game-players-add-new" + (canAddPlayers ? "" : " disabled"),
                    onClick: this.makeNewPlayers.bind(this, 1),
                    disabled: !canAddPlayers
                }, "Add new player"))));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.MapGenOption = React.createClass({
            displayName: "MapGenOption",
            handleChange: function (e) {
                var target = e.target;
                var option = this.props.option;
                var newValue = Rance.clamp(parseFloat(target.value), option.min, option.max);
                this.props.onChange(this.props.id, newValue);
            },
            shouldComponentUpdate: function (newProps) {
                return newProps.value !== this.props.value;
            },
            render: function () {
                var option = this.props.option;
                var range = option.range;
                var id = "mapGenOption_" + this.props.id;
                ["min", "max", "step"].forEach(function (prop) {
                    if (!range[prop]) {
                        throw new Error("No property " + prop + " specified on map gen option " + this.props.id);
                    }
                }.bind(this));
                // console.log(this.props.id, this.props.value);
                return (React.DOM.div({
                    className: "map-gen-option"
                }, React.DOM.label({
                    className: "map-gen-option-label",
                    title: option.displayName,
                    htmlFor: id
                }, option.displayName), React.DOM.input({
                    className: "map-gen-option-slider",
                    id: id,
                    type: "range",
                    min: range.min,
                    max: range.max,
                    step: range.step,
                    value: this.props.value,
                    onChange: this.handleChange
                }), React.DOM.input({
                    className: "map-gen-option-value",
                    title: option.displayName,
                    type: "number",
                    min: range.min,
                    max: range.max,
                    step: range.step,
                    value: this.props.value,
                    onChange: this.handleChange
                })));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../../utility.ts" />
/// <reference path="../galaxymap/optionsgroup.ts" />
/// <reference path="mapgenoption.ts" />
/// <reference path="../../templateinterfaces/mapgenoptions.d.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.MapGenOptions = React.createClass({
            displayName: "MapGenOptions",
            getInitialState: function () {
                return this.getDefaultValues(this.props.mapGenTemplate);
            },
            componentWillReceiveProps: function (newProps) {
                if (newProps.mapGenTemplate.key !== this.props.mapGenTemplate.key) {
                    this.setState(this.getDefaultValues(newProps.mapGenTemplate));
                }
            },
            getDefaultValues: function (mapGenTemplate, unsetOnly) {
                if (unsetOnly === void 0) { unsetOnly = true; }
                var defaultValues = {};
                ["defaultOptions", "basicOptions", "advancedOptions"].forEach(function (optionGroup) {
                    var options = mapGenTemplate.options[optionGroup];
                    if (!options)
                        return;
                    for (var optionName in options) {
                        var option = options[optionName].range;
                        var value;
                        if (unsetOnly && this.state && isFinite(this.getOptionValue(optionName))) {
                            if (!this.props.mapGenTemplate.options[optionGroup])
                                continue;
                            var oldOption = this.props.mapGenTemplate.options[optionGroup][optionName];
                            if (!oldOption)
                                continue;
                            var oldValuePercentage = Rance.getRelativeValue(this.getOptionValue(optionName), oldOption.range.min, oldOption.range.max);
                            value = option.min + (option.max - option.min) * oldValuePercentage;
                        }
                        else {
                            value = isFinite(option.defaultValue) ? option.defaultValue : (option.min + option.max) / 2;
                        }
                        value = Rance.clamp(Rance.roundToNearestMultiple(value, option.step), option.min, option.max);
                        defaultValues["optionValue_" + optionName] = value;
                    }
                }.bind(this));
                return defaultValues;
            },
            resetValuesToDefault: function () {
                this.setState(this.getDefaultValues(this.props.mapGenTemplate, false));
            },
            handleOptionChange: function (optionName, newValue) {
                var changedState = {};
                changedState["optionValue_" + optionName] = newValue;
                this.setState(changedState);
            },
            getOptionValue: function (optionName) {
                return this.state["optionValue_" + optionName];
            },
            randomizeOptions: function () {
                var newValues = {};
                var optionGroups = this.props.mapGenTemplate.options;
                for (var optionGroupName in optionGroups) {
                    var optionGroup = optionGroups[optionGroupName];
                    for (var optionName in optionGroup) {
                        var option = optionGroup[optionName].range;
                        var optionValue = Rance.clamp(Rance.roundToNearestMultiple(Rance.randInt(option.min, option.max), option.step), option.min, option.max);
                        newValues["optionValue_" + optionName] = optionValue;
                    }
                }
                this.setState(newValues);
            },
            getOptionValuesForTemplate: function () {
                var optionValues = Rance.extendObject(this.props.mapGenTemplate.options);
                for (var groupName in optionValues) {
                    var optionsGroup = optionValues[groupName];
                    for (var optionName in optionsGroup) {
                        var optionValue = this.getOptionValue(optionName);
                        if (!isFinite(optionValue)) {
                            throw new Error("Value " + optionValue + " for option " + optionName + " is invalid.");
                        }
                        optionValues[groupName][optionName] = optionValue;
                    }
                }
                return optionValues;
            },
            render: function () {
                var optionGroups = [];
                var optionGroupsInfo = {
                    defaultOptions: {
                        title: "Default Options",
                        isCollapsedInitially: false
                    },
                    basicOptions: {
                        title: "Basic Options",
                        isCollapsedInitially: false
                    },
                    advancedOptions: {
                        title: "Advanced Options",
                        isCollapsedInitially: true
                    }
                };
                for (var groupName in optionGroupsInfo) {
                    if (!this.props.mapGenTemplate.options[groupName])
                        continue;
                    var options = [];
                    for (var optionName in this.props.mapGenTemplate.options[groupName]) {
                        var option = this.props.mapGenTemplate.options[groupName][optionName];
                        options.push({
                            key: optionName,
                            content: UIComponents.MapGenOption({
                                key: optionName,
                                id: optionName,
                                option: option,
                                value: this.getOptionValue(optionName),
                                onChange: this.handleOptionChange
                            })
                        });
                    }
                    optionGroups.push(UIComponents.OptionsGroup({
                        key: groupName,
                        header: optionGroupsInfo[groupName].title,
                        options: options,
                        isCollapsedInitially: optionGroupsInfo[groupName].isCollapsedInitially
                    }));
                }
                return (React.DOM.div({
                    className: "map-gen-options"
                }, React.DOM.div({
                    className: "map-gen-options-option-groups"
                }, optionGroups), React.DOM.div({
                    className: "map-gen-options-buttons"
                }, React.DOM.button({
                    className: "map-gen-options-button",
                    onClick: this.randomizeOptions
                }, "randomize"), React.DOM.button({
                    className: "map-gen-options-button",
                    onClick: this.resetValuesToDefault
                }, "reset"))));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../../templateinterfaces/imapgentemplate.d.ts" />
/// <reference path="mapgenoptions.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.MapSetup = React.createClass({
            displayName: "MapSetup",
            getInitialState: function () {
                var mapGenTemplates = [];
                for (var template in app.moduleData.Templates.MapGen) {
                    if (app.moduleData.Templates.MapGen[template].key) {
                        mapGenTemplates.push(app.moduleData.Templates.MapGen[template]);
                    }
                }
                return ({
                    templates: mapGenTemplates,
                    selectedTemplate: mapGenTemplates[0]
                });
            },
            componentDidMount: function () {
                this.updatePlayerLimits();
            },
            updatePlayerLimits: function () {
                this.props.setPlayerLimits({
                    min: this.state.selectedTemplate.minPlayers,
                    max: this.state.selectedTemplate.maxPlayers
                });
            },
            setTemplate: function (e) {
                var target = e.target;
                this.setState({
                    selectedTemplate: app.moduleData.Templates.MapGen[target.value]
                }, this.updatePlayerLimits);
            },
            getMapSetupInfo: function () {
                return ({
                    template: this.state.selectedTemplate,
                    optionValues: this.refs.mapGenOptions.getOptionValuesForTemplate()
                });
            },
            render: function () {
                var mapGenTemplateOptions = [];
                for (var i = 0; i < this.state.templates.length; i++) {
                    var template = this.state.templates[i];
                    mapGenTemplateOptions.push(React.DOM.option({
                        value: template.key,
                        key: template.key,
                        title: template.description
                    }, template.displayName));
                }
                return (React.DOM.div({
                    className: "map-setup"
                }, React.DOM.select({
                    className: "map-setup-template-selector",
                    value: this.state.selectedTemplate.key,
                    onChange: this.setTemplate
                }, mapGenTemplateOptions), React.DOM.div({
                    className: "map-setup-player-limit"
                }, "Players: " + this.state.selectedTemplate.minPlayers + "-" +
                    this.state.selectedTemplate.maxPlayers), React.DOM.div({
                    className: "map-setup-description"
                }, this.state.selectedTemplate.description), UIComponents.MapGenOptions({
                    mapGenTemplate: this.state.selectedTemplate,
                    ref: "mapGenOptions"
                })));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="setupgameplayers.ts" />
/// <reference path="mapsetup.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.SetupGame = React.createClass({
            displayName: "SetupGame",
            getInitialState: function () {
                return ({
                    minPlayers: 1,
                    maxPlayers: 5
                });
            },
            setPlayerLimits: function (props) {
                this.setState({
                    minPlayers: props.min,
                    maxPlayers: props.max
                });
            },
            startGame: function () {
                var playerData = {};
                var players = this.refs.players.makeAllPlayers();
                var mapSetupInfo = this.refs.mapSetup.getMapSetupInfo();
                var mapGenFunction = mapSetupInfo.template.mapGenFunction;
                var mapGenResult = mapGenFunction(mapSetupInfo.optionValues, players);
                var map = mapGenResult.makeMap();
                app.makeGameFromSetup(map, players);
            },
            randomize: function () {
                this.refs.players.randomizeAllPlayers();
                this.refs.mapSetup.refs.mapGenOptions.randomizeOptions();
            },
            render: function () {
                return (React.DOM.div({
                    className: "setup-game-wrapper"
                }, React.DOM.div({
                    className: "setup-game"
                }, React.DOM.div({
                    className: "setup-game-options"
                }, UIComponents.SetupGamePlayers({
                    ref: "players",
                    minPlayers: this.state.minPlayers,
                    maxPlayers: this.state.maxPlayers
                }), UIComponents.MapSetup({
                    setPlayerLimits: this.setPlayerLimits,
                    ref: "mapSetup"
                })), React.DOM.div({
                    className: "setup-game-buttons"
                }, React.DOM.button({
                    className: "setup-game-button setup-game-button-randomize",
                    onClick: this.randomize
                }, "Randomize"), React.DOM.button({
                    className: "setup-game-button setup-game-button-start",
                    onClick: this.startGame
                }, "Start game")))));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="playerflag.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.FlagMaker = React.createClass({
            setStateTimeout: undefined,
            sizeValue: 46,
            getInitialState: function () {
                return ({
                    sizeValue: 46,
                    size: 46
                });
            },
            handleSizeChange: function (e) {
                if (this.setStateTimeout) {
                    window.clearTimeout(this.setStateTimeout);
                }
                var target = e.target;
                var value = parseInt(target.value);
                if (isFinite(value)) {
                    this.sizeValue = value;
                    this.setStateTimeout = window.setTimeout(this.setState.bind(this, { size: value }), 500);
                }
            },
            makeFlags: function () {
                this.forceUpdate();
            },
            render: function () {
                var flagElements = [];
                for (var i = 0; i < 100; i++) {
                    var colorScheme = Rance.generateColorScheme();
                    var flag = new Rance.Flag({
                        width: this.state.size,
                        mainColor: colorScheme.main,
                        secondaryColor: colorScheme.secondary
                    });
                    flag.generateRandom();
                    flagElements.push(UIComponents.PlayerFlag({
                        key: i,
                        props: {
                            tag: "flagMaker",
                            width: this.state.size,
                            height: this.state.size,
                            style: {
                                width: this.state.size,
                                height: this.state.size
                            }
                        },
                        flag: flag
                    }));
                }
                return (React.DOM.div(null, React.DOM.div({
                    className: "flags",
                    ref: "flags"
                }, flagElements), React.DOM.button({
                    onClick: this.makeFlags
                }, "make flags"), React.DOM.input({
                    onChange: this.handleSizeChange,
                    defaultValue: this.sizeValue,
                    type: "number"
                })));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.BattleSceneTester = React.createClass({
            displayName: "BattleSceneTester",
            idGenerator: 0,
            battle: null,
            battleScene: null,
            getInitialState: function () {
                var side1Units = [];
                var side2Units = [];
                for (var i = 0; i < 5; i++) {
                    side1Units.push(this.makeUnit());
                    side2Units.push(this.makeUnit());
                }
                var side1Player = this.makePlayer();
                var side2Player = this.makePlayer();
                var battle = this.battle = this.makeBattle({
                    side1Units: side1Units,
                    side2Units: side2Units,
                    side1Player: side1Player,
                    side2Player: side2Player
                });
                battle.init();
                return ({
                    activeUnit: side1Units[0],
                    selectedSide1Unit: side1Units[0],
                    selectedSide2Unit: side2Units[0],
                    selectedSFXTemplateKey: "particleTest",
                    duration: null
                });
            },
            componentDidMount: function () {
                var battleScene = this.battleScene = new Rance.BattleScene(this.refs["main"].getDOMNode());
                battleScene.resume();
                battleScene.activeUnit = this.state.selectedSide1Unit;
                battleScene.updateUnits();
            },
            makeUnit: function () {
                var template = Rance.getRandomProperty(app.moduleData.Templates.Units);
                return new Rance.Unit(template, this.idGenerator++);
            },
            makePlayer: function () {
                var player = new Rance.Player(false, this.idGenerator++);
                player.name = "player " + player.id;
                player.makeColorScheme();
                player.makeRandomFlag();
            },
            makeFormation: function (units) {
                var formation = [];
                var unitsIndex = 0;
                for (var i = 0; i < 2; i++) {
                    formation.push([]);
                    for (var j = 0; j < 3; j++) {
                        var unitToAdd = units[unitsIndex] ? units[unitsIndex] : null;
                        formation[i].push(unitToAdd);
                        unitsIndex++;
                    }
                }
                return formation;
            },
            makeBattle: function (props) {
                return new Rance.Battle({
                    battleData: {
                        location: null,
                        building: null,
                        attacker: {
                            player: props.side1Player,
                            units: props.side1Units
                        },
                        defender: {
                            player: props.side2Player,
                            units: props.side2Units
                        }
                    },
                    side1: this.makeFormation(props.side1Units),
                    side2: this.makeFormation(props.side2Units),
                    side1Player: props.side1Player,
                    side2Player: props.side2Player
                });
            },
            handleUnitHover: function (unit) {
                this.battleScene.hoveredUnit = unit;
                this.battleScene.updateUnits();
            },
            handleClearHover: function () {
                this.battleScene.hoveredUnit = null;
                this.battleScene.updateUnits();
            },
            selectUnit: function (unit) {
                var statePropForSide = unit.battleStats.side === "side1" ? "selectedSide1Unit" : "selectedSide2Unit";
                var statePropForOtherSide = unit.battleStats.side === "side1" ? "selectedSide2Unit" : "selectedSide1Unit";
                var previousSelectedUnit = this.state[statePropForSide];
                var newSelectedUnit = (previousSelectedUnit === unit) ? null : unit;
                var newStateObj = {};
                newStateObj[statePropForSide] = newSelectedUnit;
                var newActiveUnit = newSelectedUnit || this.state[statePropForOtherSide] || null;
                newStateObj.activeUnit = newActiveUnit;
                this.setState(newStateObj);
                this.battleScene.activeUnit = newActiveUnit;
                this.battleScene.updateUnits();
            },
            handleSelectSFXTemplate: function (e) {
                var target = e.target;
                this.setState({
                    selectedSFXTemplateKey: target.value
                });
            },
            handleChangeDuration: function (e) {
                var target = e.target;
                this.setState({
                    duration: target.value
                });
            },
            handleTestAbility1: function () {
                var overlayTestFN = function (color, params) {
                    var renderTexture = new PIXI.RenderTexture(params.renderer, params.width, params.height);
                    var sprite = new PIXI.Sprite(renderTexture);
                    var container = new PIXI.Container();
                    var text = new PIXI.Text("" + params.duration, { fill: color });
                    text.y -= 50;
                    container.addChild(text);
                    var alphaPerMillisecond = 1 / params.duration;
                    var currentTime = Date.now();
                    var startTime = currentTime;
                    var endTime = currentTime + params.duration;
                    var lastTime = currentTime;
                    function animate() {
                        currentTime = Date.now();
                        var elapsedTime = currentTime - lastTime;
                        lastTime = currentTime;
                        renderTexture.clear();
                        renderTexture.render(container);
                        if (currentTime < endTime) {
                            if (currentTime > startTime) {
                                text.text = "" + (endTime - currentTime);
                            }
                            window.requestAnimationFrame(animate);
                        }
                        else {
                            params.triggerEnd();
                        }
                    }
                    params.triggerStart(container);
                    animate();
                };
                var spriteTestFN = function (params) {
                    var container = new PIXI.Container;
                    var gfx = new PIXI.Graphics();
                    gfx.beginFill(0x0000FF);
                    gfx.drawRect(0, 0, 200, 200);
                    gfx.endFill();
                    container.addChild(gfx);
                    params.triggerStart(container);
                };
                var testSFX = {
                    duration: 1000,
                    battleOverlay: app.moduleData.Templates.BattleSFX["guard"].battleOverlay,
                    userOverlay: overlayTestFN.bind(null, 0xFF0000),
                    enemyOverlay: overlayTestFN.bind(null, 0x00FF00),
                    userSprite: spriteTestFN
                };
                var user = this.state.activeUnit;
                var target = user === this.state.selectedSide1Unit ? this.state.selectedSide2Unit : this.state.selectedSide1Unit;
                var bs = this.battleScene;
                var SFXTemplate = testSFX;
                bs.handleAbilityUse({
                    user: user,
                    target: target,
                    SFXTemplate: SFXTemplate,
                    triggerEffectCallback: function () { console.log("triggerEffect"); },
                    afterFinishedCallback: function () { console.log("afterFinishedCallback"); }
                });
            },
            useSelectedAbility: function () {
                var user = this.state.activeUnit;
                var target = user === this.state.selectedSide1Unit ? this.state.selectedSide2Unit : this.state.selectedSide1Unit;
                var bs = this.battleScene;
                var SFXTemplate = Rance.extendObject(app.moduleData.Templates.BattleSFX[this.state.selectedSFXTemplateKey]);
                if (this.state.duration) {
                    SFXTemplate.duration = this.state.duration;
                }
                bs.handleAbilityUse({
                    user: user,
                    target: target,
                    SFXTemplate: SFXTemplate,
                    triggerEffectCallback: function () { console.log("triggerEffect"); },
                    afterFinishedCallback: function () { console.log("afterFinishedCallback"); }
                });
            },
            makeUnitElements: function (units) {
                var unitElements = [];
                for (var i = 0; i < units.length; i++) {
                    var unit = units[i];
                    var style = {};
                    if (unit === this.state.activeUnit) {
                        style.border = "1px solid red";
                    }
                    if (unit === this.state.selectedSide1Unit || unit === this.state.selectedSide2Unit) {
                        style.backgroundColor = "yellow";
                    }
                    unitElements.push(React.DOM.div({
                        className: "battle-scene-test-controls-units-unit",
                        onMouseEnter: this.handleUnitHover.bind(this, unit),
                        onMouseLeave: this.handleClearHover.bind(this, unit),
                        onClick: this.selectUnit.bind(this, unit),
                        key: "" + unit.id,
                        style: style
                    }, unit.name));
                }
                return unitElements;
            },
            render: function () {
                var battle = this.battle;
                var side1UnitElements = this.makeUnitElements(battle.unitsBySide["side1"]);
                var side2UnitElements = this.makeUnitElements(battle.unitsBySide["side2"]);
                var SFXTemplateSelectOptions = [];
                SFXTemplateSelectOptions.push(React.DOM.option({
                    value: null,
                    key: "null"
                }, "null"));
                for (var key in app.moduleData.Templates.BattleSFX) {
                    var template = app.moduleData.Templates.BattleSFX[key];
                    SFXTemplateSelectOptions.push(React.DOM.option({
                        value: key,
                        key: key
                    }, key));
                }
                return (React.DOM.div({
                    className: "battle-scene-test"
                }, React.DOM.div({
                    className: "battle-scene-test-pixi-container",
                    ref: "main"
                }, null), React.DOM.div({
                    className: "battle-scene-test-controls"
                }, React.DOM.div({
                    className: "battle-scene-test-controls-units"
                }, React.DOM.div({
                    className: "battle-scene-test-controls-units-side1"
                }, side1UnitElements), React.DOM.div({
                    className: "battle-scene-test-controls-units-side2"
                }, side2UnitElements)), React.DOM.select({
                    value: this.state.selectedSFXTemplateKey,
                    onChange: this.handleSelectSFXTemplate
                }, SFXTemplateSelectOptions), React.DOM.button({
                    className: "battle-scene-test-ability2",
                    onClick: this.useSelectedAbility,
                    disabled: !this.state.selectedSFXTemplateKey || !(this.state.selectedSide1Unit && this.state.selectedSide2Unit)
                }, "use ability"), React.DOM.input({
                    type: "number",
                    step: 100,
                    min: 100,
                    max: 20000,
                    value: this.state.duration,
                    onChange: this.handleChangeDuration,
                    placeholder: "duration"
                }, null))));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../../lib/react.d.ts" />
/// <reference path="battle/battle.ts"/>
/// <reference path="unitlist/unitlist.ts"/>
/// <reference path="unitlist/itemequip.ts"/>
/// <reference path="battleprep/battleprep.ts"/>
/// <reference path="galaxymap/galaxymap.ts"/>
/// <reference path="setupgame/setupgame.ts"/>
/// <reference path="flagmaker.ts"/>
/// <reference path="battlescenetester.ts" />
var Rance;
(function (Rance) {
    var UIComponents;
    (function (UIComponents) {
        UIComponents.Stage = React.createClass({
            displayName: "Stage",
            changeScene: function () {
                var newScene = this.refs.sceneSelector.getDOMNode().value;
                this.props.changeSceneFunction(newScene);
            },
            render: function () {
                var elementsToRender = [];
                switch (this.props.sceneToRender) {
                    case "battle":
                        {
                            elementsToRender.push(UIComponents.Battle({
                                battle: this.props.battle,
                                humanPlayer: this.props.player,
                                renderer: this.props.renderer,
                                key: "battle"
                            }));
                            break;
                        }
                    case "battlePrep":
                        {
                            elementsToRender.push(UIComponents.BattlePrep({
                                battlePrep: this.props.battlePrep,
                                renderer: this.props.renderer,
                                key: "battlePrep"
                            }));
                            break;
                        }
                    case "galaxyMap":
                        {
                            elementsToRender.push(UIComponents.GalaxyMap({
                                renderer: this.props.renderer,
                                mapRenderer: this.props.mapRenderer,
                                playerControl: this.props.playerControl,
                                player: this.props.player,
                                game: this.props.game,
                                key: "galaxyMap"
                            }));
                            break;
                        }
                    case "flagMaker":
                        {
                            elementsToRender.push(UIComponents.FlagMaker({
                                key: "flagMaker"
                            }));
                            break;
                        }
                    case "setupGame":
                        {
                            elementsToRender.push(UIComponents.SetupGame({
                                key: "setupGame"
                            }));
                            break;
                        }
                    case "battleSceneTester":
                        {
                            elementsToRender.push(UIComponents.BattleSceneTester({
                                key: "battleSceneTester"
                            }));
                            break;
                        }
                }
                return (React.DOM.div({ className: "react-stage" }, elementsToRender));
            }
        });
    })(UIComponents = Rance.UIComponents || (Rance.UIComponents = {}));
})(Rance || (Rance = {}));
/// <reference path="../lib/react.d.ts" />
/// <reference path="eventmanager.ts"/>
/// <reference path="uicomponents/stage.ts"/>
var Rance;
(function (Rance) {
    var ReactUI = (function () {
        function ReactUI(container) {
            this.container = container;
            React.initializeTouchEvents(true);
            this.addEventListeners();
        }
        ReactUI.prototype.addEventListeners = function () {
            this.switchSceneFN = function (sceneName) {
                this.switchScene(sceneName);
            }.bind(this);
            Rance.eventManager.addEventListener("switchScene", this.switchSceneFN);
        };
        ReactUI.prototype.switchScene = function (newScene) {
            this.currentScene = newScene;
            this.render();
        };
        ReactUI.prototype.destroy = function () {
            Rance.eventManager.removeEventListener("switchScene", this.switchSceneFN);
            React.unmountComponentAtNode(this.container);
            this.stage = null;
            this.container = null;
        };
        ReactUI.prototype.render = function () {
            this.stage = React.renderComponent(Rance.UIComponents.Stage({
                sceneToRender: this.currentScene,
                changeSceneFunction: this.switchScene.bind(this),
                battle: this.battle,
                battlePrep: this.battlePrep,
                renderer: this.renderer,
                mapRenderer: this.mapRenderer,
                playerControl: this.playerControl,
                player: this.player,
                game: this.game
            }), this.container);
        };
        return ReactUI;
    }());
    Rance.ReactUI = ReactUI;
})(Rance || (Rance = {}));
/// <reference path="eventmanager.ts"/>
/// <reference path="player.ts"/>
/// <reference path="fleet.ts"/>
/// <reference path="star.ts"/>
/// <reference path="ibattledata.d.ts"/>
/// <reference path="ifleetattacktarget.d.ts" />
var Rance;
(function (Rance) {
    var PlayerControl = (function () {
        function PlayerControl(player) {
            this.selectedFleets = [];
            this.inspectedFleets = [];
            this.currentlyReorganizing = [];
            this.lastSelectedFleetsIds = {};
            this.preventingGhost = false;
            this.listeners = {};
            this.player = player;
            this.addEventListeners();
        }
        PlayerControl.prototype.destroy = function () {
            this.removeEventListeners();
            this.player = null;
            this.selectedFleets = null;
            this.currentlyReorganizing = null;
            this.currentAttackTargets = null;
            this.selectedStar = null;
        };
        PlayerControl.prototype.removeEventListener = function (name) {
            Rance.eventManager.removeEventListener(name, this.listeners[name]);
        };
        PlayerControl.prototype.removeEventListeners = function () {
            for (var name in this.listeners) {
                this.removeEventListener(name);
            }
        };
        PlayerControl.prototype.addEventListener = function (name, handler) {
            this.listeners[name] = handler;
            Rance.eventManager.addEventListener(name, handler);
        };
        PlayerControl.prototype.addEventListeners = function () {
            var self = this;
            this.addEventListener("updateSelection", function () {
                self.updateSelection();
            });
            this.addEventListener("selectFleets", function (fleets) {
                self.selectFleets(fleets);
            });
            this.addEventListener("deselectFleet", function (fleet) {
                self.deselectFleet(fleet);
            });
            this.addEventListener("mergeFleets", function () {
                self.mergeFleets();
            });
            this.addEventListener("splitFleet", function (fleet) {
                self.splitFleet(fleet);
            });
            this.addEventListener("startReorganizingFleets", function (fleets) {
                self.startReorganizingFleets(fleets);
            });
            this.addEventListener("endReorganizingFleets", function () {
                self.endReorganizingFleets();
            });
            this.addEventListener("starClick", function (star) {
                self.selectStar(star);
            });
            this.addEventListener("moveFleets", function (star) {
                self.moveFleets(star);
            });
            this.addEventListener("setRectangleSelectTargetFN", function (rectangleSelect) {
                rectangleSelect.getSelectionTargetsFN =
                    self.player.getFleetsWithPositions.bind(self.player);
            });
            this.addEventListener("attackTarget", function (target) {
                self.attackTarget(target);
            });
        };
        PlayerControl.prototype.preventGhost = function (delay) {
            this.preventingGhost = true;
            var self = this;
            var timeout = window.setTimeout(function () {
                self.preventingGhost = false;
                window.clearTimeout(timeout);
            }, delay);
        };
        PlayerControl.prototype.clearSelection = function () {
            this.selectedFleets = [];
            this.inspectedFleets = [];
            this.selectedStar = null;
        };
        PlayerControl.prototype.updateSelection = function (endReorganizingFleets) {
            if (endReorganizingFleets === void 0) { endReorganizingFleets = true; }
            if (endReorganizingFleets)
                this.endReorganizingFleets();
            this.currentAttackTargets = this.getCurrentAttackTargets();
            Rance.eventManager.dispatchEvent("playerControlUpdated", null);
            Rance.eventManager.dispatchEvent("clearPossibleActions", null);
        };
        PlayerControl.prototype.areAllFleetsInSameLocation = function () {
            if (this.selectedFleets.length <= 0)
                return false;
            for (var i = 1; i < this.selectedFleets.length; i++) {
                if (this.selectedFleets[i].location !== this.selectedFleets[i - 1].location) {
                    return false;
                }
            }
            return true;
        };
        PlayerControl.prototype.selectFleets = function (fleets) {
            if (fleets.length < 1) {
                this.clearSelection();
                this.updateSelection();
                return;
            }
            var playerFleets = [];
            var otherFleets = [];
            for (var i = 0; i < fleets.length; i++) {
                if (fleets[i].player === this.player) {
                    playerFleets.push(fleets[i]);
                }
                else {
                    otherFleets.push(fleets[i]);
                }
            }
            if (playerFleets.length > 0) {
                this.selectPlayerFleets(playerFleets);
            }
            else {
                this.selectOtherFleets(otherFleets);
            }
            this.updateSelection();
            this.preventGhost(15);
        };
        PlayerControl.prototype.selectPlayerFleets = function (fleets) {
            this.clearSelection();
            for (var i = 0; i < fleets.length; i++) {
                if (fleets[i].units.length < 1) {
                    if (this.currentlyReorganizing.indexOf(fleets[i]) >= 0)
                        continue;
                    fleets[i].deleteFleet();
                    fleets.splice(i, 1);
                }
            }
            var oldFleets = this.selectedFleets.slice(0);
            this.selectedFleets = fleets;
        };
        PlayerControl.prototype.selectOtherFleets = function (fleets) {
            this.inspectedFleets = fleets;
        };
        PlayerControl.prototype.deselectFleet = function (fleet) {
            var fleetsContainer = this.selectedFleets.length > 0 ? this.selectedFleets : this.inspectedFleets;
            var fleetIndex = fleetsContainer.indexOf(fleet);
            if (fleetIndex < 0)
                return;
            fleetsContainer.splice(fleetIndex, 1);
            if (fleetsContainer.length < 1) {
                this.selectedStar = fleet.location;
            }
            this.updateSelection();
        };
        PlayerControl.prototype.getMasterFleetForMerge = function (fleets) {
            return fleets[0];
        };
        PlayerControl.prototype.mergeFleetsOfSameType = function (fleets) {
            if (fleets.length === 0)
                return [];
            var master = this.getMasterFleetForMerge(fleets);
            fleets.splice(fleets.indexOf(master), 1);
            var slaves = fleets;
            for (var i = 0; i < slaves.length; i++) {
                slaves[i].mergeWith(master, i === slaves.length - 1);
            }
            return [master];
        };
        PlayerControl.prototype.mergeFleets = function () {
            var allFleets = this.selectedFleets;
            var normalFleets = [];
            var stealthyFleets = [];
            for (var i = 0; i < allFleets.length; i++) {
                if (allFleets[i].isStealthy) {
                    stealthyFleets.push(allFleets[i]);
                }
                else {
                    normalFleets.push(allFleets[i]);
                }
            }
            this.clearSelection();
            this.selectedFleets =
                this.mergeFleetsOfSameType(normalFleets).concat(this.mergeFleetsOfSameType(stealthyFleets));
            this.updateSelection();
        };
        PlayerControl.prototype.selectStar = function (star) {
            if (this.preventingGhost || this.selectedStar === star)
                return;
            this.clearSelection();
            this.selectedStar = star;
            this.updateSelection();
        };
        PlayerControl.prototype.moveFleets = function (star) {
            for (var i = 0; i < this.selectedFleets.length; i++) {
                this.selectedFleets[i].pathFind(star);
            }
        };
        PlayerControl.prototype.splitFleet = function (fleet) {
            if (fleet.units.length <= 0)
                return;
            this.endReorganizingFleets();
            var newFleet = fleet.split();
            this.currentlyReorganizing = [fleet, newFleet];
            this.selectedFleets = [fleet, newFleet];
            this.updateSelection(false);
        };
        PlayerControl.prototype.startReorganizingFleets = function (fleets) {
            if (fleets.length !== 2 ||
                fleets[0].location !== fleets[1].location ||
                this.selectedFleets.length !== 2 ||
                this.selectedFleets.indexOf(fleets[0]) < 0 ||
                this.selectedFleets.indexOf(fleets[1]) < 0) {
                throw new Error("cant reorganize fleets");
            }
            this.currentlyReorganizing = fleets;
            this.updateSelection(false);
        };
        PlayerControl.prototype.endReorganizingFleets = function () {
            for (var i = 0; i < this.currentlyReorganizing.length; i++) {
                var fleet = this.currentlyReorganizing[i];
                if (fleet.units.length <= 0) {
                    var selectedIndex = this.selectedFleets.indexOf(fleet);
                    if (selectedIndex >= 0) {
                        this.selectedFleets.splice(selectedIndex, 1);
                    }
                    fleet.deleteFleet();
                }
            }
            this.currentlyReorganizing = [];
        };
        PlayerControl.prototype.getCurrentAttackTargets = function () {
            if (this.selectedFleets.length < 1)
                return [];
            if (!this.areAllFleetsInSameLocation())
                return [];
            var location = this.selectedFleets[0].location;
            var possibleTargets = location.getTargetsForPlayer(this.player);
            return possibleTargets;
        };
        PlayerControl.prototype.attackTarget = function (target) {
            if (this.currentAttackTargets.indexOf(target) < 0) {
                throw new Error("Invalid attack target");
            }
            var currentLocation = this.selectedFleets[0].location;
            this.player.attackTarget(currentLocation, target);
        };
        return PlayerControl;
    }());
    Rance.PlayerControl = PlayerControl;
})(Rance || (Rance = {}));
/// <reference path="../lib/pixi.d.ts" />
var tempCameraId = 0;
var Rance;
(function (Rance) {
    /**
     * @class Camera
     * @constructor
     */
    var Camera = (function () {
        /**
         * [constructor description]
         * @param {PIXI.Container} container [DOC the camera views and manipulates]
         * @param {number}                      bound     [How much of the container is allowed to leave the camera view.
         * 0.0 to 1.0]
         */
        function Camera(container, bound) {
            this.bounds = {};
            this.currZoom = 1;
            // renderer view is mounted
            this.onMoveCallbacks = [];
            this.onZoomCallbacks = [];
            this.listeners = {};
            this.tempCameraId = tempCameraId++;
            this.container = container;
            this.bounds.min = bound;
            this.bounds.max = Number((1 - bound).toFixed(1));
            var screenElement = window.getComputedStyle(document.getElementById("pixi-container"), null);
            this.screenWidth = parseInt(screenElement.width);
            this.screenHeight = parseInt(screenElement.height);
            this.addEventListeners();
            this.setBounds();
        }
        Camera.prototype.destroy = function () {
            for (var name in this.listeners) {
                Rance.eventManager.removeEventListener(name, this.listeners[name]);
            }
            this.onMoveCallbacks = [];
            this.onZoomCallbacks = [];
            window.removeEventListener("resize", this.resizeListener);
        };
        /**
         * @method addEventListeners
         * @private
         */
        Camera.prototype.addEventListeners = function () {
            var self = this;
            this.resizeListener = function (e) {
                var container = document.getElementById("pixi-container");
                if (!container)
                    return;
                var style = window.getComputedStyle(container, null);
                self.screenWidth = parseInt(style.width);
                self.screenHeight = parseInt(style.height);
            };
            window.addEventListener("resize", this.resizeListener, false);
            this.listeners["setCameraToCenterOn"] =
                Rance.eventManager.addEventListener("setCameraToCenterOn", function (position) {
                    self.toCenterOn = position;
                });
            Rance.eventManager.dispatchEvent("registerOnMoveCallback", self.onMoveCallbacks);
            Rance.eventManager.dispatchEvent("registerOnZoomCallback", self.onZoomCallbacks);
        };
        /**
         * @method setBound
         * @private
         */
        Camera.prototype.setBounds = function () {
            var rect = this.container.getLocalBounds();
            this.width = this.screenWidth;
            this.height = this.screenHeight;
            this.bounds =
                {
                    xMin: (this.width * this.bounds.min) - rect.width * this.container.scale.x,
                    xMax: (this.width * this.bounds.max),
                    yMin: (this.height * this.bounds.min) - rect.height * this.container.scale.y,
                    yMax: (this.height * this.bounds.max),
                    min: this.bounds.min,
                    max: this.bounds.max
                };
        };
        /**
         * @method startScroll
         * @param {number[]} mousePos [description]
         */
        Camera.prototype.startScroll = function (mousePos) {
            this.setBounds();
            this.startClick = mousePos;
            this.startPos = [this.container.position.x, this.container.position.y];
        };
        /**
         * @method end
         */
        Camera.prototype.end = function () {
            this.startPos = undefined;
        };
        /**
         * @method getDelta
         * @param {number[]} currPos [description]
         */
        Camera.prototype.getDelta = function (currPos) {
            var x = this.startClick[0] - currPos[0];
            var y = this.startClick[1] - currPos[1];
            return [-x, -y];
        };
        /**
         * @method move
         * @param {number[]} currPos [description]
         */
        Camera.prototype.move = function (currPos) {
            var delta = this.getDelta(currPos);
            this.container.position.x = this.startPos[0] + delta[0];
            this.container.position.y = this.startPos[1] + delta[1];
            this.clampEdges();
            this.onMove();
        };
        Camera.prototype.deltaMove = function (delta) {
            this.container.position.x += delta[0];
            this.container.position.y += delta[1];
            this.clampEdges();
            this.onMove();
        };
        Camera.prototype.onMove = function () {
            for (var i = 0; i < this.onMoveCallbacks.length; i++) {
                this.onMoveCallbacks[i](this.container.position.x, this.container.position.y);
            }
        };
        Camera.prototype.getScreenCenter = function () {
            return ({
                x: this.width / 2,
                y: this.height / 2
            });
        };
        Camera.prototype.getLocalPosition = function (position) {
            var pos = position;
            return this.container.worldTransform.apply(pos);
        };
        Camera.prototype.getCenterPosition = function () {
            var localOrigin = this.getLocalPosition(this.container.position);
            return ({
                x: this.container.position.x + this.width / 2 - localOrigin.x,
                y: this.container.position.y + this.height / 2 - localOrigin.y
            });
        };
        Camera.prototype.centerOnPosition = function (pos) {
            this.setBounds();
            var localPos = this.getLocalPosition(pos);
            var center = this.getScreenCenter();
            this.container.position.x += center.x - localPos.x;
            this.container.position.y += center.y - localPos.y;
            this.clampEdges();
            this.onMove();
        };
        /**
         * @method zoom
         * @param {number} zoomAmount [description]
         */
        Camera.prototype.zoom = function (zoomAmount) {
            if (zoomAmount > 1) {
            }
            var container = this.container;
            var oldZoom = this.currZoom;
            var zoomDelta = oldZoom - zoomAmount;
            var rect = container.getLocalBounds();
            //these 2 get position of screen center in relation to the container
            //0: far left 1: far right
            var xRatio = 1 - ((container.x - this.screenWidth / 2) / rect.width / oldZoom + 1);
            var yRatio = 1 - ((container.y - this.screenHeight / 2) / rect.height / oldZoom + 1);
            var xDelta = rect.width * xRatio * zoomDelta;
            var yDelta = rect.height * yRatio * zoomDelta;
            container.position.x += xDelta;
            container.position.y += yDelta;
            container.scale.set(zoomAmount, zoomAmount);
            this.currZoom = zoomAmount;
            this.onMove();
            this.onZoom();
        };
        Camera.prototype.onZoom = function () {
            for (var i = 0; i < this.onZoomCallbacks.length; i++) {
                this.onZoomCallbacks[i](this.currZoom);
            }
        };
        /**
         * @method deltaZoom
         * @param {number} delta [description]
         * @param {number} scale [description]
         */
        Camera.prototype.deltaZoom = function (delta, scale) {
            if (delta === 0) {
                return;
            }
            //var scaledDelta = absDelta + scale / absDelta;
            var direction = delta < 0 ? "out" : "in";
            var adjDelta = 1 + Math.abs(delta) * scale;
            if (direction === "out") {
                this.zoom(this.currZoom / adjDelta);
            }
            else {
                this.zoom(this.currZoom * adjDelta);
            }
        };
        /**
         * @method clampEdges
         * @private
         */
        Camera.prototype.clampEdges = function () {
            var x = this.container.position.x;
            var y = this.container.position.y;
            //horizontal
            //left edge
            if (x < this.bounds.xMin) {
                x = this.bounds.xMin;
            }
            else if (x > this.bounds.xMax) {
                x = this.bounds.xMax;
            }
            //vertical
            //top
            if (y < this.bounds.yMin) {
                y = this.bounds.yMin;
            }
            else if (y > this.bounds.yMax) {
                y = this.bounds.yMax;
            }
            this.container.position.set(x, y);
        };
        return Camera;
    }());
    Rance.Camera = Camera;
})(Rance || (Rance = {}));
/// <reference path="../lib/pixi.d.ts" />
/// <reference path="eventmanager.ts"/>
/// <reference path="point.ts" />
var Rance;
(function (Rance) {
    var RectangleSelect = (function () {
        function RectangleSelect(parentContainer) {
            this.parentContainer = parentContainer;
            this.graphics = new PIXI.Graphics();
            parentContainer.addChild(this.graphics);
            this.addEventListeners();
        }
        RectangleSelect.prototype.destroy = function () {
            this.parentContainer = null;
            this.graphics = null;
            this.toSelectFrom = null;
            this.getSelectionTargetsFN = null;
        };
        RectangleSelect.prototype.addEventListeners = function () {
            var self = this;
            Rance.eventManager.dispatchEvent("setRectangleSelectTargetFN", this);
        };
        RectangleSelect.prototype.startSelection = function (point) {
            this.selecting = true;
            this.start = point;
            this.current = point;
        };
        RectangleSelect.prototype.moveSelection = function (point) {
            this.current = point;
            this.drawSelectionRectangle();
        };
        RectangleSelect.prototype.endSelection = function (point) {
            if (Math.abs(this.start.x - this.current.x) < 10 || Math.abs(this.start.y - this.current.y) < 10) {
                this.clearSelection();
                return;
            }
            this.setSelectionTargets();
            var inSelection = this.getAllInSelection();
            Rance.eventManager.dispatchEvent("selectFleets", inSelection);
            this.clearSelection();
        };
        RectangleSelect.prototype.clearSelection = function () {
            this.selecting = false;
            this.graphics.clear();
            this.start = null;
            this.current = null;
        };
        RectangleSelect.prototype.drawSelectionRectangle = function () {
            if (!this.current)
                return;
            var gfx = this.graphics;
            var bounds = this.getBounds();
            gfx.clear();
            gfx.lineStyle(1, 0xFFFFFF, 1);
            gfx.beginFill(0x000000, 0);
            gfx.drawRect(bounds.x1, bounds.y1, bounds.width, bounds.height);
            gfx.endFill();
        };
        RectangleSelect.prototype.setSelectionTargets = function () {
            if (!this.getSelectionTargetsFN)
                return;
            this.toSelectFrom = this.getSelectionTargetsFN();
        };
        RectangleSelect.prototype.getBounds = function () {
            var x1 = Math.min(this.start.x, this.current.x);
            var x2 = Math.max(this.start.x, this.current.x);
            var y1 = Math.min(this.start.y, this.current.y);
            var y2 = Math.max(this.start.y, this.current.y);
            return ({
                x1: x1,
                x2: x2,
                y1: y1,
                y2: y2,
                width: x2 - x1,
                height: y2 - y1
            });
        };
        RectangleSelect.prototype.getAllInSelection = function () {
            var toReturn = [];
            for (var i = 0; i < this.toSelectFrom.length; i++) {
                if (this.selectionContains(this.toSelectFrom[i].position)) {
                    toReturn.push(this.toSelectFrom[i].data);
                }
            }
            return toReturn;
        };
        RectangleSelect.prototype.selectionContains = function (point) {
            var x = point.x;
            var y = point.y;
            var bounds = this.getBounds();
            return ((x >= bounds.x1 && x <= bounds.x2) &&
                (y >= bounds.y1 && y <= bounds.y2));
        };
        return RectangleSelect;
    }());
    Rance.RectangleSelect = RectangleSelect;
})(Rance || (Rance = {}));
/// <reference path="fleet.ts"/>
/// <reference path="camera.ts"/>
/// <reference path="renderer.ts"/>
/// <reference path="rectangleselect.ts"/>
var Rance;
(function (Rance) {
    var MouseEventHandler = (function () {
        function MouseEventHandler(renderer, camera) {
            this.preventingGhost = {};
            this.listeners = {};
            this.renderer = renderer;
            this.camera = camera;
            this.rectangleSelect = new Rance.RectangleSelect(renderer.layers["select"]);
            this.currentAction = undefined;
            window.oncontextmenu = function (event) {
                var eventTarget = event.target;
                if (eventTarget.localName !== "canvas")
                    return;
                event.preventDefault();
                event.stopPropagation();
            };
            this.addEventListeners();
        }
        MouseEventHandler.prototype.destroy = function () {
            for (var name in this.listeners) {
                Rance.eventManager.removeEventListener(name, this.listeners[name]);
            }
            this.hoveredStar = null;
            this.rectangleSelect.destroy();
            this.rectangleSelect = null;
            this.renderer = null;
            this.camera = null;
        };
        MouseEventHandler.prototype.addEventListeners = function () {
            var self = this;
            var _canvas = document.getElementById("pixi-container");
            _canvas.addEventListener("DOMMouseScroll", function (e) {
                if (e.target.localName !== "canvas")
                    return;
                self.camera.deltaZoom(-e.detail, 0.05);
            });
            _canvas.addEventListener("mousewheel", function (e) {
                if (e.target.localName !== "canvas")
                    return;
                self.camera.deltaZoom(e.wheelDelta / 40, 0.05);
            });
            _canvas.addEventListener("mouseout", function (e) {
                if (e.target.localName !== "canvas")
                    return;
            });
            this.listeners["mouseDown"] = Rance.eventManager.addEventListener("mouseDown", function (e, star) {
                self.mouseDown(e, star);
            });
            this.listeners["mouseUp"] = Rance.eventManager.addEventListener("mouseUp", function (e) {
                self.mouseUp(e);
            });
            this.listeners["touchStart"] = Rance.eventManager.addEventListener("touchStart", function (e) {
                self.touchStart(e);
            });
            this.listeners["touchEnd"] = Rance.eventManager.addEventListener("touchEnd", function (e) {
                self.touchEnd(e);
            });
            this.listeners["hoverStar"] = Rance.eventManager.addEventListener("hoverStar", function (star) {
                self.setHoveredStar(star);
            });
            this.listeners["clearHover"] = Rance.eventManager.addEventListener("clearHover", function () {
                self.clearHoveredStar();
            });
        };
        MouseEventHandler.prototype.preventGhost = function (delay, type) {
            if (this.preventingGhost[type]) {
                window.clearTimeout(this.preventingGhost[type]);
            }
            var self = this;
            this.preventingGhost[type] = window.setTimeout(function () {
                self.preventingGhost[type] = null;
            }, delay);
        };
        MouseEventHandler.prototype.makeUITransparent = function () {
            if (!this.currentAction)
                return;
            var ui = document.getElementsByClassName("galaxy-map-ui")[0];
            if (ui) {
                ui.classList.add("prevent-pointer-events", "mouse-event-active-ui");
            }
        };
        MouseEventHandler.prototype.makeUIOpaque = function () {
            if (this.currentAction)
                return;
            var ui = document.getElementsByClassName("galaxy-map-ui")[0];
            if (ui) {
                ui.classList.remove("prevent-pointer-events", "mouse-event-active-ui");
            }
        };
        MouseEventHandler.prototype.cancelCurrentAction = function () {
            switch (this.currentAction) {
                case "select":
                    {
                        this.rectangleSelect.clearSelection();
                        this.currentAction = undefined;
                        this.makeUIOpaque();
                    }
            }
        };
        MouseEventHandler.prototype.mouseDown = function (event, star) {
            if (this.preventingGhost["mouseDown"])
                return;
            var originalEvent = event.data.originalEvent;
            if (originalEvent.ctrlKey ||
                originalEvent.metaKey ||
                originalEvent.button === 1) {
                this.startScroll(event);
            }
            else if (originalEvent.button === 0 ||
                !isFinite(originalEvent.button)) {
                this.cancelCurrentAction();
                this.startSelect(event);
            }
            else if (originalEvent.button === 2) {
                this.cancelCurrentAction();
                this.startFleetMove(event, star);
            }
            this.preventGhost(15, "mouseDown");
        };
        MouseEventHandler.prototype.touchStart = function (event, star) {
            if (app.playerControl.selectedFleets.length === 0) {
                this.startSelect(event);
            }
            else {
                this.startFleetMove(event, star);
            }
        };
        MouseEventHandler.prototype.touchEnd = function (event) {
            if (this.currentAction === "select") {
                this.endSelect(event);
            }
            if (this.currentAction === "fleetMove") {
                this.completeFleetMove();
            }
        };
        MouseEventHandler.prototype.mouseMove = function (event) {
            if (this.currentAction === "scroll") {
                this.scrollMove(event);
            }
            else if (this.currentAction === "zoom") {
                this.zoomMove(event);
            }
            else if (this.currentAction === "select") {
                this.dragSelect(event);
            }
        };
        MouseEventHandler.prototype.mouseUp = function (event) {
            if (this.currentAction === undefined)
                return;
            if (this.currentAction === "scroll") {
                this.endScroll(event);
                this.preventGhost(15, "mouseUp");
            }
            else if (this.currentAction === "zoom") {
                this.endZoom(event);
                this.preventGhost(15, "mouseUp");
            }
            else if (this.currentAction === "select") {
                if (!this.preventingGhost["mouseUp"])
                    this.endSelect(event);
            }
            else if (this.currentAction === "fleetMove") {
                if (!this.preventingGhost["mouseUp"])
                    this.completeFleetMove();
            }
        };
        MouseEventHandler.prototype.startScroll = function (event) {
            if (this.currentAction !== "scroll") {
                this.stashedAction = this.currentAction;
            }
            this.currentAction = "scroll";
            this.startPoint = [event.data.global.x, event.data.global.y];
            this.camera.startScroll(this.startPoint);
            this.makeUITransparent();
        };
        MouseEventHandler.prototype.scrollMove = function (event) {
            this.camera.move([event.data.global.x, event.data.global.y]);
        };
        MouseEventHandler.prototype.endScroll = function (event) {
            this.camera.end();
            this.startPoint = undefined;
            this.currentAction = this.stashedAction;
            this.stashedAction = undefined;
            this.makeUIOpaque();
        };
        MouseEventHandler.prototype.zoomMove = function (event) {
            var delta = event.data.global.x + this.currPoint[1] -
                this.currPoint[0] - event.data.global.y;
            this.camera.deltaZoom(delta, 0.005);
            this.currPoint = [event.data.global.x, event.data.global.y];
        };
        MouseEventHandler.prototype.endZoom = function (event) {
            this.startPoint = undefined;
            this.currentAction = this.stashedAction;
            this.stashedAction = undefined;
        };
        MouseEventHandler.prototype.startZoom = function (event) {
            if (this.currentAction !== "zoom") {
                this.stashedAction = this.currentAction;
            }
            this.currentAction = "zoom";
            this.startPoint = this.currPoint = [event.data.global.x, event.data.global.y];
        };
        MouseEventHandler.prototype.setHoveredStar = function (star) {
            this.preventGhost(30, "hover");
            if (star !== this.hoveredStar) {
                this.hoveredStar = star;
                this.setFleetMoveTarget(star);
            }
        };
        MouseEventHandler.prototype.clearHoveredStar = function () {
            var timeout = window.setTimeout(function () {
                if (!this.preventingGhost["hover"]) {
                    this.hoveredStar = null;
                    this.clearFleetMoveTarget();
                }
                window.clearTimeout(timeout);
            }.bind(this), 15);
        };
        MouseEventHandler.prototype.startFleetMove = function (event, star) {
            Rance.eventManager.dispatchEvent("startPotentialMove", star);
            this.currentAction = "fleetMove";
            this.makeUITransparent();
        };
        MouseEventHandler.prototype.setFleetMoveTarget = function (star) {
            if (this.currentAction !== "fleetMove")
                return;
            Rance.eventManager.dispatchEvent("setPotentialMoveTarget", star);
        };
        MouseEventHandler.prototype.completeFleetMove = function () {
            if (this.hoveredStar) {
                Rance.eventManager.dispatchEvent("moveFleets", this.hoveredStar);
            }
            Rance.eventManager.dispatchEvent("endPotentialMove");
            this.currentAction = undefined;
            this.makeUIOpaque();
        };
        MouseEventHandler.prototype.clearFleetMoveTarget = function () {
            if (this.currentAction !== "fleetMove")
                return;
            Rance.eventManager.dispatchEvent("clearPotentialMoveTarget");
        };
        MouseEventHandler.prototype.startSelect = function (event) {
            this.currentAction = "select";
            this.rectangleSelect.startSelection(event.data.getLocalPosition(this.renderer.layers["main"]));
            this.makeUITransparent();
        };
        MouseEventHandler.prototype.dragSelect = function (event) {
            this.rectangleSelect.moveSelection(event.data.getLocalPosition(this.renderer.layers["main"]));
        };
        MouseEventHandler.prototype.endSelect = function (event) {
            this.rectangleSelect.endSelection(event.data.getLocalPosition(this.renderer.layers["main"]));
            this.currentAction = undefined;
            this.makeUIOpaque();
        };
        return MouseEventHandler;
    }());
    Rance.MouseEventHandler = MouseEventHandler;
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var UniformManager = (function () {
        function UniformManager() {
            this.registeredObjects = {};
            this.timeCount = 0;
        }
        UniformManager.prototype.registerObject = function (uniformType, shader) {
            if (!this.registeredObjects[uniformType]) {
                this.registeredObjects[uniformType] = [];
            }
            this.registeredObjects[uniformType].push(shader);
        };
        UniformManager.prototype.updateTime = function () {
            this.timeCount += 0.01;
            if (!this.registeredObjects["time"])
                return;
            for (var i = 0; i < this.registeredObjects["time"].length; i++) {
                this.registeredObjects["time"][i].uniforms.time.value = this.timeCount;
            }
        };
        return UniformManager;
    }());
    Rance.UniformManager = UniformManager;
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var ShaderSources;
    (function (ShaderSources) {
        ShaderSources.beam = [
            "precision mediump float;",
            "",
            "#define DOMAIN 0 // 0 == pixi, 1 == shdr.bkcore.com",
            "",
            "#if DOMAIN == 0",
            "  varying vec2 vTextureCoord;",
            "  uniform sampler2D uSampler;",
            "",
            "  uniform float aspectRatio;",
            "",
            "  uniform vec4 beamColor;",
            "",
            "  uniform float lineIntensity;",
            "  uniform float bulgeIntensity;",
            "",
            "  uniform float bulgeXPosition;",
            "  uniform vec2 bulgeSize;",
            "  uniform float bulgeSharpness;",
            "",
            "  uniform vec2 lineXSize;",
            "  uniform float lineXSharpness;",
            "",
            "  uniform float lineYSize;",
            "  uniform float lineYSharpness;",
            "",
            "",
            "#elif DOMAIN == 1",
            "  uniform vec2 resolution;",
            "  uniform float time;",
            "",
            "  float aspectRatio = resolution.x / resolution.y;",
            "",
            "  const vec4 beamColor = vec4(1.0, 0.5, 0.5, 1.0);",
            "",
            "  const float bulgeXPosition = 0.4;",
            "  const vec2 bulgeSize = vec2(0.8, 0.4);",
            "  const float bulgeSharpness = 0.4;",
            "  const float bulgeIntensity = 3.0;",
            "",
            "  const vec2 lineXSize = vec2(0.4, 1.0);",
            "  const float lineXSharpness = 0.3;",
            "",
            "  const float lineYSize = 0.02;",
            "  const float lineYSharpness = 0.8;",
            "  const float lineIntensity = 5.0;",
            "",
            "",
            "#endif",
            "",
            "",
            "float ellipseGradient(vec2 p, float ellipseXPosition, vec2 ellipseSize)",
            "{",
            "  vec2 q = vec2(-1.0 + 2.0 * p.x, p.y); // (-1, -1) -> (1, 1)",
            "  q.x -= -1.0 + 2.0 * ellipseXPosition;",
            "  q.x *= aspectRatio;",
            "  q /= ellipseSize;",
            "",
            "  float dist = length(q);",
            "",
            "  return dist;",
            "}",
            "",
            "void main()",
            "{",
            "  #if DOMAIN == 0",
            "    vec2 uv = vTextureCoord;",
            "    vec4 color = texture2D(uSampler, vTextureCoord);",
            "  #elif DOMAIN == 1",
            "    vec2 uv = gl_FragCoord.xy / resolution;",
            "    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);",
            "  #endif",
            "",
            "  vec2 q = vec2(uv.x, -1.0 + 2.0 * uv.y); // (0, -1) -> (1, 1)",
            "",
            "  float yDistFromCenter = abs(q.y);",
            "  float insideLineY = step(yDistFromCenter, lineYSize);",
            "  float lineYDist = max(1.0 - distance(yDistFromCenter, lineYSize), insideLineY);",
            "  float lineYGradient = smoothstep(lineYSharpness, 1.0, lineYDist);",
            "",
            "  float insideLineX = step(lineXSize.x, q.x) * step(q.x, lineXSize.y);",
            "  float lineXDist = 1.0 - min(distance(q.x, lineXSize.x), distance(q.x, lineXSize.y));",
            "  lineXDist = max(insideLineX, lineXDist);",
            "",
            "  float lineXGradient = smoothstep(lineXSharpness, 1.0, lineXDist);",
            "",
            "  float lineGradient = (lineYGradient * lineXGradient) * lineIntensity;",
            "",
            "  float bulgeGradient = 1.0 - ellipseGradient(q, bulgeXPosition, bulgeSize);",
            "  bulgeGradient = smoothstep(0.0, 1.0 - bulgeSharpness, bulgeGradient) * bulgeIntensity;",
            "",
            "  float beamGradient = lineGradient + bulgeGradient;",
            "  color += beamGradient * beamColor;",
            "",
            "  gl_FragColor = color;",
            "}",
        ];
        ShaderSources.blacktoalpha = [
            "precision mediump float;",
            "",
            "varying vec2 vTextureCoord;",
            "uniform sampler2D uSampler;",
            "",
            "void main()",
            "{",
            "  vec4 color = texture2D(uSampler, vTextureCoord);",
            "  color.a = (color.r + color.g + color.b) / 3.0;",
            "",
            "  gl_FragColor = color;",
            "}",
        ];
        ShaderSources.guard = [
            "precision mediump float;",
            "",
            "uniform float frontier;",
            "uniform float trailDistance;",
            "uniform float seed;",
            "uniform float blockSize;",
            "uniform float blockWidth;",
            "uniform float lineAlpha;",
            "uniform float blockAlpha;",
            "",
            "",
            "float minX = frontier - trailDistance;",
            "float maxX = frontier + 20.0;",
            "float frontGradientStart = frontier + 17.0;",
            "float blockEnd = maxX;",
            "",
            "float hash(float n)",
            "{",
            "  return fract(sin(n) * 1e4);",
            "}",
            "float hash(vec2 p)",
            "{",
            "  return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x))));",
            "}",
            "",
            "float noise(vec2 x)",
            "{",
            "  vec2 i = floor(x);",
            "  vec2 f = fract(x);",
            "  float a = hash(i);",
            "  float b = hash(i + vec2(1.0, 0.0));",
            "  float c = hash(i + vec2(0.0, 1.0));",
            "  float d = hash(i + vec2(1.0, 1.0));",
            "  vec2 u = f * f * (3.0 - 2.0 * f);",
            "  return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;",
            "}",
            "",
            "",
            "vec4 makeLines(vec2 coord)",
            "{",
            "  float gradientAlpha = smoothstep(minX, frontier, coord.x);",
            "  gradientAlpha -= smoothstep(frontGradientStart, maxX, coord.x);",
            "  gradientAlpha += 0.5 * gradientAlpha;",
            "",
            "  float n = noise(vec2(seed, coord.y));",
            "  n = pow(n, 3.5);",
            "  float alpha = n * gradientAlpha;",
            "",
            "",
            "  float r = hash(vec2(seed, coord.y));",
            "  r = clamp(r, 0.8, 0.9) * alpha;",
            "  float g = (r + 0.7 - r) * alpha;",
            "  float b = smoothstep(0.0, 0.28, alpha);",
            "",
            "  return vec4(r, g, b, alpha);",
            "}",
            "",
            "vec4 makeBlocks(vec2 coord)",
            "{",
            "  vec4 lineColor = makeLines(vec2(frontier, coord.y));",
            "  float h = hash(vec2(seed, coord.y));",
            "  float blockWidth = blockWidth * (h / 2.0 + 0.5);",
            "",
            "  float blockStart = frontier - blockWidth;",
            "  float alpha = step(0.01, mod(smoothstep(blockStart, blockEnd, coord.x), 1.0));",
            "",
            "",
            "  return lineColor * alpha;",
            "}",
            "",
            "void main()",
            "{",
            "  vec4 lineColor = makeLines(gl_FragCoord.xy);",
            "",
            "  vec4 blockColor = vec4(0.0);",
            "",
            "  for (float i = 0.0; i < 10.0; i += 1.0)",
            "  {",
            "    float y = gl_FragCoord.y + hash(i) * blockSize * 20.0;",
            "    float blockY = floor(y / blockSize);",
            "    blockColor += makeBlocks(vec2(gl_FragCoord.x, blockY)) * 0.2;",
            "  }",
            "",
            "  gl_FragColor = lineColor * lineAlpha + blockColor * blockAlpha;",
            "}",
        ];
        ShaderSources.intersectingellipses = [
            "precision mediump float;",
            "",
            "#define DOMAIN 0 // 0 == pixi, 1 == shdr.bkcore.com",
            "",
            "#if DOMAIN == 0",
            "  varying vec2 vTextureCoord;",
            "  uniform sampler2D uSampler;",
            "",
            "  uniform vec4 mainColor;",
            "  uniform float mainAlpha;",
            "",
            "  uniform vec2 intersectingEllipseCenter;",
            "  uniform vec2 intersectingEllipseSize;",
            "  uniform float intersectingEllipseSharpness;",
            "",
            "  uniform vec2 mainEllipseSize;",
            "  uniform float mainEllipseSharpness;",
            "",
            "#elif DOMAIN == 1",
            "  uniform vec2 resolution;",
            "  uniform float time;",
            "",
            "  const vec4 mainColor = vec4(1.0, 1.0, 1.0, 1.0);",
            "  const float mainAlpha = 1.0;",
            "",
            "  const vec2 intersectingEllipseCenter = vec2(0.4, 0.0);",
            "  const vec2 intersectingEllipseSize = vec2(0.8, 1.0);",
            "  const float intersectingEllipseSharpness = 0.6;",
            "",
            "  const vec2 mainEllipseSize = vec2(0.5, 0.9);",
            "  const float mainEllipseSharpness = 0.8;",
            "",
            "#endif",
            "",
            "",
            "float ellipseGradient(vec2 p, vec2 ellipseCenter, vec2 ellipseSize)",
            "{",
            "  vec2 q = p - ellipseCenter;",
            "  q /= ellipseSize;",
            "",
            "  float dist = length(q);",
            "",
            "  return dist;",
            "}",
            "",
            "void main()",
            "{",
            "  #if DOMAIN == 0",
            "    vec2 uv = vTextureCoord;",
            "    vec4 color = texture2D(uSampler, vTextureCoord);",
            "  #elif DOMAIN == 1",
            "    vec2 uv = gl_FragCoord.xy / resolution;",
            "    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);",
            "  #endif",
            "",
            "  vec2 q = -1.0 + 2.0 * uv;",
            "",
            "  float mainDist = 1.0 - ellipseGradient(q, vec2(0.0, 0.0), mainEllipseSize);",
            "  float mainGradient = smoothstep(0.0, 1.0 - mainEllipseSharpness, mainDist);",
            "  color += mainColor * mainGradient;",
            "",
            "",
            "  float intersectingDist = ellipseGradient(q, intersectingEllipseCenter, intersectingEllipseSize);",
            "",
            "  float intersectingMask = step(intersectingEllipseSharpness, intersectingDist);",
            "  color *= intersectingMask;",
            "",
            "  float intersectingGradient = smoothstep(intersectingEllipseSharpness, 1.0, intersectingDist);",
            "  color *=  intersectingGradient;",
            "",
            "  gl_FragColor = color * mainAlpha;",
            "}",
        ];
        ShaderSources.lightburst = [
            "precision mediump float;",
            "",
            "",
            "#define PI 3.14159265359",
            "#define DOMAIN 0 // 0 == pixi, 1 == shdr.bkcore.com",
            "",
            "#if DOMAIN == 0",
            "  varying vec2 vTextureCoord;",
            "  uniform sampler2D uSampler;",
            "",
            "  uniform vec2 seed;",
            "  uniform float rotation;",
            "  uniform float rayStrength;",
            "  uniform float raySharpness;",
            "  uniform vec4 rayColor;",
            "  uniform float centerSize;",
            "  uniform float centerBloomStrength;",
            "",
            "#elif DOMAIN == 1",
            "  uniform vec2 resolution;",
            "  uniform float time;",
            "",
            "  const vec2 seed = vec2(3.3492333784616219, 0.38182701375708206);",
            "  const float rotation = 0.0;",
            "  const float rayStrength = 0.9;",
            "  const float raySharpness = 2.0;",
            "  const vec4 rayColor = vec4(1.0, 0.4, 0.4, 1.0);",
            "  const float centerSize = 1.0;",
            "  const float centerBloomStrength = 5.0;",
            "#endif",
            "",
            "//--------------------------------------------------------------------",
            "",
            "// https://www.shadertoy.com/view/4dlGW2",
            "// Tileable noise, for creating useful textures. By David Hoskins, Sept. 2013.",
            "// It can be extrapolated to other types of randomised texture.",
            "",
            "// TODO license?",
            "// https://www.shadertoy.com/terms says default license is CC BY-NC-SA 3.0 which should be fine",
            "",
            "float hash(in vec2 p, in float scale)",
            "{",
            "  // This is tiling part, adjusts with the scale...",
            "  p = mod(p, scale);",
            "  return fract(sin(dot(p, seed)) * 5151.5473453);",
            "}",
            "",
            "float noise(in vec2 p, in float scale )",
            "{",
            "  vec2 f;",
            "",
            "  p *= scale;",
            "",
            "",
            "  f = fract(p);   // Separate integer from fractional",
            "    p = floor(p);",
            "",
            "    f = f*f*(3.0-2.0*f);  // Cosine interpolation approximation",
            "",
            "    float res = mix(mix(hash(p,          scale),",
            "            hash(p + vec2(1.0, 0.0), scale), f.x),",
            "          mix(hash(p + vec2(0.0, 1.0), scale),",
            "            hash(p + vec2(1.0, 1.0), scale), f.x), f.y);",
            "    return res;",
            "}",
            "",
            "float fbm(in vec2 p)",
            "{",
            "  float f = 0.0;",
            "  // Change starting scale to any integer value...",
            "  float scale = 20.0;",
            "  float amp   = 0.5;",
            "",
            "  for (int i = 0; i < 5; i++)",
            "  {",
            "    f += noise(p, scale) * amp;",
            "    amp *= .65;",
            "    // Scale must be multiplied by an integer value...",
            "    scale *= 2.0;",
            "  }",
            "  // Clamp it just in case....",
            "  return min(f, 1.0);",
            "}",
            "",
            "//--------------------------------------------------------------------",
            "",
            "float ray(vec2 q, float angleAdjust)",
            "{",
            "  float angle = (atan(q.y, q.x) + PI + angleAdjust) / (2.0 * PI);",
            "  return fbm(vec2(angle, seed.y));",
            "}",
            "",
            "void main()",
            "{",
            "  #if DOMAIN == 0",
            "    vec2 uv = vTextureCoord;",
            "    vec4 color = texture2D(uSampler, vTextureCoord);",
            "  #elif DOMAIN == 1",
            "    vec2 uv = gl_FragCoord.xy / resolution;",
            "    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);",
            "  #endif",
            "",
            "  vec2 q = uv - 0.5;",
            "  q *= 1.8;",
            "",
            "  float dist = length(q);",
            "",
            "  float centerIntensity = pow(1.0 - dist, 8.0);",
            "  centerIntensity = smoothstep(1.0 - centerSize, 1.0, centerIntensity);",
            "",
            "  float rayIntensity = ray(q, rotation);",
            "  rayIntensity = smoothstep(0.4, 1.0, rayIntensity) * rayStrength;",
            "  rayIntensity -= dist;",
            "  rayIntensity *= max(1.0, raySharpness + 1.0 - dist);",
            "  rayIntensity += centerIntensity * centerBloomStrength;",
            "  rayIntensity = max(0.0, rayIntensity);",
            "  color += rayColor * rayIntensity;",
            "",
            "  gl_FragColor = color;",
            "}",
        ];
        ShaderSources.nebula = [
            "precision mediump float;",
            "",
            "uniform vec3 baseColor;",
            "uniform vec3 overlayColor;",
            "uniform vec3 highlightColor;",
            "",
            "uniform float coverage;",
            "",
            "uniform float scale;",
            "",
            "uniform float diffusion;",
            "uniform float streakiness;",
            "",
            "uniform float streakLightness;",
            "uniform float cloudLightness;",
            "",
            "uniform float highlightA;",
            "uniform float highlightB;",
            "",
            "uniform vec2 seed;",
            "",
            "/*",
            "const vec3 baseColor = vec3(1.0, 0.0, 0.0);",
            "const vec3 overlayColor = vec3(0.0, 0.0, 1.0);",
            "const vec3 highlightColor = vec3(1.0, 1.0, 1.0);",
            "",
            "const float coverage = 0.3;",
            "const float coverage2 = coverage / 2.0;",
            "",
            "const float scale = 4.0;",
            "",
            "const float diffusion = 3.0;",
            "const float streakiness = 2.0;",
            "",
            "const float streakLightness = 1.0;",
            "const float cloudLightness = 1.0;",
            "",
            "const float highlightA = 0.9;",
            "const float highlightB = 2.2;",
            "",
            "const vec2 seed = vec2(69.0, 42.0);",
            "*/",
            "",
            "const int sharpness = 6;",
            "",
            "float hash(vec2 p)",
            "{",
            "  return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x))));",
            "}",
            "",
            "float noise(vec2 x)",
            "{",
            "  vec2 i = floor(x);",
            "  vec2 f = fract(x);",
            "  float a = hash(i);",
            "  float b = hash(i + vec2(1.0, 0.0));",
            "  float c = hash(i + vec2(0.0, 1.0));",
            "  float d = hash(i + vec2(1.0, 1.0));",
            "  vec2 u = f * f * (3.0 - 2.0 * f);",
            "  return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;",
            "}",
            "",
            "float fbm(vec2 x)",
            "{",
            "  float v = 0.0;",
            "  float a = 0.5;",
            "  vec2 shift = vec2(100);",
            "  mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));",
            "  for (int i = 0; i < sharpness; ++i)",
            "  {",
            "    v += a * noise(x);",
            "    x = rot * x * 2.0 + shift;",
            "    a *= 0.5;",
            "    }",
            "  return v;",
            "}",
            "",
            "float relativeValue(float v, float min, float max)",
            "{",
            "  return (v - min) / (max - min);",
            "}",
            "",
            "float displace(vec2 pos, out vec2 q)",
            "{",
            "  q = vec2(fbm(pos),",
            "    fbm(pos + vec2(23.3, 46.7)));",
            "  return fbm(pos + vec2(q.x * streakiness, q.y));",
            "}",
            "",
            "vec3 colorLayer(vec2 pos, vec3 color)",
            "{",
            "  float v = fbm(pos);",
            "  return mix(vec3(0.0), color, v);",
            "}",
            "",
            "vec3 nebula(vec2 pos, out float volume)",
            "{",
            "  vec2 on = vec2(0.0);",
            "",
            "  volume = displace(pos, on);",
            "  volume = relativeValue(volume, coverage, streakLightness);",
            "  volume += relativeValue(fbm(pos), coverage, cloudLightness);",
            "  volume = pow(volume, diffusion);",
            "",
            "  vec3 c = colorLayer(pos + vec2(42.0, 6.9), baseColor);",
            "  c = mix(c, overlayColor, dot(on.x, on.y));",
            "  c = mix(c, highlightColor, volume *",
            "    smoothstep(highlightA, highlightB, abs(on.x)+abs(on.y)) );",
            "",
            "",
            "  return c * volume;",
            "}",
            "",
            "float star(vec2 pos, float volume)",
            "{",
            "  float genValue = hash(pos);",
            "",
            "  genValue -= volume * 0.01;",
            "",
            "  float color = 0.0;",
            "",
            "  if (genValue < 0.001)",
            "  {",
            "    float r = hash(pos + vec2(4.20, 6.9));",
            "    color = r;",
            "    return color;",
            "  }",
            "  else",
            "  {",
            "    return color;",
            "  }",
            "}",
            "",
            "void main(void)",
            "{",
            "  vec2 pos = gl_FragCoord.xy / 50.0 / scale;",
            "  pos += seed;",
            "  float volume = 0.0;",
            "  vec3 c = nebula(pos, volume);",
            "  c += vec3(star(pos, volume));",
            "",
            "  gl_FragColor = vec4(c, 1.0);",
            "}",
        ];
        ShaderSources.occupation = [
            "precision mediump float;",
            "",
            "uniform vec4 baseColor;",
            "uniform vec4 lineColor;",
            "uniform float gapSize;",
            "uniform vec2 offset;",
            "uniform float zoom;",
            "",
            "void main( void )",
            "{",
            "  vec2 position = gl_FragCoord.xy + offset;",
            "  position.x += position.y;",
            "  float scaled = floor(position.x * 0.1 / zoom);",
            "  float res = mod(scaled, gapSize);",
            "  if(res > 0.0)",
            "  {",
            "    gl_FragColor = mix(gl_FragColor, baseColor, 0.5);",
            "  }",
            "  else",
            "  {",
            "    gl_FragColor = mix(gl_FragColor, lineColor, 0.5);",
            "  }",
            "}",
        ];
        ShaderSources.shinyparticle = [
            "precision mediump float;",
            "",
            "#define DOMAIN 0 // 0 == pixi, 1 == shdr.bkcore.com",
            "",
            "#if DOMAIN == 0",
            "  varying vec2 vTextureCoord;",
            "  uniform sampler2D uSampler;",
            "",
            "  uniform float spikeIntensity;",
            "  uniform float highlightIntensity;",
            "  uniform vec4 spikeColor;",
            "#elif DOMAIN == 1",
            "  uniform vec2 resolution;",
            "",
            "  const float spikeIntensity = 1.0;",
            "  const float highlightIntensity = 0.1;",
            "  const vec4 spikeColor = vec4(0.3686274509803922, 0.792156862745098, 0.6941176470588235, 1.0);",
            "#endif",
            "",
            "",
            "const vec4 highlightColor = vec4(1.0, 1.0, 1.0, 1.0);",
            "const vec2 center = vec2(0.5, 0.5);",
            "const float angle = -0.1 * 3.141592;",
            "",
            "float spike(vec2 q)",
            "{",
            "  vec2 rotated;",
            "  rotated.x = cos(angle) * q.x - sin(angle) * q.y;",
            "  rotated.y = sin(angle) * q.x + cos(angle) * q.y;",
            "",
            "  float xStrength = max(0.5 - abs(rotated.x), 0.0);",
            "  float yStrength = max(0.5 - abs(rotated.y), 0.0);",
            "",
            "  return xStrength + yStrength;",
            "}",
            "",
            "void main()",
            "{",
            "  #if DOMAIN == 0",
            "    vec2 uv = vTextureCoord;",
            "    vec4 color = texture2D(uSampler, uv);",
            "  #elif DOMAIN == 1",
            "    vec2 uv = gl_FragCoord.xy / resolution;",
            "    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);",
            "  #endif",
            "",
            "  vec2 q = uv - 0.5;",
            "  // q *= 2.5;",
            "",
            "  float dist = length(q);",
            "",
            "  float spikeStrength = spike(q);",
            "  spikeStrength -= dist;",
            "  spikeStrength = pow(spikeStrength, 1.5);",
            "  spikeStrength *= spikeIntensity;",
            "",
            "  color += spikeColor * spikeStrength;",
            "",
            "",
            "  // center highlight",
            "  float highlightStrength = 1.0 - dist;",
            "  highlightStrength = pow(highlightStrength, 8.0);",
            "  highlightStrength *= highlightIntensity;",
            "",
            "  color += highlightColor * highlightStrength;",
            "",
            "",
            "  gl_FragColor = color;",
            "}",
        ];
    })(ShaderSources = Rance.ShaderSources || (Rance.ShaderSources = {}));
})(Rance || (Rance = {}));
/// <reference path="uniformmanager.ts"/>
/// <reference path="shaders/converted/shadersources.ts"/>
var Rance;
(function (Rance) {
    var NebulaFilter = (function (_super) {
        __extends(NebulaFilter, _super);
        function NebulaFilter(uniforms) {
            _super.call(this, null, Rance.ShaderSources.nebula.join("\n"), uniforms);
        }
        return NebulaFilter;
    }(PIXI.AbstractFilter));
    Rance.NebulaFilter = NebulaFilter;
    var OccupationFilter = (function (_super) {
        __extends(OccupationFilter, _super);
        function OccupationFilter(uniforms) {
            _super.call(this, null, Rance.ShaderSources.occupation.join("\n"), uniforms);
        }
        return OccupationFilter;
    }(PIXI.AbstractFilter));
    Rance.OccupationFilter = OccupationFilter;
    var GuardFilter = (function (_super) {
        __extends(GuardFilter, _super);
        function GuardFilter(uniforms) {
            _super.call(this, null, Rance.ShaderSources.guard.join("\n"), uniforms);
        }
        return GuardFilter;
    }(PIXI.AbstractFilter));
    Rance.GuardFilter = GuardFilter;
    var ShaderManager = (function () {
        function ShaderManager() {
            this.shaders = {};
            this.uniformManager = new Rance.UniformManager();
            this.initNebula();
        }
        ShaderManager.prototype.initNebula = function () {
            var nebulaColorScheme = Rance.generateColorScheme();
            var lightness = Rance.randRange(1.1, 1.3);
            var nebulaUniforms = {
                baseColor: { type: "3fv", value: Rance.hex2rgb(nebulaColorScheme.main) },
                overlayColor: { type: "3fv", value: Rance.hex2rgb(nebulaColorScheme.secondary) },
                highlightColor: { type: "3fv", value: [1.0, 1.0, 1.0] },
                coverage: { type: "1f", value: Rance.randRange(0.28, 0.32) },
                scale: { type: "1f", value: Rance.randRange(4, 8) },
                diffusion: { type: "1f", value: Rance.randRange(1.5, 3.0) },
                streakiness: { type: "1f", value: Rance.randRange(1.5, 2.5) },
                streakLightness: { type: "1f", value: lightness },
                cloudLightness: { type: "1f", value: lightness },
                highlightA: { type: "1f", value: 0.9 },
                highlightB: { type: "1f", value: 2.2 },
                seed: { type: "2fv", value: [Math.random() * 100, Math.random() * 100] }
            };
            this.shaders["nebula"] = new NebulaFilter(nebulaUniforms);
        };
        return ShaderManager;
    }());
    Rance.ShaderManager = ShaderManager;
})(Rance || (Rance = {}));
/// <reference path="../lib/pixi.d.ts" />
/// <reference path="eventmanager.ts"/>
/// <reference path="fleet.ts" />
/// <reference path="star.ts" />
var Rance;
(function (Rance) {
    var PathfindingArrow = (function () {
        function PathfindingArrow(parentContainer) {
            this.selectedFleets = [];
            this.labelCache = {};
            this.listeners = {};
            this.curveStyles = {
                reachable: {
                    color: 0xFFFFF0
                },
                unreachable: {
                    color: 0xFF0000
                }
            };
            this.parentContainer = parentContainer;
            this.container = new PIXI.Container();
            this.parentContainer.addChild(this.container);
            this.addEventListeners();
        }
        PathfindingArrow.prototype.destroy = function () {
            this.active = false;
            this.removeEventListeners();
            this.parentContainer = null;
            this.container = null;
            this.currentTarget = null;
            window.clearTimeout(this.clearTargetTimeout);
            this.selectedFleets = null;
            this.labelCache = null;
        };
        PathfindingArrow.prototype.removeEventListener = function (name) {
            Rance.eventManager.removeEventListener(name, this.listeners[name]);
        };
        PathfindingArrow.prototype.removeEventListeners = function () {
            for (var name in this.listeners) {
                this.removeEventListener(name);
            }
        };
        PathfindingArrow.prototype.addEventListener = function (name, handler) {
            this.listeners[name] = handler;
            Rance.eventManager.addEventListener(name, handler);
        };
        PathfindingArrow.prototype.addEventListeners = function () {
            var self = this;
            this.addEventListener("startPotentialMove", function (star) {
                self.startMove();
                if (star) {
                    self.setTarget(star);
                }
            });
            this.addEventListener("setPotentialMoveTarget", function (star) {
                self.setTarget(star);
            });
            this.addEventListener("clearPotentialMoveTarget", function () {
                self.clearTarget();
            });
            this.addEventListener("endPotentialMove", function () {
                self.endMove();
            });
        };
        PathfindingArrow.prototype.startMove = function () {
            var fleets = app.playerControl.selectedFleets;
            if (this.active || !fleets || fleets.length < 1) {
                return;
            }
            this.active = true;
            this.currentTarget = null;
            this.selectedFleets = fleets;
            this.clearArrows();
        };
        PathfindingArrow.prototype.setTarget = function (star) {
            if (!this.active) {
                return;
            }
            if (this.clearTargetTimeout) {
                window.clearTimeout(this.clearTargetTimeout);
            }
            this.currentTarget = star;
            window.setTimeout(this.drawAllCurrentCurves.bind(this), 10);
            //this.drawAllCurrentCurves();
        };
        PathfindingArrow.prototype.clearTarget = function () {
            if (!this.active) {
                return;
            }
            var self = this;
            if (this.clearTargetTimeout) {
                window.clearTimeout(this.clearTargetTimeout);
            }
            this.clearTargetTimeout = window.setTimeout(function () {
                self.currentTarget = null;
                self.clearArrows();
                self.clearTargetTimeout = null;
            }, 10);
        };
        PathfindingArrow.prototype.endMove = function () {
            this.active = false;
            this.currentTarget = null;
            this.selectedFleets = [];
            this.clearArrows();
        };
        PathfindingArrow.prototype.clearArrows = function () {
            this.container.removeChildren();
        };
        PathfindingArrow.prototype.makeLabel = function (style, distance) {
            var textStyle;
            switch (style) {
                case "reachable":
                    {
                        textStyle =
                            {
                                fill: 0xFFFFF0
                            };
                        break;
                    }
                case "unreachable":
                    {
                        textStyle =
                            {
                                fill: 0xFF0000
                            };
                        break;
                    }
            }
            if (!this.labelCache[style]) {
                this.labelCache[style] = {};
            }
            this.labelCache[style][distance] = new PIXI.Text("" + distance, textStyle);
        };
        PathfindingArrow.prototype.getLabel = function (style, distance) {
            if (!this.labelCache[style] || !this.labelCache[style][distance]) {
                this.makeLabel(style, distance);
            }
            return this.labelCache[style][distance];
        };
        PathfindingArrow.prototype.getAllCurrentPaths = function () {
            var paths = [];
            for (var i = 0; i < this.selectedFleets.length; i++) {
                var fleet = this.selectedFleets[i];
                if (fleet.location.id === this.currentTarget.id)
                    continue;
                var path = fleet.getPathTo(this.currentTarget);
                paths.push({
                    fleet: fleet,
                    path: path
                });
            }
            return paths;
        };
        PathfindingArrow.prototype.getAllCurrentCurves = function () {
            var paths = this.getAllCurrentPaths();
            var curves = [];
            var totalPathsPerStar = {};
            var alreadyVisitedPathsPerStar = {};
            // get total paths passing through star
            // used for seperating overlapping paths to pass through
            // orbits around the star
            for (var i = 0; i < paths.length; i++) {
                for (var j = 0; j < paths[i].path.length; j++) {
                    var star = paths[i].path[j].star;
                    if (!totalPathsPerStar[star.id]) {
                        totalPathsPerStar[star.id] = 0;
                        alreadyVisitedPathsPerStar[star.id] = 0;
                    }
                    totalPathsPerStar[star.id]++;
                }
            }
            for (var i = 0; i < paths.length; i++) {
                var fleet = paths[i].fleet;
                var path = paths[i].path;
                var distance = path.length - 1;
                var currentMovePoints = fleet.getMinCurrentMovePoints();
                var canReach = currentMovePoints >= distance;
                var style = canReach ? "reachable" : "unreachable";
                var curvePoints = [];
                for (var j = path.length - 1; j >= 0; j--) {
                    var star = path[j].star;
                    var sourceStar = j < path.length - 1 ? path[j + 1].star : null;
                    if (totalPathsPerStar[star.id] > 1 && star !== this.currentTarget) {
                        var visits = ++alreadyVisitedPathsPerStar[star.id];
                        curvePoints.unshift(this.getTargetOffset(star, sourceStar, visits, totalPathsPerStar[star.id], 12));
                    }
                    else {
                        curvePoints.unshift(star);
                    }
                }
                var curveData = this.getCurveData(curvePoints);
                curves.push({
                    style: style,
                    curveData: curveData
                });
            }
            return curves;
        };
        PathfindingArrow.prototype.drawAllCurrentCurves = function () {
            this.clearArrows();
            var curves = this.getAllCurrentCurves();
            for (var i = 0; i < curves.length; i++) {
                var curve = this.drawCurve(curves[i].curveData, this.curveStyles[curves[i].style]);
                this.container.addChild(curve);
            }
        };
        PathfindingArrow.prototype.getCurveData = function (points) {
            var i6 = 1.0 / 6.0;
            var path = [];
            var abababa = [points[0]].concat(points);
            abababa.push(points[points.length - 1]);
            for (var i = 3, n = abababa.length; i < n; i++) {
                var p0 = abababa[i - 3];
                var p1 = abababa[i - 2];
                var p2 = abababa[i - 1];
                var p3 = abababa[i];
                path.push([
                    p2.x * i6 + p1.x - p0.x * i6,
                    p2.y * i6 + p1.y - p0.y * i6,
                    p3.x * -i6 + p2.x + p1.x * i6,
                    p3.y * -i6 + p2.y + p1.y * i6,
                    p2.x,
                    p2.y
                ]);
            }
            path[0][0] = points[0].x;
            path[0][1] = points[0].y;
            return path;
        };
        PathfindingArrow.prototype.drawCurve = function (points, style) {
            var gfx = new PIXI.Graphics();
            gfx.lineStyle(12, style.color, 0.7);
            gfx.moveTo(points[0][0], points[0][1]);
            for (var i = 0; i < points.length; i++) {
                gfx.bezierCurveTo.apply(gfx, points[i]);
            }
            var curveShape = gfx.currentPath.shape;
            curveShape.closed = false; // PIXI 3.0.7 bug
            this.drawArrowHead(gfx, style.color);
            return gfx;
        };
        PathfindingArrow.prototype.drawArrowHead = function (gfx, color) {
            var curveShape = gfx.graphicsData[0].shape;
            var points = curveShape.points;
            var x1 = points[points.length - 12];
            var y1 = points[points.length - 11];
            var x2 = points[points.length - 2];
            var y2 = points[points.length - 1];
            var lineAngle = Math.atan2(y2 - y1, x2 - x1);
            var headLength = 30;
            var buttAngle = 27 * (Math.PI / 180);
            var hypotenuseLength = Math.abs(headLength / Math.cos(buttAngle));
            var angle1 = lineAngle + Math.PI + buttAngle;
            var topX = x2 + Math.cos(angle1) * hypotenuseLength;
            var topY = y2 + Math.sin(angle1) * hypotenuseLength;
            var angle2 = lineAngle + Math.PI - buttAngle;
            var botX = x2 + Math.cos(angle2) * hypotenuseLength;
            var botY = y2 + Math.sin(angle2) * hypotenuseLength;
            gfx.lineStyle(null);
            gfx.moveTo(x2, y2);
            gfx.beginFill(color, 0.7);
            gfx.lineTo(topX, topY);
            gfx.lineTo(botX, botY);
            gfx.lineTo(x2, y2);
            gfx.endFill();
            var buttMidX = x2 + Math.cos(lineAngle + Math.PI) * headLength;
            var buttMidY = y2 + Math.sin(lineAngle + Math.PI) * headLength;
            for (var i = points.length - 1; i >= 0; i -= 2) {
                var y = points[i];
                var x = points[i - 1];
                var distance = Math.sqrt(Math.pow(x2 - x, 2) + Math.pow(y2 - y, 2));
                if (distance >= headLength + 10) {
                    points.push(buttMidX);
                    points.push(buttMidY);
                    break;
                }
                else {
                    points.pop();
                    points.pop();
                }
            }
        };
        PathfindingArrow.prototype.getTargetOffset = function (target, sourcePoint, i, totalPaths, offsetPerOrbit) {
            var maxPerOrbit = 6;
            var currentOrbit = Math.ceil(i / maxPerOrbit);
            var isOuterOrbit = currentOrbit > Math.floor(totalPaths / maxPerOrbit);
            var pathsInCurrentOrbit = isOuterOrbit ? totalPaths % maxPerOrbit : maxPerOrbit;
            var positionInOrbit = (i - 1) % pathsInCurrentOrbit;
            var distance = currentOrbit * offsetPerOrbit;
            var angle = (Math.PI * 2 / pathsInCurrentOrbit) * positionInOrbit;
            if (sourcePoint) {
                var dx = sourcePoint.x - target.x;
                var dy = sourcePoint.y - target.y;
                var approachAngle = Math.atan2(dy, dx);
                angle += approachAngle;
            }
            var x = Math.sin(angle) * distance;
            var y = Math.cos(angle) * distance;
            return ({
                x: target.x + x,
                y: target.y - y
            });
        };
        return PathfindingArrow;
    }());
    Rance.PathfindingArrow = PathfindingArrow;
})(Rance || (Rance = {}));
/// <reference path="../lib/pixi.d.ts" />
/// <reference path="camera.ts"/>
/// <reference path="mouseeventhandler.ts"/>
/// <reference path="shadermanager.ts"/>
/// <reference path="pathfindingarrow.ts"/>
var Rance;
(function (Rance) {
    var Renderer = (function () {
        function Renderer(galaxyMap) {
            this.layers = {};
            this.activeRenderLoopId = 0;
            this.isPaused = false;
            this.forceFrame = false;
            this.backgroundIsDirty = true;
            this.isBattleBackground = false;
            PIXI.SCALE_MODES.DEFAULT = PIXI.SCALE_MODES.NEAREST;
            this.stage = new PIXI.Container();
            this.galaxyMap = galaxyMap;
            this.resizeListener = this.resize.bind(this);
            window.addEventListener("resize", this.resizeListener, false);
        }
        Renderer.prototype.init = function () {
            this.shaderManager = new Rance.ShaderManager();
            this.initLayers();
            this.addEventListeners();
            this.activeRenderLoopId++;
            this.stage.renderable = true;
        };
        Renderer.prototype.destroy = function () {
            this.stage.renderable = false;
            this.pause();
            if (this.pathfindingArrow) {
                this.pathfindingArrow.destroy();
                this.pathfindingArrow = null;
            }
            if (this.mouseEventHandler) {
                this.mouseEventHandler.destroy();
                this.mouseEventHandler = null;
            }
            if (this.camera) {
                this.camera.destroy();
                this.camera = null;
            }
            this.shaderManager = null;
            this.galaxyMap = null;
            if (this.renderer) {
                this.renderer.destroy(true);
                this.renderer = null;
            }
            this.stage.destroy(true);
            this.stage = null;
            this.pixiContainer = null;
            window.removeEventListener("resize", this.resizeListener);
        };
        Renderer.prototype.removeRendererView = function () {
            if (this.renderer && this.renderer.view.parentNode) {
                this.renderer.view.parentNode.removeChild(this.renderer.view);
            }
        };
        Renderer.prototype.bindRendererView = function (container) {
            this.pixiContainer = container;
            if (!this.renderer) {
                var containerStyle = window.getComputedStyle(this.pixiContainer);
                this.renderer = PIXI.autoDetectRenderer(parseInt(containerStyle.width), parseInt(containerStyle.height), {
                    autoResize: false,
                    antialias: true
                });
            }
            this.pixiContainer.appendChild(this.renderer.view);
            this.renderer.view.setAttribute("id", "pixi-canvas");
            this.resize();
            if (!this.isBattleBackground) {
                this.setupDefaultLayers();
                this.addCamera();
            }
            else {
                this.setupBackgroundLayers();
            }
        };
        Renderer.prototype.initLayers = function () {
            var _bgSprite = this.layers["bgSprite"] = new PIXI.Container();
            _bgSprite.interactiveChildren = false;
            var _main = this.layers["main"] = new PIXI.Container();
            var _map = this.layers["map"] = new PIXI.Container();
            var _bgFilter = this.layers["bgFilter"] = new PIXI.Container();
            _bgFilter.interactiveChildren = false;
            var _select = this.layers["select"] = new PIXI.Container();
            _select.interactiveChildren = false;
            _main.addChild(_map);
            _main.addChild(_select);
        };
        Renderer.prototype.setupDefaultLayers = function () {
            this.stage.removeChildren();
            this.stage.addChild(this.layers["bgSprite"]);
            this.stage.addChild(this.layers["main"]);
            this.renderOnce();
        };
        Renderer.prototype.setupBackgroundLayers = function () {
            this.stage.removeChildren();
            this.stage.addChild(this.layers["bgSprite"]);
            this.renderOnce();
        };
        Renderer.prototype.addCamera = function () {
            var oldToCenterOn;
            if (this.mouseEventHandler)
                this.mouseEventHandler.destroy();
            if (this.camera) {
                oldToCenterOn = this.camera.toCenterOn;
                this.camera.destroy();
            }
            this.camera = new Rance.Camera(this.layers["main"], 0.5);
            this.camera.toCenterOn = this.toCenterOn || oldToCenterOn;
            this.toCenterOn = null;
            this.mouseEventHandler = new Rance.MouseEventHandler(this, this.camera);
            this.pathfindingArrow = new Rance.PathfindingArrow(this.layers["select"]);
        };
        Renderer.prototype.addEventListeners = function () {
            var self = this;
            var main = this.stage;
            main.interactive = true;
            main.hitArea = new PIXI.Rectangle(-10000, -10000, 20000, 20000);
            var mainMouseDownFN = function (event) {
                if (event.target !== main)
                    return;
                self.mouseEventHandler.mouseDown(event);
            };
            var mainMouseMoveFN = function (event) {
                if (event.target !== main)
                    return;
                self.mouseEventHandler.mouseMove(event);
            };
            var mainMouseUpFN = function (event) {
                if (event.target !== main)
                    return;
                self.mouseEventHandler.mouseUp(event);
            };
            var mainMouseUpOutsideFN = function (event) {
                if (event.target !== main)
                    return;
                self.mouseEventHandler.mouseUp(event);
            };
            var mainListeners = {
                mousedown: mainMouseDownFN,
                rightdown: mainMouseDownFN,
                touchstart: mainMouseDownFN,
                mousemove: mainMouseMoveFN,
                touchmove: mainMouseMoveFN,
                mouseup: mainMouseUpFN,
                rightup: mainMouseUpFN,
                touchend: mainMouseUpFN,
                mouseupoutside: mainMouseUpOutsideFN,
                rightupoutside: mainMouseUpOutsideFN,
                touchendoutside: mainMouseUpOutsideFN,
            };
            for (var eventType in mainListeners) {
                main.on(eventType, mainListeners[eventType]);
            }
        };
        Renderer.prototype.resize = function () {
            if (this.renderer && document.body.contains(this.renderer.view)) {
                var w = this.pixiContainer.offsetWidth * window.devicePixelRatio;
                var h = this.pixiContainer.offsetHeight * window.devicePixelRatio;
                this.renderer.resize(w, h);
                this.layers["bgFilter"].filterArea = new PIXI.Rectangle(0, 0, w, h);
                this.backgroundIsDirty = true;
                if (this.isPaused) {
                    this.renderOnce();
                }
            }
        };
        Renderer.prototype.renderBackground = function () {
            var bgObject;
            if (this.isBattleBackground) {
                bgObject = this.renderBlurredBackground.apply(this, this.blurProps);
            }
            else {
                bgObject = app.moduleData.mapBackgroundDrawingFunction(this.galaxyMap.seed, this.renderer);
            }
            this.layers["bgSprite"].removeChildren();
            this.layers["bgSprite"].addChild(bgObject);
            this.backgroundIsDirty = false;
        };
        Renderer.prototype.renderBlurredBackground = function (x, y, width, height, seed) {
            var bg = app.moduleData.starBackgroundDrawingFunction(seed, this.renderer);
            var fg = app.moduleData.starBackgroundDrawingFunction(seed, this.renderer);
            var container = new PIXI.Container();
            container.addChild(bg);
            container.addChild(fg);
            var blurFilter = new PIXI.filters.BlurFilter();
            blurFilter.blur = 1;
            fg.filters = [blurFilter];
            fg.filterArea = new PIXI.Rectangle(x, y, width, height);
            var texture = container.generateTexture(this.renderer); //, PIXI.SCALE_MODES.DEFAULT, 1, bg.getLocalBounds());
            var sprite = new PIXI.Sprite(texture);
            return sprite;
        };
        Renderer.prototype.renderOnce = function () {
            this.forceFrame = true;
            this.render();
        };
        Renderer.prototype.pause = function () {
            this.isPaused = true;
            this.forceFrame = false;
        };
        Renderer.prototype.resume = function () {
            this.isPaused = false;
            this.forceFrame = false;
            this.activeRenderLoopId = this.activeRenderLoopId++;
            this.render(this.activeRenderLoopId);
        };
        Renderer.prototype.render = function (renderLoopId) {
            if (!document.body.contains(this.pixiContainer)) {
                this.pause();
                return;
            }
            if (this.isPaused) {
                if (this.forceFrame) {
                    this.forceFrame = false;
                }
                else {
                    return;
                }
            }
            if (this.backgroundIsDirty) {
                this.renderBackground();
            }
            this.shaderManager.uniformManager.updateTime();
            this.renderer.render(this.stage);
            if (this.activeRenderLoopId === renderLoopId) {
                window.requestAnimationFrame(this.render.bind(this, renderLoopId));
            }
        };
        return Renderer;
    }());
    Rance.Renderer = Renderer;
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    Rance.defaultRuleSet = {
        manufactory: {
            startingCapacity: 1,
            maxCapacity: 3,
            buildCost: 1000
        },
        research: {
            baseResearchSpeed: 3000
        },
        battle: {
            rowsPerFormation: 2,
            cellsPerRow: 3,
            maxUnitsPerSide: 6,
            maxUnitsPerRow: 3,
            baseMaxCapturedUnits: 1,
            absoluteMaxCapturedUnits: 3,
            baseUnitCaptureChance: 0.1,
            humanUnitDeathChance: 0.65,
            aiUnitDeathChance: 0.65,
            independentUnitDeathChance: 1.0,
            loserUnitExtraDeathChance: 0.35
        }
    };
})(Rance || (Rance = {}));
/// <reference path="ruleset.ts" />
var Rance;
(function (Rance) {
    var ModuleData = (function () {
        function ModuleData() {
            this.subModuleMetaData = [];
            this.mapRendererLayers = {};
            this.mapRendererMapModes = {};
            this.Templates = {
                Abilities: {},
                AttitudeModifiers: {},
                BattleSFX: {},
                Buildings: {},
                Cultures: {},
                Effects: {},
                Items: {},
                MapGen: {},
                MapRendererLayers: {},
                MapRendererMapModes: {},
                Notifications: {},
                Objectives: {},
                PassiveSkills: {},
                Personalities: {},
                Resources: {},
                StatusEffects: {},
                SubEmblems: {},
                Technologies: {},
                UnitArchetypes: {},
                UnitFamilies: {},
                Units: {}
            };
            this.ruleSet = Rance.extendObject(Rance.defaultRuleSet);
        }
        ModuleData.prototype.copyTemplates = function (source, category) {
            if (!this.Templates[category]) {
                console.warn("Tried to copy templates in invalid category \"" + category +
                    "\". Category must be one of: " + Object.keys(this.Templates).join(", "));
                return;
            }
            for (var templateType in source) {
                if (this.Templates[category][templateType]) {
                    console.warn("Duplicate template identifier for " + templateType + " in " + category);
                    continue;
                }
                this.Templates[category][templateType] = source[templateType];
            }
        };
        ModuleData.prototype.copyAllTemplates = function (source) {
            for (var category in this.Templates) {
                if (source[category]) {
                    this.copyTemplates(source[category], category);
                }
            }
        };
        ModuleData.prototype.addSubModule = function (moduleFile) {
            this.subModuleMetaData.push(moduleFile.metaData);
        };
        ModuleData.prototype.getDefaultMap = function () {
            if (this.defaultMap)
                return this.defaultMap;
            else if (Object.keys(this.Templates.MapGen).length > 0) {
                return Rance.getRandomProperty(this.Templates.MapGen);
            }
            else
                throw new Error("Module has no maps registered");
        };
        return ModuleData;
    }());
    Rance.ModuleData = ModuleData;
})(Rance || (Rance = {}));
/// <reference path="moduledata.ts" />
var Rance;
(function (Rance) {
    var ModuleLoader = (function () {
        function ModuleLoader() {
            this.moduleFiles = {};
            this.hasLoaded = {};
            this.moduleLoadStart = {};
            this.moduleData = new Rance.ModuleData();
        }
        ModuleLoader.prototype.addModuleFile = function (moduleFile) {
            if (this.moduleFiles[moduleFile.key]) {
                throw new Error("Duplicate module key " + moduleFile.key);
            }
            this.moduleFiles[moduleFile.key] = moduleFile;
            this.hasLoaded[moduleFile.key] = false;
        };
        ModuleLoader.prototype.loadModuleFile = function (moduleFile, afterLoaded) {
            if (!this.moduleFiles[moduleFile.key]) {
                this.addModuleFile(moduleFile);
            }
            this.moduleLoadStart[moduleFile.key] = Date.now();
            moduleFile.loadAssets(this.finishLoadingModuleFile.bind(this, moduleFile, afterLoaded));
            if (moduleFile.ruleSet) {
                this.copyRuleSet(moduleFile.ruleSet);
            }
        };
        ModuleLoader.prototype.loadAll = function (afterLoaded) {
            var boundCheckAll = function () {
                if (this.hasFinishedLoading()) {
                    afterLoaded();
                }
            }.bind(this);
            for (var index in this.moduleFiles) {
                this.loadModuleFile(this.moduleFiles[index], boundCheckAll);
            }
        };
        ModuleLoader.prototype.hasFinishedLoading = function () {
            for (var index in this.hasLoaded) {
                if (!this.hasLoaded[index]) {
                    return false;
                }
            }
            return true;
        };
        ModuleLoader.prototype.finishLoadingModuleFile = function (moduleFile, afterLoaded) {
            this.hasLoaded[moduleFile.key] = true;
            this.constructModuleFile(moduleFile);
            var loadTime = Date.now() - this.moduleLoadStart[moduleFile.key];
            console.log("Module '" + moduleFile.key + "' finished loading in " + loadTime + "ms");
            afterLoaded();
        };
        ModuleLoader.prototype.constructModuleFile = function (moduleFile) {
            moduleFile.constructModule(this.moduleData);
            this.moduleData.addSubModule(moduleFile);
        };
        ModuleLoader.prototype.copyRuleSet = function (toCopy) {
            this.moduleData.ruleSet = Rance.deepMerge(this.moduleData.ruleSet, toCopy);
        };
        return ModuleLoader;
    }());
    Rance.ModuleLoader = ModuleLoader;
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    ;
    function processSpriteSheet(sheetData, sheetImg, processFrameFN) {
        for (var spriteName in sheetData.frames) {
            processFrameFN(sheetImg, sheetData.frames[spriteName].frame, spriteName);
        }
    }
    function cacheSpriteSheetAsImages(sheetData, sheetImg) {
        var spriteToImageFN = function (sheetImg, frame, spriteName) {
            var canvas = document.createElement("canvas");
            canvas.width = frame.w;
            canvas.height = frame.h;
            var context = canvas.getContext("2d");
            context.drawImage(sheetImg, frame.x, frame.y, frame.w, frame.h, 0, 0, frame.w, frame.h);
            var image = new Image();
            image.src = canvas.toDataURL();
            // this is never true as pixi loader silently ignores duplicates, which is a shame
            // if (app.images[spriteName])
            // {
            //   throw new Error("Duplicate image name " + spriteName);
            //   return;
            // }
            app.images[spriteName] = image;
        };
        processSpriteSheet(sheetData, sheetImg, spriteToImageFN);
    }
    Rance.cacheSpriteSheetAsImages = cacheSpriteSheetAsImages;
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            function drawNebula(seed, renderer) {
                var oldRng = Math.random;
                Math.random = RNG.prototype.uniform.bind(new RNG(seed));
                var nebulaColorScheme = Rance.generateColorScheme();
                var lightness = Rance.randRange(1, 1.2);
                var uniforms = {
                    baseColor: { type: "3fv", value: Rance.hex2rgb(nebulaColorScheme.main) },
                    overlayColor: { type: "3fv", value: Rance.hex2rgb(nebulaColorScheme.secondary) },
                    highlightColor: { type: "3fv", value: [1.0, 1.0, 1.0] },
                    coverage: { type: "1f", value: Rance.randRange(0.28, 0.32) },
                    scale: { type: "1f", value: Rance.randRange(4, 8) },
                    diffusion: { type: "1f", value: Rance.randRange(1.5, 3.0) },
                    streakiness: { type: "1f", value: Rance.randRange(1.5, 2.5) },
                    streakLightness: { type: "1f", value: lightness },
                    cloudLightness: { type: "1f", value: lightness },
                    highlightA: { type: "1f", value: 0.9 },
                    highlightB: { type: "1f", value: 2.2 },
                    seed: { type: "2fv", value: [Math.random() * 100, Math.random() * 100] }
                };
                var filter = new Rance.NebulaFilter(uniforms);
                var filterContainer = new PIXI.Container();
                filterContainer.filterArea = new PIXI.Rectangle(0, 0, renderer.width, renderer.height);
                filterContainer.filters = [filter];
                // TODO performance | need to destroy or reuse texture from filterContainer.generateTexture()
                // creates a new PIXI.FilterManager() every time that doesn't get cleaned up anywhere
                // balloons up gpu memory
                var texture = filterContainer.generateTexture(renderer, PIXI.SCALE_MODES.DEFAULT, 1, filterContainer.filterArea);
                var sprite = new PIXI.Sprite(texture);
                filterContainer.filters = null;
                filterContainer = null;
                return sprite;
            }
            DefaultModule.drawNebula = drawNebula;
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
/// <reference path="../../../src/templateinterfaces/imaprendererlayertemplate.d.ts" />
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var MapRendererLayers;
            (function (MapRendererLayers) {
                MapRendererLayers.nonFillerStars = {
                    key: "nonFillerStars",
                    displayName: "Stars",
                    interactive: true,
                    drawingFunction: function (map) {
                        var doc = new PIXI.Container();
                        var points;
                        if (!this.player) {
                            points = map.stars;
                        }
                        else {
                            points = this.player.getRevealedStars();
                        }
                        var mouseDownFN = function (event) {
                            Rance.eventManager.dispatchEvent("mouseDown", event, this);
                        };
                        var mouseUpFN = function (event) {
                            Rance.eventManager.dispatchEvent("mouseUp", event);
                        };
                        var onClickFN = function (star) {
                            Rance.eventManager.dispatchEvent("starClick", star);
                        };
                        var mouseOverFN = function (star) {
                            Rance.eventManager.dispatchEvent("hoverStar", star);
                        };
                        var mouseOutFN = function (event) {
                            Rance.eventManager.dispatchEvent("clearHover");
                        };
                        var touchStartFN = function (event) {
                            Rance.eventManager.dispatchEvent("touchStart", event);
                        };
                        var touchEndFN = function (event) {
                            Rance.eventManager.dispatchEvent("touchEnd", event);
                        };
                        for (var i = 0; i < points.length; i++) {
                            var star = points[i];
                            var starSize = 1;
                            if (star.buildings["defence"]) {
                                starSize += star.buildings["defence"].length * 2;
                            }
                            var gfx = new PIXI.Graphics();
                            if (!star.owner.isIndependent) {
                                gfx.lineStyle(starSize / 2, star.owner.color, 1);
                            }
                            gfx.beginFill(0xFFFFF0);
                            gfx.drawCircle(star.x, star.y, starSize);
                            gfx.endFill();
                            gfx.interactive = true;
                            gfx.hitArea = new PIXI.Polygon(star.voronoiCell.vertices);
                            var boundMouseDown = mouseDownFN.bind(star);
                            var gfxClickFN = function (event) {
                                var originalEvent = event.data.originalEvent;
                                if (originalEvent.button)
                                    return;
                                onClickFN(this);
                            }.bind(star);
                            gfx.on("mousedown", boundMouseDown);
                            gfx.on("mouseup", mouseUpFN);
                            gfx.on("rightdown", boundMouseDown);
                            gfx.on("rightup", mouseUpFN);
                            gfx.on("click", gfxClickFN);
                            gfx.on("mouseover", mouseOverFN.bind(gfx, star));
                            gfx.on("mouseout", mouseOutFN);
                            gfx.on("tap", gfxClickFN);
                            doc.addChild(gfx);
                        }
                        doc.interactive = true;
                        // cant be set on gfx as touchmove and touchend only register
                        // on the object that had touchstart called on it
                        doc.on("touchstart", touchStartFN);
                        doc.on("touchend", touchEndFN);
                        doc.on("touchmove", function (event) {
                            var local = event.data.getLocalPosition(doc);
                            var starAtLocal = map.voronoi.getStarAtPoint(local);
                            if (starAtLocal) {
                                Rance.eventManager.dispatchEvent("hoverStar", starAtLocal);
                            }
                        });
                        return doc;
                    }
                };
                MapRendererLayers.starOwners = {
                    key: "starOwners",
                    displayName: "Star owners",
                    interactive: false,
                    alpha: 0.5,
                    drawingFunction: function (map) {
                        var doc = new PIXI.Container();
                        var points;
                        if (!this.player) {
                            points = map.stars;
                        }
                        else {
                            points = this.player.getRevealedStars();
                        }
                        for (var i = 0; i < points.length; i++) {
                            var star = points[i];
                            var occupier = star.getSecondaryController();
                            if (!star.owner || (!occupier && star.owner.colorAlpha === 0))
                                continue;
                            var poly = new PIXI.Polygon(star.voronoiCell.vertices);
                            var gfx = new PIXI.Graphics();
                            var alpha = 1;
                            if (isFinite(star.owner.colorAlpha))
                                alpha *= star.owner.colorAlpha;
                            gfx.beginFill(star.owner.color, alpha);
                            gfx.drawShape(poly);
                            gfx.endFill();
                            if (occupier) {
                                var container = new PIXI.Container();
                                doc.addChild(container);
                                var mask = new PIXI.Graphics();
                                mask.isMask = true;
                                mask.beginFill(0);
                                mask.drawShape(poly);
                                mask.endFill();
                                container.addChild(gfx);
                                container.addChild(mask);
                                gfx.filters = [this.getOccupationShader(star.owner, occupier)];
                                container.mask = mask;
                            }
                            else {
                                doc.addChild(gfx);
                            }
                        }
                        return doc;
                    }
                };
                MapRendererLayers.fogOfWar = {
                    key: "fogOfWar",
                    displayName: "Fog of war",
                    interactive: false,
                    alpha: 0.35,
                    drawingFunction: function (map) {
                        var doc = new PIXI.Container();
                        if (!this.player)
                            return doc;
                        var points = this.player.getRevealedButNotVisibleStars();
                        if (!points || points.length < 1)
                            return doc;
                        for (var i = 0; i < points.length; i++) {
                            var star = points[i];
                            var sprite = this.getFowSpriteForStar(star);
                            doc.addChild(sprite);
                        }
                        return doc;
                    }
                };
                MapRendererLayers.starIncome = {
                    key: "starIncome",
                    displayName: "Income",
                    interactive: false,
                    drawingFunction: function (map) {
                        var doc = new PIXI.Container();
                        var points;
                        if (!this.player) {
                            points = map.stars;
                        }
                        else {
                            points = this.player.getRevealedStars();
                        }
                        var incomeBounds = map.getIncomeBounds();
                        function getRelativeValue(min, max, value) {
                            var difference = max - min;
                            if (difference < 1)
                                difference = 1;
                            // clamps to n different colors
                            var threshhold = difference / 10;
                            if (threshhold < 1)
                                threshhold = 1;
                            var relative = (Math.round(value / threshhold) * threshhold - min) / (difference);
                            return relative;
                        }
                        var colorIndexes = {};
                        function getRelativeColor(min, max, value) {
                            if (!colorIndexes[value]) {
                                if (value < 0)
                                    value = 0;
                                else if (value > 1)
                                    value = 1;
                                var deviation = Math.abs(0.5 - value) * 2;
                                var hue = 110 * value;
                                var saturation = 0.5 + 0.2 * deviation;
                                var lightness = 0.6 + 0.25 * deviation;
                                colorIndexes[value] = Rance.hslToHex(hue / 360, saturation, lightness / 2);
                            }
                            return colorIndexes[value];
                        }
                        for (var i = 0; i < points.length; i++) {
                            var star = points[i];
                            var income = star.getIncome();
                            var relativeIncome = getRelativeValue(incomeBounds.min, incomeBounds.max, income);
                            var color = getRelativeColor(incomeBounds.min, incomeBounds.max, relativeIncome);
                            var poly = new PIXI.Polygon(star.voronoiCell.vertices);
                            var gfx = new PIXI.Graphics();
                            gfx.beginFill(color, 0.6);
                            gfx.drawShape(poly);
                            gfx.endFill();
                            doc.addChild(gfx);
                        }
                        return doc;
                    }
                };
                MapRendererLayers.playerInfluence = {
                    key: "playerInfluence",
                    displayName: "Influence",
                    interactive: false,
                    drawingFunction: function (map) {
                        var doc = new PIXI.Container();
                        var points;
                        if (!this.player) {
                            points = map.stars;
                        }
                        else {
                            points = this.player.getRevealedStars();
                        }
                        var mapEvaluator = new Rance.MapAI.MapEvaluator(map, this.player);
                        var influenceByStar = mapEvaluator.buildPlayerInfluenceMap(this.player);
                        var minInfluence, maxInfluence;
                        for (var starId in influenceByStar) {
                            var influence = influenceByStar[starId];
                            if (!isFinite(minInfluence) || influence < minInfluence) {
                                minInfluence = influence;
                            }
                            if (!isFinite(maxInfluence) || influence > maxInfluence) {
                                maxInfluence = influence;
                            }
                        }
                        function getRelativeValue(min, max, value) {
                            var difference = max - min;
                            if (difference < 1)
                                difference = 1;
                            // clamps to n different colors
                            var threshhold = difference / 10;
                            if (threshhold < 1)
                                threshhold = 1;
                            var relative = (Math.round(value / threshhold) * threshhold - min) / (difference);
                            return relative;
                        }
                        var colorIndexes = {};
                        function getRelativeColor(min, max, value) {
                            if (!colorIndexes[value]) {
                                if (value < 0)
                                    value = 0;
                                else if (value > 1)
                                    value = 1;
                                var deviation = Math.abs(0.5 - value) * 2;
                                var hue = 110 * value;
                                var saturation = 0.5 + 0.2 * deviation;
                                var lightness = 0.6 + 0.25 * deviation;
                                colorIndexes[value] = Rance.hslToHex(hue / 360, saturation, lightness / 2);
                            }
                            return colorIndexes[value];
                        }
                        for (var i = 0; i < points.length; i++) {
                            var star = points[i];
                            var influence = influenceByStar[star.id];
                            if (!influence)
                                continue;
                            var relativeInfluence = getRelativeValue(minInfluence, maxInfluence, influence);
                            var color = getRelativeColor(minInfluence, maxInfluence, relativeInfluence);
                            var poly = new PIXI.Polygon(star.voronoiCell.vertices);
                            var gfx = new PIXI.Graphics();
                            gfx.beginFill(color, 0.6);
                            gfx.drawShape(poly);
                            gfx.endFill;
                            doc.addChild(gfx);
                        }
                        return doc;
                    }
                };
                MapRendererLayers.nonFillerVoronoiLines = {
                    key: "nonFillerVoronoiLines",
                    displayName: "Star borders",
                    interactive: false,
                    drawingFunction: function (map) {
                        var doc = new PIXI.Container();
                        var gfx = new PIXI.Graphics();
                        doc.addChild(gfx);
                        gfx.lineStyle(1, 0xA0A0A0, 0.5);
                        var visible = this.player ? this.player.getRevealedStars() : null;
                        var lines = map.voronoi.getNonFillerVoronoiLines(visible);
                        for (var i = 0; i < lines.length; i++) {
                            var line = lines[i];
                            gfx.moveTo(line.va.x, line.va.y);
                            gfx.lineTo(line.vb.x, line.vb.y);
                        }
                        return doc;
                    }
                };
                MapRendererLayers.ownerBorders = {
                    key: "ownerBorders",
                    displayName: "Owner borders",
                    interactive: false,
                    alpha: 0.7,
                    drawingFunction: function (map) {
                        var doc = new PIXI.Container();
                        if (Rance.Options.display.borderWidth <= 0) {
                            return doc;
                        }
                        var revealedStars = this.player.getRevealedStars();
                        var borderEdges = Rance.getRevealedBorderEdges(revealedStars, map.voronoi);
                        for (var i = 0; i < borderEdges.length; i++) {
                            var gfx = new PIXI.Graphics();
                            doc.addChild(gfx);
                            var polyLineData = borderEdges[i];
                            var player = polyLineData.points[0].star.owner;
                            gfx.lineStyle(Rance.Options.display.borderWidth, player.secondaryColor, 1);
                            var polygon = new PIXI.Polygon(polyLineData.points);
                            polygon.closed = polyLineData.isClosed;
                            gfx.drawShape(polygon);
                        }
                        return doc;
                    }
                };
                MapRendererLayers.starLinks = {
                    key: "starLinks",
                    displayName: "Links",
                    interactive: false,
                    drawingFunction: function (map) {
                        var doc = new PIXI.Container();
                        var gfx = new PIXI.Graphics();
                        doc.addChild(gfx);
                        gfx.lineStyle(1, 0xCCCCCC, 0.6);
                        var points;
                        if (!this.player) {
                            points = map.stars;
                        }
                        else {
                            points = this.player.getRevealedStars();
                        }
                        var starsFullyConnected = {};
                        for (var i = 0; i < points.length; i++) {
                            var star = points[i];
                            if (starsFullyConnected[star.id])
                                continue;
                            starsFullyConnected[star.id] = true;
                            for (var j = 0; j < star.linksTo.length; j++) {
                                gfx.moveTo(star.x, star.y);
                                gfx.lineTo(star.linksTo[j].x, star.linksTo[j].y);
                            }
                            for (var j = 0; j < star.linksFrom.length; j++) {
                                gfx.moveTo(star.linksFrom[j].x, star.linksFrom[j].y);
                                gfx.lineTo(star.x, star.y);
                            }
                        }
                        return doc;
                    }
                };
                MapRendererLayers.resources = {
                    key: "resources",
                    displayName: "Resources",
                    interactive: false,
                    drawingFunction: function (map) {
                        var self = this;
                        var doc = new PIXI.Container();
                        var points;
                        if (!this.player) {
                            points = map.stars;
                        }
                        else {
                            points = this.player.getRevealedStars();
                        }
                        for (var i = 0; i < points.length; i++) {
                            var star = points[i];
                            if (!star.resource)
                                continue;
                            var text = new PIXI.Text(star.resource.displayName, {
                                fill: "#FFFFFF",
                                stroke: "#000000",
                                strokeThickness: 2
                            });
                            text.x = star.x;
                            text.x -= text.width / 2;
                            text.y = star.y + 8;
                            doc.addChild(text);
                        }
                        return doc;
                    }
                };
                MapRendererLayers.fleets = {
                    key: "fleets",
                    displayName: "Fleets",
                    interactive: true,
                    drawingFunction: function (map) {
                        var self = this;
                        var doc = new PIXI.Container();
                        var points;
                        if (!this.player) {
                            points = map.stars;
                        }
                        else {
                            points = this.player.getVisibleStars();
                        }
                        var mouseDownFN = function (event) {
                            Rance.eventManager.dispatchEvent("mouseDown", event, this.location);
                        };
                        var mouseUpFN = function (event) {
                            Rance.eventManager.dispatchEvent("mouseUp", event);
                        };
                        var mouseOverFN = function (fleet) {
                            Rance.eventManager.dispatchEvent("hoverStar", fleet.location);
                            if (Rance.Options.debugMode && fleet.units.length > 0 && fleet.units[0].front) {
                                var objective = fleet.units[0].front.objective;
                                var target = objective.target ? objective.target.id : null;
                                console.log(objective.type, target, objective.priority);
                            }
                        };
                        function fleetClickFn(event) {
                            var originalEvent = event.data.originalEvent;
                            ;
                            if (originalEvent.button === 0) {
                                Rance.eventManager.dispatchEvent("selectFleets", [this]);
                            }
                        }
                        function singleFleetDrawFN(fleet) {
                            var fleetContainer = new PIXI.Container();
                            var color = fleet.player.color;
                            var fillAlpha = fleet.isStealthy ? 0.3 : 0.7;
                            var textTexture = self.getFleetTextTexture(fleet);
                            var text = new PIXI.Sprite(textTexture);
                            var containerGfx = new PIXI.Graphics();
                            containerGfx.lineStyle(1, 0x00000, 1);
                            // debug
                            var front = fleet.units[0].front;
                            if (front && Rance.Options.debugMode) {
                                switch (front.objective.type) {
                                    case "discovery":
                                        {
                                            containerGfx.lineStyle(5, 0xFF0000, 1);
                                            break;
                                        }
                                    case "scoutingPerimeter":
                                        {
                                            containerGfx.lineStyle(5, 0x0000FF, 1);
                                            break;
                                        }
                                }
                            }
                            // end debug
                            containerGfx.beginFill(color, fillAlpha);
                            containerGfx.drawRect(0, 0, text.width + 4, text.height);
                            containerGfx.endFill();
                            fleetContainer.addChild(containerGfx);
                            fleetContainer.addChild(text);
                            text.x += 2;
                            text.y -= 1;
                            fleetContainer.interactive = true;
                            var boundMouseDownFN = mouseDownFN.bind(fleet);
                            var boundFleetClickFN = fleetClickFn.bind(fleet);
                            fleetContainer.on("click", boundFleetClickFN);
                            fleetContainer.on("tap", boundFleetClickFN);
                            fleetContainer.on("mousedown", boundMouseDownFN);
                            fleetContainer.on("mouseup", mouseUpFN);
                            fleetContainer.on("rightdown", boundMouseDownFN);
                            fleetContainer.on("rightup", mouseUpFN);
                            fleetContainer.on("mouseover", mouseOverFN.bind(fleetContainer, fleet));
                            return fleetContainer;
                        }
                        for (var i = 0; i < points.length; i++) {
                            var star = points[i];
                            var fleets = star.getAllFleets();
                            if (!fleets || fleets.length <= 0)
                                continue;
                            var fleetsContainer = new PIXI.Container();
                            fleetsContainer.x = star.x;
                            fleetsContainer.y = star.y - 40;
                            for (var j = 0; j < fleets.length; j++) {
                                if (fleets[j].units.length === 0) {
                                    continue;
                                }
                                if (fleets[j].isStealthy && this.player && !this.player.starIsDetected(fleets[j].location)) {
                                    continue;
                                }
                                var drawnFleet = singleFleetDrawFN(fleets[j]);
                                drawnFleet.position.x = fleetsContainer.width;
                                fleetsContainer.addChild(drawnFleet);
                            }
                            if (fleetsContainer.children.length > 0) {
                                fleetsContainer.x -= fleetsContainer.width / 2;
                                doc.addChild(fleetsContainer);
                            }
                        }
                        return doc;
                    }
                };
                MapRendererLayers.debugSectors = {
                    key: "debugSectors",
                    displayName: "Sectors (debug)",
                    interactive: false,
                    alpha: 0.5,
                    drawingFunction: function (map) {
                        var doc = new PIXI.Container();
                        var points;
                        if (!this.player) {
                            points = map.stars;
                        }
                        else {
                            points = this.player.getRevealedStars();
                        }
                        if (!points[0].mapGenData || !points[0].mapGenData.sector) {
                            return doc;
                        }
                        var sectorIds = {};
                        for (var i = 0; i < points.length; i++) {
                            var star = points[i];
                            if (star.mapGenData && star.mapGenData.sector) {
                                sectorIds[star.mapGenData.sector.id] = true;
                            }
                        }
                        var sectorsCount = Object.keys(sectorIds).length;
                        for (var i = 0; i < points.length; i++) {
                            var star = points[i];
                            var sector = star.mapGenData.sector;
                            var hue = sector.id / sectorsCount;
                            var color = Rance.hslToHex(hue, 0.8, 0.5);
                            var poly = new PIXI.Polygon(star.voronoiCell.vertices);
                            var gfx = new PIXI.Graphics();
                            gfx.beginFill(color, 1);
                            gfx.drawShape(poly);
                            gfx.endFill();
                            doc.addChild(gfx);
                        }
                        return doc;
                    }
                };
            })(MapRendererLayers = DefaultModule.MapRendererLayers || (DefaultModule.MapRendererLayers = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
/// <reference path="../../../src/templateinterfaces/imaprenderermapmodetemplate.d.ts" />
/// <reference path="maprendererlayers.ts" />
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var MapRendererMapModes;
            (function (MapRendererMapModes) {
                MapRendererMapModes.defaultMapMode = {
                    key: "defaultMapMode",
                    displayName: "Default",
                    layers: [
                        DefaultModule.MapRendererLayers.nonFillerVoronoiLines,
                        DefaultModule.MapRendererLayers.starOwners,
                        DefaultModule.MapRendererLayers.ownerBorders,
                        DefaultModule.MapRendererLayers.starLinks,
                        DefaultModule.MapRendererLayers.nonFillerStars,
                        DefaultModule.MapRendererLayers.fogOfWar,
                        DefaultModule.MapRendererLayers.fleets
                    ]
                };
                MapRendererMapModes.noStatic = {
                    key: "noStatic",
                    displayName: "No Static Layers",
                    layers: [
                        DefaultModule.MapRendererLayers.starOwners,
                        DefaultModule.MapRendererLayers.ownerBorders,
                        DefaultModule.MapRendererLayers.nonFillerStars,
                        DefaultModule.MapRendererLayers.fogOfWar,
                        DefaultModule.MapRendererLayers.fleets
                    ]
                };
                MapRendererMapModes.income = {
                    key: "income",
                    displayName: "Income",
                    layers: [
                        DefaultModule.MapRendererLayers.starIncome,
                        DefaultModule.MapRendererLayers.nonFillerVoronoiLines,
                        DefaultModule.MapRendererLayers.starLinks,
                        DefaultModule.MapRendererLayers.nonFillerStars,
                        DefaultModule.MapRendererLayers.fleets
                    ]
                };
                MapRendererMapModes.influence = {
                    key: "influence",
                    displayName: "Player Influence",
                    layers: [
                        DefaultModule.MapRendererLayers.playerInfluence,
                        DefaultModule.MapRendererLayers.nonFillerVoronoiLines,
                        DefaultModule.MapRendererLayers.starLinks,
                        DefaultModule.MapRendererLayers.nonFillerStars,
                        DefaultModule.MapRendererLayers.fleets
                    ]
                };
                MapRendererMapModes.resources = {
                    key: "resources",
                    displayName: "Resources",
                    layers: [
                        DefaultModule.MapRendererLayers.debugSectors,
                        DefaultModule.MapRendererLayers.nonFillerVoronoiLines,
                        DefaultModule.MapRendererLayers.starLinks,
                        DefaultModule.MapRendererLayers.nonFillerStars,
                        DefaultModule.MapRendererLayers.fogOfWar,
                        DefaultModule.MapRendererLayers.fleets,
                        DefaultModule.MapRendererLayers.resources
                    ]
                };
            })(MapRendererMapModes = DefaultModule.MapRendererMapModes || (DefaultModule.MapRendererMapModes = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
/// <reference path="../fillerpoint.ts" />
/// <reference path="../star.ts" />
var Rance;
(function (Rance) {
    var MapGenCore;
    (function (MapGenCore) {
        var Region = (function () {
            function Region(id, isFiller) {
                this.stars = [];
                this.fillerPoints = [];
                this.id = id;
                this.isFiller = isFiller;
            }
            Region.prototype.addStar = function (star) {
                this.stars.push(star);
                star.mapGenData.region = this;
            };
            Region.prototype.addFillerPoint = function (point) {
                this.fillerPoints.push(point);
                point.mapGenData.region;
            };
            Region.prototype.severLinksByQualifier = function (qualifierFN) {
                for (var i = 0; i < this.stars.length; i++) {
                    var star = this.stars[i];
                    var links = star.getAllLinks();
                    for (var j = 0; j < links.length; j++) {
                        if (qualifierFN(star, links[j])) {
                            star.removeLink(links[j]);
                        }
                    }
                }
            };
            Region.prototype.severLinksToRegionsExcept = function (exemptRegions) {
                this.severLinksByQualifier(function (a, b) {
                    return exemptRegions.indexOf(b.mapGenData.region) !== -1;
                });
            };
            return Region;
        }());
        MapGenCore.Region = Region;
    })(MapGenCore = Rance.MapGenCore || (Rance.MapGenCore = {}));
})(Rance || (Rance = {}));
/// <reference path="../templateinterfaces/iresourcetemplate.d.ts" />
/// <reference path="../star.ts" />
var Rance;
(function (Rance) {
    var MapGenCore;
    (function (MapGenCore) {
        var Sector = (function () {
            function Sector(id) {
                this.stars = [];
                this.addedDistributables = [];
                this.id = id;
            }
            Sector.prototype.addStar = function (star) {
                if (star.mapGenData.sector) {
                    throw new Error("Star already part of a sector");
                }
                this.stars.push(star);
                star.mapGenData.sector = this;
            };
            Sector.prototype.addResource = function (resource) {
                var star = this.stars[0];
                this.resourceType = resource;
                this.resourceLocation = star;
                star.setResource(resource);
            };
            Sector.prototype.getNeighboringStars = function () {
                var neighbors = [];
                var alreadyAdded = {};
                for (var i = 0; i < this.stars.length; i++) {
                    var frontier = this.stars[i].getLinkedInRange(1).all;
                    for (var j = 0; j < frontier.length; j++) {
                        if (frontier[j].mapGenData.sector !== this && !alreadyAdded[frontier[j].id]) {
                            neighbors.push(frontier[j]);
                            alreadyAdded[frontier[j].id] = true;
                        }
                    }
                }
                return neighbors;
            };
            Sector.prototype.getNeighboringSectors = function () {
                var sectors = [];
                var alreadyAdded = {};
                var neighborStars = this.getNeighboringStars();
                for (var i = 0; i < neighborStars.length; i++) {
                    var sector = neighborStars[i].mapGenData.sector;
                    if (!alreadyAdded[sector.id]) {
                        alreadyAdded[sector.id] = true;
                        sectors.push(sector);
                    }
                }
                return sectors;
            };
            Sector.prototype.getMajorityRegions = function () {
                var regionsByStars = {};
                var biggestRegionStarCount = 0;
                for (var i = 0; i < this.stars.length; i++) {
                    var star = this.stars[i];
                    var region = star.mapGenData.region;
                    if (!regionsByStars[region.id]) {
                        regionsByStars[region.id] =
                            {
                                count: 0,
                                region: region
                            };
                    }
                    regionsByStars[region.id].count++;
                    if (regionsByStars[region.id].count > biggestRegionStarCount) {
                        biggestRegionStarCount = regionsByStars[region.id].count;
                    }
                }
                var majorityRegions = [];
                for (var regionId in regionsByStars) {
                    if (regionsByStars[regionId].count >= biggestRegionStarCount) {
                        majorityRegions.push(regionsByStars[regionId].region);
                    }
                }
                return majorityRegions;
            };
            Sector.prototype.getPerimeterLengthWithStar = function (star) {
                var perimeterLength = 0;
                for (var i = 0; i < this.stars.length; i++) {
                    var ownStar = this.stars[i];
                    var halfEdges = ownStar.voronoiCell.halfedges;
                    for (var j = 0; j < halfEdges.length; j++) {
                        var edge = halfEdges[j].edge;
                        if (edge.lSite === star || edge.rSite === star) {
                            var edgeLength = Math.abs(edge.va.x - edge.vb.x) + Math.abs(edge.va.y - edge.vb.y);
                            perimeterLength += edgeLength;
                        }
                    }
                }
                return perimeterLength;
            };
            Sector.prototype.setupIndependents = function (player, intensity, variance) {
                if (intensity === void 0) { intensity = 1; }
                if (variance === void 0) { variance = 0.33; }
                var independentStars = this.stars.filter(function (star) {
                    return !star.owner || star.owner.isIndependent;
                });
                var distanceFromPlayerOwnedLocationById = {};
                var starIsOwnedByPlayerQualifierFN = function (star) {
                    return star.owner && !star.owner.isIndependent;
                };
                var makeUnitFN = function (template, player, unitStatsModifier, unitHealthModifier) {
                    var unit = new Rance.Unit(template);
                    unit.setAttributes(unitStatsModifier);
                    unit.setBaseHealth(unitHealthModifier);
                    player.addUnit(unit);
                    return unit;
                };
                var maxDistance = 0;
                for (var i = 0; i < independentStars.length; i++) {
                    var star = independentStars[i];
                    player.addStar(star);
                    star.addBuilding(new Rance.Building({
                        template: app.moduleData.Templates.Buildings["starBase"],
                        location: star
                    }));
                    var nearestPlayerStar = star.getNearestStarForQualifier(starIsOwnedByPlayerQualifierFN);
                    var distance = star.getDistanceToStar(nearestPlayerStar);
                    distanceFromPlayerOwnedLocationById[star.id] = distance;
                    maxDistance = Math.max(maxDistance, distance);
                }
                var starsAtMaxDistance = independentStars.filter(function (star) {
                    return distanceFromPlayerOwnedLocationById[star.id] === maxDistance;
                });
                var commanderStar = starsAtMaxDistance.sort(function (a, b) {
                    return b.mapGenData.connectedness - a.mapGenData.connectedness;
                })[0];
                var minUnits = 2;
                var maxUnits = 5;
                var globalBuildableUnitTypes = player.getGloballyBuildableUnits();
                for (var i = 0; i < independentStars.length; i++) {
                    var star = independentStars[i];
                    var distance = distanceFromPlayerOwnedLocationById[star.id];
                    var inverseMapGenDistance = 1 - star.mapGenData.distance;
                    var localBuildableUnitTypes = [];
                    for (var j = 0; j < star.buildableUnitTypes.length; j++) {
                        var template = star.buildableUnitTypes[j];
                        if (!template.technologyRequirements ||
                            star.owner.meetsTechnologyRequirements(template.technologyRequirements)) {
                            localBuildableUnitTypes.push(template);
                        }
                    }
                    // TODO map gen | kinda weird
                    var unitsToAddCount = minUnits;
                    for (var j = minUnits; j < distance; j++) {
                        unitsToAddCount += (1 - variance + Math.random() * distance * variance) * intensity;
                        if (unitsToAddCount >= maxUnits) {
                            unitsToAddCount = maxUnits;
                            break;
                        }
                    }
                    var elitesAmount = Math.floor(unitsToAddCount / 2);
                    var templateCandidates = localBuildableUnitTypes.concat(globalBuildableUnitTypes);
                    var units = [];
                    if (star === commanderStar) {
                        var template = Rance.getRandomArrayItem(localBuildableUnitTypes);
                        var commander = makeUnitFN(template, player, 1.4, 1.4 + inverseMapGenDistance);
                        commander.name = "Pirate commander";
                        units.push(commander);
                    }
                    for (var j = 0; j < unitsToAddCount; j++) {
                        var isElite = j < elitesAmount;
                        var unitHealthModifier = (isElite ? 1.2 : 1) + inverseMapGenDistance;
                        var unitStatsModifier = (isElite ? 1.2 : 1);
                        var template = Rance.getRandomArrayItem(templateCandidates);
                        var unit = makeUnitFN(template, player, unitStatsModifier, unitHealthModifier);
                        unit.name = (isElite ? "Pirate elite" : "Pirate");
                        units.push(unit);
                    }
                    var fleet = new Rance.Fleet(player, units, star, undefined, false);
                    fleet.name = "Pirates";
                }
            };
            return Sector;
        }());
        MapGenCore.Sector = Sector;
    })(MapGenCore = Rance.MapGenCore || (Rance.MapGenCore = {}));
})(Rance || (Rance = {}));
/// <reference path="../star.ts" />
/// <reference path="sector.ts" />
/// <reference path="triangulation.ts" />
var Rance;
(function (Rance) {
    var MapGenCore;
    (function (MapGenCore) {
        function linkAllStars(stars) {
            if (stars.length < 3) {
                if (stars.length === 2) {
                    stars[0].addLink(stars[1]);
                }
                return;
            }
            var triangles = MapGenCore.triangulate(stars);
            for (var i = 0; i < triangles.length; i++) {
                var edges = triangles[i].getEdges();
                for (var j = 0; j < edges.length; j++) {
                    edges[j][0].addLink(edges[j][1]);
                }
            }
        }
        MapGenCore.linkAllStars = linkAllStars;
        function partiallyCutLinks(stars, minConnections, maxCutsPerRegion) {
            for (var i = 0; i < stars.length; i++) {
                var star = stars[i];
                var regionsAlreadyCut = {};
                var neighbors = star.getAllLinks();
                if (neighbors.length <= minConnections)
                    continue;
                for (var j = neighbors.length - 1; j >= 0; j--) {
                    var neighbor = neighbors[j];
                    if (regionsAlreadyCut[neighbor.mapGenData.region.id] >= maxCutsPerRegion) {
                        continue;
                    }
                    var neighborLinks = neighbor.getAllLinks();
                    if (neighbors.length <= minConnections || neighborLinks.length <= minConnections)
                        continue;
                    var totalLinks = neighbors.length + neighborLinks.length;
                    var cutThreshhold = 0.05 + 0.025 * (totalLinks - minConnections) * (1 - star.mapGenData.distance);
                    var minMultipleCutThreshhold = 0.15;
                    if (cutThreshhold > 0) {
                        if (Math.random() < cutThreshhold) {
                            star.removeLink(neighbor);
                            neighbors.pop();
                            if (!regionsAlreadyCut[neighbor.mapGenData.region.id]) {
                                regionsAlreadyCut[neighbor.mapGenData.region.id] = 0;
                            }
                            regionsAlreadyCut[neighbor.mapGenData.region.id]++;
                            var path = Rance.aStar(star, neighbor);
                            if (!path) {
                                star.addLink(neighbor);
                                regionsAlreadyCut[neighbor.mapGenData.region.id]--;
                                neighbors.push(neighbor);
                            }
                        }
                        cutThreshhold -= minMultipleCutThreshhold;
                    }
                }
            }
        }
        MapGenCore.partiallyCutLinks = partiallyCutLinks;
        function calculateConnectedness(stars, maxRange) {
            for (var i = 0; i < stars.length; i++) {
                var connectedness = 0;
                var linkedByRange = stars[i].getLinkedInRange(maxRange).byRange;
                for (var rangeString in linkedByRange) {
                    var range = parseInt(rangeString);
                    connectedness += linkedByRange[rangeString].length / range;
                }
                stars[i].mapGenData.connectedness = connectedness;
            }
        }
        MapGenCore.calculateConnectedness = calculateConnectedness;
        function makeSectors(stars, minSize, maxSize) {
            /*
            while average size sectors left to assign && unassigned stars left
              pick random unassigned star
              if star cannot form island bigger than minsize
                put from unassigned into leftovers & continue
              else
                add random neighbors into sector until minsize is met
      
            while leftovers
              pick random leftover
              if leftover has no assigned neighbor pick, continue
      
              leftover gets assigned to smallest neighboring sector
              if sizes equal, assign to sector with least neighboring leftovers
      
            for each sector larger than maxSize
              assign extra stars to smaller neighboring sectors
             */
            var totalStars = stars.length;
            var unassignedStars = stars.slice(0);
            var leftoverStars = [];
            var averageSize = (minSize + maxSize) / 2;
            var averageSectorsAmount = Math.round(totalStars / averageSize);
            var sectorsById = {};
            var sectorIdGen = 0;
            var sectorsOverMaxSize = [];
            var sameSectorFN = function (a, b) {
                return a.mapGenData.sector === b.mapGenData.sector;
            };
            calculateConnectedness(stars, minSize);
            unassignedStars.sort(function (a, b) {
                return b.mapGenData.connectedness - a.mapGenData.connectedness;
            });
            while (averageSectorsAmount > 0 && unassignedStars.length > 0) {
                var seedStar = unassignedStars.pop();
                var canFormMinSizeSector = seedStar.getIslandForQualifier(sameSectorFN, minSize).length >= minSize;
                if (canFormMinSizeSector) {
                    var sector = new MapGenCore.Sector(sectorIdGen++);
                    sectorsById[sector.id] = sector;
                    var discoveryStarIndex = 0;
                    sector.addStar(seedStar);
                    while (sector.stars.length < minSize) {
                        var discoveryStar = sector.stars[discoveryStarIndex];
                        var frontier = discoveryStar.getLinkedInRange(1).all;
                        frontier = frontier.filter(function (star) {
                            return !star.mapGenData.sector;
                        });
                        while (sector.stars.length < minSize && frontier.length > 0) {
                            var frontierSortScores = {};
                            for (var i = 0; i < frontier.length; i++) {
                                var perimeter = sector.getPerimeterLengthWithStar(frontier[i]) / 15;
                                var sortScore = frontier[i].mapGenData.connectedness - perimeter;
                                frontierSortScores[frontier[i].id] = sortScore;
                            }
                            frontier.sort(function (a, b) {
                                return frontierSortScores[b.id] - frontierSortScores[a.id];
                            });
                            var toAdd = frontier.pop();
                            unassignedStars.splice(unassignedStars.indexOf(toAdd), 1);
                            sector.addStar(toAdd);
                        }
                        discoveryStarIndex++;
                    }
                }
                else {
                    leftoverStars.push(seedStar);
                }
            }
            while (leftoverStars.length > 0) {
                var star = leftoverStars.pop();
                var neighbors = star.getLinkedInRange(1).all;
                var alreadyAddedNeighborSectors = {};
                var candidateSectors = [];
                for (var j = 0; j < neighbors.length; j++) {
                    if (!neighbors[j].mapGenData.sector)
                        continue;
                    else {
                        if (!alreadyAddedNeighborSectors[neighbors[j].mapGenData.sector.id]) {
                            alreadyAddedNeighborSectors[neighbors[j].mapGenData.sector.id] = true;
                            candidateSectors.push(neighbors[j].mapGenData.sector);
                        }
                    }
                }
                // all neighboring stars don't have sectors
                // put star at back of queue and try again later
                if (candidateSectors.length < 1) {
                    leftoverStars.unshift(star);
                    continue;
                }
                var unclaimedNeighborsPerSector = {};
                for (var j = 0; j < candidateSectors.length; j++) {
                    var sectorNeighbors = candidateSectors[j].getNeighboringStars();
                    var unclaimed = 0;
                    for (var k = 0; k < sectorNeighbors.length; k++) {
                        if (!sectorNeighbors[k].mapGenData.sector) {
                            unclaimed++;
                        }
                    }
                    unclaimedNeighborsPerSector[candidateSectors[j].id] = unclaimed;
                }
                candidateSectors.sort(function (a, b) {
                    var sizeSort = a.stars.length - b.stars.length;
                    if (sizeSort)
                        return sizeSort;
                    var unclaimedSort = unclaimedNeighborsPerSector[b.id] -
                        unclaimedNeighborsPerSector[a.id];
                    if (sizeSort)
                        return unclaimedSort;
                    var perimeterSort = b.getPerimeterLengthWithStar(star) - a.getPerimeterLengthWithStar(star);
                    if (perimeterSort)
                        return perimeterSort;
                });
                candidateSectors[0].addStar(star);
            }
            return sectorsById;
        }
        MapGenCore.makeSectors = makeSectors;
        function setSectorDistributionFlags(sectors) {
            for (var i = 0; i < sectors.length; i++) {
                var sector = sectors[i];
                sector.distributionFlags = [];
                var majorityRegions = sector.getMajorityRegions();
                for (var j = 0; j < majorityRegions.length; j++) {
                    if (majorityRegions[j].id.indexOf("center") !== -1) {
                        sector.distributionFlags.push("rare");
                    }
                    else {
                        sector.distributionFlags.push("common");
                    }
                }
            }
        }
        MapGenCore.setSectorDistributionFlags = setSectorDistributionFlags;
        function distributeDistributablesPerSector(sectors, distributableType, allDistributables, placerFunction) {
            if (!sectors[0].distributionFlags) {
                setSectorDistributionFlags(sectors);
            }
            var probabilityWeights = {};
            for (var name in allDistributables) {
                probabilityWeights[name] = allDistributables[name].rarity;
            }
            for (var i = 0; i < sectors.length; i++) {
                var sector = sectors[i];
                var alreadyAddedByWeight = Rance.getRelativeWeightsFromObject(probabilityWeights);
                var candidates = [];
                for (var j = 0; j < sector.distributionFlags.length; j++) {
                    var flag = sector.distributionFlags[j];
                    var distributablesForFlag = Rance.TemplateIndexes.distributablesByDistributionGroup[flag][distributableType];
                    candidates = candidates.concat(distributablesForFlag);
                }
                if (candidates.length === 0)
                    continue;
                var neighborSectors = sector.getNeighboringSectors();
                var candidatesNotInNeighboringSectors = candidates.filter(function (candidate) {
                    for (var k = 0; k < neighborSectors.length; k++) {
                        if (neighborSectors[k].addedDistributables.indexOf(candidate) !== -1) {
                            return false;
                        }
                    }
                    return true;
                });
                if (candidatesNotInNeighboringSectors.length > 0) {
                    candidates = candidatesNotInNeighboringSectors;
                }
                var candidatesByWeight = {};
                for (var j = 0; j < candidates.length; j++) {
                    candidatesByWeight[candidates[j].type] =
                        alreadyAddedByWeight[candidates[j].type];
                }
                var selectedKey = Rance.getRandomKeyWithWeights(candidatesByWeight);
                var selectedType = allDistributables[selectedKey];
                probabilityWeights[selectedKey] /= 2;
                placerFunction(sector, selectedType);
                sector.addedDistributables.push(selectedType);
            }
        }
        MapGenCore.distributeDistributablesPerSector = distributeDistributablesPerSector;
        function addDefenceBuildings(star, amount, addSectorCommand) {
            if (amount === void 0) { amount = 1; }
            if (addSectorCommand === void 0) { addSectorCommand = true; }
            if (!star.owner) {
                console.warn("Tried to add defence buildings to star without owner.");
                return;
            }
            if (amount < 1) {
                return;
            }
            if (addSectorCommand) {
                star.addBuilding(new Rance.Building({
                    template: app.moduleData.Templates.Buildings["sectorCommand"],
                    location: star
                }));
                var amount = amount - 1;
            }
            for (var i = 0; i < amount; i++) {
                star.addBuilding(new Rance.Building({
                    template: app.moduleData.Templates.Buildings["starBase"],
                    location: star
                }));
            }
        }
        MapGenCore.addDefenceBuildings = addDefenceBuildings;
        function setupPirates(player) {
            player.name = "Pirates";
            player.color = 0x000000;
            player.colorAlpha = 0;
            player.secondaryColor = 0xFFFFFF;
            player.isIndependent = true;
            var foregroundEmblem = new Rance.Emblem(player.secondaryColor);
            foregroundEmblem.inner = app.moduleData.Templates.SubEmblems["Flag_of_Edward_England"];
            player.flag = new Rance.Flag({
                width: 46,
                mainColor: player.color,
                secondaryColor: player.secondaryColor
            });
            player.flag.setForegroundEmblem(foregroundEmblem);
        }
        MapGenCore.setupPirates = setupPirates;
        function severLinksToNonAdjacentStars(star) {
            var allLinks = star.getAllLinks();
            var neighborVoronoiIds = star.voronoiCell.getNeighborIds();
            for (var i = 0; i < allLinks.length; i++) {
                var toSever = allLinks[i];
                if (neighborVoronoiIds.indexOf(toSever.voronoiId) === -1) {
                    star.removeLink(toSever);
                }
            }
        }
        MapGenCore.severLinksToNonAdjacentStars = severLinksToNonAdjacentStars;
    })(MapGenCore = Rance.MapGenCore || (Rance.MapGenCore = {}));
})(Rance || (Rance = {}));
/// <reference path="../../../src/utility.ts" />
/// <reference path="../../../src/point.ts" />
/// <reference path="../../../src/player.ts" />
/// <reference path="../../../src/star.ts" />
/// <reference path="../../../src/mapgencore/region.ts" />
/// <reference path="../../../src/mapgencore/mapgenutils.ts" />
/// <reference path="../../../src/mapgencore/mapgenresult.ts" />
/// <reference path="../../../src/templateinterfaces/iunitfamily.d.ts" />
/// <reference path="../../../src/templateinterfaces/iresourcetemplate.d.ts" />
/// <reference path="../../../src/templateinterfaces/mapgenoptions.d.ts" />
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var MapGenFunctions;
            (function (MapGenFunctions) {
                function spiralGalaxyGeneration(options, players) {
                    // generate points
                    // in closure because tons of temporary variables we dont really care about
                    var sg = (function setStarGenerationProps(options) {
                        var totalSize = options.defaultOptions.width * options.defaultOptions.height;
                        var totalStars = options.defaultOptions.starCount;
                        var actualArms = options.basicOptions["arms"];
                        var totalArms = actualArms * 2; // includes filler arms
                        var percentageInCenter = 0.3;
                        var percentageInArms = 1 - percentageInCenter;
                        var amountInCenter = totalStars * percentageInCenter;
                        var amountPerArm = Math.round(totalStars / actualArms * percentageInArms);
                        var amountPerFillerArm = Math.round(amountPerArm / 2);
                        var amountPerCenter = Math.round(amountInCenter / totalArms);
                        // to prevent rounding issues, probably a better way to do this
                        var actualStarsInArms = actualArms * amountPerArm;
                        var actualStarsInCenter = totalArms * amountPerCenter;
                        var actualStars = actualStarsInCenter + actualStarsInArms;
                        var starsDeficit = totalStars - actualStars;
                        var armsToMakeUpDeficit = [];
                        var starsToAddPerDeficitArm = 0;
                        if (starsDeficit !== 0) {
                            starsToAddPerDeficitArm = starsDeficit > 0 ? 1 : -1;
                            var deficitStep = totalArms / Math.abs(starsDeficit);
                            for (var i = 0; i < totalArms; i += deficitStep) {
                                armsToMakeUpDeficit.push(Math.round(i));
                            }
                        }
                        return ({
                            totalArms: totalArms,
                            armsToMakeUpDeficit: armsToMakeUpDeficit,
                            starsToAddPerDeficitArm: starsToAddPerDeficitArm,
                            amountPerArm: amountPerArm,
                            amountPerFillerArm: amountPerFillerArm,
                            amountPerCenter: amountPerCenter,
                            centerSize: 0.4,
                            armDistance: Math.PI * 2 / totalArms,
                            armOffsetMax: 0.5,
                            armRotationFactor: actualArms / 3,
                            galaxyRotation: Rance.randRange(0, Math.PI * 2) // rotation of entire galaxy
                        });
                    })(options);
                    function makePoint(distanceMin, distanceMax, arm, maxOffset) {
                        var distance = Rance.randRange(distanceMin, distanceMax);
                        var offset = Math.random() * maxOffset - maxOffset / 2;
                        offset *= (1 / distance);
                        if (offset < 0)
                            offset = Math.pow(offset, 2) * -1;
                        else
                            offset = Math.pow(offset, 2);
                        var armRotation = distance * sg.armRotationFactor;
                        var angle = arm * sg.armDistance + sg.galaxyRotation + offset + armRotation;
                        var width = options.defaultOptions.width / 2;
                        var height = options.defaultOptions.height / 2;
                        var x = Math.cos(angle) * distance * width + width;
                        var y = Math.sin(angle) * distance * height + height;
                        return ({
                            pos: {
                                x: x,
                                y: y
                            },
                            distance: distance
                        });
                    }
                    function makeStar(point, distance) {
                        var star = new Rance.Star(point.x, point.y);
                        star.mapGenData.distance = distance;
                        star.baseIncome = Rance.randInt(4, 10) * 10;
                        return star;
                    }
                    var stars = [];
                    var fillerPoints = [];
                    var regions = [];
                    var centerRegion = new Rance.MapGenCore.Region("center", false);
                    regions.push(centerRegion);
                    var fillerRegionId = 0;
                    var regionId = 0;
                    for (var i = 0; i < sg.totalArms; i++) {
                        var isFiller = i % 2 !== 0;
                        var regionName = isFiller ? "filler_" + fillerRegionId++ : "arm_" + regionId++;
                        var region = new Rance.MapGenCore.Region(regionName, isFiller);
                        regions.push(region);
                        var amountForThisArm = isFiller ? sg.amountPerFillerArm : sg.amountPerArm;
                        var amountForThisCenter = sg.amountPerCenter;
                        if (sg.armsToMakeUpDeficit.indexOf(i) !== -1) {
                            amountForThisCenter += sg.starsToAddPerDeficitArm;
                        }
                        var maxOffsetForThisArm = isFiller ? sg.armOffsetMax / 2 : sg.armOffsetMax;
                        for (var j = 0; j < amountForThisArm; j++) {
                            var point = makePoint(sg.centerSize, 1, i, maxOffsetForThisArm);
                            if (isFiller) {
                                var fillerPoint = new Rance.FillerPoint(point.pos.x, point.pos.y);
                                region.addFillerPoint(fillerPoint);
                                fillerPoint.mapGenData.distance = point.distance;
                                fillerPoints.push(fillerPoint);
                            }
                            else {
                                var star = makeStar(point.pos, point.distance);
                                region.addStar(star);
                                stars.push(star);
                            }
                        }
                        for (var j = 0; j < amountForThisCenter; j++) {
                            var point = makePoint(0, sg.centerSize, i, maxOffsetForThisArm);
                            var star = makeStar(point.pos, point.distance);
                            centerRegion.addStar(star);
                            stars.push(star);
                        }
                    }
                    var allPoints = fillerPoints.concat(stars);
                    // make voronoi
                    var voronoi = Rance.MapGenCore.makeVoronoi(allPoints, options.defaultOptions.width, options.defaultOptions.height);
                    // relax voronoi
                    var regularity = options.basicOptions["starSizeRegularity"] / 100;
                    var centerDensity = options.basicOptions["centerDensity"] / 100;
                    var inverseCenterDensity = 1 - centerDensity;
                    for (var i = 0; i < 2; i++) {
                        Rance.MapGenCore.relaxVoronoi(voronoi, function (star) {
                            return (inverseCenterDensity + centerDensity * star.mapGenData.distance) * regularity;
                        });
                        voronoi = Rance.MapGenCore.makeVoronoi(allPoints, options.defaultOptions.width, options.defaultOptions.height);
                    }
                    // link stars
                    Rance.MapGenCore.linkAllStars(stars);
                    // sever links
                    for (var i = 0; i < regions.length; i++) {
                        regions[i].severLinksByQualifier(function (a, b) {
                            return (a.mapGenData.region !== b.mapGenData.region &&
                                a.mapGenData.region !== regions[0] &&
                                b.mapGenData.region !== regions[0]);
                        });
                        for (var j = 0; j < regions[i].stars.length; j++) {
                            Rance.MapGenCore.severLinksToNonAdjacentStars(regions[i].stars[j]);
                        }
                    }
                    var isConnected = stars[0].getLinkedInRange(stars.length).all.length === stars.length;
                    if (!isConnected) {
                        console.log("Regenerated map due to insufficient connections");
                        return spiralGalaxyGeneration(options, players);
                    }
                    Rance.MapGenCore.partiallyCutLinks(stars, 4, 2);
                    // make sectors
                    var sectorsById = Rance.MapGenCore.makeSectors(stars, 3, 3);
                    // set resources && local units
                    var allSectors = [];
                    for (var sectorId in sectorsById) {
                        allSectors.push(sectorsById[sectorId]);
                    }
                    var resourcePlacerFN = function (sector, resource) {
                        sector.addResource(resource);
                    };
                    Rance.MapGenCore.distributeDistributablesPerSector(allSectors, "resources", app.moduleData.Templates.Resources, resourcePlacerFN);
                    var localUnitPlacerFN = function (sector, unitFamily) {
                        for (var i = 0; i < sector.stars.length; i++) {
                            var star = sector.stars[i];
                            star.buildableUnitTypes = star.buildableUnitTypes.concat(unitFamily.associatedTemplates);
                        }
                    };
                    Rance.MapGenCore.distributeDistributablesPerSector(allSectors, "unitFamilies", app.moduleData.Templates.UnitFamilies, localUnitPlacerFN);
                    // set players
                    var startRegions = (function setStartingRegions() {
                        var armCount = options.basicOptions["arms"];
                        var playerCount = Math.min(players.length, armCount);
                        var playerArmStep = armCount / playerCount;
                        var startRegions = [];
                        var candidateRegions = regions.filter(function (region) {
                            return region.id.indexOf("arm") !== -1;
                        });
                        for (var i = 0; i < playerCount; i++) {
                            var regionNumber = Math.floor(i * playerArmStep);
                            var regionToAdd = candidateRegions[regionNumber];
                            startRegions.push(regionToAdd);
                        }
                        return startRegions;
                    })();
                    var startPositions = (function getStartPoints(regions) {
                        var startPositions = [];
                        for (var i = 0; i < regions.length; i++) {
                            var region = regions[i];
                            var starsByDistance = region.stars.slice(0).sort(function (a, b) {
                                return b.mapGenData.distance - a.mapGenData.distance;
                            });
                            var star = starsByDistance[0];
                            startPositions.push(star);
                        }
                        return startPositions;
                    })(startRegions);
                    for (var i = 0; i < startPositions.length; i++) {
                        var star = startPositions[i];
                        var player = players[i];
                        player.addStar(star);
                        Rance.MapGenCore.addDefenceBuildings(star, 2);
                        star.buildManufactory();
                    }
                    var pirates = new Rance.Player(true);
                    Rance.MapGenCore.setupPirates(pirates);
                    for (var i = 0; i < allSectors.length; i++) {
                        var sector = allSectors[i];
                        sector.setupIndependents(pirates, 1, 0);
                    }
                    return new Rance.MapGenCore.MapGenResult({
                        stars: stars,
                        fillerPoints: fillerPoints,
                        width: options.defaultOptions.width,
                        height: options.defaultOptions.height,
                        seed: "" + Math.random(),
                        independents: [pirates]
                    });
                }
                MapGenFunctions.spiralGalaxyGeneration = spiralGalaxyGeneration;
            })(MapGenFunctions = DefaultModule.MapGenFunctions || (DefaultModule.MapGenFunctions = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
/// <reference path="spiralgalaxygeneration.ts" />
/// <reference path="../../../src/templateinterfaces/imapgentemplate.d.ts" />
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var Templates;
            (function (Templates) {
                var MapGen;
                (function (MapGen) {
                    MapGen.spiralGalaxy = {
                        key: "spiralGalaxy",
                        displayName: "Spiral galaxy",
                        description: "Create a spiral galaxy with arms",
                        minPlayers: 2,
                        maxPlayers: 5,
                        mapGenFunction: DefaultModule.MapGenFunctions.spiralGalaxyGeneration,
                        options: {
                            defaultOptions: {
                                height: {
                                    displayName: "Height",
                                    range: {
                                        min: 800,
                                        max: 1600,
                                        step: 1
                                    }
                                },
                                width: {
                                    displayName: "Width",
                                    range: {
                                        min: 800,
                                        max: 1600,
                                        step: 1
                                    }
                                },
                                starCount: {
                                    displayName: "Star count",
                                    range: {
                                        min: 20,
                                        max: 40,
                                        step: 1
                                    }
                                }
                            },
                            basicOptions: {
                                arms: {
                                    displayName: "Arms",
                                    range: {
                                        min: 3,
                                        max: 6,
                                        step: 1,
                                        defaultValue: 5
                                    }
                                },
                                starSizeRegularity: {
                                    displayName: "Star size regularity",
                                    range: {
                                        min: 1,
                                        max: 100,
                                        step: 1,
                                        defaultValue: 100
                                    }
                                },
                                centerDensity: {
                                    displayName: "Center density",
                                    range: {
                                        min: 1,
                                        max: 90,
                                        step: 1,
                                        defaultValue: 50
                                    }
                                }
                            }
                        }
                    };
                })(MapGen = Templates.MapGen || (Templates.MapGen = {}));
            })(Templates = DefaultModule.Templates || (DefaultModule.Templates = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
/// <reference path="spiralgalaxygeneration.ts" />
/// <reference path="../../../src/templateinterfaces/imapgentemplate.d.ts" />
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var Templates;
            (function (Templates) {
                var MapGen;
                (function (MapGen) {
                    MapGen.tinierSpiralGalaxy = {
                        key: "tinierSpiralGalaxy",
                        displayName: "Tinier Spiral galaxy",
                        description: "Create a spiral galaxy with arms but tinier (just for testing)",
                        minPlayers: 2,
                        maxPlayers: 4,
                        mapGenFunction: DefaultModule.MapGenFunctions.spiralGalaxyGeneration,
                        options: {
                            defaultOptions: {
                                height: {
                                    displayName: "height",
                                    range: {
                                        min: 500,
                                        max: 1000,
                                        step: 1
                                    }
                                },
                                width: {
                                    displayName: "width",
                                    range: {
                                        min: 500,
                                        max: 1000,
                                        step: 1
                                    }
                                },
                                starCount: {
                                    displayName: "starCount",
                                    range: {
                                        min: 15,
                                        max: 30,
                                        step: 1,
                                        defaultValue: 20
                                    }
                                }
                            },
                            basicOptions: {
                                arms: {
                                    displayName: "arms",
                                    range: {
                                        min: 2,
                                        max: 5,
                                        step: 1,
                                        defaultValue: 4
                                    }
                                },
                                starSizeRegularity: {
                                    displayName: "starSizeRegularity",
                                    range: {
                                        min: 1,
                                        max: 100,
                                        step: 1,
                                        defaultValue: 100
                                    }
                                },
                                centerDensity: {
                                    displayName: "centerDensity",
                                    range: {
                                        min: 1,
                                        max: 90,
                                        step: 1,
                                        defaultValue: 50
                                    }
                                }
                            }
                        }
                    };
                })(MapGen = Templates.MapGen || (Templates.MapGen = {}));
            })(Templates = DefaultModule.Templates || (DefaultModule.Templates = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
/// <reference path="../../../src/templateinterfaces/itechnologytemplate.d.ts"/>
/// <reference path="../../../src/templateinterfaces/idistributable.d.ts" />
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var Templates;
            (function (Templates) {
                var Technologies;
                (function (Technologies) {
                    Technologies.stealth = {
                        key: "stealth",
                        displayName: "Stealth",
                        description: "stealthy stuff",
                        maxLevel: 9
                    };
                    Technologies.lasers = {
                        key: "lasers",
                        displayName: "Lasers",
                        description: "pew pew",
                        maxLevel: 9
                    };
                    Technologies.missiles = {
                        key: "missiles",
                        displayName: "Missiles",
                        description: "boom",
                        maxLevel: 9
                    };
                    Technologies.test1 = {
                        key: "test1",
                        displayName: "test1",
                        description: "test1",
                        maxLevel: 1
                    };
                    Technologies.test2 = {
                        key: "test2",
                        displayName: "test2",
                        description: "test2",
                        maxLevel: 2
                    };
                })(Technologies = Templates.Technologies || (Templates.Technologies = {}));
            })(Templates = DefaultModule.Templates || (DefaultModule.Templates = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var BattleSFXFunctions;
            (function (BattleSFXFunctions) {
                function makeSFXFromVideo(videoSrc, onStartFN, props) {
                    function clearBaseTextureListeners() {
                        baseTexture.removeListener("loaded", onVideoLoaded);
                        baseTexture.removeListener("error", onVideoError);
                    }
                    function onVideoLoaded() {
                        clearBaseTextureListeners();
                        baseTexture.autoUpdate = false;
                        if (onStartFN) {
                            onStartFN(sprite);
                        }
                        startTime = Date.now();
                        props.triggerStart(sprite);
                        animate();
                    }
                    function onVideoError() {
                        clearBaseTextureListeners();
                        throw new Error("Video " + videoSrc + " failed to load.");
                    }
                    var baseTexture = PIXI.VideoBaseTexture.fromUrl(videoSrc);
                    var texture = new PIXI.Texture(baseTexture);
                    var sprite = new PIXI.Sprite(texture);
                    if (!props.facingRight) {
                        sprite.x = props.width;
                        sprite.scale.x = -1;
                    }
                    if (baseTexture.hasLoaded) {
                        onVideoLoaded();
                    }
                    else if (baseTexture.isLoading) {
                        baseTexture.on("loaded", onVideoLoaded);
                        baseTexture.on("error", onVideoError);
                    }
                    else {
                        onVideoError();
                    }
                    var startTime;
                    function animate() {
                        var elapsedTime = Date.now() - startTime;
                        baseTexture.update();
                        if (elapsedTime < props.duration && !baseTexture.source.paused) {
                            requestAnimationFrame(animate);
                        }
                        else {
                            props.triggerEnd();
                            sprite.destroy(true, true);
                        }
                    }
                }
                BattleSFXFunctions.makeSFXFromVideo = makeSFXFromVideo;
            })(BattleSFXFunctions = DefaultModule.BattleSFXFunctions || (DefaultModule.BattleSFXFunctions = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
/// <reference path="../../../src/templateinterfaces/ieffecttemplate.d.ts"/>
/// <reference path="../../../src/targeting.ts" />
/// <reference path="../../../src/unit.ts" />
/// <reference path="../../../src/damagetype.ts" />
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var Templates;
            (function (Templates) {
                var Effects;
                (function (Effects) {
                    Effects.singleTargetDamage = {
                        name: "singleTargetDamage",
                        targetFormations: Rance.TargetFormation.enemy,
                        battleAreaFunction: Rance.areaSingle,
                        targetRangeFunction: Rance.targetAll,
                        effect: function (user, target, battle, data) {
                            var baseDamage = data.baseDamage;
                            var damageType = data.damageType;
                            var damageIncrease = user.getAttackDamageIncrease(damageType);
                            var damage = baseDamage * damageIncrease;
                            target.receiveDamage(damage, damageType);
                        }
                    };
                    Effects.closeAttack = {
                        name: "closeAttack",
                        targetFormations: Rance.TargetFormation.enemy,
                        battleAreaFunction: Rance.areaRowNeighbors,
                        targetRangeFunction: Rance.targetNextRow,
                        effect: function (user, target, battle) {
                            var baseDamage = 0.66;
                            var damageType = Rance.DamageType.physical;
                            var damageIncrease = user.getAttackDamageIncrease(damageType);
                            var damage = baseDamage * damageIncrease;
                            target.receiveDamage(damage, damageType);
                        }
                    };
                    Effects.wholeRowAttack = {
                        name: "wholeRowAttack",
                        targetFormations: Rance.TargetFormation.either,
                        battleAreaFunction: Rance.areaColumn,
                        targetRangeFunction: Rance.targetAll,
                        effect: function (user, target, battle) {
                            var baseDamage = 0.75;
                            var damageType = Rance.DamageType.magical;
                            var damageIncrease = user.getAttackDamageIncrease(damageType);
                            var damage = baseDamage * damageIncrease;
                            target.receiveDamage(damage, damageType);
                        }
                    };
                    Effects.bombAttack = {
                        name: "bombAttack",
                        targetFormations: Rance.TargetFormation.enemy,
                        battleAreaFunction: Rance.areaNeighbors,
                        targetRangeFunction: Rance.targetAll,
                        effect: function (user, target, battle) {
                            var baseDamage = 0.5;
                            var damageType = Rance.DamageType.physical;
                            var damageIncrease = user.getAttackDamageIncrease(damageType);
                            var damage = baseDamage * damageIncrease;
                            target.receiveDamage(damage, damageType);
                        }
                    };
                    Effects.guardRow = {
                        name: "guardRow",
                        targetFormations: Rance.TargetFormation.either,
                        battleAreaFunction: Rance.areaSingle,
                        targetRangeFunction: Rance.targetSelf,
                        effect: function (user, target, battle, data) {
                            var data = data || {};
                            var guardPerInt = data.perInt || 0;
                            var flat = data.flat || 0;
                            var guardAmount = guardPerInt * user.attributes.intelligence + flat;
                            user.addGuard(guardAmount, Rance.GuardCoverage.row);
                        }
                    };
                    Effects.receiveCounterAttack = {
                        name: "receiveCounterAttack",
                        targetFormations: Rance.TargetFormation.either,
                        battleAreaFunction: Rance.areaSingle,
                        targetRangeFunction: Rance.targetSelf,
                        effect: function (user, target, battle, data) {
                            var counterStrength = target.getCounterAttackStrength();
                            if (counterStrength) {
                                Templates.Effects.singleTargetDamage.effect(target, user, battle, {
                                    baseDamage: data.baseDamage * counterStrength,
                                    damageType: Rance.DamageType.physical
                                });
                            }
                        }
                    };
                    Effects.increaseCaptureChance = {
                        name: "increaseCaptureChance",
                        targetFormations: Rance.TargetFormation.enemy,
                        battleAreaFunction: Rance.areaSingle,
                        targetRangeFunction: Rance.targetAll,
                        effect: function (user, target, battle, data) {
                            if (!data)
                                return;
                            if (data.flat) {
                                target.battleStats.captureChance += data.flat;
                            }
                            if (isFinite(data.multiplier)) {
                                target.battleStats.captureChance *= data.multiplier;
                            }
                        }
                    };
                    Effects.buffTest = {
                        name: "buffTest",
                        targetFormations: Rance.TargetFormation.either,
                        battleAreaFunction: Rance.areaSingle,
                        targetRangeFunction: Rance.targetAll,
                        effect: function (user, target, battle) {
                            target.addStatusEffect(new Rance.StatusEffect(Templates.StatusEffects.test, 2));
                        }
                    };
                    Effects.healTarget = {
                        name: "healTarget",
                        targetFormations: Rance.TargetFormation.ally,
                        battleAreaFunction: Rance.areaSingle,
                        targetRangeFunction: Rance.targetAll,
                        effect: function (user, target, battle, data) {
                            var healAmount = 0;
                            if (data.flat) {
                                healAmount += data.flat;
                            }
                            if (data.maxHealthPercentage) {
                                healAmount += target.maxHealth * data.maxHealthPercentage;
                            }
                            if (data.perUserUnit) {
                                healAmount += data.perUserUnit * user.getAttackDamageIncrease(Rance.DamageType.magical);
                            }
                            target.removeStrength(-healAmount);
                        }
                    };
                    Effects.healSelf = {
                        name: "healSelf",
                        targetFormations: Rance.TargetFormation.ally,
                        battleAreaFunction: Rance.areaSingle,
                        targetRangeFunction: Rance.targetSelf,
                        effect: function (user, target, battle, data) {
                            Templates.Effects.healTarget.effect(user, user, battle, data);
                        }
                    };
                    Effects.standBy = {
                        name: "standBy",
                        targetFormations: Rance.TargetFormation.either,
                        battleAreaFunction: Rance.areaSingle,
                        targetRangeFunction: Rance.targetSelf,
                        effect: function () { }
                    };
                })(Effects = Templates.Effects || (Templates.Effects = {}));
            })(Templates = DefaultModule.Templates || (DefaultModule.Templates = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var BattleSFXFunctions;
            (function (BattleSFXFunctions) {
                function projectileAttack(props, params) {
                    // TODO battleSFX | would be nice to draw SFX based on unit scenes
                    // eg. height here = unit scene height
                    var minY = Math.max(params.height * 0.3, 30); // from top
                    var maxY = params.height - 30;
                    var maxSpeed = (params.width / params.duration) * props.maxSpeed;
                    var acceleration = maxSpeed * props.acceleration;
                    var container = new PIXI.Container();
                    if (!params.facingRight) {
                        container.scale.x = -1;
                        container.x = params.width;
                    }
                    var startTime = Date.now();
                    var endTime = startTime + params.duration;
                    var stopSpawningTime = startTime + params.duration / 2;
                    var lastTime = startTime;
                    var nextSpawnTime = startTime;
                    var amountToSpawn = Rance.randInt(props.amountToSpawn.min, props.amountToSpawn.max);
                    var spawnRate = (stopSpawningTime - startTime) / amountToSpawn;
                    var projectiles = [];
                    var hasTriggeredEffect = false;
                    function animate() {
                        var currentTime = Date.now();
                        var elapsedTime = currentTime - lastTime;
                        lastTime = currentTime;
                        if (currentTime < stopSpawningTime && currentTime >= nextSpawnTime) {
                            nextSpawnTime += spawnRate;
                            var texture = Rance.getRandomArrayItem(props.projectileTextures);
                            var sprite = new PIXI.Sprite(texture);
                            sprite.x = 20;
                            sprite.y = Rance.randInt(minY, maxY);
                            container.addChild(sprite);
                            projectiles.push({
                                sprite: sprite,
                                speed: 0,
                                willImpact: (projectiles.length - 1) % props.impactRate === 0,
                                impactX: Rance.randInt(params.width - 200, params.width - 50),
                                hasImpact: false
                            });
                        }
                        for (var i = 0; i < projectiles.length; i++) {
                            var projectile = projectiles[i];
                            if (!projectile.hasImpact) {
                                if (projectile.speed < maxSpeed) {
                                    projectile.speed += acceleration;
                                }
                                projectile.sprite.x += projectile.speed * elapsedTime;
                            }
                            if (!projectile.hasImpact && projectile.willImpact &&
                                projectile.sprite.x >= projectile.impactX) {
                                if (params.triggerEffect && !hasTriggeredEffect) {
                                    hasTriggeredEffect = true;
                                    params.triggerEffect();
                                }
                                projectile.hasImpact = true;
                                var impactTextures = Rance.getRandomArrayItem(props.impactTextures);
                                var impactClip = new PIXI.extras.MovieClip(impactTextures);
                                impactClip.anchor = new PIXI.Point(0.5, 0.5);
                                impactClip.loop = false;
                                impactClip.position = projectile.sprite.position;
                                container.removeChild(projectile.sprite);
                                container.addChild(impactClip);
                                impactClip.play();
                            }
                        }
                        if (currentTime < endTime) {
                            requestAnimationFrame(animate);
                        }
                        else {
                            params.triggerEnd();
                        }
                    }
                    params.triggerStart(container);
                    animate();
                }
                BattleSFXFunctions.projectileAttack = projectileAttack;
            })(BattleSFXFunctions = DefaultModule.BattleSFXFunctions || (DefaultModule.BattleSFXFunctions = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
/// <reference path="projectileattack.ts" />
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var BattleSFXFunctions;
            (function (BattleSFXFunctions) {
                function rocketAttack(params) {
                    var explosionTextures = [];
                    for (var i = 0; i < 26; i++) {
                        var explosionTexture = PIXI.Texture.fromFrame("Explosion_Sequence_A " + (i + 1) + '.png');
                        explosionTextures.push(explosionTexture);
                    }
                    var props = {
                        projectileTextures: [PIXI.Texture.fromFrame("modules\/default\/img\/battleEffects\/rocket.png")],
                        impactTextures: [explosionTextures],
                        maxSpeed: 3,
                        acceleration: 0.05,
                        amountToSpawn: {
                            min: 20,
                            max: 20
                        },
                        impactRate: 5
                    };
                    return BattleSFXFunctions.projectileAttack(props, params);
                }
                BattleSFXFunctions.rocketAttack = rocketAttack;
            })(BattleSFXFunctions = DefaultModule.BattleSFXFunctions || (DefaultModule.BattleSFXFunctions = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var BattleSFXFunctions;
            (function (BattleSFXFunctions) {
                function guard(props) {
                    var userCanvasWidth = props.width * 0.4; // TODO BattleSFX
                    var maxFrontier = userCanvasWidth;
                    var baseTrailDistance = 80;
                    var maxTrailDistance = maxFrontier;
                    var trailDistanceGrowth = maxTrailDistance - baseTrailDistance;
                    var maxBlockWidth = maxFrontier * 2;
                    var uniforms = {
                        frontier: {
                            type: "1f",
                            value: 0
                        },
                        trailDistance: {
                            type: "1f",
                            value: baseTrailDistance
                        },
                        seed: {
                            type: "1f",
                            value: Math.random() * 420
                        },
                        blockSize: {
                            type: "1f",
                            value: 90
                        },
                        blockWidth: {
                            type: "1f",
                            value: 0
                        },
                        lineAlpha: {
                            type: "1f",
                            value: 1.5
                        },
                        blockAlpha: {
                            type: "1f",
                            value: 0
                        }
                    };
                    var travelTime = 0.2;
                    var hasTriggeredEffect = false;
                    var syncUniformsFN = function (time) {
                        if (time < travelTime) {
                            var adjustedtime = time / travelTime;
                            uniforms.frontier.value = maxFrontier * adjustedtime;
                        }
                        else {
                            if (props.triggerEffect && !hasTriggeredEffect) {
                                hasTriggeredEffect = true;
                                props.triggerEffect();
                            }
                            var adjustedtime = Rance.getRelativeValue(time, travelTime - 0.02, 1);
                            adjustedtime = Math.pow(adjustedtime, 4);
                            uniforms.trailDistance.value = baseTrailDistance + trailDistanceGrowth * adjustedtime;
                            uniforms.blockWidth.value = adjustedtime * maxBlockWidth;
                            uniforms.lineAlpha.value = (1 - adjustedtime) * 1.5;
                            var relativeDistance = Rance.getRelativeValue(Math.abs(0.2 - adjustedtime), 0, 0.8);
                            uniforms.blockAlpha.value = 1 - relativeDistance;
                        }
                    };
                    var guardFilter = new Rance.GuardFilter(uniforms);
                    var container = new PIXI.Container();
                    container.filters = [guardFilter];
                    container.filterArea = new PIXI.Rectangle(0, 0, maxFrontier + 20, props.height);
                    var renderTexture = new PIXI.RenderTexture(props.renderer, props.width, props.height);
                    var sprite = new PIXI.Sprite(renderTexture);
                    if (!props.facingRight) {
                        sprite.x = props.width;
                        sprite.scale.x = -1;
                    }
                    function animate() {
                        var elapsedTime = Date.now() - startTime;
                        var relativeTime = elapsedTime / props.duration;
                        syncUniformsFN(relativeTime);
                        renderTexture.clear();
                        renderTexture.render(container);
                        if (elapsedTime < props.duration) {
                            requestAnimationFrame(animate);
                        }
                        else {
                            props.triggerEnd();
                        }
                    }
                    props.triggerStart(sprite);
                    var startTime = Date.now();
                    animate();
                }
                BattleSFXFunctions.guard = guard;
            })(BattleSFXFunctions = DefaultModule.BattleSFXFunctions || (DefaultModule.BattleSFXFunctions = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
/// <reference path="../../../lib/proton.d.ts" />
/// <reference path="../../../lib/pixi.d.ts" />
// Proton.Rate(amountOfParticlesPerEmit, timeBetweenEmits)
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var ProtonWrapper = (function () {
                function ProtonWrapper(renderer, container) {
                    // emitters: Proton.Emitter[];
                    this.emitters = {};
                    this.emitterKeysByID = {};
                    this.onSpriteCreated = {};
                    this.proton = new Proton();
                    this.pixiRenderer = renderer;
                    this.container = container;
                    this.initProtonRenderer();
                }
                ProtonWrapper.prototype.destroy = function () {
                    this.pixiRenderer = null;
                    for (var key in this.emitters) {
                        this.removeEmitterWithKey(key);
                    }
                    this.emitters = {};
                    this.protonRenderer.stop(); // start() initializes renderer, stop() destroys it
                    this.proton.destroy();
                    this.proton = null;
                };
                ProtonWrapper.prototype.initProtonRenderer = function () {
                    var renderer = this.protonRenderer = new Proton.Renderer("other", this.proton);
                    // TODO performance | .bind might be too much un-needed overhead
                    renderer.onParticleCreated = this.onProtonParticleCreated.bind(this);
                    renderer.onParticleUpdate = this.onProtonParticleUpdated.bind(this);
                    renderer.onParticleDead = this.onProtonParticleDead.bind(this);
                    renderer.start(); // start() initializes renderer, stop() destroys it
                };
                ProtonWrapper.prototype.onProtonParticleCreated = function (particle) {
                    var sprite = new PIXI.Sprite(particle.target);
                    sprite.anchor.x = 0.5;
                    sprite.anchor.y = 0.5;
                    particle.sprite = sprite;
                    var emitter = particle.parent;
                    var emitterKey = this.emitterKeysByID[emitter.id];
                    if (this.onSpriteCreated[emitterKey]) {
                        this.onSpriteCreated[emitterKey](sprite);
                    }
                    this.container.addChild(sprite);
                };
                ProtonWrapper.prototype.onProtonParticleUpdated = function (particle) {
                    var sprite = particle.sprite;
                    sprite.position.x = particle.p.x;
                    sprite.position.y = particle.p.y;
                    sprite.scale.x = particle.scale;
                    sprite.scale.y = particle.scale;
                    sprite.alpha = particle.alpha;
                    sprite.rotation = particle.rotation * PIXI.DEG_TO_RAD;
                    // todo update other transforms
                };
                ProtonWrapper.prototype.onProtonParticleDead = function (particle) {
                    this.container.removeChild(particle.sprite);
                };
                ProtonWrapper.prototype.destroyEmitter = function (emitter) {
                    emitter.stopEmit();
                    emitter.removeAllParticles();
                    emitter.destroy();
                };
                ProtonWrapper.prototype.addEmitter = function (emitter, key) {
                    this.emitters[key] = emitter;
                    this.emitterKeysByID[emitter.id] = key;
                    this.proton.addEmitter(emitter);
                };
                ProtonWrapper.prototype.getEmitterKeyWithID = function (id) {
                    return this.emitterKeysByID[id];
                };
                ProtonWrapper.prototype.getEmitterKey = function (emitter) {
                    return this.getEmitterKeyWithID(emitter.id) || null;
                };
                ProtonWrapper.prototype.removeEmitterWithKey = function (key) {
                    var emitter = this.emitters[key];
                    this.destroyEmitter(emitter);
                    this.emitterKeysByID[emitter.id] = null;
                    delete this.emitterKeysByID[emitter.id];
                    this.emitters[key] = null;
                    delete this.emitters[key];
                };
                ProtonWrapper.prototype.removeEmitter = function (emitter) {
                    this.removeEmitterWithKey(this.getEmitterKey(emitter));
                };
                ProtonWrapper.prototype.addInitializeToExistingParticles = function (emitter, initialize) {
                    emitter.particles.forEach(function (particle) {
                        initialize.initialize(particle);
                    });
                    emitter.addInitialize(initialize);
                };
                ProtonWrapper.prototype.update = function () {
                    this.proton.update();
                };
                return ProtonWrapper;
            }());
            DefaultModule.ProtonWrapper = ProtonWrapper;
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var UniformSyncer = (function () {
        function UniformSyncer(uniformTypes, updaterFunction) {
            this.uniformTypes = uniformTypes;
            this.updaterFunction = updaterFunction;
            this.initUniforms(uniformTypes);
        }
        UniformSyncer.prototype.initUniforms = function (uniformTypes) {
            this.uniforms = {};
            for (var key in uniformTypes) {
                this.uniforms[key] =
                    {
                        type: uniformTypes[key],
                        value: undefined
                    };
            }
        };
        UniformSyncer.prototype.sync = function (time) {
            var newValues = this.updaterFunction(time);
            for (var key in newValues) {
                this.uniforms[key].value = newValues[key];
            }
        };
        UniformSyncer.prototype.set = function (key, value) {
            this.uniforms[key].value = value;
        };
        UniformSyncer.prototype.getUniformsObject = function () {
            return this.uniforms;
        };
        UniformSyncer.prototype.makeClone = function () {
            return new UniformSyncer(this.uniformTypes, this.updaterFunction);
        };
        return UniformSyncer;
    }());
    Rance.UniformSyncer = UniformSyncer;
})(Rance || (Rance = {}));
/// <reference path="protonwrapper.ts" />
/// <reference path="uniformsyncer.ts" />
var Rance;
(function (Rance) {
    // TODO temporary
    function drawEasingFunctionGraph(easingFunction) {
        var canvas = document.createElement("canvas");
        canvas.width = 180;
        canvas.height = 100;
        var context = canvas.getContext("2d");
        context.fillStyle = "rgb(250,250,250)";
        context.fillRect(0, 0, 180, 100);
        context.lineWidth = 0.5;
        context.strokeStyle = "rgb(230,230,230)";
        context.beginPath();
        context.moveTo(0, 20);
        context.lineTo(180, 20);
        context.moveTo(0, 80);
        context.lineTo(180, 80);
        context.closePath();
        context.stroke();
        context.lineWidth = 2;
        context.strokeStyle = "rgb(255,127,127)";
        context.beginPath();
        context.moveTo(5, 80);
        var resolution = 100;
        for (var i = 0; i < resolution; i++) {
            var x = i / resolution;
            var y = easingFunction(x);
            var canvasX = 5 + x * (canvas.width - 10);
            var canvasY = 80 - y * (canvas.height - 40);
            context.lineTo(canvasX, canvasY);
        }
        context.stroke();
        document.body.appendChild(canvas);
    }
    Rance.drawEasingFunctionGraph = drawEasingFunctionGraph;
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var BattleSFXFunctions;
            (function (BattleSFXFunctions) {
                // TODO refactor | move shaders
                var ShinyParticleFilter = (function (_super) {
                    __extends(ShinyParticleFilter, _super);
                    function ShinyParticleFilter(uniforms) {
                        _super.call(this, null, Rance.ShaderSources.shinyparticle.join("\n"), uniforms);
                    }
                    ShinyParticleFilter.getUniformTypes = function () {
                        return ({
                            spikeColor: "4fv",
                            spikeIntensity: "1f",
                            highlightIntensity: "1f"
                        });
                    };
                    return ShinyParticleFilter;
                }(PIXI.AbstractFilter));
                BattleSFXFunctions.ShinyParticleFilter = ShinyParticleFilter;
                var LightBurstFilter = (function (_super) {
                    __extends(LightBurstFilter, _super);
                    function LightBurstFilter(uniforms) {
                        _super.call(this, null, Rance.ShaderSources.lightburst.join("\n"), uniforms);
                    }
                    LightBurstFilter.getUniformTypes = function () {
                        return ({
                            seed: "2fv",
                            rotation: "1f",
                            rayStrength: "1f",
                            raySharpness: "1f",
                            rayColor: "4fv",
                            centerSize: "1f",
                            centerBloomStrength: "1f"
                        });
                    };
                    return LightBurstFilter;
                }(PIXI.AbstractFilter));
                BattleSFXFunctions.LightBurstFilter = LightBurstFilter;
                var IntersectingEllipsesFilter = (function (_super) {
                    __extends(IntersectingEllipsesFilter, _super);
                    function IntersectingEllipsesFilter(uniforms) {
                        _super.call(this, null, Rance.ShaderSources.intersectingellipses.join("\n"), uniforms);
                    }
                    IntersectingEllipsesFilter.getUniformTypes = function () {
                        return ({
                            mainColor: "4fv",
                            mainAlpha: "1f",
                            intersectingEllipseCenter: "2fv",
                            intersectingEllipseSize: "2fv",
                            intersectingEllipseSharpness: "1f",
                            mainEllipseSize: "2fv",
                            mainEllipseSharpness: "1f"
                        });
                    };
                    return IntersectingEllipsesFilter;
                }(PIXI.AbstractFilter));
                BattleSFXFunctions.IntersectingEllipsesFilter = IntersectingEllipsesFilter;
                var BeamFilter = (function (_super) {
                    __extends(BeamFilter, _super);
                    function BeamFilter(uniforms) {
                        _super.call(this, null, Rance.ShaderSources.beam.join("\n"), uniforms);
                    }
                    BeamFilter.getUniformTypes = function () {
                        return ({
                            aspectRatio: "1f",
                            beamColor: "4fv",
                            lineIntensity: "1f",
                            bulgeIntensity: "1f",
                            bulgeXPosition: "1f",
                            bulgeSize: "2fv",
                            bulgeSharpness: "1f",
                            lineXSize: "2fv",
                            lineXSharpness: "1f",
                            lineYSize: "1f",
                            lineYSharpness: "1f"
                        });
                    };
                    return BeamFilter;
                }(PIXI.AbstractFilter));
                BattleSFXFunctions.BeamFilter = BeamFilter;
                function particleTest(props) {
                    //----------INIT GENERAL
                    var width2 = props.width / 2;
                    var height2 = props.height / 2;
                    var mainContainer = new PIXI.Container();
                    var bg = new PIXI.Graphics();
                    bg.beginFill(0x000000);
                    bg.drawRect(0, 0, props.width, props.height);
                    bg.endFill();
                    bg.alpha = 1.0;
                    // mainContainer.addChild(bg);
                    var impactHasOccurred = false;
                    var relativeImpactTime = 0.24;
                    var beamOrigin = {
                        x: 100,
                        y: props.height * 0.66
                    };
                    var relativeBeamOrigin = {
                        x: beamOrigin.x / props.width,
                        y: beamOrigin.y / props.height
                    };
                    var renderTexture = new PIXI.RenderTexture(props.renderer, props.width, props.height);
                    var renderedSprite = new PIXI.Sprite(renderTexture);
                    if (!props.facingRight) {
                        renderedSprite.x = props.width;
                        renderedSprite.scale.x = -1;
                    }
                    var finalColor = [
                        0.368627450980392,
                        0.792156862745098,
                        0.694117647058823,
                        1.0
                    ];
                    //----------INIT PARTICLES
                    var particleContainer = new PIXI.Container();
                    // particleContainer.alpha = 0.1;
                    mainContainer.addChild(particleContainer);
                    var protonWrapper = new DefaultModule.ProtonWrapper(props.renderer, particleContainer);
                    var particleShaderColor = {
                        r: 1.0,
                        g: 1.0,
                        b: 1.0,
                        a: 1.0
                    };
                    var particleShaderColorArray = [
                        particleShaderColor.r,
                        particleShaderColor.g,
                        particleShaderColor.b,
                        particleShaderColor.a
                    ];
                    var particleShaderColorTween = new TWEEN.Tween(particleShaderColor).to({
                        r: finalColor[0],
                        g: finalColor[1],
                        b: finalColor[2],
                        a: 1.0
                    }, props.duration / 2);
                    var particlesAmountScale = props.width / 700;
                    //----------INIT BEAM
                    var beamSpriteSize = {
                        x: props.width,
                        y: props.height
                    };
                    var beamUniforms = new Rance.UniformSyncer(BeamFilter.getUniformTypes(), function (time) {
                        var rampUpValue = Math.min(time / relativeImpactTime, 1.0);
                        rampUpValue = Math.pow(rampUpValue, 7.0);
                        var timeAfterImpact = Math.max(time - relativeImpactTime, 0.0);
                        var relativeTimeAfterImpact = Rance.getRelativeValue(timeAfterImpact, 0.0, 1.0 - relativeImpactTime);
                        var rampDownValue = Math.min(Math.pow(relativeTimeAfterImpact * 1.2, 12.0), 1.0);
                        var beamIntensity = rampUpValue - rampDownValue;
                        return ({
                            lineIntensity: 2.0 + 3.0 * beamIntensity,
                            bulgeIntensity: 6.0 * beamIntensity,
                            bulgeSize: [
                                0.7 * Math.pow(beamIntensity, 1.5),
                                0.4 * Math.pow(beamIntensity, 1.5)
                            ],
                            bulgeSharpness: 0.3 + 0.35 * beamIntensity,
                            lineXSize: [
                                relativeBeamOrigin.x * rampUpValue,
                                1.0
                            ],
                            lineXSharpness: 0.99 - beamIntensity * 0.99,
                            lineYSize: 0.001 + beamIntensity * 0.03,
                            lineYSharpness: 0.99 - beamIntensity * 0.15 + 0.01 * rampDownValue
                        });
                    });
                    beamUniforms.set("beamColor", finalColor);
                    beamUniforms.set("aspectRatio", beamSpriteSize.x / beamSpriteSize.y);
                    beamUniforms.set("bulgeXPosition", relativeBeamOrigin.x + 0.1);
                    var beamFilter = new BeamFilter(beamUniforms.getUniformsObject());
                    var beamSprite = Rance.createDummySpriteForShader(0, beamOrigin.y - beamSpriteSize.y / 2, beamSpriteSize.x, beamSpriteSize.y);
                    beamSprite.shader = beamFilter;
                    beamSprite.blendMode = PIXI.BLEND_MODES.SCREEN;
                    mainContainer.addChild(beamSprite);
                    //----------INIT SMALL EMITTER
                    var smallEmitter = new Proton.BehaviourEmitter();
                    smallEmitter.p.x = beamOrigin.x + 50;
                    smallEmitter.p.y = beamOrigin.y;
                    smallEmitter.damping = 0.013;
                    var smallParticleGraphicsSize = {
                        x: 4,
                        y: 4
                    };
                    var smallParticleGraphics = new PIXI.Graphics();
                    smallParticleGraphics.beginFill(0x5ECAB1, 1.0);
                    smallParticleGraphics.drawRect(smallParticleGraphicsSize.x / 2, smallParticleGraphicsSize.y / 2, smallParticleGraphicsSize.x, smallParticleGraphicsSize.y);
                    smallParticleGraphics.endFill();
                    var smallParticleTexture = smallParticleGraphics.generateTexture(props.renderer, 1, PIXI.SCALE_MODES.DEFAULT, new PIXI.Rectangle(0, 0, smallParticleGraphicsSize.x * 1.5, smallParticleGraphicsSize.y * 1.5));
                    smallEmitter.addInitialize(new Proton.ImageTarget(smallParticleTexture));
                    smallEmitter.addInitialize(new Proton.Velocity(new Proton.Span(2.5, 3.5), new Proton.Span(270, 35, true), 'polar'));
                    smallEmitter.addInitialize(new Proton.Position(new Proton.RectZone(0, -30, props.width + 100 - smallEmitter.p.x, 30)));
                    smallEmitter.addInitialize(new Proton.Life(new Proton.Span(props.duration * (1.0 - relativeImpactTime) / 6000, props.duration * (1.0 - relativeImpactTime) / 3000)));
                    smallEmitter.addBehaviour(new Proton.Scale(new Proton.Span(0.8, 1), 0));
                    smallEmitter.addBehaviour(new Proton.Alpha(1, 0));
                    smallEmitter.addBehaviour(new Proton.RandomDrift(20, 30, props.duration / 2000));
                    protonWrapper.addEmitter(smallEmitter, "smallParticles");
                    var smallParticleUniforms = new Rance.UniformSyncer(ShinyParticleFilter.getUniformTypes(), function (time) {
                        var lifeLeft = 1.0 - time;
                        return ({
                            spikeColor: particleShaderColorArray,
                            spikeIntensity: Math.pow(lifeLeft, 1.5) * 0.4,
                            highlightIntensity: Math.pow(lifeLeft, 1.5)
                        });
                    });
                    var smallParticleFilter = new ShinyParticleFilter(smallParticleUniforms.getUniformsObject());
                    protonWrapper.onSpriteCreated["smallParticles"] = function (sprite) {
                        sprite.shader = smallParticleFilter;
                        sprite.blendMode = PIXI.BLEND_MODES.SCREEN;
                    };
                    //----------INIT SHINY EMITTER
                    var shinyEmitter = new Proton.BehaviourEmitter();
                    shinyEmitter.p.x = beamOrigin.x;
                    shinyEmitter.p.y = beamOrigin.y;
                    var shinyParticleTexture = Rance.getDummyTextureForShader();
                    shinyEmitter.addInitialize(new Proton.ImageTarget(shinyParticleTexture));
                    var shinyEmitterLifeInitialize = new Proton.Life(new Proton.Span(props.duration / 3000, props.duration / 1000));
                    shinyEmitter.addInitialize(shinyEmitterLifeInitialize);
                    shinyEmitter.damping = 0.009;
                    var emitterZone = new Proton.RectZone(0, -5, props.width + 100 - shinyEmitter.p.x, 5);
                    shinyEmitter.addInitialize(new Proton.Position(emitterZone));
                    shinyEmitter.addBehaviour(new Proton.Scale(new Proton.Span(60, 100), 0));
                    shinyEmitter.addBehaviour(new Proton.Alpha(1, 0));
                    // shinyEmitter.addBehaviour(new Proton.RandomDrift(5, 10, 0.3));
                    protonWrapper.addEmitter(shinyEmitter, "shinyParticles");
                    var shinyParticleUniforms = new Rance.UniformSyncer(ShinyParticleFilter.getUniformTypes(), function (time) {
                        var lifeLeft = 1.0 - time;
                        return ({
                            spikeColor: particleShaderColorArray,
                            spikeIntensity: 1 - time * 0.1,
                            highlightIntensity: Math.pow(lifeLeft, 2.0)
                        });
                    });
                    var shinyParticleFilter = new ShinyParticleFilter(shinyParticleUniforms.getUniformsObject());
                    protonWrapper.onSpriteCreated["shinyParticles"] = function (sprite) {
                        sprite.shader = shinyParticleFilter;
                        sprite.blendMode = PIXI.BLEND_MODES.SCREEN;
                    };
                    shinyEmitter.rate = new Proton.Rate(150 * particlesAmountScale, // particles per emit
                    0 // time between emits in seconds
                    );
                    shinyEmitter.emit("once");
                    //----------INIT SHOCKWAVE
                    var shockWaveMainEllipseMaxSize = {
                        x: 0.3,
                        y: 0.9
                    };
                    var shockWaveIntersectingEllipseMaxSize = {
                        x: 0.8,
                        y: 1.0
                    };
                    var shockWaveUniforms = new Rance.UniformSyncer(IntersectingEllipsesFilter.getUniformTypes(), function (time) {
                        var burstX;
                        if (time < (relativeImpactTime - 0.02)) {
                            burstX = 0;
                        }
                        else {
                            burstX = time - (relativeImpactTime - 0.02);
                        }
                        var shockWaveSize = TWEEN.Easing.Quintic.Out(burstX);
                        return ({
                            mainEllipseSize: [
                                shockWaveMainEllipseMaxSize.x * shockWaveSize,
                                shockWaveMainEllipseMaxSize.y * shockWaveSize
                            ],
                            intersectingEllipseSize: [
                                shockWaveIntersectingEllipseMaxSize.x * shockWaveSize,
                                shockWaveIntersectingEllipseMaxSize.y * shockWaveSize
                            ],
                            intersectingEllipseCenter: [
                                0.05 + 0.3 * shockWaveSize,
                                0.0
                            ],
                            mainEllipseSharpness: 0.8 + 0.18 * (1.0 - shockWaveSize),
                            intersectingEllipseSharpness: 0.4 + 0.4 * (1.0 - shockWaveSize),
                            mainAlpha: 1.0 - shockWaveSize
                        });
                    });
                    shockWaveUniforms.set("mainColor", [1, 1, 1, 1]);
                    var shockWaveFilter = new IntersectingEllipsesFilter(shockWaveUniforms.getUniformsObject());
                    var shockWaveSpriteSize = {
                        x: props.height * 3.0,
                        y: props.height * 3.0
                    };
                    var shockWaveSprite = Rance.createDummySpriteForShader(beamOrigin.x - (shockWaveSpriteSize.x / 2 * 1.04), beamOrigin.y - shockWaveSpriteSize.y / 2, shockWaveSpriteSize.x, shockWaveSpriteSize.y);
                    shockWaveSprite.shader = shockWaveFilter;
                    // shockWaveSprite.blendMode = PIXI.BLEND_MODES.SCREEN;
                    mainContainer.addChild(shockWaveSprite);
                    //----------INIT LIGHTBURST
                    var lightBurstUniforms = new Rance.UniformSyncer(LightBurstFilter.getUniformTypes(), function (time) {
                        var rampUpValue = Math.min(time / relativeImpactTime, 1.0);
                        rampUpValue = Math.pow(rampUpValue, 7.0);
                        var timeAfterImpact = Math.max(time - relativeImpactTime, 0.0);
                        var rampDownValue = Math.pow(timeAfterImpact * 5.0, 2.0);
                        var lightBurstIntensity = Math.max(rampUpValue - rampDownValue, 0.0);
                        return ({
                            centerSize: Math.pow(lightBurstIntensity, 2.0),
                            centerBloomStrength: Math.pow(lightBurstIntensity, 2.0) * 5.0,
                            rayStrength: Math.pow(lightBurstIntensity, 3.0)
                        });
                    });
                    lightBurstUniforms.set("seed", [Math.random() * 69, Math.random() * 420]);
                    lightBurstUniforms.set("rotation", 0.0);
                    lightBurstUniforms.set("raySharpness", 2.0);
                    lightBurstUniforms.set("rayColor", [0.75, 0.75, 0.62, 1.0]);
                    var lightBurstFilter = new LightBurstFilter(lightBurstUniforms.getUniformsObject());
                    var lightBurstSize = {
                        x: props.height * 1.5,
                        y: props.height * 3
                    };
                    var lightBurstSprite = Rance.createDummySpriteForShader(beamOrigin.x - lightBurstSize.x / 2, beamOrigin.y - lightBurstSize.y / 2, lightBurstSize.x, lightBurstSize.y);
                    lightBurstSprite.shader = lightBurstFilter;
                    lightBurstSprite.blendMode = PIXI.BLEND_MODES.SCREEN;
                    mainContainer.addChild(lightBurstSprite);
                    //----------ANIMATE
                    function animate() {
                        var elapsedTime = Date.now() - startTime;
                        protonWrapper.update();
                        var tweenTime = window.performance.now();
                        particleShaderColorTween.update(tweenTime);
                        particleShaderColorArray[0] = particleShaderColor.r;
                        particleShaderColorArray[1] = particleShaderColor.g;
                        particleShaderColorArray[2] = particleShaderColor.b;
                        particleShaderColorArray[3] = particleShaderColor.a;
                        var timePassed = elapsedTime / props.duration;
                        var lifeLeft = 1 - timePassed;
                        var timePassedSinceImpact = Rance.getRelativeValue(timePassed, relativeImpactTime, 1.0);
                        if (timePassed >= relativeImpactTime - 0.02) {
                            if (!impactHasOccurred) {
                                impactHasOccurred = true;
                                var lifeLeftInSeconds = props.duration * lifeLeft / 1000;
                                var emitterLife = lifeLeftInSeconds * 0.8;
                                var velocityInitialize = new Proton.Velocity(new Proton.Span(1.5, 3), new Proton.Span(270, 25, true), 'polar');
                                protonWrapper.addInitializeToExistingParticles(shinyEmitter, velocityInitialize);
                                shinyEmitter.removeInitialize(shinyEmitterLifeInitialize);
                                shinyEmitter.addInitialize(new Proton.Life(new Proton.Span(emitterLife / 4, emitterLife / 2.5)));
                                shinyEmitter.rate = new Proton.Rate(4 * particlesAmountScale, 0.02);
                                shinyEmitter.life = emitterLife;
                                shinyEmitter.emit();
                                smallEmitter.rate = new Proton.Rate(6 * particlesAmountScale, 0.02);
                                smallEmitter.life = emitterLife;
                                smallEmitter.emit();
                                props.triggerEffect();
                            }
                            smallParticleUniforms.sync(timePassed);
                        }
                        beamUniforms.sync(timePassed);
                        shinyParticleUniforms.sync(timePassed);
                        lightBurstUniforms.sync(timePassed);
                        shockWaveUniforms.sync(timePassed);
                        renderTexture.clear();
                        renderTexture.render(mainContainer);
                        if (elapsedTime < props.duration) {
                            requestAnimationFrame(animate);
                        }
                        else {
                            smallParticleTexture.destroy(true);
                            protonWrapper.destroy();
                            props.triggerEnd();
                        }
                    }
                    props.triggerStart(renderedSprite);
                    var startTime = Date.now();
                    particleShaderColorTween.start();
                    animate();
                }
                BattleSFXFunctions.particleTest = particleTest;
            })(BattleSFXFunctions = DefaultModule.BattleSFXFunctions || (DefaultModule.BattleSFXFunctions = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
/// <reference path="../../../src/templateinterfaces/ibattlesfxtemplate.d.ts"/>
/// <reference path="../../../src/templateinterfaces/sfxparams.d.ts"/>
/// <reference path="../graphics/rocketattack.ts" />
/// <reference path="../graphics/guard.ts" />
/// <reference path="../graphics/particletest.ts" />
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            // TODO refactor | move shaders
            var BlackToAlphaFilter = (function (_super) {
                __extends(BlackToAlphaFilter, _super);
                function BlackToAlphaFilter() {
                    _super.call(this, null, Rance.ShaderSources.blacktoalpha.join("\n"), null);
                }
                return BlackToAlphaFilter;
            }(PIXI.AbstractFilter));
            DefaultModule.BlackToAlphaFilter = BlackToAlphaFilter;
            var Templates;
            (function (Templates) {
                var BattleSFX;
                (function (BattleSFX) {
                    BattleSFX.rocketAttack = {
                        duration: 1500,
                        battleOverlay: DefaultModule.BattleSFXFunctions.rocketAttack,
                        SFXWillTriggerEffect: true
                    };
                    BattleSFX.guard = {
                        duration: 1000,
                        battleOverlay: DefaultModule.BattleSFXFunctions.guard,
                        SFXWillTriggerEffect: true
                    };
                    BattleSFX.particleTest = {
                        duration: 3000,
                        battleOverlay: DefaultModule.BattleSFXFunctions.particleTest,
                        SFXWillTriggerEffect: true
                    };
                    BattleSFX.videoTest = {
                        duration: 1000,
                        battleOverlay: DefaultModule.BattleSFXFunctions.makeSFXFromVideo.bind(null, "img/bushiAttack.webm", function (sprite) {
                            sprite.blendMode = PIXI.BLEND_MODES.SCREEN;
                            sprite.shader = new BlackToAlphaFilter();
                        }),
                        SFXWillTriggerEffect: true
                    };
                })(BattleSFX = Templates.BattleSFX || (Templates.BattleSFX = {}));
            })(Templates = DefaultModule.Templates || (DefaultModule.Templates = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
/// <reference path="../graphics/makesfxfromvideo.ts"/>
/// <reference path="../../../src/templateinterfaces/sfxparams.d.ts"/>
/// <reference path="../../../src/templateinterfaces/iabilitytemplate.d.ts"/>
/// <reference path="../../../src/templateinterfaces/iabilitytemplateeffect.d.ts"/>
/// <reference path="effects.ts" />
/// <reference path="battlesfx.ts" />
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var Templates;
            (function (Templates) {
                var Abilities;
                (function (Abilities) {
                    Abilities.rangedAttack = {
                        type: "rangedAttack",
                        displayName: "Ranged Attack",
                        description: "Standard ranged attack",
                        moveDelay: 100,
                        actionsUse: 1,
                        mainEffect: {
                            template: Templates.Effects.singleTargetDamage,
                            sfx: Templates.BattleSFX.rocketAttack,
                            data: {
                                baseDamage: 1,
                                damageType: Rance.DamageType.physical
                            },
                            attachedEffects: [
                                {
                                    template: Templates.Effects.receiveCounterAttack,
                                    data: {
                                        baseDamage: 0.5
                                    }
                                }
                            ]
                        },
                        canUpgradeInto: ["bombAttack", "boardingHook", "ranceAttack"]
                    };
                    Abilities.closeAttack = {
                        type: "closeAttack",
                        displayName: "Close Attack",
                        description: "Close range attack that hits adjacent targets in same row as well",
                        moveDelay: 90,
                        actionsUse: 2,
                        mainEffect: {
                            template: Templates.Effects.closeAttack,
                            sfx: Templates.BattleSFX.rocketAttack
                        }
                    };
                    Abilities.wholeRowAttack = {
                        type: "wholeRowAttack",
                        displayName: "Row Attack",
                        description: "Attack entire row of units",
                        moveDelay: 300,
                        actionsUse: 1,
                        bypassesGuard: true,
                        mainEffect: {
                            template: Templates.Effects.wholeRowAttack,
                            sfx: Templates.BattleSFX.particleTest
                        }
                    };
                    Abilities.bombAttack = {
                        type: "bombAttack",
                        displayName: "Bomb Attack",
                        description: "Ranged attack that hits all adjacent enemy units",
                        moveDelay: 120,
                        actionsUse: 1,
                        mainEffect: {
                            template: Templates.Effects.bombAttack,
                            sfx: Templates.BattleSFX.rocketAttack
                        }
                    };
                    Abilities.guardRow = {
                        type: "guardRow",
                        displayName: "Guard Row",
                        description: "Protect allies in the same row and boost defence up to 2x",
                        moveDelay: 100,
                        actionsUse: 1,
                        mainEffect: {
                            template: Templates.Effects.guardRow,
                            sfx: Templates.BattleSFX.guard,
                            data: {
                                perInt: 20
                            }
                        }
                    };
                    Abilities.guardColumn = Abilities.guardRow; // legacy alias 10.3.2016
                    Abilities.boardingHook = {
                        type: "boardingHook",
                        displayName: "Boarding Hook",
                        description: "0.8x damage but increases target capture chance",
                        moveDelay: 100,
                        actionsUse: 1,
                        mainEffect: {
                            template: Templates.Effects.singleTargetDamage,
                            sfx: Templates.BattleSFX.rocketAttack,
                            data: {
                                baseDamage: 0.8,
                                damageType: Rance.DamageType.physical
                            },
                            attachedEffects: [
                                {
                                    template: Templates.Effects.increaseCaptureChance,
                                    data: {
                                        flat: 0.5
                                    }
                                },
                                {
                                    template: Templates.Effects.receiveCounterAttack,
                                    data: {
                                        baseDamage: 0.5
                                    }
                                }
                            ]
                        }
                    };
                    Abilities.debugAbility = {
                        type: "debugAbility",
                        displayName: "Debug Ability",
                        description: "who knows what its going to do today",
                        moveDelay: 0,
                        actionsUse: 1,
                        mainEffect: {
                            template: Templates.Effects.buffTest,
                            sfx: Templates.BattleSFX.guard,
                            data: {}
                        }
                    };
                    Abilities.ranceAttack = {
                        type: "ranceAttack",
                        displayName: "Rance attack",
                        description: "dont sue",
                        moveDelay: 0,
                        actionsUse: 0,
                        mainEffect: {
                            template: Templates.Effects.singleTargetDamage,
                            sfx: {
                                duration: 1200,
                                userSprite: function (props) {
                                    // cg13600.bmp
                                    return PIXI.Sprite.fromImage("img\/battleEffects\/ranceAttack2.png");
                                }
                            },
                            data: {
                                baseDamage: 0.1,
                                damageType: Rance.DamageType.physical
                            }
                        },
                        secondaryEffects: [
                            {
                                template: Templates.Effects.singleTargetDamage,
                                data: {
                                    baseDamage: 0.1,
                                    damageType: Rance.DamageType.physical
                                },
                                attachedEffects: [
                                    {
                                        template: Templates.Effects.receiveCounterAttack,
                                        data: {
                                            baseDamage: 0.5
                                        }
                                    }
                                ],
                                sfx: {
                                    duration: 1500,
                                    userSprite: function (props) {
                                        // cg13300.bmp
                                        return PIXI.Sprite.fromImage("img\/battleEffects\/ranceAttack.png");
                                    }
                                }
                            }
                        ],
                        onlyAllowExplicitUpgrade: true
                    };
                    Abilities.standBy = {
                        type: "standBy",
                        displayName: "Standby",
                        description: "Skip a turn but next one comes faster",
                        moveDelay: 50,
                        actionsUse: 1,
                        AIEvaluationPriority: 0.6,
                        AIScoreAdjust: -0.1,
                        disableInAIBattles: true,
                        mainEffect: {
                            template: Templates.Effects.standBy,
                            sfx: {
                                duration: 750
                            }
                        }
                    };
                })(Abilities = Templates.Abilities || (Templates.Abilities = {}));
            })(Templates = DefaultModule.Templates || (DefaultModule.Templates = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
/// <reference path="../../../src/templateinterfaces/iattitudemodifiertemplate.d.ts"/>
var Rance;
(function (Rance) {
    (function (AttitudeModifierFamily) {
        AttitudeModifierFamily[AttitudeModifierFamily["geographic"] = 0] = "geographic";
        AttitudeModifierFamily[AttitudeModifierFamily["history"] = 1] = "history";
        AttitudeModifierFamily[AttitudeModifierFamily["current"] = 2] = "current";
    })(Rance.AttitudeModifierFamily || (Rance.AttitudeModifierFamily = {}));
    var AttitudeModifierFamily = Rance.AttitudeModifierFamily;
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var Templates;
            (function (Templates) {
                var AttitudeModifiers;
                (function (AttitudeModifiers) {
                    AttitudeModifiers.neighborStars = {
                        type: "neighborStars",
                        displayName: "neighborStars",
                        family: AttitudeModifierFamily.geographic,
                        duration: -1,
                        startCondition: function (evaluation) {
                            return (evaluation.neighborStars >= 2 && evaluation.opinion < 50);
                        },
                        getEffectFromEvaluation: function (evaluation) {
                            return -2 * evaluation.neighborStars;
                        }
                    };
                    AttitudeModifiers.atWar = {
                        type: "atWar",
                        displayName: "At war",
                        family: AttitudeModifierFamily.current,
                        duration: -1,
                        startCondition: function (evaluation) {
                            return (evaluation.currentStatus >= Rance.DiplomaticState.war);
                        },
                        constantEffect: -30
                    };
                    AttitudeModifiers.declaredWar = {
                        type: "declaredWar",
                        displayName: "Declared war",
                        family: AttitudeModifierFamily.history,
                        duration: 15,
                        triggers: ["addDeclaredWarAttitudeModifier"],
                        constantEffect: -35
                    };
                })(AttitudeModifiers = Templates.AttitudeModifiers || (Templates.AttitudeModifiers = {}));
            })(Templates = DefaultModule.Templates || (DefaultModule.Templates = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
/// <reference path="../../../src/templateinterfaces/idefencebuildingtemplate.d.ts"/>
/// <reference path="../../../src/templateinterfaces/ibuildingtemplate.d.ts"/>
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var Templates;
            (function (Templates) {
                var Buildings;
                (function (Buildings) {
                    Buildings.sectorCommand = {
                        type: "sectorCommand",
                        category: "defence",
                        family: "sectorCommand",
                        displayName: "Sector Command",
                        description: "Defence building with slight defender advantage. (All defence buildings must " +
                            "be captured to gain control of area)",
                        iconSrc: "sectorCommand.png",
                        buildCost: 200,
                        maxPerType: 1,
                        maxUpgradeLevel: 1,
                        upgradeInto: [
                            {
                                templateType: "sectorCommand1",
                                level: 1
                            },
                            {
                                templateType: "sectorCommand2",
                                level: 1
                            }
                        ],
                        defenderAdvantage: 0.2
                    };
                    Buildings.sectorCommand1 = {
                        type: "sectorCommand1",
                        category: "defence",
                        family: "sectorCommand",
                        displayName: "Sector Command1",
                        description: "just testing upgrade paths",
                        iconSrc: "sectorCommand.png",
                        buildCost: 100,
                        maxPerType: 1,
                        maxUpgradeLevel: 1,
                        upgradeOnly: true,
                        defenderAdvantage: 0.3
                    };
                    Buildings.sectorCommand2 = {
                        type: "sectorCommand2",
                        category: "defence",
                        family: "sectorCommand",
                        displayName: "Sector Command2",
                        description: "just testing upgrade paths",
                        iconSrc: "sectorCommand.png",
                        buildCost: 200,
                        maxPerType: 1,
                        maxUpgradeLevel: 1,
                        upgradeOnly: true,
                        defenderAdvantage: 0.3
                    };
                    Buildings.starBase = {
                        type: "starBase",
                        category: "defence",
                        displayName: "Starbase",
                        description: "Defence building with no defender advantage. (All defence buildings must " +
                            "be captured to gain control of area)",
                        iconSrc: "starBase.png",
                        buildCost: 200,
                        maxPerType: 3,
                        maxUpgradeLevel: 1,
                        defenderAdvantage: 0.1,
                        upgradeInto: [
                            {
                                templateType: "sectorCommand",
                                level: 1
                            }
                        ]
                    };
                    Buildings.commercialPort = {
                        type: "commercialPort",
                        category: "economy",
                        displayName: "Commercial Spaceport",
                        description: "Increase star income by 20",
                        iconSrc: "commercialPort.png",
                        buildCost: 200,
                        maxPerType: 1,
                        effect: {
                            income: {
                                flat: 20
                            }
                        },
                        maxUpgradeLevel: 4
                    };
                    Buildings.deepSpaceRadar = {
                        type: "deepSpaceRadar",
                        category: "vision",
                        displayName: "Deep Space Radar",
                        description: "Increase star vision and detection radius",
                        iconSrc: "commercialPort.png",
                        buildCost: 200,
                        maxPerType: 1,
                        effect: {
                            vision: 1,
                            detection: 0.999
                        },
                        maxUpgradeLevel: 2
                    };
                    Buildings.resourceMine = {
                        type: "resourceMine",
                        category: "mine",
                        displayName: "Mine",
                        description: "Gathers resources from current star",
                        iconSrc: "commercialPort.png",
                        buildCost: 500,
                        maxPerType: 1,
                        effect: {
                            resourceIncome: {
                                flat: 1
                            }
                        },
                        maxUpgradeLevel: 3
                    };
                    Buildings.reserachLab = {
                        type: "reserachLab",
                        category: "research",
                        displayName: "Research Lab",
                        description: "Increase research speed",
                        iconSrc: "commercialPort.png",
                        buildCost: 300,
                        maxPerType: 1,
                        effect: {
                            research: {
                                flat: 10
                            }
                        },
                        maxUpgradeLevel: 3
                    };
                })(Buildings = Templates.Buildings || (Templates.Buildings = {}));
            })(Templates = DefaultModule.Templates || (DefaultModule.Templates = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
/// <reference path="../../../src/templateinterfaces/iculturetemplate.d.ts"/>
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var Templates;
            (function (Templates) {
                var Cultures;
                (function (Cultures) {
                    Cultures.badassCulture = {
                        key: "badassCulture",
                        nameGenerator: function (unit) {
                            var ownCulture = app.moduleData.Templates.Cultures["badassCulture"];
                            var title = Rance.getRandomProperty(ownCulture.firstNames).displayName;
                            return title + " " + unit.template.displayName;
                        },
                        firstNames: {
                            cool: {
                                key: "cool",
                                displayName: "Cool"
                            },
                            badass: {
                                key: "badass",
                                displayName: "Badass"
                            }
                        }
                    };
                })(Cultures = Templates.Cultures || (Templates.Cultures = {}));
            })(Templates = DefaultModule.Templates || (DefaultModule.Templates = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
/// <reference path="../../../src/templateinterfaces/ipassiveskilltemplate.d.ts"/>
/// <reference path="../../../src/templateinterfaces/ibattleprepeffect.d.ts"/>
/// <reference path="../../../src/templateinterfaces/iturnstarteffect.d.ts"/>
/// <reference path="abilities.ts" />
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var Templates;
            (function (Templates) {
                var PassiveSkills;
                (function (PassiveSkills) {
                    PassiveSkills.autoHeal = {
                        type: "autoHeal",
                        displayName: "Auto heal",
                        description: "Heal 50 health after every turn",
                        afterAbilityUse: [
                            {
                                template: Templates.Effects.healSelf,
                                data: {
                                    flat: 50
                                },
                                sfx: {
                                    duration: 1200
                                },
                                trigger: function (user, target) {
                                    return user.currentHealth < user.maxHealth;
                                }
                            }
                        ]
                    };
                    PassiveSkills.poisoned = {
                        type: "poisoned",
                        displayName: "Poisoned",
                        description: "-10% max health per turn",
                        afterAbilityUse: [
                            {
                                template: Templates.Effects.healSelf,
                                data: {
                                    maxHealthPercentage: -0.1
                                },
                                sfx: {
                                    duration: 1200,
                                    userOverlay: function (props) {
                                        var canvas = document.createElement("canvas");
                                        canvas.width = props.width;
                                        canvas.height = props.height;
                                        var ctx = canvas.getContext("2d");
                                        ctx.fillStyle = "rgba(30, 150, 30, 0.5)";
                                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                                        return canvas;
                                    }
                                }
                            }
                        ]
                    };
                    PassiveSkills.overdrive = {
                        type: "overdrive",
                        displayName: "Overdrive",
                        description: "Gives buffs at battle start but become poisoned",
                        atBattleStart: [
                            {
                                template: Templates.Effects.buffTest
                            }
                        ]
                    };
                    PassiveSkills.initialGuard = {
                        type: "initialGuard",
                        displayName: "Initial Guard",
                        description: "Adds initial guard",
                        isHidden: true,
                        atBattleStart: [
                            {
                                template: Templates.Effects.guardRow,
                                data: { perInt: 0, flat: 50 }
                            }
                        ],
                        inBattlePrep: [
                            function (user, battlePrep) {
                                Templates.Effects.guardRow.effect(user, user, null, { perInt: 0, flat: 50 });
                            }
                        ]
                    };
                    PassiveSkills.warpJammer = {
                        type: "warpJammer",
                        displayName: "Warp Jammer",
                        description: "Forces an extra unit to defend in neutral territory",
                        inBattlePrep: [
                            function (user, battlePrep) {
                                if (user.fleet.player === battlePrep.attacker) {
                                    battlePrep.minDefendersInNeutralTerritory += 1;
                                }
                            }
                        ],
                        canUpgradeInto: ["medic"]
                    };
                    PassiveSkills.medic = {
                        type: "medic",
                        displayName: "Medic",
                        description: "Heals all units in same star to full at turn start",
                        atTurnStart: [
                            function (user) {
                                var star = user.fleet.location;
                                var allFriendlyUnits = star.getAllUnitsOfPlayer(user.fleet.player);
                                for (var i = 0; i < allFriendlyUnits.length; i++) {
                                    allFriendlyUnits[i].addStrength(allFriendlyUnits[i].maxHealth);
                                }
                            }
                        ]
                    };
                })(PassiveSkills = Templates.PassiveSkills || (Templates.PassiveSkills = {}));
            })(Templates = DefaultModule.Templates || (DefaultModule.Templates = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
/// <reference path="../../../src/templateinterfaces/iitemtemplate.d.ts"/>
/// <reference path="abilities.ts" />
/// <reference path="passiveskills.ts" />
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var Templates;
            (function (Templates) {
                var Items;
                (function (Items) {
                    Items.bombLauncher1 = {
                        type: "bombLauncher1",
                        displayName: "Bomb Launcher 1",
                        description: "",
                        icon: "modules\/default\/img\/items\/cannon.png",
                        techLevel: 1,
                        buildCost: 100,
                        slot: "high",
                        ability: Templates.Abilities.bombAttack
                    };
                    Items.bombLauncher2 = {
                        type: "bombLauncher2",
                        displayName: "Bomb Launcher 2",
                        description: "",
                        icon: "modules\/default\/img\/items\/cannon.png",
                        techLevel: 2,
                        buildCost: 200,
                        attributes: {
                            attack: 1
                        },
                        slot: "high",
                        ability: Templates.Abilities.bombAttack
                    };
                    Items.bombLauncher3 = {
                        type: "bombLauncher3",
                        displayName: "Bomb Launcher 3",
                        description: "",
                        icon: "modules\/default\/img\/items\/cannon.png",
                        techLevel: 3,
                        buildCost: 300,
                        attributes: {
                            attack: 3
                        },
                        slot: "high",
                        ability: Templates.Abilities.bombAttack
                    };
                    Items.afterBurner1 = {
                        type: "afterBurner1",
                        displayName: "Afterburner 1",
                        description: "",
                        icon: "modules\/default\/img\/items\/blueThing.png",
                        techLevel: 1,
                        buildCost: 100,
                        attributes: {
                            speed: 1
                        },
                        slot: "mid",
                        passiveSkill: Templates.PassiveSkills.overdrive
                    };
                    Items.afterBurner2 = {
                        type: "afterBurner2",
                        displayName: "Afterburner 2",
                        description: "",
                        icon: "modules\/default\/img\/items\/blueThing.png",
                        techLevel: 2,
                        buildCost: 200,
                        attributes: {
                            speed: 2
                        },
                        slot: "mid"
                    };
                    Items.afterBurner3 = {
                        type: "afterBurner3",
                        displayName: "Afterburner 3",
                        description: "",
                        icon: "modules\/default\/img\/items\/blueThing.png",
                        techLevel: 3,
                        buildCost: 300,
                        attributes: {
                            maxActionPoints: 1,
                            speed: 3
                        },
                        slot: "mid"
                    };
                    Items.shieldPlating1 = {
                        type: "shieldPlating1",
                        displayName: "Shield Plating 1",
                        description: "",
                        icon: "modules\/default\/img\/items\/armor1.png",
                        techLevel: 1,
                        buildCost: 100,
                        attributes: {
                            defence: 1
                        },
                        slot: "low"
                    };
                    Items.shieldPlating2 = {
                        type: "shieldPlating2",
                        displayName: "Shield Plating 2",
                        description: "",
                        icon: "modules\/default\/img\/items\/armor1.png",
                        techLevel: 2,
                        buildCost: 200,
                        attributes: {
                            defence: 2
                        },
                        slot: "low"
                    };
                    Items.shieldPlating3 = {
                        type: "shieldPlating3",
                        displayName: "Shield Plating 3",
                        description: "",
                        icon: "modules\/default\/img\/items\/armor1.png",
                        techLevel: 3,
                        buildCost: 300,
                        attributes: {
                            defence: 3,
                            speed: -1
                        },
                        slot: "low",
                        ability: Templates.Abilities.guardRow
                    };
                })(Items = Templates.Items || (Templates.Items = {}));
            })(Templates = DefaultModule.Templates || (DefaultModule.Templates = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
/// <reference path="../../../src/templateinterfaces/istatuseffectattributeadjustment.d.ts"/>
/// <reference path="../../../src/templateinterfaces/istatuseffectattributes.d.ts"/>
/// <reference path="../../../src/templateinterfaces/istatuseffecttemplate.d.ts"/>
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var Templates;
            (function (Templates) {
                var StatusEffects;
                (function (StatusEffects) {
                    StatusEffects.test = {
                        type: "test",
                        displayName: "test",
                        attributes: {
                            attack: {
                                flat: 9
                            },
                            defence: {
                                flat: 9
                            },
                            speed: {
                                flat: 9
                            }
                        },
                        passiveSkills: [Templates.PassiveSkills.poisoned]
                    };
                })(StatusEffects = Templates.StatusEffects || (Templates.StatusEffects = {}));
            })(Templates = DefaultModule.Templates || (DefaultModule.Templates = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
/// <reference path="../../../src/templateinterfaces/isubemblemtemplate.d.ts"/>
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var Templates;
            (function (Templates) {
                var SubEmblems;
                (function (SubEmblems) {
                    SubEmblems.Aguila_explayada_2 = {
                        key: "Aguila_explayada_2",
                        src: "modules\/default\/img\/emblems\/Aguila_explayada_2.svg",
                        coverage: [Rance.SubEmblemCoverage.both],
                        position: [Rance.SubEmblemPosition.both]
                    };
                    SubEmblems.Berliner_Baer = {
                        key: "Berliner_Baer",
                        src: "modules\/default\/img\/emblems\/Berliner_Baer.svg",
                        coverage: [Rance.SubEmblemCoverage.both],
                        position: [Rance.SubEmblemPosition.both]
                    };
                    SubEmblems.Cles_en_sautoir = {
                        key: "Cles_en_sautoir",
                        src: "modules\/default\/img\/emblems\/Cles_en_sautoir.svg",
                        coverage: [Rance.SubEmblemCoverage.both],
                        position: [Rance.SubEmblemPosition.both]
                    };
                    SubEmblems.Coa_Illustration_Cross_Bowen_3 = {
                        key: "Coa_Illustration_Cross_Bowen_3",
                        src: "modules\/default\/img\/emblems\/Coa_Illustration_Cross_Bowen_3.svg",
                        coverage: [Rance.SubEmblemCoverage.both],
                        position: [Rance.SubEmblemPosition.both]
                    };
                    SubEmblems.Coa_Illustration_Cross_Malte_1 = {
                        key: "Coa_Illustration_Cross_Malte_1",
                        src: "modules\/default\/img\/emblems\/Coa_Illustration_Cross_Malte_1.svg",
                        coverage: [Rance.SubEmblemCoverage.both],
                        position: [Rance.SubEmblemPosition.both]
                    };
                    SubEmblems.Coa_Illustration_Elements_Planet_Moon = {
                        key: "Coa_Illustration_Elements_Planet_Moon",
                        src: "modules\/default\/img\/emblems\/Coa_Illustration_Elements_Planet_Moon.svg",
                        coverage: [Rance.SubEmblemCoverage.both],
                        position: [Rance.SubEmblemPosition.both]
                    };
                    SubEmblems.Couronne_heraldique_svg = {
                        key: "Couronne_heraldique_svg",
                        src: "modules\/default\/img\/emblems\/Couronne_heraldique_svg.svg",
                        coverage: [Rance.SubEmblemCoverage.both],
                        position: [Rance.SubEmblemPosition.both]
                    };
                    SubEmblems.Gomaisasa = {
                        key: "Gomaisasa",
                        src: "modules\/default\/img\/emblems\/Gomaisasa.svg",
                        coverage: [Rance.SubEmblemCoverage.both],
                        position: [Rance.SubEmblemPosition.both]
                    };
                    SubEmblems.Gryphon_Segreant = {
                        key: "Gryphon_Segreant",
                        src: "modules\/default\/img\/emblems\/Gryphon_Segreant.svg",
                        coverage: [Rance.SubEmblemCoverage.both],
                        position: [Rance.SubEmblemPosition.both]
                    };
                    SubEmblems.Heraldic_pentacle = {
                        key: "Heraldic_pentacle",
                        src: "modules\/default\/img\/emblems\/Heraldic_pentacle.svg",
                        coverage: [Rance.SubEmblemCoverage.both],
                        position: [Rance.SubEmblemPosition.both]
                    };
                    SubEmblems.Japanese_Crest_Futatsudomoe_1 = {
                        key: "Japanese_Crest_Futatsudomoe_1",
                        src: "modules\/default\/img\/emblems\/Japanese_Crest_Futatsudomoe_1.svg",
                        coverage: [Rance.SubEmblemCoverage.both],
                        position: [Rance.SubEmblemPosition.both]
                    };
                    SubEmblems.Japanese_Crest_Hana_Hisi = {
                        key: "Japanese_Crest_Hana_Hisi",
                        src: "modules\/default\/img\/emblems\/Japanese_Crest_Hana_Hisi.svg",
                        coverage: [Rance.SubEmblemCoverage.both],
                        position: [Rance.SubEmblemPosition.both]
                    };
                    SubEmblems.Japanese_Crest_Mitsumori_Janome = {
                        key: "Japanese_Crest_Mitsumori_Janome",
                        src: "modules\/default\/img\/emblems\/Japanese_Crest_Mitsumori_Janome.svg",
                        coverage: [Rance.SubEmblemCoverage.both],
                        position: [Rance.SubEmblemPosition.both]
                    };
                    SubEmblems.Japanese_Crest_Oda_ka = {
                        key: "Japanese_Crest_Oda_ka",
                        src: "modules\/default\/img\/emblems\/Japanese_Crest_Oda_ka.svg",
                        coverage: [Rance.SubEmblemCoverage.both],
                        position: [Rance.SubEmblemPosition.both]
                    };
                    SubEmblems.Japanese_crest_Tsuki_ni_Hoshi = {
                        key: "Japanese_crest_Tsuki_ni_Hoshi",
                        src: "modules\/default\/img\/emblems\/Japanese_crest_Tsuki_ni_Hoshi.svg",
                        coverage: [Rance.SubEmblemCoverage.both],
                        position: [Rance.SubEmblemPosition.both]
                    };
                    SubEmblems.Japanese_Crest_Ume = {
                        key: "Japanese_Crest_Ume",
                        src: "modules\/default\/img\/emblems\/Japanese_Crest_Ume.svg",
                        coverage: [Rance.SubEmblemCoverage.both],
                        position: [Rance.SubEmblemPosition.both]
                    };
                    SubEmblems.Mitsuuroko = {
                        key: "Mitsuuroko",
                        src: "modules\/default\/img\/emblems\/Mitsuuroko.svg",
                        coverage: [Rance.SubEmblemCoverage.both],
                        position: [Rance.SubEmblemPosition.both]
                    };
                    SubEmblems.Musubikashiwa = {
                        key: "Musubikashiwa",
                        src: "modules\/default\/img\/emblems\/Musubi-kashiwa.svg",
                        coverage: [Rance.SubEmblemCoverage.both],
                        position: [Rance.SubEmblemPosition.both]
                    };
                    SubEmblems.Takeda_mon = {
                        key: "Takeda_mon",
                        src: "modules\/default\/img\/emblems\/Takeda_mon.svg",
                        coverage: [Rance.SubEmblemCoverage.both],
                        position: [Rance.SubEmblemPosition.both]
                    };
                    SubEmblems.threeHorns = {
                        key: "threeHorns",
                        src: "modules\/default\/img\/emblems\/threeHorns.svg",
                        coverage: [Rance.SubEmblemCoverage.both],
                        position: [Rance.SubEmblemPosition.both]
                    };
                    SubEmblems.Flag_of_Edward_England = {
                        key: "Flag_of_Edward_England",
                        src: "modules\/default\/img\/emblems\/Flag_of_Edward_England.svg",
                        coverage: [Rance.SubEmblemCoverage.both],
                        position: [Rance.SubEmblemPosition.both],
                        disallowRandomGeneration: true
                    };
                })(SubEmblems = Templates.SubEmblems || (Templates.SubEmblems = {}));
            })(Templates = DefaultModule.Templates || (DefaultModule.Templates = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
/// <reference path="../../../src/templateinterfaces/iunitarchetype.d.ts"/>
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var Templates;
            (function (Templates) {
                var UnitArchetypes;
                (function (UnitArchetypes) {
                    UnitArchetypes.combat = {
                        type: "combat",
                        idealWeightInBattle: 1,
                        idealWeightInFleet: 1,
                        rowScores: {
                            ROW_FRONT: 1,
                            ROW_BACK: 0.6
                        }
                    };
                    UnitArchetypes.utility = {
                        type: "utility",
                        idealWeightInBattle: 0.33,
                        idealWeightInFleet: 0.5,
                        rowScores: {
                            ROW_FRONT: 0.4,
                            ROW_BACK: 0.6
                        }
                    };
                    UnitArchetypes.scouting = {
                        type: "scouting",
                        idealWeightInBattle: 0.01,
                        idealWeightInFleet: 0.2,
                        rowScores: {
                            ROW_FRONT: 0.01,
                            ROW_BACK: 0.02
                        }
                    };
                    UnitArchetypes.defence = {
                        type: "defence",
                        idealWeightInBattle: 0.5,
                        idealWeightInFleet: 0.5,
                        rowScores: {
                            ROW_FRONT: 1,
                            ROW_BACK: 0.5
                        },
                        scoreMultiplierForRowFN: function (row, rowUnits, enemyUnits) {
                            var multiplier = (row === "ROW_BACK" ? 0.7 : 1);
                            var totalDefenceUnderThreshhold = 0;
                            var threshhold = 6;
                            var alreadyHasDefender = false;
                            for (var i = 0; i < rowUnits.length; i++) {
                                var unit = rowUnits[i];
                                if (!unit)
                                    continue;
                                if (unit.template.archetype.type === "defence") {
                                    return multiplier;
                                }
                                totalDefenceUnderThreshhold += Math.max(0, threshhold - unit.attributes.defence);
                            }
                            return multiplier + totalDefenceUnderThreshhold * 0.2;
                        }
                    };
                })(UnitArchetypes = Templates.UnitArchetypes || (Templates.UnitArchetypes = {}));
            })(Templates = DefaultModule.Templates || (DefaultModule.Templates = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
/// <reference path="../../../src/templateinterfaces/iunitfamily.d.ts"/>
/// <reference path="../../../src/templateinterfaces/idistributable.d.ts" />
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var Templates;
            (function (Templates) {
                var UnitFamilies;
                (function (UnitFamilies) {
                    UnitFamilies.debug = {
                        type: "debug",
                        debugOnly: true,
                        alwaysAvailable: true,
                        rarity: 0,
                        distributionGroups: []
                    };
                    UnitFamilies.basic = {
                        type: "basic",
                        debugOnly: false,
                        alwaysAvailable: true,
                        rarity: 0,
                        distributionGroups: []
                    };
                    UnitFamilies.red = {
                        type: "red",
                        debugOnly: false,
                        alwaysAvailable: false,
                        rarity: 1,
                        distributionGroups: ["common", "rare"]
                    };
                    UnitFamilies.blue = {
                        type: "blue",
                        debugOnly: false,
                        alwaysAvailable: false,
                        rarity: 1,
                        distributionGroups: ["common", "rare"]
                    };
                })(UnitFamilies = Templates.UnitFamilies || (Templates.UnitFamilies = {}));
            })(Templates = DefaultModule.Templates || (DefaultModule.Templates = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
/// <reference path="../../../lib/pixi.d.ts"/>
/// <reference path="../../../src/templateinterfaces/iunitdrawingfunction.d.ts"/>
/// <reference path="../../../src/templateinterfaces/sfxparams.d.ts"/>
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            DefaultModule.defaultUnitScene = function (unit, SFXParams) {
                var spriteTemplate = unit.template.sprite;
                var texture = PIXI.Texture.fromFrame(spriteTemplate.imageSrc);
                var container = new PIXI.Container;
                var props = {
                    zDistance: 8,
                    xDistance: 5,
                    maxUnitsPerColumn: 7,
                    degree: -0.5,
                    rotationAngle: 70,
                    scalingFactor: 0.04
                };
                var maxUnitsPerColumn = props.maxUnitsPerColumn;
                var isConvex = true;
                var degree = props.degree;
                if (degree < 0) {
                    isConvex = !isConvex;
                    degree = Math.abs(degree);
                }
                var image = app.images[spriteTemplate.imageSrc];
                var zDistance = props.zDistance;
                var xDistance = props.xDistance;
                var unitsToDraw;
                if (!unit.isSquadron) {
                    unitsToDraw = 1;
                }
                else {
                    var lastHealthDrawnAt = unit.lastHealthDrawnAt || unit.battleStats.lastHealthBeforeReceivingDamage;
                    unit.lastHealthDrawnAt = unit.currentHealth;
                    unitsToDraw = Math.round(lastHealthDrawnAt * 0.04) * (1 / unit.template.maxHealth);
                    var heightRatio = 25 / image.height;
                    heightRatio = Math.min(heightRatio, 1.25);
                    maxUnitsPerColumn = Math.round(maxUnitsPerColumn * heightRatio);
                    unitsToDraw = Math.round(unitsToDraw * heightRatio);
                    zDistance *= (1 / heightRatio);
                    unitsToDraw = Rance.clamp(unitsToDraw, 1, maxUnitsPerColumn * 3);
                }
                var xMin, xMax, yMin, yMax;
                var rotationAngle = Math.PI / 180 * props.rotationAngle;
                var sA = Math.sin(rotationAngle);
                var cA = Math.cos(rotationAngle);
                var rotationMatrix = [
                    1, 0, 0,
                    0, cA, -sA,
                    0, sA, cA
                ];
                var minXOffset = isConvex ? 0 : Math.sin(Math.PI / (maxUnitsPerColumn + 1));
                var yPadding = Math.min(SFXParams.height * 0.1, 30);
                var desiredHeight = SFXParams.height - yPadding;
                var averageHeight = image.height * (maxUnitsPerColumn / 2 * props.scalingFactor);
                var spaceToFill = desiredHeight - (averageHeight * maxUnitsPerColumn);
                zDistance = spaceToFill / maxUnitsPerColumn * 1.35;
                for (var i = unitsToDraw - 1; i >= 0; i--) {
                    var column = Math.floor(i / maxUnitsPerColumn);
                    var isLastColumn = column === Math.floor(unitsToDraw / maxUnitsPerColumn);
                    var zPos;
                    if (isLastColumn) {
                        var maxUnitsInThisColumn = unitsToDraw % maxUnitsPerColumn;
                        if (maxUnitsInThisColumn === 1) {
                            zPos = (maxUnitsPerColumn - 1) / 2;
                        }
                        else {
                            var positionInLastColumn = i % maxUnitsInThisColumn;
                            zPos = positionInLastColumn * ((maxUnitsPerColumn - 1) / (maxUnitsInThisColumn - 1));
                        }
                    }
                    else {
                        zPos = i % maxUnitsPerColumn;
                    }
                    var xOffset = Math.sin(Math.PI / (maxUnitsPerColumn + 1) * (zPos + 1));
                    if (isConvex) {
                        xOffset = 1 - xOffset;
                    }
                    xOffset -= minXOffset;
                    var scale = 1 - zPos * props.scalingFactor;
                    var scaledWidth = image.width * scale;
                    var scaledHeight = image.height * scale;
                    var x = xOffset * scaledWidth * degree + column * (scaledWidth + xDistance * scale);
                    var y = (scaledHeight + zDistance * scale) * (maxUnitsPerColumn - zPos);
                    var translated = Rance.transformMat3({ x: x, y: y }, rotationMatrix);
                    x = Math.round(translated.x);
                    y = Math.round(translated.y);
                    var sprite = new PIXI.Sprite(texture);
                    sprite.scale.x = sprite.scale.y = scale;
                    sprite.x = x;
                    sprite.y = y;
                    container.addChild(sprite);
                }
                SFXParams.triggerStart(container);
                return container;
            };
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
/// <reference path="../../../src/templateinterfaces/iunittemplate.d.ts"/>
/// <reference path="../../../src/templateinterfaces/ispritetemplate.d.ts"/>
/// <reference path="../graphics/defaultunitscene.ts" />
/// <reference path="abilities.ts"/>
/// <reference path="passiveskills.ts" />
/// <reference path="unitfamilies.ts" />
/// <reference path="unitarchetypes.ts" />
/// <reference path="cultures.ts" />
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var Templates;
            (function (Templates) {
                var Units;
                (function (Units) {
                    Units.cheatShip = {
                        type: "cheatShip",
                        displayName: "Debug Ship",
                        description: "debug",
                        archetype: Templates.UnitArchetypes.combat,
                        families: [Templates.UnitFamilies.debug],
                        cultures: [],
                        sprite: {
                            imageSrc: "cheatShip.png",
                            anchor: { x: 0.5, y: 0.5 }
                        },
                        isSquadron: false,
                        buildCost: 0,
                        icon: "modules\/default\/img\/unitIcons\/f.png",
                        maxHealth: 1,
                        maxMovePoints: 999,
                        visionRange: 1,
                        detectionRange: -1,
                        attributeLevels: {
                            attack: 9,
                            defence: 9,
                            intelligence: 9,
                            speed: 9
                        },
                        possibleAbilities: [
                            {
                                flatProbability: 1,
                                probabilityItems: [
                                    Templates.Abilities.debugAbility,
                                    Templates.Abilities.rangedAttack,
                                    Templates.Abilities.standBy
                                ]
                            },
                            {
                                flatProbability: 1,
                                probabilityItems: [
                                    {
                                        weight: 0.33,
                                        probabilityItems: [Templates.Abilities.bombAttack]
                                    },
                                    {
                                        weight: 0.33,
                                        probabilityItems: [Templates.Abilities.boardingHook]
                                    },
                                    {
                                        weight: 0.33,
                                        probabilityItems: [Templates.Abilities.guardRow]
                                    }
                                ]
                            }
                        ],
                        possiblePassiveSkills: [
                            {
                                flatProbability: 1,
                                probabilityItems: [
                                    {
                                        weight: 0.33,
                                        probabilityItems: [Templates.PassiveSkills.autoHeal]
                                    },
                                    {
                                        weight: 0.33,
                                        probabilityItems: [Templates.PassiveSkills.warpJammer]
                                    },
                                    {
                                        weight: 0.33,
                                        probabilityItems: [Templates.PassiveSkills.medic]
                                    }
                                ]
                            }
                        ],
                        specialAbilityUpgrades: [
                            Templates.Abilities.ranceAttack
                        ],
                        learnableAbilities: [
                            Templates.Abilities.guardRow,
                            Templates.Abilities.closeAttack,
                            [Templates.Abilities.debugAbility, Templates.Abilities.ranceAttack]
                        ],
                        unitDrawingFN: DefaultModule.defaultUnitScene
                    };
                    Units.fighterSquadron = {
                        type: "fighterSquadron",
                        displayName: "Fighter Squadron",
                        description: "Fast and cheap unit with good attack and speed but low defence",
                        archetype: Templates.UnitArchetypes.combat,
                        families: [Templates.UnitFamilies.basic],
                        cultures: [],
                        sprite: {
                            imageSrc: "fighter.png",
                            anchor: { x: 0.5, y: 0.5 }
                        },
                        isSquadron: true,
                        buildCost: 100,
                        icon: "modules\/default\/img\/unitIcons\/fa.png",
                        maxHealth: 0.7,
                        maxMovePoints: 2,
                        visionRange: 1,
                        detectionRange: -1,
                        attributeLevels: {
                            attack: 0.8,
                            defence: 0.6,
                            intelligence: 0.4,
                            speed: 1
                        },
                        possibleAbilities: [
                            {
                                flatProbability: 1,
                                probabilityItems: [
                                    Templates.Abilities.rangedAttack,
                                    Templates.Abilities.closeAttack,
                                    Templates.Abilities.standBy
                                ]
                            }
                        ],
                        unitDrawingFN: DefaultModule.defaultUnitScene
                    };
                    Units.bomberSquadron = {
                        type: "bomberSquadron",
                        displayName: "Bomber Squadron",
                        description: "Can damage multiple targets with special bomb attack",
                        archetype: Templates.UnitArchetypes.combat,
                        families: [Templates.UnitFamilies.basic],
                        cultures: [],
                        sprite: {
                            imageSrc: "bomber.png",
                            anchor: { x: 0.5, y: 0.5 }
                        },
                        isSquadron: true,
                        buildCost: 200,
                        icon: "modules\/default\/img\/unitIcons\/fb.png",
                        maxHealth: 0.5,
                        maxMovePoints: 1,
                        visionRange: 1,
                        detectionRange: -1,
                        attributeLevels: {
                            attack: 0.7,
                            defence: 0.4,
                            intelligence: 0.5,
                            speed: 0.8
                        },
                        possibleAbilities: [
                            {
                                flatProbability: 1,
                                probabilityItems: [
                                    Templates.Abilities.rangedAttack,
                                    Templates.Abilities.bombAttack,
                                    Templates.Abilities.standBy
                                ]
                            }
                        ],
                        unitDrawingFN: DefaultModule.defaultUnitScene
                    };
                    Units.battleCruiser = {
                        type: "battleCruiser",
                        displayName: "Battlecruiser",
                        description: "Strong combat ship with low speed",
                        archetype: Templates.UnitArchetypes.combat,
                        families: [Templates.UnitFamilies.basic],
                        cultures: [],
                        sprite: {
                            imageSrc: "battleCruiser.png",
                            anchor: { x: 0.5, y: 0.5 }
                        },
                        isSquadron: true,
                        buildCost: 200,
                        icon: "modules\/default\/img\/unitIcons\/bc.png",
                        maxHealth: 1,
                        maxMovePoints: 1,
                        visionRange: 1,
                        detectionRange: -1,
                        attributeLevels: {
                            attack: 0.8,
                            defence: 0.8,
                            intelligence: 0.7,
                            speed: 0.6
                        },
                        possibleAbilities: [
                            {
                                flatProbability: 1,
                                probabilityItems: [
                                    Templates.Abilities.rangedAttack,
                                    Templates.Abilities.wholeRowAttack,
                                    Templates.Abilities.standBy
                                ]
                            }
                        ],
                        unitDrawingFN: DefaultModule.defaultUnitScene
                    };
                    Units.scout = {
                        type: "scout",
                        displayName: "Scout",
                        description: "Weak in combat, but has high vision and can reveal stealthy units and details of units in same star",
                        archetype: Templates.UnitArchetypes.scouting,
                        families: [Templates.UnitFamilies.basic],
                        cultures: [],
                        sprite: {
                            imageSrc: "scout.png",
                            anchor: { x: 0.5, y: 0.5 }
                        },
                        isSquadron: true,
                        buildCost: 200,
                        icon: "modules\/default\/img\/unitIcons\/sc.png",
                        maxHealth: 0.6,
                        maxMovePoints: 2,
                        visionRange: 2,
                        detectionRange: 0,
                        attributeLevels: {
                            attack: 0.5,
                            defence: 0.5,
                            intelligence: 0.8,
                            speed: 0.7
                        },
                        possibleAbilities: [
                            {
                                flatProbability: 1,
                                probabilityItems: [
                                    Templates.Abilities.rangedAttack,
                                    Templates.Abilities.standBy
                                ]
                            }
                        ],
                        unitDrawingFN: DefaultModule.defaultUnitScene
                    };
                    Units.stealthShip = {
                        type: "stealthShip",
                        displayName: "Stealth Ship",
                        description: "Weak ship that is undetectable by regular vision",
                        archetype: Templates.UnitArchetypes.scouting,
                        families: [Templates.UnitFamilies.debug],
                        cultures: [],
                        sprite: {
                            imageSrc: "scout.png",
                            anchor: { x: 0.5, y: 0.5 }
                        },
                        isSquadron: true,
                        buildCost: 500,
                        icon: "modules\/default\/img\/unitIcons\/sc.png",
                        maxHealth: 0.6,
                        maxMovePoints: 1,
                        visionRange: 1,
                        detectionRange: -1,
                        isStealthy: true,
                        attributeLevels: {
                            attack: 0.5,
                            defence: 0.5,
                            intelligence: 0.8,
                            speed: 0.7
                        },
                        possibleAbilities: [
                            {
                                flatProbability: 1,
                                probabilityItems: [
                                    Templates.Abilities.rangedAttack,
                                    Templates.Abilities.standBy
                                ]
                            }
                        ],
                        technologyRequirements: [{ technology: Templates.Technologies.stealth, level: 1 }],
                        unitDrawingFN: DefaultModule.defaultUnitScene
                    };
                    Units.shieldBoat = {
                        type: "shieldBoat",
                        displayName: "Shield Boat",
                        description: "Great defence and ability to protect allies in same row",
                        archetype: Templates.UnitArchetypes.defence,
                        families: [Templates.UnitFamilies.basic],
                        cultures: [],
                        sprite: {
                            imageSrc: "shieldBoat.png",
                            anchor: { x: 0.5, y: 0.5 }
                        },
                        isSquadron: true,
                        buildCost: 200,
                        icon: "modules\/default\/img\/unitIcons\/sh.png",
                        maxHealth: 0.9,
                        maxMovePoints: 1,
                        visionRange: 1,
                        detectionRange: -1,
                        attributeLevels: {
                            attack: 0.5,
                            defence: 0.9,
                            intelligence: 0.6,
                            speed: 0.4
                        },
                        possibleAbilities: [
                            {
                                flatProbability: 1,
                                probabilityItems: [
                                    Templates.Abilities.rangedAttack,
                                    Templates.Abilities.guardRow,
                                    Templates.Abilities.standBy
                                ]
                            }
                        ],
                        possiblePassiveSkills: [
                            {
                                flatProbability: 1,
                                probabilityItems: [
                                    Templates.PassiveSkills.initialGuard
                                ]
                            }
                        ],
                        unitDrawingFN: DefaultModule.defaultUnitScene
                    };
                    Units.commandShip = {
                        type: "commandShip",
                        displayName: "Command Ship",
                        description: "todo",
                        archetype: Templates.UnitArchetypes.utility,
                        families: [Templates.UnitFamilies.basic],
                        cultures: [],
                        sprite: {
                            imageSrc: "shieldBoat.png",
                            anchor: { x: 0.5, y: 0.5 }
                        },
                        isSquadron: false,
                        buildCost: 300,
                        icon: "modules\/default\/img\/unitIcons\/sh.png",
                        maxHealth: 0.7,
                        maxMovePoints: 1,
                        visionRange: 1,
                        detectionRange: -1,
                        attributeLevels: {
                            attack: 0.5,
                            defence: 0.6,
                            intelligence: 0.7,
                            speed: 0.6
                        },
                        possibleAbilities: [
                            {
                                flatProbability: 1,
                                probabilityItems: [
                                    Templates.Abilities.rangedAttack,
                                    Templates.Abilities.standBy
                                ]
                            }
                        ],
                        possiblePassiveSkills: [
                            {
                                flatProbability: 1,
                                probabilityItems: [
                                    Templates.PassiveSkills.initialGuard
                                ]
                            }
                        ],
                        unitDrawingFN: DefaultModule.defaultUnitScene
                    };
                    Units.redShip = {
                        type: "redShip",
                        displayName: "Red ship",
                        description: "Just used for testing unit distribution. (all the other units are just for testing something too)",
                        archetype: Templates.UnitArchetypes.utility,
                        families: [Templates.UnitFamilies.red],
                        cultures: [],
                        sprite: {
                            imageSrc: "scout.png",
                            anchor: { x: 0.5, y: 0.5 }
                        },
                        isSquadron: true,
                        buildCost: 200,
                        icon: "modules\/default\/img\/unitIcons\/sc.png",
                        maxHealth: 0.6,
                        maxMovePoints: 2,
                        visionRange: 2,
                        detectionRange: 0,
                        attributeLevels: {
                            attack: 0.5,
                            defence: 0.5,
                            intelligence: 0.8,
                            speed: 0.7
                        },
                        possibleAbilities: [
                            {
                                flatProbability: 1,
                                probabilityItems: [
                                    Templates.Abilities.rangedAttack,
                                    Templates.Abilities.standBy
                                ]
                            }
                        ],
                        unitDrawingFN: DefaultModule.defaultUnitScene
                    };
                    Units.blueShip = {
                        type: "blueShip",
                        displayName: "Blue ship",
                        description: "Just used for testing unit distribution. (all the other units are just for testing something too)",
                        archetype: Templates.UnitArchetypes.utility,
                        families: [Templates.UnitFamilies.blue],
                        cultures: [],
                        sprite: {
                            imageSrc: "scout.png",
                            anchor: { x: 0.5, y: 0.5 }
                        },
                        isSquadron: true,
                        buildCost: 200,
                        icon: "modules\/default\/img\/unitIcons\/sc.png",
                        maxHealth: 0.6,
                        maxMovePoints: 2,
                        visionRange: 2,
                        detectionRange: 0,
                        attributeLevels: {
                            attack: 0.5,
                            defence: 0.5,
                            intelligence: 0.8,
                            speed: 0.7
                        },
                        possibleAbilities: [
                            {
                                flatProbability: 1,
                                probabilityItems: [
                                    Templates.Abilities.rangedAttack,
                                    Templates.Abilities.standBy
                                ]
                            }
                        ],
                        unitDrawingFN: DefaultModule.defaultUnitScene
                    };
                })(Units = Templates.Units || (Templates.Units = {}));
            })(Templates = DefaultModule.Templates || (DefaultModule.Templates = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var AIUtils;
            (function (AIUtils) {
                function moveToRoutine(front, afterMoveCallback, getMoveTargetFN) {
                    var fleets = front.getAssociatedFleets();
                    if (fleets.length <= 0) {
                        afterMoveCallback();
                        return;
                    }
                    var finishedMovingCount = 0;
                    var finishFleetMoveFN = function () {
                        finishedMovingCount++;
                        if (finishedMovingCount >= fleets.length) {
                            afterMoveCallback();
                        }
                    };
                    for (var i = 0; i < fleets.length; i++) {
                        var moveTarget = getMoveTargetFN ? getMoveTargetFN(fleets[i]) : front.objective.target;
                        fleets[i].pathFind(moveTarget, null, finishFleetMoveFN);
                    }
                }
                AIUtils.moveToRoutine = moveToRoutine;
                function independentTargetFilter(target) {
                    return target.enemy.isIndependent;
                }
                AIUtils.independentTargetFilter = independentTargetFilter;
                function buildingControllerFilter(target) {
                    return target.building && target.enemy === target.building.controller;
                }
                AIUtils.buildingControllerFilter = buildingControllerFilter;
                function musterAndAttackRoutine(targetFilter, front, afterMoveCallback) {
                    var shouldMoveToTarget;
                    var unitsByLocation = front.getUnitsByLocation();
                    var fleets = front.getAssociatedFleets();
                    var atMuster = unitsByLocation[front.musterLocation.id] ?
                        unitsByLocation[front.musterLocation.id].length : 0;
                    var inRangeOfTarget = 0;
                    for (var i = 0; i < fleets.length; i++) {
                        var distance = fleets[i].location.getDistanceToStar(front.targetLocation);
                        if (fleets[i].getMinCurrentMovePoints() >= distance) {
                            inRangeOfTarget += fleets[i].units.length;
                        }
                    }
                    if (front.hasMustered) {
                        shouldMoveToTarget = true;
                    }
                    else {
                        if (atMuster >= front.minUnitsDesired || inRangeOfTarget >= front.minUnitsDesired) {
                            front.hasMustered = true;
                            shouldMoveToTarget = true;
                        }
                        else {
                            shouldMoveToTarget = false;
                        }
                    }
                    var moveTarget = shouldMoveToTarget ? front.targetLocation : front.musterLocation;
                    var finishAllMoveFN = function () {
                        unitsByLocation = front.getUnitsByLocation();
                        var atTarget = unitsByLocation[front.targetLocation.id] ?
                            unitsByLocation[front.targetLocation.id].length : 0;
                        if (atTarget >= front.minUnitsDesired) {
                            var star = front.targetLocation;
                            var player = front.units[0].fleet.player;
                            var attackTargets = star.getTargetsForPlayer(player);
                            var target = attackTargets.filter(targetFilter)[0];
                            player.attackTarget(star, target, afterMoveCallback);
                        }
                        else {
                            afterMoveCallback();
                        }
                    };
                    var finishedMovingCount = 0;
                    var finishFleetMoveFN = function () {
                        finishedMovingCount++;
                        if (finishedMovingCount >= fleets.length) {
                            finishAllMoveFN();
                        }
                    };
                    for (var i = 0; i < fleets.length; i++) {
                        fleets[i].pathFind(moveTarget, null, finishFleetMoveFN);
                    }
                }
                AIUtils.musterAndAttackRoutine = musterAndAttackRoutine;
                function defaultUnitDesireFN(front) {
                    var desire = 1;
                    // lower desire if front requirements already met
                    // more important fronts get priority but dont hog units
                    var unitsOverMinimum = front.units.length - front.minUnitsDesired;
                    var unitsOverIdeal = front.units.length - front.idealUnitsDesired;
                    var unitsUnderMinimum = front.minUnitsDesired - front.units.length;
                    if (unitsOverMinimum > 0) {
                        desire *= 0.85 / unitsOverMinimum;
                    }
                    if (unitsOverIdeal > 0) {
                        desire *= 0.6 / unitsOverIdeal;
                    }
                    // penalize initial units for front
                    // inertia at beginning of adding units to front
                    // so ai prioritizes fully formed fronts to incomplete ones
                    if (unitsUnderMinimum > 0) {
                        var intertiaPerMissingUnit = 0.5 / front.minUnitsDesired;
                        var newUnitInertia = intertiaPerMissingUnit * (unitsUnderMinimum - 1);
                        desire *= 1 - newUnitInertia;
                    }
                    return desire;
                }
                AIUtils.defaultUnitDesireFN = defaultUnitDesireFN;
                function defaultUnitFitFN(unit, front, lowHealthThreshhold, healthAdjust, distanceAdjust) {
                    if (lowHealthThreshhold === void 0) { lowHealthThreshhold = 0.75; }
                    if (healthAdjust === void 0) { healthAdjust = 1; }
                    if (distanceAdjust === void 0) { distanceAdjust = 1; }
                    var score = 1;
                    // penalize units on low health
                    var healthPercentage = unit.currentHealth / unit.maxHealth;
                    if (healthPercentage < lowHealthThreshhold) {
                        score *= healthPercentage * healthAdjust;
                    }
                    // prioritize units closer to front target
                    var turnsToReach = unit.getTurnsToReachStar(front.targetLocation);
                    if (turnsToReach > 0) {
                        turnsToReach *= distanceAdjust;
                        var distanceMultiplier = 1 / (Math.log(turnsToReach + 2.5) / Math.log(2.5));
                        score *= distanceMultiplier;
                    }
                    return score;
                }
                AIUtils.defaultUnitFitFN = defaultUnitFitFN;
                function scoutingUnitDesireFN(front) {
                    if (front.units.length < 1)
                        return 1;
                    else
                        return 0;
                }
                AIUtils.scoutingUnitDesireFN = scoutingUnitDesireFN;
                function scoutingUnitFitFN(unit, front) {
                    var baseScore = 0;
                    // ++ stealth
                    var isStealthy = unit.isStealthy();
                    if (isStealthy)
                        baseScore += 0.2;
                    // ++ vision
                    var visionRange = unit.getVisionRange();
                    if (visionRange <= 0) {
                        return -1;
                    }
                    else {
                        baseScore += Math.pow(visionRange, 1.5) / 2;
                    }
                    // -- strength
                    var strength = unit.getStrengthEvaluation();
                    baseScore -= strength / 1000;
                    // -- cost
                    var cost = unit.getTotalCost();
                    baseScore -= cost / 1000;
                    var score = baseScore * defaultUnitFitFN(unit, front, -1, 0, 2);
                    return Rance.clamp(score, 0, 1);
                }
                AIUtils.scoutingUnitFitFN = scoutingUnitFitFN;
                function mergeScoresByStar(merged, scores) {
                    for (var i = 0; i < scores.length; i++) {
                        var star = scores[i].star;
                        if (!merged[star.id]) {
                            merged[star.id] = scores[i];
                        }
                        else {
                            merged[star.id].score += scores[i].score;
                        }
                    }
                    return merged;
                }
                AIUtils.mergeScoresByStar = mergeScoresByStar;
                function makeObjectivesFromScores(template, evaluationScores, basePriority) {
                    var allObjectives = [];
                    var minScore = 0;
                    var maxScore;
                    for (var i = 0; i < evaluationScores.length; i++) {
                        var score = evaluationScores[i].score;
                        maxScore = isFinite(maxScore) ? Math.max(maxScore, score) : score;
                    }
                    for (var i = 0; i < evaluationScores.length; i++) {
                        var star = evaluationScores[i].star || null;
                        var player = evaluationScores[i].player || null;
                        if (score < 0.04)
                            continue;
                        var relativeScore = Rance.getRelativeValue(evaluationScores[i].score, minScore, maxScore);
                        var priority = relativeScore * basePriority;
                        allObjectives.push(new Rance.MapAI.Objective(template, priority, star, player));
                    }
                    return allObjectives;
                }
                AIUtils.makeObjectivesFromScores = makeObjectivesFromScores;
                function perimeterObjectiveCreation(templateKey, isForScouting, basePriority, grandStrategyAI, mapEvaluator, objectivesAI) {
                    var playersToEstablishPerimeterAgainst = [];
                    var diplomacyStatus = mapEvaluator.player.diplomacyStatus;
                    var statusByPlayer = diplomacyStatus.statusByPlayer;
                    for (var playerId in statusByPlayer) {
                        if (statusByPlayer[playerId] >= Rance.DiplomaticState.war) {
                            playersToEstablishPerimeterAgainst.push(diplomacyStatus.metPlayers[playerId]);
                        }
                    }
                    var allScoresByStar = {};
                    for (var i = 0; i < playersToEstablishPerimeterAgainst.length; i++) {
                        var player = playersToEstablishPerimeterAgainst[i];
                        var scores = mapEvaluator.getScoredPerimeterLocationsAgainstPlayer(player, 1, isForScouting);
                        AIUtils.mergeScoresByStar(allScoresByStar, scores);
                    }
                    var allScores = [];
                    for (var starId in allScoresByStar) {
                        if (allScoresByStar[starId].score > 0.04) {
                            allScores.push(allScoresByStar[starId]);
                        }
                    }
                    var template = Rance.Modules.DefaultModule.Objectives[templateKey];
                    var objectives = AIUtils.makeObjectivesFromScores(template, allScores, basePriority);
                    return objectives;
                }
                AIUtils.perimeterObjectiveCreation = perimeterObjectiveCreation;
                function getUnitsToBeatImmediateTarget(mapEvaluator, objective) {
                    var min;
                    var ideal;
                    var star = objective.target;
                    var hostileUnits = mapEvaluator.getHostileUnitsAtStar(star).all;
                    if (hostileUnits.length <= 1) {
                        min = hostileUnits.length + 1;
                        ideal = hostileUnits.length + 1;
                    }
                    else {
                        min = Math.min(hostileUnits.length + 2, 6);
                        ideal = 6;
                    }
                    return ({
                        min: min,
                        ideal: ideal
                    });
                }
                AIUtils.getUnitsToBeatImmediateTarget = getUnitsToBeatImmediateTarget;
            })(AIUtils = DefaultModule.AIUtils || (DefaultModule.AIUtils = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
/// <reference path="../../../src/templateinterfaces/iobjectivetemplate.d.ts" />
/// <reference path="aiutils.ts" />
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var Objectives;
            (function (Objectives) {
                Objectives.discovery = {
                    key: "discovery",
                    movePriority: 999,
                    preferredUnitComposition: {
                        scouting: 1
                    },
                    moveRoutineFN: DefaultModule.AIUtils.moveToRoutine,
                    unitDesireFN: DefaultModule.AIUtils.scoutingUnitDesireFN,
                    unitFitFN: DefaultModule.AIUtils.scoutingUnitFitFN,
                    creatorFunction: function (grandStrategyAI, mapEvaluator) {
                        var scores = [];
                        var starsWithDistance = {};
                        var linksToUnrevealedStars = mapEvaluator.player.getLinksToUnRevealedStars();
                        var minDistance;
                        var maxDistance;
                        for (var starId in linksToUnrevealedStars) {
                            var star = mapEvaluator.player.revealedStars[starId];
                            var nearest = mapEvaluator.player.getNearestOwnedStarTo(star);
                            var distance = star.getDistanceToStar(nearest);
                            starsWithDistance[starId] = distance;
                            if (!isFinite(minDistance)) {
                                minDistance = distance;
                            }
                            else {
                                minDistance = Math.min(minDistance, distance);
                            }
                            if (!isFinite(maxDistance)) {
                                maxDistance = distance;
                            }
                            else {
                                maxDistance = Math.max(maxDistance, distance);
                            }
                        }
                        for (var starId in linksToUnrevealedStars) {
                            var star = mapEvaluator.player.revealedStars[starId];
                            var score = 0;
                            var relativeDistance = Rance.getRelativeValue(starsWithDistance[starId], minDistance, maxDistance, true);
                            var distanceMultiplier = 0.3 + 0.7 * relativeDistance;
                            var linksScore = linksToUnrevealedStars[starId].length * 20;
                            score += linksScore;
                            var desirabilityScore = mapEvaluator.evaluateIndividualStarDesirability(star);
                            desirabilityScore *= distanceMultiplier;
                            score += desirabilityScore;
                            score *= distanceMultiplier;
                            scores.push({
                                star: star,
                                score: score
                            });
                        }
                        var template = Rance.Modules.DefaultModule.Objectives.discovery;
                        return DefaultModule.AIUtils.makeObjectivesFromScores(template, scores, 0.5);
                    },
                    unitsToFillObjectiveFN: function (mapEvaluator, objective) {
                        return { min: 1, ideal: 1 };
                    }
                };
            })(Objectives = DefaultModule.Objectives || (DefaultModule.Objectives = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
/// <reference path="../../../src/templateinterfaces/iobjectivetemplate.d.ts" />
/// <reference path="aiutils.ts" />
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var Objectives;
            (function (Objectives) {
                Objectives.heal = {
                    key: "heal",
                    movePriority: -1,
                    preferredUnitComposition: {},
                    moveRoutineFN: function (front, afterMoveCallback) {
                        DefaultModule.AIUtils.moveToRoutine(front, afterMoveCallback, function (fleet) {
                            return fleet.player.getNearestOwnedStarTo(fleet.location);
                        });
                    },
                    unitDesireFN: function (front) { return 1; },
                    unitFitFN: function (unit, front) {
                        var healthPercentage = unit.currentHealth / unit.maxHealth;
                        return 1 - healthPercentage;
                    },
                    creatorFunction: function (grandStrategyAI, mapEvaluator) {
                        var template = Rance.Modules.DefaultModule.Objectives.heal;
                        return [new Rance.MapAI.Objective(template, 1, null)];
                    },
                    unitsToFillObjectiveFN: function (mapEvaluator, objective) {
                        return { min: 0, ideal: 0 };
                    }
                };
            })(Objectives = DefaultModule.Objectives || (DefaultModule.Objectives = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
/// <reference path="../../../src/templateinterfaces/iobjectivetemplate.d.ts" />
/// <reference path="aiutils.ts" />
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var Objectives;
            (function (Objectives) {
                Objectives.expansion = {
                    key: "expansion",
                    movePriority: 4,
                    preferredUnitComposition: {
                        combat: 0.65,
                        defence: 0.25,
                        utility: 0.1
                    },
                    moveRoutineFN: DefaultModule.AIUtils.musterAndAttackRoutine.bind(null, DefaultModule.AIUtils.independentTargetFilter),
                    unitDesireFN: DefaultModule.AIUtils.defaultUnitDesireFN,
                    unitFitFN: DefaultModule.AIUtils.defaultUnitFitFN,
                    creatorFunction: function (grandStrategyAI, mapEvaluator) {
                        var basePriority = grandStrategyAI.desireForExpansion;
                        var independentNeighborStars = mapEvaluator.getIndependentNeighborStars();
                        var evaluations = mapEvaluator.evaluateIndependentTargets(independentNeighborStars);
                        var scores = mapEvaluator.scoreIndependentTargets(evaluations);
                        var template = Rance.Modules.DefaultModule.Objectives.expansion;
                        return DefaultModule.AIUtils.makeObjectivesFromScores(template, scores, basePriority);
                    },
                    unitsToFillObjectiveFN: DefaultModule.AIUtils.getUnitsToBeatImmediateTarget
                };
            })(Objectives = DefaultModule.Objectives || (DefaultModule.Objectives = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
/// <reference path="../../../src/templateinterfaces/iobjectivetemplate.d.ts" />
/// <reference path="aiutils.ts" />
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var Objectives;
            (function (Objectives) {
                Objectives.cleanUpPirates = {
                    key: "cleanUpPirates",
                    movePriority: 3,
                    preferredUnitComposition: {
                        combat: 0.65,
                        defence: 0.25,
                        utility: 0.1
                    },
                    moveRoutineFN: DefaultModule.AIUtils.musterAndAttackRoutine.bind(null, DefaultModule.AIUtils.independentTargetFilter),
                    unitDesireFN: DefaultModule.AIUtils.defaultUnitDesireFN,
                    unitFitFN: DefaultModule.AIUtils.defaultUnitFitFN,
                    creatorFunction: function (grandStrategyAI, mapEvaluator, objectivesAI) {
                        var basePriority = grandStrategyAI.desireForExpansion;
                        var ownedStarsWithPirates = mapEvaluator.player.controlledLocations.filter(function (star) {
                            return star.getIndependentUnits().length > 0 && !star.getSecondaryController();
                        });
                        var evaluations = mapEvaluator.evaluateIndependentTargets(ownedStarsWithPirates);
                        var scores = mapEvaluator.scoreIndependentTargets(evaluations);
                        var template = Rance.Modules.DefaultModule.Objectives.cleanUpPirates;
                        return DefaultModule.AIUtils.makeObjectivesFromScores(template, scores, basePriority);
                    },
                    unitsToFillObjectiveFN: DefaultModule.AIUtils.getUnitsToBeatImmediateTarget
                };
            })(Objectives = DefaultModule.Objectives || (DefaultModule.Objectives = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
/// <reference path="../../../src/templateinterfaces/iobjectivetemplate.d.ts" />
/// <reference path="aiutils.ts" />
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var Objectives;
            (function (Objectives) {
                Objectives.scoutingPerimeter = {
                    key: "scoutingPerimeter",
                    movePriority: 7,
                    preferredUnitComposition: {
                        scouting: 1
                    },
                    moveRoutineFN: DefaultModule.AIUtils.moveToRoutine,
                    unitDesireFN: DefaultModule.AIUtils.scoutingUnitDesireFN,
                    unitFitFN: DefaultModule.AIUtils.scoutingUnitFitFN,
                    creatorFunction: DefaultModule.AIUtils.perimeterObjectiveCreation.bind(null, "scoutingPerimeter", true, 0.3),
                    unitsToFillObjectiveFN: function (mapEvaluator, objective) {
                        return { min: 1, ideal: 1 };
                    }
                };
            })(Objectives = DefaultModule.Objectives || (DefaultModule.Objectives = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
/// <reference path="../../../src/templateinterfaces/iobjectivetemplate.d.ts" />
/// <reference path="aiutils.ts" />
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var Objectives;
            (function (Objectives) {
                Objectives.conquer = {
                    key: "conquer",
                    movePriority: 6,
                    preferredUnitComposition: {
                        combat: 0.65,
                        defence: 0.25,
                        utility: 0.1
                    },
                    moveRoutineFN: DefaultModule.AIUtils.musterAndAttackRoutine.bind(null, DefaultModule.AIUtils.buildingControllerFilter),
                    unitDesireFN: DefaultModule.AIUtils.defaultUnitDesireFN,
                    unitFitFN: DefaultModule.AIUtils.defaultUnitFitFN,
                    creatorFunction: function (grandStrategyAI, mapEvaluator, objectivesAI) {
                        var hostilePlayers = [];
                        var diplomacyStatus = mapEvaluator.player.diplomacyStatus;
                        for (var playerId in diplomacyStatus.metPlayers) {
                            if (diplomacyStatus.statusByPlayer[playerId] >= Rance.DiplomaticState.war) {
                                hostilePlayers.push(diplomacyStatus.metPlayers[playerId]);
                            }
                        }
                        var relativeThreatOfPlayers = mapEvaluator.getRelativePerceivedThreatOfAllKnownPlayers();
                        var possibleTargets = [];
                        for (var i = 0; i < hostilePlayers.length; i++) {
                            var desirabilityByStar = mapEvaluator.evaluateDesirabilityOfPlayersStars(hostilePlayers[i]).byStar;
                            var sortedIds = Rance.getObjectKeysSortedByValueOfProp(desirabilityByStar, "desirabilityByStar", "desc");
                            if (sortedIds.length === 0) {
                                continue;
                            }
                            possibleTargets.push(desirabilityByStar[sortedIds[0]].star);
                        }
                        var template = Rance.Modules.DefaultModule.Objectives.conquer;
                        var objectives = [];
                        for (var i = 0; i < possibleTargets.length; i++) {
                            var star = possibleTargets[i];
                            var player = star.owner;
                            var threat = relativeThreatOfPlayers[player.id];
                            objectives.push(new Rance.MapAI.Objective(template, threat, star));
                        }
                        return objectives;
                    },
                    unitsToFillObjectiveFN: DefaultModule.AIUtils.getUnitsToBeatImmediateTarget
                };
            })(Objectives = DefaultModule.Objectives || (DefaultModule.Objectives = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
/// <reference path="../../../src/templateinterfaces/iobjectivetemplate.d.ts" />
/// <reference path="aiutils.ts" />
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var Objectives;
            (function (Objectives) {
                Objectives.declareWar = {
                    key: "declareWar",
                    creatorFunction: function (grandStrategyAI, mapEvaluator) {
                        var template = Rance.Modules.DefaultModule.Objectives.declareWar;
                        var basePriority = grandStrategyAI.desireForWar;
                        var scores = [];
                        for (var playerId in mapEvaluator.player.diplomacyStatus.metPlayers) {
                            var player = mapEvaluator.player.diplomacyStatus.metPlayers[playerId];
                            if (!mapEvaluator.player.diplomacyStatus.canDeclareWarOn(player)) {
                                continue;
                            }
                            var score = mapEvaluator.getDesireToGoToWarWith(player) *
                                mapEvaluator.getAbilityToGoToWarWith(player);
                            scores.push({
                                player: player,
                                score: score
                            });
                        }
                        return DefaultModule.AIUtils.makeObjectivesFromScores(template, scores, basePriority);
                    },
                    diplomacyRoutineFN: function (objective, diplomacyAI, adjustments, afterDoneCallback) {
                        diplomacyAI.diplomacyStatus.declareWarOn(objective.targetPlayer);
                        afterDoneCallback();
                    }
                };
            })(Objectives = DefaultModule.Objectives || (DefaultModule.Objectives = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
/// <reference path="../../../src/templateinterfaces/iobjectivetemplate.d.ts" />
/// <reference path="aiutils.ts" />
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var Objectives;
            (function (Objectives) {
                Objectives.expandManufactoryCapacity = {
                    key: "expandManufactoryCapacity",
                    creatorFunction: function (grandStrategyAI, mapEvaluator, objectivesAI) {
                        // TODO economy ai
                        // base priority = manufacturing demand / manufacturing capacity
                        var template = Rance.Modules.DefaultModule.Objectives.expandManufactoryCapacity;
                        return [new Rance.MapAI.Objective(template, 0.5, null)];
                    },
                    economyRoutineFN: function (objective, economyAI) {
                        // TODO economy ai
                        var costByStar = [];
                        var player = economyAI.player;
                        var stars = player.controlledLocations;
                        if (player.money < 1200)
                            return;
                        for (var i = 0; i < stars.length; i++) {
                            var star = stars[i];
                            var fullyExpanded = star.manufactory && star.manufactory.capacity >= star.manufactory.maxCapacity;
                            if (fullyExpanded)
                                continue;
                            var expansionCost;
                            if (!star.manufactory)
                                expansionCost = app.moduleData.ruleSet.manufactory.buildCost;
                            else {
                                expansionCost = star.manufactory.getCapacityUpgradeCost();
                            }
                            costByStar.push({
                                star: star,
                                cost: expansionCost
                            });
                        }
                        if (costByStar.length === 0)
                            return;
                        costByStar.sort(function (a, b) {
                            return a.cost - b.cost;
                        });
                        var star = costByStar[0].star;
                        var cost = costByStar[0].cost;
                        if (player.money < cost * 1.1) {
                            return;
                        }
                        if (star.manufactory) {
                            star.manufactory.upgradeCapacity(1);
                        }
                        else {
                            star.buildManufactory();
                            player.money -= app.moduleData.ruleSet.manufactory.buildCost;
                        }
                    }
                };
            })(Objectives = DefaultModule.Objectives || (DefaultModule.Objectives = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var UIComponents;
            (function (UIComponents) {
                UIComponents.BattleFinishNotification = React.createClass({
                    displayName: "BattleFinishNotification",
                    render: function () {
                        var notification = this.props.notification;
                        var p = notification.props;
                        var attacker = p.attacker;
                        var defender = p.defender;
                        var victor = p.victor;
                        var location = p.location;
                        var message = notification.makeMessage();
                        var attackSuccessString = victor === attacker ? " succesfully " : " unsuccesfully ";
                        var attackerGainedControl = location.owner === attacker;
                        var controllerString = attackerGainedControl ? " now controls " :
                            " maintains control of ";
                        return (React.DOM.div({
                            className: "battle-finish-notification draggable-container"
                        }, message + ".", React.DOM.br(null), React.DOM.br(null), "" + attacker.name + attackSuccessString + "attacked " + defender.name + " in " +
                            location.name + ". " + victor.name + controllerString + location.name + "."));
                    }
                });
            })(UIComponents = DefaultModule.UIComponents || (DefaultModule.UIComponents = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
/// <reference path="../../../src/templateinterfaces/inotificationtemplate.d.ts"/>
/// <reference path="uicomponents/battlefinishnotification.ts" />
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var Notifications;
            (function (Notifications) {
                Notifications.battleFinishNotification = {
                    key: "battleFinishNotification",
                    displayName: "Battle finished",
                    category: "combat",
                    defaultFilterState: [Rance.NotificationFilterState.neverShow],
                    iconSrc: "modules\/default\/img\/resources\/test1.png",
                    eventListeners: ["makeBattleFinishNotification"],
                    contentConstructor: DefaultModule.UIComponents.BattleFinishNotification,
                    messageConstructor: function (props) {
                        var message = "A battle was fought in " + props.location.name + " between " +
                            props.attacker.name + " and " + props.defender.name;
                        return message;
                    },
                    serializeProps: function (props) {
                        return ({
                            attackerId: props.attacker.id,
                            defenderId: props.defender.id,
                            locationId: props.location.id,
                            victorId: props.victor.id
                        });
                    },
                    deserializeProps: function (props, gameLoader) {
                        return ({
                            attacker: gameLoader.playersById[props.attackerId],
                            defender: gameLoader.playersById[props.defenderId],
                            location: gameLoader.starsById[props.locationId],
                            victor: gameLoader.playersById[props.victorId]
                        });
                    }
                };
            })(Notifications = DefaultModule.Notifications || (DefaultModule.Notifications = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var UIComponents;
            (function (UIComponents) {
                UIComponents.WarDeclarationNotification = React.createClass({
                    displayName: "WarDeclarationNotification",
                    render: function () {
                        var notification = this.props.notification;
                        var p = notification.props;
                        return (React.DOM.div({
                            className: "war-declaration-notification draggable-container"
                        }, null));
                    }
                });
            })(UIComponents = DefaultModule.UIComponents || (DefaultModule.UIComponents = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
/// <reference path="../../../src/templateinterfaces/inotificationtemplate.d.ts"/>
/// <reference path="uicomponents/wardeclarationnotification.ts" />
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var Notifications;
            (function (Notifications) {
                Notifications.WarDeclarationNotification = {
                    key: "WarDeclarationNotification",
                    displayName: "War declaration",
                    category: "diplomacy",
                    defaultFilterState: [Rance.NotificationFilterState.showIfInvolved],
                    iconSrc: "modules\/default\/img\/resources\/test2.png",
                    eventListeners: ["makeWarDeclarationNotification"],
                    contentConstructor: DefaultModule.UIComponents.WarDeclarationNotification,
                    messageConstructor: function (props) {
                        var message = props.player1.name + " declared war on " + props.player2.name;
                        return message;
                    },
                    serializeProps: function (props) {
                        return ({
                            player1Id: props.player1.id,
                            player2Id: props.player2.id,
                        });
                    },
                    deserializeProps: function (props, gameLoader) {
                        return ({
                            player1: gameLoader.playersById[props.player1Id],
                            player2: gameLoader.playersById[props.player2Id],
                        });
                    }
                };
            })(Notifications = DefaultModule.Notifications || (DefaultModule.Notifications = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var UIComponents;
            (function (UIComponents) {
                UIComponents.PlayerDiedNotification = React.createClass({
                    displayName: "PlayerDiedNotification",
                    render: function () {
                        var notification = this.props.notification;
                        return (React.DOM.div({
                            className: "player-died-notification draggable-container"
                        }, "Here lies " + notification.props.deadPlayerName + ".", React.DOM.br(null), React.DOM.br(null), "He never scored."));
                    }
                });
            })(UIComponents = DefaultModule.UIComponents || (DefaultModule.UIComponents = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
/// <reference path="../../../src/templateinterfaces/inotificationtemplate.d.ts"/>
/// <reference path="uicomponents/playerdiednotification.ts" />
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var DefaultModule;
        (function (DefaultModule) {
            var Notifications;
            (function (Notifications) {
                Notifications.playerDiedNotification = {
                    key: "playerDiedNotification",
                    displayName: "Player died",
                    category: "game",
                    defaultFilterState: [Rance.NotificationFilterState.alwaysShow],
                    iconSrc: "modules\/default\/img\/resources\/test1.png",
                    eventListeners: ["makePlayerDiedNotification"],
                    contentConstructor: DefaultModule.UIComponents.PlayerDiedNotification,
                    messageConstructor: function (props) {
                        var message = "Player " + props.deadPlayerName + " died";
                        return message;
                    },
                    serializeProps: function (props) {
                        return ({
                            deadPlayerName: props.deadPlayerName
                        });
                    },
                    deserializeProps: function (props, gameLoader) {
                        return ({
                            deadPlayerName: props.deadPlayerName
                        });
                    }
                };
            })(Notifications = DefaultModule.Notifications || (DefaultModule.Notifications = {}));
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
/// <reference path="../../src/moduledata.ts" />
/// <reference path="../../src/spritesheetcachingfunctions.ts" />
/// <reference path="graphics/drawnebula.ts" />
/// <reference path="graphics/maprendererlayers.ts" />
/// <reference path="graphics/maprenderermapmodes.ts" />
/// <reference path="mapgen/spiralgalaxy.ts" />
/// <reference path="mapgen/test.ts" />
/// <reference path="templates/technologies.ts" />
/// <reference path="templates/abilities.ts" />
/// <reference path="templates/attitudemodifiers.ts" />
/// <reference path="templates/battlesfx.ts" />
/// <reference path="templates/buildings.ts" />
/// <reference path="templates/cultures.ts" />
/// <reference path="templates/effects.ts" />
/// <reference path="templates/items.ts" />
/// <reference path="templates/passiveskills.ts" />
/// <reference path="templates/personalities.ts" />
/// <reference path="templates/resources.ts" />
/// <reference path="templates/statuseffects.ts" />
/// <reference path="templates/subemblems.ts" />
/// <reference path="templates/unitarchetypes.ts" />
/// <reference path="templates/unitfamilies.ts" />
/// <reference path="templates/units.ts" />
/// <reference path="ai/discoveryobjective.ts" />
/// <reference path="ai/healobjective.ts" />
/// <reference path="ai/expansionobjective.ts" />
/// <reference path="ai/cleanupobjective.ts" />
/// <reference path="ai/scoutingperimeterobjective.ts" />
/// <reference path="ai/conquerobjective.ts" />
/// <reference path="ai/declarewarobjective.ts" />
/// <reference path="ai/expandmanufactorycapacityobjective.ts" />
/// <reference path="notifications/battlefinishnotification.ts" />
/// <reference path="notifications/wardeclarationnotification.ts" />
/// <reference path="notifications/playerdiednotification.ts" />
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        // TODO module | split into smaller modules (DefaultUnits, DefaultRuleSet, etc.)
        // would allow easier reuse but needs some kind of module management system.
        // probably not worth doing in the near future
        var DefaultModule;
        (function (DefaultModule) {
            DefaultModule.moduleFile = {
                key: "default",
                metaData: {
                    name: "default",
                    version: "6.9",
                    author: "me",
                    description: "default module"
                },
                loadAssets: function (onLoaded) {
                    var loader = new PIXI.loaders.Loader();
                    loader.add("img\/fowTexture.png"); // TODO module
                    loader.add("units", "modules\/default\/img\/units\/units.json");
                    loader.add("buildings", "modules\/default\/img\/buildings\/buildings.json");
                    loader.add("explosion", "modules\/default\/img\/battleEffects\/explosion.json");
                    loader.add("modules\/default\/img\/battleEffects\/rocket.png");
                    for (var templateKey in DefaultModule.Templates.SubEmblems) {
                        var template = DefaultModule.Templates.SubEmblems[templateKey];
                        loader.add({
                            url: template.src,
                            loadType: 2,
                            xhrType: "png"
                        });
                    }
                    loader.load(function (loader) {
                        ["units", "buildings"].forEach(function (spriteSheetName) {
                            var json = loader.resources[spriteSheetName].data;
                            var image = loader.resources[spriteSheetName + "_image"].data;
                            Rance.cacheSpriteSheetAsImages(json, image);
                        });
                        for (var templateKey in DefaultModule.Templates.SubEmblems) {
                            var template = DefaultModule.Templates.SubEmblems[templateKey];
                            var image = loader.resources[template.src].data;
                            app.images[template.src] = image;
                            // IE fix
                            if (!image.width) {
                                document.body.appendChild(image);
                                image.width = image.offsetWidth;
                                image.height = image.offsetHeight;
                                document.body.removeChild(image);
                            }
                        }
                        onLoaded();
                    });
                },
                constructModule: function (moduleData) {
                    moduleData.copyAllTemplates(DefaultModule.Templates);
                    moduleData.copyTemplates(DefaultModule.MapRendererLayers, "MapRendererLayers");
                    moduleData.copyTemplates(DefaultModule.MapRendererMapModes, "MapRendererMapModes");
                    moduleData.copyTemplates(DefaultModule.Objectives, "Objectives");
                    moduleData.copyTemplates(DefaultModule.Notifications, "Notifications");
                    moduleData.mapBackgroundDrawingFunction = DefaultModule.drawNebula;
                    moduleData.starBackgroundDrawingFunction = DefaultModule.drawNebula;
                    moduleData.defaultMap = DefaultModule.Templates.MapGen.spiralGalaxy;
                    return moduleData;
                }
            };
        })(DefaultModule = Modules.DefaultModule || (Modules.DefaultModule = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
/// <reference path="../../src/templateinterfaces/iculturetemplate.d.ts" />
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var PaintingPortraits;
        (function (PaintingPortraits) {
            var Culture;
            (function (Culture) {
                Culture.paintingPortraitsCulture = {
                    key: "paintingPortraitsCulture",
                    portraits: {
                        adelaide_hanscom1: {
                            key: "adelaide_hanscom1",
                            imageSrc: "modules\/paintingportraits\/img\/adelaide_hanscom1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        alessandro_allori1: {
                            key: "alessandro_allori1",
                            imageSrc: "modules\/paintingportraits\/img\/alessandro_allori1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        alessandro_allori2: {
                            key: "alessandro_allori2",
                            imageSrc: "modules\/paintingportraits\/img\/alessandro_allori2.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        alexandre_cabanel1: {
                            key: "alexandre_cabanel1",
                            imageSrc: "modules\/paintingportraits\/img\/alexandre_cabanel1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        alexei_harlamov1: {
                            key: "alexei_harlamov1",
                            imageSrc: "modules\/paintingportraits\/img\/alexei_harlamov1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        alexey_petrovich_antropov1: {
                            key: "alexey_petrovich_antropov1",
                            imageSrc: "modules\/paintingportraits\/img\/alexey_petrovich_antropov1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        alice_pike_barney1: {
                            key: "alice_pike_barney1",
                            imageSrc: "modules\/paintingportraits\/img\/alice_pike_barney1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        aman_theodor1: {
                            key: "aman_theodor1",
                            imageSrc: "modules\/paintingportraits\/img\/aman_theodor1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        antonello_messina1: {
                            key: "antonello_messina1",
                            imageSrc: "modules\/paintingportraits\/img\/antonello_messina1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        antonio_herrera_toro1: {
                            key: "antonio_herrera_toro1",
                            imageSrc: "modules\/paintingportraits\/img\/antonio_herrera_toro1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        benjaminconstant1: {
                            key: "benjaminconstant1",
                            imageSrc: "modules\/paintingportraits\/img\/benjamin-constant1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        benoist_marieguillemine1: {
                            key: "benoist_marieguillemine1",
                            imageSrc: "modules\/paintingportraits\/img\/benoist_marie-guillemine1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        bouguereau_williamadolphe1: {
                            key: "bouguereau_williamadolphe1",
                            imageSrc: "modules\/paintingportraits\/img\/bouguereau_william-adolphe1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        byron1: {
                            key: "byron1",
                            imageSrc: "modules\/paintingportraits\/img\/byron1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        carl_fredric_breda1: {
                            key: "carl_fredric_breda1",
                            imageSrc: "modules\/paintingportraits\/img\/carl_fredric_breda1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        carl_fredric_breda2: {
                            key: "carl_fredric_breda2",
                            imageSrc: "modules\/paintingportraits\/img\/carl_fredric_breda2.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        cramacj_lucas1: {
                            key: "cramacj_lucas1",
                            imageSrc: "modules\/paintingportraits\/img\/cramacj_lucas1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        cranach_lucas2: {
                            key: "cranach_lucas2",
                            imageSrc: "modules\/paintingportraits\/img\/cranach_lucas2.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        cristobal_rojas1: {
                            key: "cristobal_rojas1",
                            imageSrc: "modules\/paintingportraits\/img\/cristobal_rojas1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        delacroix_eugene_ferdinand_victor1: {
                            key: "delacroix_eugene_ferdinand_victor1",
                            imageSrc: "modules\/paintingportraits\/img\/delacroix_eugene_ferdinand_victor1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        domenikos_theotokopoulos1: {
                            key: "domenikos_theotokopoulos1",
                            imageSrc: "modules\/paintingportraits\/img\/domenikos_theotokopoulos1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        edmund_blair_leighton1: {
                            key: "edmund_blair_leighton1",
                            imageSrc: "modules\/paintingportraits\/img\/edmund_blair_leighton1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        edmund_blair_leighton2: {
                            key: "edmund_blair_leighton2",
                            imageSrc: "modules\/paintingportraits\/img\/edmund_blair_leighton2.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        edwin_longsden_long1: {
                            key: "edwin_longsden_long1",
                            imageSrc: "modules\/paintingportraits\/img\/edwin_longsden_long1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        falero_luis_ricardo1: {
                            key: "falero_luis_ricardo1",
                            imageSrc: "modules\/paintingportraits\/img\/falero_luis_ricardo1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        felix_bonfils1: {
                            key: "felix_bonfils1",
                            imageSrc: "modules\/paintingportraits\/img\/felix_bonfils1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        francesco_hayez1: {
                            key: "francesco_hayez1",
                            imageSrc: "modules\/paintingportraits\/img\/francesco_hayez1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        francisco_goya_lucientes1: {
                            key: "francisco_goya_lucientes1",
                            imageSrc: "modules\/paintingportraits\/img\/francisco_goya_lucientes1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        francisco_goya_lucientes2: {
                            key: "francisco_goya_lucientes2",
                            imageSrc: "modules\/paintingportraits\/img\/francisco_goya_lucientes2.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        francisco_zurbaran1: {
                            key: "francisco_zurbaran1",
                            imageSrc: "modules\/paintingportraits\/img\/francisco_zurbaran1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        franz_von_defregger1: {
                            key: "franz_von_defregger1",
                            imageSrc: "modules\/paintingportraits\/img\/franz_von_defregger1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        franz_von_defregger2: {
                            key: "franz_von_defregger2",
                            imageSrc: "modules\/paintingportraits\/img\/franz_von_defregger2.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        franz_von_defregger3: {
                            key: "franz_von_defregger3",
                            imageSrc: "modules\/paintingportraits\/img\/franz_von_defregger3.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        frederick_leighton1: {
                            key: "frederick_leighton1",
                            imageSrc: "modules\/paintingportraits\/img\/frederick_leighton1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        frederic_westin1: {
                            key: "frederic_westin1",
                            imageSrc: "modules\/paintingportraits\/img\/frederic_westin1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        frederic_yates1: {
                            key: "frederic_yates1",
                            imageSrc: "modules\/paintingportraits\/img\/frederic_yates1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        gaston_bussiere1: {
                            key: "gaston_bussiere1",
                            imageSrc: "modules\/paintingportraits\/img\/gaston_bussiere1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        george_henry_hall1: {
                            key: "george_henry_hall1",
                            imageSrc: "modules\/paintingportraits\/img\/george_henry_hall1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        giovanni_battista_tiepolo1: {
                            key: "giovanni_battista_tiepolo1",
                            imageSrc: "modules\/paintingportraits\/img\/giovanni_battista_tiepolo1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        giovanni_bellini1: {
                            key: "giovanni_bellini1",
                            imageSrc: "modules\/paintingportraits\/img\/giovanni_bellini1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        hans_holbein1: {
                            key: "hans_holbein1",
                            imageSrc: "modules\/paintingportraits\/img\/hans_holbein1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        hayez_francesco1: {
                            key: "hayez_francesco1",
                            imageSrc: "modules\/paintingportraits\/img\/hayez_francesco1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        henryk_siemiradzki1: {
                            key: "henryk_siemiradzki1",
                            imageSrc: "modules\/paintingportraits\/img\/henryk_siemiradzki1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        ilja_jefimowitsch_repin1: {
                            key: "ilja_jefimowitsch_repin1",
                            imageSrc: "modules\/paintingportraits\/img\/ilja_jefimowitsch_repin1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        james_carrol_beckwith1: {
                            key: "james_carrol_beckwith1",
                            imageSrc: "modules\/paintingportraits\/img\/james_carrol_beckwith1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        jeanbaptistecamille_corot1: {
                            key: "jeanbaptistecamille_corot1",
                            imageSrc: "modules\/paintingportraits\/img\/jean-baptiste-camille_corot1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        jeanbaptistecamille_corot2: {
                            key: "jeanbaptistecamille_corot2",
                            imageSrc: "modules\/paintingportraits\/img\/jean-baptiste-camille_corot2.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        jeanleon_gerome1: {
                            key: "jeanleon_gerome1",
                            imageSrc: "modules\/paintingportraits\/img\/jean-leon_gerome1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        jeanleon_gerome2: {
                            key: "jeanleon_gerome2",
                            imageSrc: "modules\/paintingportraits\/img\/jean-leon_gerome2.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        jeanleon_gerome3: {
                            key: "jeanleon_gerome3",
                            imageSrc: "modules\/paintingportraits\/img\/jean-leon_gerome3.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        jeanleon_gerome4: {
                            key: "jeanleon_gerome4",
                            imageSrc: "modules\/paintingportraits\/img\/jean-leon_gerome4.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        john_william_godward1: {
                            key: "john_william_godward1",
                            imageSrc: "modules\/paintingportraits\/img\/john_william_godward1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        john_william_godward2: {
                            key: "john_william_godward2",
                            imageSrc: "modules\/paintingportraits\/img\/john_william_godward2.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        john_william_godward3: {
                            key: "john_william_godward3",
                            imageSrc: "modules\/paintingportraits\/img\/john_william_godward3.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        julije_klovic1: {
                            key: "julije_klovic1",
                            imageSrc: "modules\/paintingportraits\/img\/julije_klovic1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        juriaen_streek1: {
                            key: "juriaen_streek1",
                            imageSrc: "modules\/paintingportraits\/img\/juriaen_streek1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        kiprenskij_orest_adamovic1: {
                            key: "kiprenskij_orest_adamovic1",
                            imageSrc: "modules\/paintingportraits\/img\/kiprenskij_orest_adamovic1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        konstantin_makovsky1: {
                            key: "konstantin_makovsky1",
                            imageSrc: "modules\/paintingportraits\/img\/konstantin_makovsky1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        lefebvre_jules_joseph1: {
                            key: "lefebvre_jules_joseph1",
                            imageSrc: "modules\/paintingportraits\/img\/lefebvre_jules_joseph1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        leonfrancois_comerre1: {
                            key: "leonfrancois_comerre1",
                            imageSrc: "modules\/paintingportraits\/img\/leon-francois_comerre1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        leopold_loffler1: {
                            key: "leopold_loffler1",
                            imageSrc: "modules\/paintingportraits\/img\/leopold_loffler1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        lewis_john_frederick1: {
                            key: "lewis_john_frederick1",
                            imageSrc: "modules\/paintingportraits\/img\/lewis_john_frederick1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        madrazo_garreta_raimundo1: {
                            key: "madrazo_garreta_raimundo1",
                            imageSrc: "modules\/paintingportraits\/img\/madrazo_garreta_raimundo1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        marie_bashkirtseff1: {
                            key: "marie_bashkirtseff1",
                            imageSrc: "modules\/paintingportraits\/img\/marie_bashkirtseff1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        moritz_kellerhoven1: {
                            key: "moritz_kellerhoven1",
                            imageSrc: "modules\/paintingportraits\/img\/moritz_kellerhoven1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        nathaniel_jocelyn1: {
                            key: "nathaniel_jocelyn1",
                            imageSrc: "modules\/paintingportraits\/img\/nathaniel_jocelyn1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        nikolai_alexandrowitsch_jaroschenko1: {
                            key: "nikolai_alexandrowitsch_jaroschenko1",
                            imageSrc: "modules\/paintingportraits\/img\/nikolai_alexandrowitsch_jaroschenko1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        nils_johan_olsson_blommer1: {
                            key: "nils_johan_olsson_blommer1",
                            imageSrc: "modules\/paintingportraits\/img\/nils_johan_olsson_blommer1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        paolo_veronese1: {
                            key: "paolo_veronese1",
                            imageSrc: "modules\/paintingportraits\/img\/paolo_veronese1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        parmigianino1: {
                            key: "parmigianino1",
                            imageSrc: "modules\/paintingportraits\/img\/parmigianino1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        paul_cesar_helleu1: {
                            key: "paul_cesar_helleu1",
                            imageSrc: "modules\/paintingportraits\/img\/paul_cesar_helleu1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        regnault_henri1: {
                            key: "regnault_henri1",
                            imageSrc: "modules\/paintingportraits\/img\/regnault_henri1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        richard_bergh1: {
                            key: "richard_bergh1",
                            imageSrc: "modules\/paintingportraits\/img\/richard_bergh1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        richard_bergh2: {
                            key: "richard_bergh2",
                            imageSrc: "modules\/paintingportraits\/img\/richard_bergh2.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        robert_dampier1: {
                            key: "robert_dampier1",
                            imageSrc: "modules\/paintingportraits\/img\/robert_dampier1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        robert_lefevre1: {
                            key: "robert_lefevre1",
                            imageSrc: "modules\/paintingportraits\/img\/robert_lefevre1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        robert_leopold1: {
                            key: "robert_leopold1",
                            imageSrc: "modules\/paintingportraits\/img\/robert_leopold1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        sichel_nathanael1: {
                            key: "sichel_nathanael1",
                            imageSrc: "modules\/paintingportraits\/img\/sichel_nathanael1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        svetoslav_roerich1: {
                            key: "svetoslav_roerich1",
                            imageSrc: "modules\/paintingportraits\/img\/svetoslav_roerich1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        velazquez_diego1: {
                            key: "velazquez_diego1",
                            imageSrc: "modules\/paintingportraits\/img\/velazquez_diego1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        viktor_vasnetsov1: {
                            key: "viktor_vasnetsov1",
                            imageSrc: "modules\/paintingportraits\/img\/viktor_vasnetsov1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        },
                        williamadolphe_bouguereau1: {
                            key: "williamadolphe_bouguereau1",
                            imageSrc: "modules\/paintingportraits\/img\/william-adolphe_bouguereau1.png",
                            generatedFor: [
                                Rance.RandomGenUnitRarity.common,
                                Rance.RandomGenUnitRarity.elite,
                                Rance.RandomGenUnitRarity.commander
                            ]
                        }
                    }
                };
            })(Culture = PaintingPortraits.Culture || (PaintingPortraits.Culture = {}));
        })(PaintingPortraits = Modules.PaintingPortraits || (Modules.PaintingPortraits = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
/// <reference path="../../src/moduledata.ts" />
/// <reference path="culture.ts" />
var Rance;
(function (Rance) {
    var Modules;
    (function (Modules) {
        var PaintingPortraits;
        (function (PaintingPortraits) {
            PaintingPortraits.moduleFile = {
                key: "paintingPortraits",
                metaData: {
                    name: "paintingPortraits",
                    version: "0.0.420",
                    author: "various artists",
                    description: "old ppl"
                },
                loadAssets: function (onLoaded) {
                    onLoaded();
                },
                constructModule: function (moduleData) {
                    moduleData.copyTemplates(PaintingPortraits.Culture, "Cultures");
                    return moduleData;
                }
            };
        })(PaintingPortraits = Modules.PaintingPortraits || (Modules.PaintingPortraits = {}));
    })(Modules = Rance.Modules || (Rance.Modules = {}));
})(Rance || (Rance = {}));
/// <reference path="game.ts"/>
/// <reference path="player.ts"/>
/// <reference path="galaxymap.ts"/>
/// <reference path="star.ts" />
/// <reference path="fillerpoint.ts" />
/// <reference path="savedata/iattitudemodifiersavedata.d.ts" />
/// <reference path="savedata/iitemsavedata.d.ts" />
/// <reference path="savedata/ibuildingsavedata.d.ts" />
/// <reference path="savedata/imanufactorysavedata.d.ts" />
/// <reference path="savedata/idiplomacystatussavedata.d.ts" />
/// <reference path="savedata/inotificationlogsavedata.d.ts" />
/// <reference path="savedata/iemblemsavedata.d.ts" />
/// <reference path="savedata/inotificationsavedata.d.ts" />
/// <reference path="savedata/iflagsavedata.d.ts" />
/// <reference path="savedata/iplayersavedata.d.ts" />
/// <reference path="savedata/ifleetsavedata.d.ts" />
/// <reference path="savedata/iplayertechnologysavedata.d.ts" />
/// <reference path="savedata/igalaxymapsavedata.d.ts" />
/// <reference path="savedata/istarsavedata.d.ts" />
/// <reference path="savedata/igamesavedata.d.ts" />
/// <reference path="savedata/iunitsavedata.d.ts" />
var Rance;
(function (Rance) {
    var GameLoader = (function () {
        function GameLoader() {
            this.players = [];
            this.independents = [];
            this.playersById = {};
            this.starsById = {};
            this.unitsById = {};
            this.buildingsByControllerId = {};
        }
        GameLoader.prototype.deserializeGame = function (data) {
            this.map = this.deserializeMap(data.galaxyMap);
            for (var i = 0; i < data.players.length; i++) {
                var playerData = data.players[i];
                var id = playerData.id;
                var player = this.playersById[id] = this.deserializePlayer(playerData);
                if (player.isIndependent) {
                    this.independents.push(player);
                }
                else {
                    this.players.push(player);
                }
            }
            for (var i = 0; i < data.players.length; i++) {
                var playerData = data.players[i];
                this.deserializeDiplomacyStatus(this.playersById[playerData.id], playerData.diplomacyStatus);
                this.deserializeIdentifiedUnits(this.playersById[playerData.id], playerData.identifiedUnitIds);
            }
            this.humanPlayer = this.playersById[data.humanPlayerId];
            this.deserializeBuildings(data.galaxyMap);
            var game = new Rance.Game(this.map, this.players, this.humanPlayer);
            game.independents = game.independents.concat(this.independents);
            game.turnNumber = data.turnNumber;
            if (data.notificationLog) {
                game.notificationLog = this.deserializeNotificationLog(data.notificationLog);
                game.notificationLog.setTurn(game.turnNumber, true);
            }
            return game;
        };
        // legacy savedata 10.3.2016
        GameLoader.prototype.deserializeNotificationLog = function (data) {
            var notificationsData = Array.isArray(data) ? data : data.notifications;
            var notificationLog = new Rance.NotificationLog(this.humanPlayer);
            for (var i = 0; i < notificationsData.length; i++) {
                var template = app.moduleData.Templates.Notifications[notificationsData[i].templateKey];
                var props = template.deserializeProps(notificationsData[i].props, this);
                var notification = new Rance.Notification(template, props, notificationsData[i].turn);
                notification.hasBeenRead = notificationsData[i].hasBeenRead;
                notificationLog.addNotification(notification);
            }
            return notificationLog;
        };
        GameLoader.prototype.deserializeMap = function (data) {
            var stars = [];
            for (var i = 0; i < data.stars.length; i++) {
                var star = this.deserializeStar(data.stars[i]);
                stars.push(star);
                this.starsById[star.id] = star;
            }
            for (var i = 0; i < data.stars.length; i++) {
                var dataStar = data.stars[i];
                var realStar = this.starsById[dataStar.id];
                for (var j = 0; j < dataStar.linksToIds.length; j++) {
                    var linkId = dataStar.linksToIds[j];
                    var linkStar = this.starsById[linkId];
                    realStar.addLink(linkStar);
                }
            }
            var fillerPoints = [];
            for (var i = 0; i < data.fillerPoints.length; i++) {
                var dataPoint = data.fillerPoints[i];
                fillerPoints.push(new Rance.FillerPoint(dataPoint.x, dataPoint.y));
            }
            var mapGenResult = new Rance.MapGenCore.MapGenResult({
                stars: stars,
                fillerPoints: fillerPoints,
                width: data.width,
                height: data.height,
                seed: data.seed,
                independents: null
            });
            var galaxyMap = mapGenResult.makeMap();
            return galaxyMap;
        };
        GameLoader.prototype.deserializeStar = function (data) {
            var star = new Rance.Star(data.x, data.y, data.id);
            star.name = data.name;
            star.baseIncome = data.baseIncome;
            star.seed = data.seed;
            if (data.resourceType) {
                star.setResource(app.moduleData.Templates.Resources[data.resourceType]);
            }
            if (data.buildableUnitTypes) {
                for (var i = 0; i < data.buildableUnitTypes.length; i++) {
                    star.buildableUnitTypes.push(app.moduleData.Templates.Units[data.buildableUnitTypes[i]]);
                }
            }
            return star;
        };
        GameLoader.prototype.deserializeBuildings = function (data) {
            for (var i = 0; i < data.stars.length; i++) {
                var starData = data.stars[i];
                var star = this.starsById[starData.id];
                for (var category in starData.buildings) {
                    for (var j = 0; j < starData.buildings[category].length; j++) {
                        var buildingData = starData.buildings[category][j];
                        var building = this.deserializeBuilding(buildingData);
                        star.addBuilding(building);
                    }
                }
                if (starData.manufactory) {
                    star.manufactory = new Rance.Manufactory(star, starData.manufactory);
                }
            }
        };
        GameLoader.prototype.deserializeBuilding = function (data) {
            var template = app.moduleData.Templates.Buildings[data.templateType];
            var building = new Rance.Building({
                template: template,
                location: this.starsById[data.locationId],
                controller: this.playersById[data.controllerId],
                upgradeLevel: data.upgradeLevel,
                totalCost: data.totalCost,
                id: data.id
            });
            return building;
        };
        GameLoader.prototype.deserializePlayer = function (data) {
            var personality;
            if (data.personality) {
                personality = Rance.extendObject(data.personality, Rance.makeRandomPersonality(), true);
            }
            var player = new Rance.Player(data.isAI, data.id);
            player.name = data.name;
            player.money = data.money;
            player.isIndependent = data.isIndependent;
            if (data.resources) {
                player.resources = Rance.extendObject(data.resources);
            }
            player.personality = personality;
            player.color = data.color;
            player.secondaryColor = data.secondaryColor;
            player.colorAlpha = data.colorAlpha;
            if (data.flag) {
                player.flag = this.deserializeFlag(data.flag);
            }
            else {
                player.makeRandomFlag();
            }
            // fleets & units
            for (var i = 0; i < data.fleets.length; i++) {
                var fleet = data.fleets[i];
                player.addFleet(this.deserializeFleet(player, fleet));
            }
            // stars
            for (var i = 0; i < data.controlledLocationIds.length; i++) {
                player.addStar(this.starsById[data.controlledLocationIds[i]]);
            }
            for (var i = 0; i < data.items.length; i++) {
                this.deserializeItem(data.items[i], player);
            }
            for (var i = 0; i < data.revealedStarIds.length; i++) {
                var id = data.revealedStarIds[i];
                player.revealedStars[id] = this.starsById[id];
            }
            // technology
            player.initTechnologies(data.researchByTechnology);
            return player;
        };
        GameLoader.prototype.deserializeDiplomacyStatus = function (player, data) {
            if (data) {
                for (var i = 0; i < data.metPlayerIds.length; i++) {
                    var id = data.metPlayerIds[i];
                    player.diplomacyStatus.metPlayers[id] = this.playersById[id];
                }
                player.diplomacyStatus.statusByPlayer = data.statusByPlayer;
                for (var playerId in data.attitudeModifiersByPlayer) {
                    var modifiers = data.attitudeModifiersByPlayer[playerId];
                    if (!modifiers || modifiers.length === 0) {
                        player.diplomacyStatus.attitudeModifiersByPlayer[playerId] = [];
                        continue;
                    }
                    for (var i = 0; i < modifiers.length; i++) {
                        var template = app.moduleData.Templates.AttitudeModifiers[modifiers[i].templateType];
                        var modifier = new Rance.AttitudeModifier({
                            template: template,
                            startTurn: modifiers[i].startTurn,
                            endTurn: modifiers[i].endTurn,
                            strength: modifiers[i].strength
                        });
                        player.diplomacyStatus.addAttitudeModifier(this.playersById[playerId], modifier);
                    }
                }
            }
        };
        GameLoader.prototype.deserializeIdentifiedUnits = function (player, data) {
            for (var i = 0; i < data.length; i++) {
                var unit = this.unitsById[data[i]];
                if (unit) {
                    player.identifyUnit(unit);
                }
            }
        };
        GameLoader.prototype.deserializeEmblem = function (emblemData, color) {
            var inner = app.moduleData.Templates.SubEmblems[emblemData.innerKey];
            var outer = emblemData.outerKey ?
                app.moduleData.Templates.SubEmblems[emblemData.outerKey] : null;
            return new Rance.Emblem(color, emblemData.alpha, inner, outer);
        };
        GameLoader.prototype.deserializeFlag = function (data) {
            var flag = new Rance.Flag({
                width: 46,
                mainColor: data.mainColor,
                secondaryColor: data.secondaryColor,
                tetriaryColor: data.tetriaryColor
            });
            if (data.customImage) {
                flag.setCustomImage(data.customImage);
            }
            else if (data.seed) {
                flag.generateRandom(data.seed);
            }
            else {
                if (data.foregroundEmblem) {
                    var fgEmblem = this.deserializeEmblem(data.foregroundEmblem, data.secondaryColor);
                    flag.setForegroundEmblem(fgEmblem);
                }
                if (data.backgroundEmblem) {
                    var bgEmblem = this.deserializeEmblem(data.backgroundEmblem, data.tetriaryColor);
                    flag.setBackgroundEmblem(bgEmblem);
                }
            }
            return flag;
        };
        GameLoader.prototype.deserializeFleet = function (player, data) {
            var units = [];
            // legacy savedata 10.3.2016
            var castedData = data;
            var unitsToDeserialize = castedData.units || castedData.ships;
            for (var i = 0; i < unitsToDeserialize.length; i++) {
                var unit = this.deserializeUnit(unitsToDeserialize[i]);
                player.addUnit(unit);
                units.push(unit);
            }
            var fleet = new Rance.Fleet(player, units, this.starsById[data.locationId], data.id, false);
            fleet.name = data.name;
            return fleet;
        };
        GameLoader.prototype.deserializeUnit = function (data) {
            var template = app.moduleData.Templates.Units[data.templateType];
            var unit = new Rance.Unit(template, data.id, data);
            this.unitsById[unit.id] = unit;
            return unit;
        };
        GameLoader.prototype.deserializeItem = function (data, player) {
            var template = app.moduleData.Templates.Items[data.templateType];
            var item = new Rance.Item(template, data.id);
            player.addItem(item);
            if (isFinite(data.unitId)) {
                this.unitsById[data.unitId].addItem(item);
            }
        };
        return GameLoader;
    }());
    Rance.GameLoader = GameLoader;
})(Rance || (Rance = {}));
/// <reference path="../src/utility.ts" />
/// <reference path="../src/unit.ts" />
var Rance;
(function (Rance) {
    function setAllDynamicTemplateProperties() {
        setAbilityGuardAddition();
        setAttitudeModifierOverride();
        setUnitFamilyAssociatedTemplates();
    }
    Rance.setAllDynamicTemplateProperties = setAllDynamicTemplateProperties;
    function setAbilityGuardAddition() {
        function checkIfAbilityAddsGuard(ability) {
            var effects = [ability.mainEffect];
            if (ability.secondaryEffects) {
                effects = effects.concat(ability.secondaryEffects);
            }
            var dummyUser = new Rance.Unit(Rance.getRandomProperty(app.moduleData.Templates.Units));
            var dummyTarget = new Rance.Unit(Rance.getRandomProperty(app.moduleData.Templates.Units));
            for (var i = 0; i < effects.length; i++) {
                effects[i].template.effect(dummyUser, dummyTarget, null, effects[i].data);
                if (dummyUser.battleStats.guardAmount) {
                    return true;
                }
            }
            return false;
        }
        for (var abilityName in app.moduleData.Templates.Abilities) {
            var ability = app.moduleData.Templates.Abilities[abilityName];
            ability.addsGuard = checkIfAbilityAddsGuard(ability);
        }
    }
    function setAttitudeModifierOverride() {
        for (var modifierType in app.moduleData.Templates.AttitudeModifiers) {
            var modifier = app.moduleData.Templates.AttitudeModifiers[modifierType];
            if (modifier.canBeOverriddenBy) {
                for (var i = 0; i < modifier.canBeOverriddenBy.length; i++) {
                    if (!modifier.canBeOverriddenBy[i].canOverride) {
                        modifier.canBeOverriddenBy[i].canOverride = [];
                    }
                    modifier.canBeOverriddenBy[i].canOverride.push(modifier);
                }
            }
        }
    }
    function setUnitFamilyAssociatedTemplates() {
        for (var unitType in app.moduleData.Templates.Units) {
            var template = app.moduleData.Templates.Units[unitType];
            for (var i = 0; i < template.families.length; i++) {
                var family = template.families[i];
                if (!family.associatedTemplates) {
                    family.associatedTemplates = [];
                }
                family.associatedTemplates.push(template);
            }
        }
    }
})(Rance || (Rance = {}));
var Rance;
(function (Rance) {
    function buildTemplateIndexes() {
        TemplateIndexes.distributablesByDistributionGroup = getDistributablesByDistributionGroup();
        TemplateIndexes.itemsByTechLevel = getItemsByTechLevel();
    }
    Rance.buildTemplateIndexes = buildTemplateIndexes;
    function getDistributablesByDistributionGroup() {
        var result = {};
        function putInGroups(distributables, distributableType) {
            for (var prop in distributables) {
                var distributable = distributables[prop];
                for (var i = 0; i < distributable.distributionGroups.length; i++) {
                    var groupName = distributable.distributionGroups[i];
                    if (!result[groupName]) {
                        result[groupName] =
                            {
                                unitFamilies: [],
                                resources: []
                            };
                    }
                    result[groupName][distributableType].push(distributable);
                }
            }
        }
        putInGroups(app.moduleData.Templates.UnitFamilies, "unitFamilies");
        putInGroups(app.moduleData.Templates.Resources, "resources");
        return result;
    }
    function getItemsByTechLevel() {
        var itemsByTechLevel = {};
        for (var itemName in app.moduleData.Templates.Items) {
            var item = app.moduleData.Templates.Items[itemName];
            if (!itemsByTechLevel[item.techLevel]) {
                itemsByTechLevel[item.techLevel] = [];
            }
            itemsByTechLevel[item.techLevel].push(item);
        }
        return itemsByTechLevel;
    }
    var TemplateIndexes;
    (function (TemplateIndexes) {
    })(TemplateIndexes = Rance.TemplateIndexes || (Rance.TemplateIndexes = {}));
})(Rance || (Rance = {}));
/// <reference path="../src/utility.ts" />
var Rance;
(function (Rance) {
    function saveOptions(slot) {
        if (slot === void 0) { slot = 0; }
        var data = JSON.stringify({
            options: Rance.Options,
            date: new Date()
        });
        var saveName = "Rance.Options." + slot;
        localStorage.setItem(saveName, data);
    }
    Rance.saveOptions = saveOptions;
    function loadOptions(slot) {
        var baseString = "Rance.Options.";
        var parsedData;
        if (slot && localStorage[baseString + slot]) {
            parsedData = JSON.parse(localStorage.getItem(baseString + slot));
        }
        else {
            parsedData = Rance.getMatchingLocalstorageItemsByDate(baseString)[0];
        }
        if (parsedData) {
            // month goes 0-11
            var optionsToResetIfSetEarlierThan = {
                "battleAnimationTiming": Date.UTC(2016, 1, 25, 10, 50)
            };
            var dateOptionsWereSaved = Date.parse(parsedData.date);
            for (var key in optionsToResetIfSetEarlierThan) {
                if (Rance.Options[key] !== undefined) {
                    if (optionsToResetIfSetEarlierThan[key] && dateOptionsWereSaved <= optionsToResetIfSetEarlierThan[key]) {
                        parsedData.options[key] = Rance.extendObject(Rance.Options[key]);
                        console.log("Reset option: " + key);
                    }
                }
            }
            Rance.Options = Rance.deepMerge(Rance.Options, parsedData.options, true);
        }
    }
    Rance.loadOptions = loadOptions;
    var defaultOptions;
    (function (defaultOptions) {
        defaultOptions.battleAnimationTiming = {
            before: 750,
            effectDuration: 1,
            after: 1500,
            unitEnter: 200,
            unitExit: 100
        };
        defaultOptions.debugMode = false;
        defaultOptions.debugOptions = {
            battleSimulationDepth: 20
        };
        defaultOptions.ui = {
            noHamburger: false
        };
        defaultOptions.display = {
            borderWidth: 8
        };
    })(defaultOptions = Rance.defaultOptions || (Rance.defaultOptions = {}));
})(Rance || (Rance = {}));
/// <reference path="../lib/pixi.d.ts" />
/// <reference path="templateinterfaces/IBattleSFXTemplate.d.ts" />
/// <reference path="unit.ts" />
var Rance;
(function (Rance) {
    (function (BattleSceneUnitState) {
        BattleSceneUnitState[BattleSceneUnitState["entering"] = 0] = "entering";
        BattleSceneUnitState[BattleSceneUnitState["stationary"] = 1] = "stationary";
        BattleSceneUnitState[BattleSceneUnitState["exiting"] = 2] = "exiting";
        BattleSceneUnitState[BattleSceneUnitState["removed"] = 3] = "removed";
    })(Rance.BattleSceneUnitState || (Rance.BattleSceneUnitState = {}));
    var BattleSceneUnitState = Rance.BattleSceneUnitState;
    var BattleSceneUnit = (function () {
        function BattleSceneUnit(container, renderer) {
            this.unitState = BattleSceneUnitState.removed;
            this.hasSFXSprite = false;
            this.container = container;
            this.renderer = renderer;
            this.initLayers();
        }
        BattleSceneUnit.prototype.destroy = function () {
        };
        BattleSceneUnit.prototype.initLayers = function () {
            this.spriteContainer = new PIXI.Container;
            this.container.addChild(this.spriteContainer);
        };
        BattleSceneUnit.prototype.changeActiveUnit = function (unit, afterChangedCallback) {
            if (this.hasSFXSprite) {
                if (unit) {
                    this.enterUnitSpriteWithoutAnimation(unit);
                }
                else {
                    this.exitUnitSpriteWithoutAnimation();
                }
                this.hasSFXSprite = false;
            }
            else if (!unit && this.activeUnit) {
                this.onFinishExit = afterChangedCallback;
                this.exitUnitSprite();
            }
            else if (unit && unit !== this.activeUnit) {
                this.onFinishEnter = afterChangedCallback;
                this.enterUnitSprite(unit);
            }
            else if (afterChangedCallback) {
                afterChangedCallback();
            }
        };
        BattleSceneUnit.prototype.setSFX = function (SFXTemplate, user, target) {
            if (this.activeUnit) {
                var duration = SFXTemplate.duration * Rance.Options.battleAnimationTiming.effectDuration;
                if (this.activeUnit === user && SFXTemplate.userSprite) {
                    this.setSFXSprite(SFXTemplate.userSprite, duration);
                }
                else if (this.activeUnit === target && SFXTemplate.enemySprite) {
                    this.setSFXSprite(SFXTemplate.enemySprite, duration);
                }
                else {
                }
            }
            else {
            }
        };
        BattleSceneUnit.prototype.resize = function () {
            if (this.spriteContainer.children.length > 0) {
                this.setContainerPosition();
            }
        };
        // enter without animation
        BattleSceneUnit.prototype.enterUnitSpriteWithoutAnimation = function (unit) {
            this.setUnit(unit);
            this.setUnitSprite(unit);
            this.finishUnitSpriteEnter();
        };
        // exit without animation
        BattleSceneUnit.prototype.exitUnitSpriteWithoutAnimation = function () {
            this.finishUnitSpriteExit();
        };
        // enter with animation
        BattleSceneUnit.prototype.enterUnitSprite = function (unit) {
            if (this.unitState === BattleSceneUnitState.stationary) {
                // trigger exit
                // on exit finish:
                //    trigger enter
                this.onFinishExit = this.startUnitSpriteEnter.bind(this, unit);
                this.exitUnitSprite();
            }
            else if (this.unitState === BattleSceneUnitState.exiting) {
                // on exit finish:
                //    trigger enter
                this.onFinishExit = this.startUnitSpriteEnter.bind(this, unit);
            }
            else {
                // clear
                // trigger enter
                this.clearUnit();
                this.clearUnitSprite();
                this.startUnitSpriteEnter(unit);
            }
            // this.clearUnit();
            // this.clearUnitSprite();
            // this.startUnitSpriteEnter(unit);
        };
        // exit with animation
        BattleSceneUnit.prototype.exitUnitSprite = function () {
            if (this.unitState === BattleSceneUnitState.entering) {
                this.finishUnitSpriteExit();
            }
            else if (this.unitState === BattleSceneUnitState.stationary) {
                this.startUnitSpriteExit();
            }
            else if (this.unitState === BattleSceneUnitState.exiting) {
                this.onFinishExit = null;
            }
            else {
                console.warn("called exitUnitSprite with unintended animation state " +
                    BattleSceneUnitState[this.unitState]);
            }
        };
        BattleSceneUnit.prototype.startUnitSpriteEnter = function (unit) {
            var enterAnimationDuration = Rance.Options.battleAnimationTiming.unitEnter;
            if (enterAnimationDuration <= 0) {
                this.enterUnitSpriteWithoutAnimation(unit);
                return;
            }
            this.setUnit(unit);
            this.setUnitSprite(unit);
            this.unitState = BattleSceneUnitState.entering;
            this.tween = this.makeEnterExitTween("enter", enterAnimationDuration, this.finishUnitSpriteEnter.bind(this));
            this.tween.start();
        };
        BattleSceneUnit.prototype.finishUnitSpriteEnter = function () {
            this.unitState = BattleSceneUnitState.stationary;
            this.clearTween();
            if (this.onFinishEnter) {
                this.onFinishEnter();
                this.onFinishEnter = null;
            }
        };
        BattleSceneUnit.prototype.startUnitSpriteExit = function () {
            var exitAnimationDuration = Rance.Options.battleAnimationTiming.unitExit;
            if (exitAnimationDuration <= 0) {
                this.exitUnitSpriteWithoutAnimation();
                return;
            }
            this.unitState = BattleSceneUnitState.exiting;
            this.tween = this.makeEnterExitTween("exit", exitAnimationDuration, this.finishUnitSpriteExit.bind(this));
            this.tween.start();
        };
        BattleSceneUnit.prototype.finishUnitSpriteExit = function () {
            this.clearUnit();
            this.clearUnitSprite();
            if (this.onFinishExit) {
                this.onFinishExit();
                this.onFinishExit = null;
            }
        };
        BattleSceneUnit.prototype.getSFXParams = function (props) {
            var bounds = this.getSceneBounds();
            return ({
                user: props.unit,
                width: bounds.width,
                height: bounds.height,
                duration: props.duration,
                facingRight: props.unit.battleStats.side === "side1",
                renderer: this.renderer,
                triggerStart: props.triggerStart,
                triggerEnd: props.triggerEnd
            });
        };
        BattleSceneUnit.prototype.setContainerPosition = function (positionOffScreen) {
            if (positionOffScreen === void 0) { positionOffScreen = false; }
            // TODO battle scene | This & unit drawing FN rely on overly fiddly positioning.
            // This function might not work properly with other drawing functions.
            var sceneBounds = this.getSceneBounds();
            var shouldReverse = this.activeUnit.battleStats.side === "side1";
            var container = this.spriteContainer;
            var containerBounds = container.getLocalBounds();
            var xPadding = 30;
            var yPadding = 40;
            container.y = Math.round(sceneBounds.height - containerBounds.height - containerBounds.y - yPadding);
            if (shouldReverse) {
                container.scale.x = -1;
                container.x = Math.round(containerBounds.width + containerBounds.x + xPadding);
            }
            else {
                container.x = Math.round(sceneBounds.width - containerBounds.width - containerBounds.x - xPadding);
            }
        };
        BattleSceneUnit.prototype.setUnit = function (unit) {
            this.clearUnit();
            this.activeUnit = unit;
        };
        BattleSceneUnit.prototype.clearUnit = function () {
            this.unitState = BattleSceneUnitState.removed;
            this.activeUnit = null;
            this.clearTween();
        };
        BattleSceneUnit.prototype.makeUnitSprite = function (unit, SFXParams) {
            return unit.drawBattleScene(SFXParams);
        };
        BattleSceneUnit.prototype.addUnitSprite = function (sprite) {
            this.spriteContainer.addChild(sprite);
            this.setContainerPosition();
        };
        BattleSceneUnit.prototype.clearUnitSprite = function () {
            this.spriteContainer.removeChildren();
        };
        BattleSceneUnit.prototype.setUnitSprite = function (unit) {
            this.clearUnitSprite();
            var SFXParams = this.getSFXParams({
                unit: unit,
                triggerStart: this.addUnitSprite.bind(this)
            });
            this.makeUnitSprite(unit, SFXParams);
        };
        BattleSceneUnit.prototype.clearTween = function () {
            if (this.tween) {
                this.tween.stop();
                TWEEN.remove(this.tween);
                this.tween = null;
            }
        };
        BattleSceneUnit.prototype.makeEnterExitTween = function (direction, duration, onComplete) {
            var side = this.activeUnit.battleStats.side;
            var container = this.spriteContainer;
            var bounds = container.getBounds();
            var distanceToMove = bounds.width * 1.25;
            if (side === "side2") {
                distanceToMove *= -1;
            }
            var offscreenLocation = container.x - distanceToMove;
            var stationaryLocation = container.x;
            var startX = direction === "enter" ? offscreenLocation : stationaryLocation;
            var finishX = direction === "enter" ? stationaryLocation : offscreenLocation;
            container.x = startX;
            var tween = new TWEEN.Tween({
                x: startX
            }).to({
                x: finishX
            }, duration).onStart(function () {
                container.x = startX;
            }).onUpdate(function () {
                container.x = this.x;
            }).onComplete(onComplete);
            tween.start();
            return tween;
        };
        BattleSceneUnit.prototype.setSFXSprite = function (spriteDrawingFN, duration) {
            this.clearUnitSprite();
            var SFXParams = this.getSFXParams({
                unit: this.activeUnit,
                duration: duration,
                triggerStart: this.addUnitSprite.bind(this)
            });
            this.hasSFXSprite = true;
            spriteDrawingFN(SFXParams);
        };
        return BattleSceneUnit;
    }());
    Rance.BattleSceneUnit = BattleSceneUnit;
})(Rance || (Rance = {}));
/// <reference path="../lib/pixi.d.ts" />
/// <reference path="templateinterfaces/IBattleSFXTemplate.d.ts" />
/// <reference path="unit.ts" />
var Rance;
(function (Rance) {
    var BattleSceneUnitOverlay = (function () {
        function BattleSceneUnitOverlay(container, renderer) {
            this.animationIsActive = false;
            this.container = container;
            this.renderer = renderer;
            this.initLayers();
        }
        BattleSceneUnitOverlay.prototype.destroy = function () {
        };
        BattleSceneUnitOverlay.prototype.initLayers = function () {
            this.overlayContainer = new PIXI.Container;
            this.container.addChild(this.overlayContainer);
        };
        BattleSceneUnitOverlay.prototype.setSFX = function (SFXTemplate, user, target) {
            if (this.activeUnit) {
                var duration = SFXTemplate.duration * Rance.Options.battleAnimationTiming.effectDuration;
                if (this.activeUnit === user && SFXTemplate.userOverlay) {
                    this.setOverlay(SFXTemplate.userOverlay, user, duration);
                }
                else if (this.activeUnit === target && SFXTemplate.enemyOverlay) {
                    this.setOverlay(SFXTemplate.enemyOverlay, target, duration);
                }
                else {
                }
            }
            else {
            }
        };
        BattleSceneUnitOverlay.prototype.setOverlay = function (overlayFN, unit, duration) {
            this.clearOverlay();
            if (duration <= 0) {
                return;
            }
            if (this.animationIsActive) {
                console.warn("Triggered new unit overlay animation without clearing previous one");
            }
            this.activeUnit = unit;
            var SFXParams = this.getSFXParams(duration, this.addOverlay.bind(this), this.finishAnimation.bind(this));
            overlayFN(SFXParams);
        };
        BattleSceneUnitOverlay.prototype.clearOverlay = function () {
            this.animationIsActive = false;
            this.onAnimationFinish = null;
            this.activeUnit = null;
            this.overlayContainer.removeChildren();
        };
        BattleSceneUnitOverlay.prototype.getSFXParams = function (duration, triggerStart, triggerEnd) {
            var bounds = this.getSceneBounds();
            return ({
                user: this.activeUnit,
                width: bounds.width,
                height: bounds.height,
                duration: duration,
                facingRight: this.activeUnit.battleStats.side === "side1",
                renderer: this.renderer,
                triggerStart: triggerStart,
                triggerEnd: triggerEnd
            });
        };
        BattleSceneUnitOverlay.prototype.setContainerPosition = function () {
            var sceneBounds = this.getSceneBounds();
            var shouldLockToRight = this.activeUnit.battleStats.side === "side2";
            var containerBounds = this.overlayContainer.getLocalBounds();
            this.overlayContainer.y = sceneBounds.height - containerBounds.height;
            if (shouldLockToRight) {
                this.overlayContainer.x = sceneBounds.width - containerBounds.width;
            }
        };
        BattleSceneUnitOverlay.prototype.addOverlay = function (overlay) {
            this.animationIsActive = true;
            this.overlayContainer.addChild(overlay);
            this.setContainerPosition();
        };
        BattleSceneUnitOverlay.prototype.finishAnimation = function () {
            if (this.onAnimationFinish) {
                this.onAnimationFinish();
            }
            this.clearOverlay();
        };
        return BattleSceneUnitOverlay;
    }());
    Rance.BattleSceneUnitOverlay = BattleSceneUnitOverlay;
})(Rance || (Rance = {}));
/// <reference path="../lib/pixi.d.ts" />
/// <reference path="templateinterfaces/IBattleSFXTemplate.d.ts" />
/// <reference path="unit.ts" />
/// <reference path="battlesceneunit.ts" />
/// <reference path="battlesceneunitoverlay.ts" />
var Rance;
(function (Rance) {
    // TODO performance
    // BattleScene.render() shouldn't be called unless there's something new to render
    // 
    var BattleScene = (function () {
        function BattleScene(pixiContainer) {
            this.side1UnitHasFinishedUpdating = false;
            this.side2UnitHasFinishedUpdating = false;
            this.isPaused = false;
            this.forceFrame = false;
            this.pixiContainer = pixiContainer;
            this.container = new PIXI.Container();
            var pixiContainerStyle = window.getComputedStyle(this.pixiContainer);
            this.renderer = PIXI.autoDetectRenderer(parseInt(pixiContainerStyle.width), parseInt(pixiContainerStyle.height), {
                autoResize: false,
                antialias: true,
                transparent: true
            });
            this.pixiContainer.appendChild(this.renderer.view);
            this.renderer.view.setAttribute("id", "battle-scene-pixi-canvas");
            this.initLayers();
            this.resizeListener = this.handleResize.bind(this);
            window.addEventListener("resize", this.resizeListener, false);
        }
        BattleScene.prototype.destroy = function () {
            this.container.renderable = false;
            this.pause();
            if (this.renderer) {
                this.renderer.destroy(true);
                this.renderer = null;
            }
            this.container.destroy(true);
            this.container = null;
            this.pixiContainer = null;
            window.removeEventListener("resize", this.resizeListener);
        };
        BattleScene.prototype.initLayers = function () {
            this.layers =
                {
                    battleOverlay: new PIXI.Container,
                    side1Container: new PIXI.Container,
                    side2Container: new PIXI.Container
                };
            this.side1Unit = new Rance.BattleSceneUnit(this.layers.side1Container, this.renderer);
            this.side2Unit = new Rance.BattleSceneUnit(this.layers.side2Container, this.renderer);
            this.side1Unit.getSceneBounds = this.side2Unit.getSceneBounds = this.getSceneBounds;
            this.side1Overlay = new Rance.BattleSceneUnitOverlay(this.layers.side1Container, this.renderer);
            this.side2Overlay = new Rance.BattleSceneUnitOverlay(this.layers.side2Container, this.renderer);
            this.side1Overlay.getSceneBounds = this.side2Overlay.getSceneBounds = this.getSceneBounds;
            this.container.addChild(this.layers.side1Container);
            this.container.addChild(this.layers.side2Container);
            this.container.addChild(this.layers.battleOverlay);
        };
        BattleScene.prototype.handleResize = function () {
            var w = this.pixiContainer.offsetWidth * window.devicePixelRatio;
            var h = this.pixiContainer.offsetHeight * window.devicePixelRatio;
            this.renderer.resize(w, h);
            this.side1Unit.resize();
            this.side2Unit.resize();
        };
        BattleScene.prototype.getSceneBounds = function () {
            return ({
                width: this.renderer.width,
                height: this.renderer.height
            });
        };
        BattleScene.prototype.getSFXParams = function (props) {
            var bounds = this.getSceneBounds();
            var duration = this.activeSFX.duration * Rance.Options.battleAnimationTiming.effectDuration;
            return ({
                user: this.userUnit,
                target: this.targetUnit,
                width: bounds.width,
                height: bounds.height,
                duration: duration,
                facingRight: this.userUnit.battleStats.side === "side1",
                renderer: this.renderer,
                triggerStart: props.triggerStart,
                triggerEffect: this.executeTriggerEffectCallback.bind(this),
                triggerEnd: props.triggerEnd
            });
        };
        BattleScene.prototype.getHighestPriorityUnitForSide = function (side) {
            var units = [
                this.targetUnit,
                this.userUnit,
                this.activeUnit,
                this.hoveredUnit
            ];
            for (var i = 0; i < units.length; i++) {
                var unit = units[i];
                if (unit && unit.battleStats.side === side) {
                    return unit;
                }
            }
            return null;
        };
        BattleScene.prototype.haveBothUnitsFinishedUpdating = function () {
            return this.side1UnitHasFinishedUpdating && this.side2UnitHasFinishedUpdating;
        };
        BattleScene.prototype.executeIfBothUnitsHaveFinishedUpdating = function () {
            if (this.afterUnitsHaveFinishedUpdatingCallback && this.haveBothUnitsFinishedUpdating()) {
                var temp = this.afterUnitsHaveFinishedUpdatingCallback;
                this.afterUnitsHaveFinishedUpdatingCallback = null;
                temp();
            }
            else {
                return;
            }
        };
        BattleScene.prototype.finishUpdatingUnit = function (side) {
            if (side === "side1") {
                this.side1UnitHasFinishedUpdating = true;
            }
            else {
                this.side2UnitHasFinishedUpdating = true;
            }
            this.executeIfBothUnitsHaveFinishedUpdating();
        };
        BattleScene.prototype.handleAbilityUse = function (props) {
            this.clearActiveSFX();
            this.userUnit = props.user;
            this.targetUnit = props.target;
            this.activeSFX = props.SFXTemplate;
            this.abilityUseHasFinishedCallback = props.afterFinishedCallback;
            this.activeSFXHasFinishedCallback = this.cleanUpAfterSFX.bind(this);
            this.triggerEffectCallback = props.triggerEffectCallback;
            this.beforeUseDelayHasFinishedCallback = this.playSFX.bind(this);
            this.prepareSFX();
            // this.prepareSFX();
            // this.playSFX();
            // props.triggerEffectCallback();
            // this.cleanUpAfterSFX();
            // props.afterFinishedCallback();
        };
        BattleScene.prototype.executeBeforeUseDelayHasFinishedCallback = function () {
            if (!this.beforeUseDelayHasFinishedCallback) {
                throw new Error("No callback set for 'before ability use delay' finish.");
            }
            var temp = this.beforeUseDelayHasFinishedCallback;
            this.beforeUseDelayHasFinishedCallback = null;
            temp();
        };
        BattleScene.prototype.executeTriggerEffectCallback = function () {
            if (!this.triggerEffectCallback) {
                return;
            }
            var temp = this.triggerEffectCallback;
            this.triggerEffectCallback = null;
            temp();
        };
        BattleScene.prototype.executeActiveSFXHasFinishedCallback = function () {
            if (!this.activeSFXHasFinishedCallback) {
                throw new Error("No callback set for active SFX finish.");
            }
            var temp = this.activeSFXHasFinishedCallback;
            this.activeSFXHasFinishedCallback = null;
            temp();
        };
        BattleScene.prototype.executeAfterUseDelayHasFinishedCallback = function () {
            if (!this.afterUseDelayHasFinishedCallback) {
                throw new Error("No callback set for 'after ability use delay' finish.");
            }
            var temp = this.afterUseDelayHasFinishedCallback;
            this.afterUseDelayHasFinishedCallback = null;
            temp();
        };
        BattleScene.prototype.executeAbilityUseHasFinishedCallback = function () {
            if (!this.abilityUseHasFinishedCallback) {
                throw new Error("No callback set for ability use finish.");
            }
            var temp = this.abilityUseHasFinishedCallback;
            this.abilityUseHasFinishedCallback = null;
            temp();
        };
        BattleScene.prototype.prepareSFX = function () {
            var beforeUseDelay = Rance.Options.battleAnimationTiming.before;
            var afterUnitsHaveFinishedUpdatingCallback = function () {
                if (beforeUseDelay >= 0) {
                    window.setTimeout(this.executeBeforeUseDelayHasFinishedCallback.bind(this), beforeUseDelay);
                }
                else {
                    this.executeBeforeUseDelayHasFinishedCallback();
                }
            }.bind(this);
            this.updateUnits(afterUnitsHaveFinishedUpdatingCallback);
        };
        BattleScene.prototype.playSFX = function () {
            var SFXDuration = Rance.Options.battleAnimationTiming.effectDuration *
                this.activeSFX.duration;
            if (SFXDuration <= 0) {
                this.executeTriggerEffectCallback();
                this.handleActiveSFXEnd();
            }
            else {
                this.triggerSFXStart(this.activeSFX, this.userUnit, this.targetUnit, this.handleActiveSFXEnd.bind(this));
            }
        };
        BattleScene.prototype.handleActiveSFXEnd = function () {
            this.activeSFX = null;
            this.clearBattleOverlay();
            this.clearUnitOverlays();
            this.executeActiveSFXHasFinishedCallback();
        };
        BattleScene.prototype.cleanUpAfterSFX = function () {
            var afterUseDelay = Rance.Options.battleAnimationTiming.after;
            this.afterUseDelayHasFinishedCallback = function () {
                this.userUnit = null;
                this.targetUnit = null;
                this.updateUnits(this.executeAbilityUseHasFinishedCallback.bind(this));
            }.bind(this);
            if (afterUseDelay >= 0) {
                window.setTimeout(this.executeAfterUseDelayHasFinishedCallback.bind(this), afterUseDelay);
            }
            else {
                this.executeAfterUseDelayHasFinishedCallback();
            }
        };
        BattleScene.prototype.updateUnits = function (afterFinishedUpdatingCallback) {
            var boundAfterFinishFN1 = null;
            var boundAfterFinishFN2 = null;
            if (afterFinishedUpdatingCallback) {
                this.afterUnitsHaveFinishedUpdatingCallback = afterFinishedUpdatingCallback;
                boundAfterFinishFN1 = this.finishUpdatingUnit.bind(this, "side1");
                boundAfterFinishFN2 = this.finishUpdatingUnit.bind(this, "side2");
                this.side1UnitHasFinishedUpdating = false;
                this.side2UnitHasFinishedUpdating = false;
            }
            var activeSide1Unit = this.getHighestPriorityUnitForSide("side1");
            var activeSide2Unit = this.getHighestPriorityUnitForSide("side2");
            this.side1Unit.changeActiveUnit(activeSide1Unit, boundAfterFinishFN1);
            this.side1Overlay.activeUnit = activeSide1Unit;
            this.side2Unit.changeActiveUnit(activeSide2Unit, boundAfterFinishFN2);
            this.side2Overlay.activeUnit = activeSide2Unit;
        };
        BattleScene.prototype.clearActiveSFX = function () {
            this.activeSFX = null;
            this.userUnit = null;
            this.targetUnit = null;
            this.clearBattleOverlay();
            this.clearUnitOverlays();
        };
        BattleScene.prototype.triggerSFXStart = function (SFXTemplate, user, target, afterFinishedCallback) {
            this.activeSFX = SFXTemplate;
            this.side1Unit.setSFX(SFXTemplate, user, target);
            this.side2Unit.setSFX(SFXTemplate, user, target);
            this.side1Overlay.setSFX(SFXTemplate, user, target);
            this.side2Overlay.setSFX(SFXTemplate, user, target);
            this.makeBattleOverlay(afterFinishedCallback);
        };
        BattleScene.prototype.makeBattleOverlay = function (afterFinishedCallback) {
            if (afterFinishedCallback === void 0) { afterFinishedCallback = this.clearActiveSFX.bind(this); }
            if (!this.activeSFX.battleOverlay) {
                afterFinishedCallback();
            }
            else {
                var SFXParams = this.getSFXParams({
                    triggerStart: this.addBattleOverlay.bind(this),
                    triggerEnd: afterFinishedCallback
                });
                this.activeSFX.battleOverlay(SFXParams);
            }
        };
        BattleScene.prototype.addBattleOverlay = function (overlay) {
            this.layers.battleOverlay.addChild(overlay);
        };
        BattleScene.prototype.clearBattleOverlay = function () {
            this.layers.battleOverlay.removeChildren();
        };
        BattleScene.prototype.clearUnitOverlays = function () {
            this.side1Overlay.clearOverlay();
            this.side2Overlay.clearOverlay();
        };
        BattleScene.prototype.getBattleSceneUnit = function (unit) {
            switch (unit.battleStats.side) {
                case "side1":
                    {
                        return this.side1Unit;
                    }
                case "side2":
                    {
                        return this.side2Unit;
                    }
            }
        };
        BattleScene.prototype.getBattleSceneUnitOverlay = function (unit) {
            switch (unit.battleStats.side) {
                case "side1":
                    {
                        return this.side1Overlay;
                    }
                case "side2":
                    {
                        return this.side2Overlay;
                    }
            }
        };
        // RENDERING
        BattleScene.prototype.renderOnce = function () {
            this.forceFrame = true;
            this.render();
        };
        BattleScene.prototype.pause = function () {
            this.isPaused = true;
            this.forceFrame = false;
        };
        BattleScene.prototype.resume = function () {
            this.isPaused = false;
            this.forceFrame = false;
            this.render();
        };
        BattleScene.prototype.render = function (timeStamp) {
            if (this.isPaused) {
                if (this.forceFrame) {
                    this.forceFrame = false;
                }
                else {
                    return;
                }
            }
            this.renderer.render(this.container);
            TWEEN.update();
            window.requestAnimationFrame(this.render.bind(this));
        };
        return BattleScene;
    }());
    Rance.BattleScene = BattleScene;
})(Rance || (Rance = {}));
/// <reference path="reactui.ts"/>
/// <reference path="player.ts"/>
/// <reference path="playercontrol.ts"/>
/// <reference path="maprenderer.ts" />
/// <reference path="galaxymap.ts"/>
/// <reference path="renderer.ts"/>
/// <reference path="game.ts"/>
/// <reference path="moduledata.ts"/>
/// <reference path="moduleloader.ts" />
/// <reference path="../modules/default/defaultmodule.ts" />
/// <reference path="../modules/paintingportraits/modulefile.ts" />
/// <reference path="gameloader.ts"/>
/// <reference path="notificationlog.ts" />
/// <reference path="setdynamictemplateproperties.ts"/>
/// <reference path="templateindexes.ts"/>
/// <reference path="options.ts"/>
/// <reference path="tutorials/tutorialstatus.ts" />
/// <reference path="battlescene.ts" />
var Rance;
(function (Rance) {
    Rance.idGenerators = {
        fleet: 0,
        item: 0,
        player: 0,
        star: 0,
        unit: 0,
        building: 0,
        objective: 0
    };
    var App = (function () {
        function App() {
            this.images = {};
            var self = this;
            PIXI.utils._saidHello = true;
            this.seed = "" + Math.random();
            Math.random = RNG.prototype.uniform.bind(new RNG(this.seed));
            var boundMakeApp = this.makeApp.bind(this);
            Rance.onDOMLoaded(function () {
                var moduleLoader = self.moduleLoader = new Rance.ModuleLoader();
                self.moduleData = moduleLoader.moduleData;
                moduleLoader.addModuleFile(Rance.Modules.DefaultModule.moduleFile);
                moduleLoader.addModuleFile(Rance.Modules.PaintingPortraits.moduleFile);
                moduleLoader.loadAll(boundMakeApp);
            });
        }
        App.prototype.makeApp = function () {
            var startTime = Date.now();
            Rance.Options = Rance.extendObject(Rance.defaultOptions);
            Rance.loadOptions();
            Rance.TutorialState = Rance.extendObject(Rance.defaultTutorialState);
            Rance.loadTutorialState();
            Rance.setAllDynamicTemplateProperties();
            Rance.buildTemplateIndexes();
            this.initUI();
            this.setInitialScene();
            if (this.reactUI.currentScene === "galaxyMap") {
                this.game = this.makeGame();
                this.initGame();
                this.initDisplay();
                this.hookUI();
            }
            this.reactUI.render();
            console.log("Init in " + (Date.now() - startTime) + " ms");
        };
        App.prototype.destroy = function () {
            if (this.game) {
                this.game.destroy();
                this.game = null;
            }
            if (this.mapRenderer) {
                this.mapRenderer.destroy();
                this.mapRenderer = null;
            }
            if (this.renderer) {
                this.renderer.destroy();
                this.renderer = null;
            }
            if (this.playerControl) {
                this.playerControl.destroy();
                this.playerControl = null;
            }
            if (this.reactUI) {
                this.reactUI.destroy();
                this.reactUI = null;
            }
        };
        App.prototype.load = function (saveKey) {
            var data = localStorage.getItem(saveKey);
            if (!data)
                return;
            var parsed = JSON.parse(data);
            Rance.idGenerators = Rance.extendObject(parsed.idGenerators);
            this.destroy();
            this.initUI();
            this.game = new Rance.GameLoader().deserializeGame(parsed.gameData);
            this.game.gameStorageKey = saveKey;
            this.initGame();
            this.initDisplay();
            this.hookUI();
            if (parsed.cameraLocation) {
                this.renderer.toCenterOn = parsed.cameraLocation;
            }
            this.reactUI.switchScene("galaxyMap");
        };
        App.prototype.makeGameFromSetup = function (map, players) {
            this.destroy();
            this.initUI();
            this.game = new Rance.Game(map, players, players[0]);
            this.initGame();
            this.initDisplay();
            this.hookUI();
            this.reactUI.switchScene("galaxyMap");
        };
        App.prototype.makeGame = function () {
            var playerData = this.makePlayers();
            var players = playerData.players;
            var map = this.makeMap(playerData);
            var game = new Rance.Game(map, players, players[0]);
            return game;
        };
        App.prototype.makePlayers = function () {
            var players = [];
            for (var i = 0; i < 5; i++) {
                var player = new Rance.Player(i >= 1);
                player.makeRandomFlag();
                player.initTechnologies();
                players.push(player);
            }
            return ({
                players: players
            });
        };
        App.prototype.makeMap = function (playerData) {
            var optionValues = {
                defaultOptions: {
                    height: 1200,
                    width: 1200,
                    starCount: 30
                },
                basicOptions: {
                    arms: 5,
                    centerDensity: 40,
                    starSizeRegularity: 100
                }
            };
            var mapGenResult = app.moduleData.getDefaultMap().mapGenFunction(optionValues, playerData.players);
            var galaxyMap = mapGenResult.makeMap();
            return galaxyMap;
        };
        App.prototype.initGame = function () {
            if (!this.game)
                throw new Error("App tried to init game without " +
                    "having one specified");
            this.humanPlayer = this.game.humanPlayer;
            this.humanPlayer.isAI = false;
            if (this.playerControl)
                this.playerControl.removeEventListeners();
            this.playerControl = new Rance.PlayerControl(this.humanPlayer);
            for (var i = 0; i < this.game.playerOrder.length; i++) {
                var player = this.game.playerOrder[i];
                if (player.isAI) {
                    player.setupAI(this.game);
                }
            }
            if (!this.game.notificationLog) {
                this.game.notificationLog = new Rance.NotificationLog(this.humanPlayer);
                this.game.notificationLog.setTurn(this.game.turnNumber, true);
            }
        };
        App.prototype.initDisplay = function () {
            this.renderer = new Rance.Renderer(this.game.galaxyMap);
            this.renderer.init();
            this.mapRenderer = new Rance.MapRenderer(this.game.galaxyMap, this.humanPlayer);
            this.mapRenderer.setParent(this.renderer.layers["map"]);
            this.mapRenderer.init();
            // some initialization is done when the react component owning the
            // renderer mounts, such as in uicomponents/galaxymap/galaxymap.ts
        };
        App.prototype.initUI = function () {
            this.reactUI = new Rance.ReactUI(document.getElementById("react-container"));
        };
        App.prototype.hookUI = function () {
            this.reactUI.game = this.game;
            this.reactUI.player = this.humanPlayer;
            this.reactUI.playerControl = this.playerControl;
            this.reactUI.renderer = this.renderer;
            this.reactUI.mapRenderer = this.mapRenderer;
        };
        App.prototype.setInitialScene = function () {
            var uriParser = document.createElement("a");
            uriParser.href = document.URL;
            var hash = uriParser.hash;
            if (hash) {
                this.reactUI.currentScene = hash.slice(1);
            }
            else {
                this.reactUI.currentScene = "setupGame";
            }
        };
        return App;
    }());
    Rance.App = App;
})(Rance || (Rance = {}));
var app = new Rance.App();
//# sourceMappingURL=main.js.map
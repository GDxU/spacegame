module Rance
{
  export module ShaderSources
  {
      export var beam =
      [
        "precision mediump float;",
        "",
        "#define DOMAIN 0 // 0 == pixi, 1 == shdr.bkcore.com",
        "",
        "#if DOMAIN == 0",
        "  varying vec2 vTextureCoord;",
        "  uniform sampler2D uSampler;",
        "",
        "  uniform float aspectRatio;",
        "",
        "  uniform vec4 beamColor;",
        "",
        "  uniform float lineIntensity;",
        "  uniform float bulgeIntensity;",
        "",
        "  uniform float bulgeXPosition;",
        "  uniform vec2 bulgeSize;",
        "  uniform float bulgeSharpness;",
        "",
        "  uniform vec2 lineXSize;",
        "  uniform float lineXSharpness;",
        "",
        "  uniform float lineYSize;",
        "  uniform float lineYSharpness;",
        "",
        "",
        "#elif DOMAIN == 1",
        "  uniform vec2 resolution;",
        "  uniform float time;",
        "",
        "  float aspectRatio = resolution.x / resolution.y;",
        "",
        "  const vec4 beamColor = vec4(1.0, 0.5, 0.5, 1.0);",
        "",
        "  const float bulgeXPosition = 0.4;",
        "  const vec2 bulgeSize = vec2(0.8, 0.4);",
        "  const float bulgeSharpness = 0.4;",
        "  const float bulgeIntensity = 3.0;",
        "",
        "  const vec2 lineXSize = vec2(0.4, 1.0);",
        "  const float lineXSharpness = 0.3;",
        "",
        "  const float lineYSize = 0.02;",
        "  const float lineYSharpness = 0.8;",
        "  const float lineIntensity = 5.0;",
        "",
        "",
        "#endif",
        "",
        "",
        "float ellipseGradient(vec2 p, float ellipseXPosition, vec2 ellipseSize)",
        "{",
        "  vec2 q = vec2(-1.0 + 2.0 * p.x, p.y); // (-1, -1) -> (1, 1)",
        "  q.x -= -1.0 + 2.0 * ellipseXPosition;",
        "  q.x *= aspectRatio;",
        "  q /= ellipseSize;",
        "",
        "  float dist = length(q);",
        "",
        "  return dist;",
        "}",
        "",
        "void main()",
        "{",
        "  #if DOMAIN == 0",
        "    vec2 uv = vTextureCoord;",
        "    vec4 color = texture2D(uSampler, vTextureCoord);",
        "  #elif DOMAIN == 1",
        "    vec2 uv = gl_FragCoord.xy / resolution;",
        "    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);",
        "  #endif",
        "",
        "  vec2 q = vec2(uv.x, -1.0 + 2.0 * uv.y); // (0, -1) -> (1, 1)",
        "",
        "  float yDistFromCenter = abs(q.y);",
        "  float insideLineY = step(yDistFromCenter, lineYSize);",
        "  float lineYDist = max(1.0 - distance(yDistFromCenter, lineYSize), insideLineY);",
        "  float lineYGradient = smoothstep(lineYSharpness, 1.0, lineYDist);",
        "",
        "  float insideLineX = step(lineXSize.x, q.x) * step(q.x, lineXSize.y);",
        "  float lineXDist = 1.0 - min(distance(q.x, lineXSize.x), distance(q.x, lineXSize.y));",
        "  lineXDist = max(insideLineX, lineXDist);",
        "",
        "  float lineXGradient = smoothstep(lineXSharpness, 1.0, lineXDist);",
        "",
        "  float lineGradient = (lineYGradient * lineXGradient) * lineIntensity;",
        "",
        "  float bulgeGradient = 1.0 - ellipseGradient(q, bulgeXPosition, bulgeSize);",
        "  bulgeGradient = smoothstep(0.0, 1.0 - bulgeSharpness, bulgeGradient) * bulgeIntensity;",
        "",
        "  float beamGradient = lineGradient + bulgeGradient;",
        "  color += beamGradient * beamColor;",
        "",
        "  gl_FragColor = color;",
        "}",
      ]
      export var blacktoalpha =
      [
        "precision mediump float;",
        "",
        "varying vec2 vTextureCoord;",
        "uniform sampler2D uSampler;",
        "",
        "void main()",
        "{",
        "  vec4 color = texture2D(uSampler, vTextureCoord);",
        "  color.a = (color.r + color.g + color.b) / 3.0;",
        "",
        "  gl_FragColor = color;",
        "}",
      ]
      export var guard =
      [
        "precision mediump float;",
        "",
        "uniform float frontier;",
        "uniform float trailDistance;",
        "uniform float seed;",
        "uniform float blockSize;",
        "uniform float blockWidth;",
        "uniform float lineAlpha;",
        "uniform float blockAlpha;",
        "",
        "",
        "float minX = frontier - trailDistance;",
        "float maxX = frontier + 20.0;",
        "float frontGradientStart = frontier + 17.0;",
        "float blockEnd = maxX;",
        "",
        "float hash(float n)",
        "{",
        "  return fract(sin(n) * 1e4);",
        "}",
        "float hash(vec2 p)",
        "{",
        "  return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x))));",
        "}",
        "",
        "float noise(vec2 x)",
        "{",
        "  vec2 i = floor(x);",
        "  vec2 f = fract(x);",
        "  float a = hash(i);",
        "  float b = hash(i + vec2(1.0, 0.0));",
        "  float c = hash(i + vec2(0.0, 1.0));",
        "  float d = hash(i + vec2(1.0, 1.0));",
        "  vec2 u = f * f * (3.0 - 2.0 * f);",
        "  return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;",
        "}",
        "",
        "",
        "vec4 makeLines(vec2 coord)",
        "{",
        "  float gradientAlpha = smoothstep(minX, frontier, coord.x);",
        "  gradientAlpha -= smoothstep(frontGradientStart, maxX, coord.x);",
        "  gradientAlpha += 0.5 * gradientAlpha;",
        "",
        "  float n = noise(vec2(seed, coord.y));",
        "  n = pow(n, 3.5);",
        "  float alpha = n * gradientAlpha;",
        "",
        "",
        "  float r = hash(vec2(seed, coord.y));",
        "  r = clamp(r, 0.8, 0.9) * alpha;",
        "  float g = (r + 0.7 - r) * alpha;",
        "  float b = smoothstep(0.0, 0.28, alpha);",
        "",
        "  return vec4(r, g, b, alpha);",
        "}",
        "",
        "vec4 makeBlocks(vec2 coord)",
        "{",
        "  vec4 lineColor = makeLines(vec2(frontier, coord.y));",
        "  float h = hash(vec2(seed, coord.y));",
        "  float blockWidth = blockWidth * (h / 2.0 + 0.5);",
        "",
        "  float blockStart = frontier - blockWidth;",
        "  float alpha = step(0.01, mod(smoothstep(blockStart, blockEnd, coord.x), 1.0));",
        "",
        "",
        "  return lineColor * alpha;",
        "}",
        "",
        "void main()",
        "{",
        "  vec4 lineColor = makeLines(gl_FragCoord.xy);",
        "",
        "  vec4 blockColor = vec4(0.0);",
        "",
        "  for (float i = 0.0; i < 10.0; i += 1.0)",
        "  {",
        "    float y = gl_FragCoord.y + hash(i) * blockSize * 20.0;",
        "    float blockY = floor(y / blockSize);",
        "    blockColor += makeBlocks(vec2(gl_FragCoord.x, blockY)) * 0.2;",
        "  }",
        "",
        "  gl_FragColor = lineColor * lineAlpha + blockColor * blockAlpha;",
        "}",
      ]
      export var intersectingellipses =
      [
        "precision mediump float;",
        "",
        "#define DOMAIN 0 // 0 == pixi, 1 == shdr.bkcore.com",
        "",
        "#if DOMAIN == 0",
        "  varying vec2 vTextureCoord;",
        "  uniform sampler2D uSampler;",
        "",
        "  uniform vec4 mainColor;",
        "  uniform float mainAlpha;",
        "",
        "  uniform vec2 intersectingEllipseCenter;",
        "  uniform vec2 intersectingEllipseSize;",
        "  uniform float intersectingEllipseSharpness;",
        "",
        "  uniform vec2 mainEllipseSize;",
        "  uniform float mainEllipseSharpness;",
        "",
        "#elif DOMAIN == 1",
        "  uniform vec2 resolution;",
        "  uniform float time;",
        "",
        "  const vec4 mainColor = vec4(1.0, 1.0, 1.0, 1.0);",
        "  const float mainAlpha = 1.0;",
        "",
        "  const vec2 intersectingEllipseCenter = vec2(0.4, 0.0);",
        "  const vec2 intersectingEllipseSize = vec2(0.8, 1.0);",
        "  const float intersectingEllipseSharpness = 0.6;",
        "",
        "  const vec2 mainEllipseSize = vec2(0.5, 0.9);",
        "  const float mainEllipseSharpness = 0.8;",
        "",
        "#endif",
        "",
        "",
        "float ellipseGradient(vec2 p, vec2 ellipseCenter, vec2 ellipseSize)",
        "{",
        "  vec2 q = p - ellipseCenter;",
        "  q /= ellipseSize;",
        "",
        "  float dist = length(q);",
        "",
        "  return dist;",
        "}",
        "",
        "void main()",
        "{",
        "  #if DOMAIN == 0",
        "    vec2 uv = vTextureCoord;",
        "    vec4 color = texture2D(uSampler, vTextureCoord);",
        "  #elif DOMAIN == 1",
        "    vec2 uv = gl_FragCoord.xy / resolution;",
        "    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);",
        "  #endif",
        "",
        "  vec2 q = -1.0 + 2.0 * uv;",
        "",
        "  float mainDist = 1.0 - ellipseGradient(q, vec2(0.0, 0.0), mainEllipseSize);",
        "  float mainGradient = smoothstep(0.0, 1.0 - mainEllipseSharpness, mainDist);",
        "  color += mainColor * mainGradient;",
        "",
        "",
        "  float intersectingDist = ellipseGradient(q, intersectingEllipseCenter, intersectingEllipseSize);",
        "",
        "  float intersectingMask = step(intersectingEllipseSharpness, intersectingDist);",
        "  color *= intersectingMask;",
        "",
        "  float intersectingGradient = smoothstep(intersectingEllipseSharpness, 1.0, intersectingDist);",
        "  color *=  intersectingGradient;",
        "",
        "  gl_FragColor = color * mainAlpha;",
        "}",
      ]
      export var lightburst =
      [
        "precision mediump float;",
        "",
        "",
        "#define PI 3.14159265359",
        "#define DOMAIN 0 // 0 == pixi, 1 == shdr.bkcore.com",
        "",
        "#if DOMAIN == 0",
        "  varying vec2 vTextureCoord;",
        "  uniform sampler2D uSampler;",
        "",
        "  uniform vec2 seed;",
        "  uniform float rotation;",
        "  uniform float rayStrength;",
        "  uniform float raySharpness;",
        "  uniform vec4 rayColor;",
        "  uniform float centerSize;",
        "  uniform float centerBloomStrength;",
        "",
        "#elif DOMAIN == 1",
        "  uniform vec2 resolution;",
        "  uniform float time;",
        "",
        "  const vec2 seed = vec2(3.3492333784616219, 0.38182701375708206);",
        "  const float rotation = 0.0;",
        "  const float rayStrength = 0.9;",
        "  const float raySharpness = 2.0;",
        "  const vec4 rayColor = vec4(1.0, 0.4, 0.4, 1.0);",
        "  const float centerSize = 1.0;",
        "  const float centerBloomStrength = 5.0;",
        "#endif",
        "",
        "//--------------------------------------------------------------------",
        "",
        "// https://www.shadertoy.com/view/4dlGW2",
        "// Tileable noise, for creating useful textures. By David Hoskins, Sept. 2013.",
        "// It can be extrapolated to other types of randomised texture.",
        "",
        "// TODO license?",
        "// https://www.shadertoy.com/terms says default license is CC BY-NC-SA 3.0 which should be fine",
        "",
        "float hash(in vec2 p, in float scale)",
        "{",
        "  // This is tiling part, adjusts with the scale...",
        "  p = mod(p, scale);",
        "  return fract(sin(dot(p, seed)) * 5151.5473453);",
        "}",
        "",
        "float noise(in vec2 p, in float scale )",
        "{",
        "  vec2 f;",
        "",
        "  p *= scale;",
        "",
        "",
        "  f = fract(p);   // Separate integer from fractional",
        "    p = floor(p);",
        "",
        "    f = f*f*(3.0-2.0*f);  // Cosine interpolation approximation",
        "",
        "    float res = mix(mix(hash(p,          scale),",
        "            hash(p + vec2(1.0, 0.0), scale), f.x),",
        "          mix(hash(p + vec2(0.0, 1.0), scale),",
        "            hash(p + vec2(1.0, 1.0), scale), f.x), f.y);",
        "    return res;",
        "}",
        "",
        "float fbm(in vec2 p)",
        "{",
        "  float f = 0.0;",
        "  // Change starting scale to any integer value...",
        "  float scale = 20.0;",
        "  float amp   = 0.5;",
        "",
        "  for (int i = 0; i < 5; i++)",
        "  {",
        "    f += noise(p, scale) * amp;",
        "    amp *= .65;",
        "    // Scale must be multiplied by an integer value...",
        "    scale *= 2.0;",
        "  }",
        "  // Clamp it just in case....",
        "  return min(f, 1.0);",
        "}",
        "",
        "//--------------------------------------------------------------------",
        "",
        "float ray(vec2 q, float angleAdjust)",
        "{",
        "  float angle = (atan(q.y, q.x) + PI + angleAdjust) / (2.0 * PI);",
        "  return fbm(vec2(angle, seed.y));",
        "}",
        "",
        "void main()",
        "{",
        "  #if DOMAIN == 0",
        "    vec2 uv = vTextureCoord;",
        "    vec4 color = texture2D(uSampler, vTextureCoord);",
        "  #elif DOMAIN == 1",
        "    vec2 uv = gl_FragCoord.xy / resolution;",
        "    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);",
        "  #endif",
        "",
        "  vec2 q = uv - 0.5;",
        "  q *= 1.8;",
        "",
        "  float dist = length(q);",
        "",
        "  float centerIntensity = pow(1.0 - dist, 8.0);",
        "  centerIntensity = smoothstep(1.0 - centerSize, 1.0, centerIntensity);",
        "",
        "  float rayIntensity = ray(q, rotation);",
        "  rayIntensity = smoothstep(0.4, 1.0, rayIntensity) * rayStrength;",
        "  rayIntensity -= dist;",
        "  rayIntensity *= max(1.0, raySharpness + 1.0 - dist);",
        "  rayIntensity += centerIntensity * centerBloomStrength;",
        "  rayIntensity = max(0.0, rayIntensity);",
        "  color += rayColor * rayIntensity;",
        "",
        "  gl_FragColor = color;",
        "}",
      ]
      export var nebula =
      [
        "precision mediump float;",
        "",
        "uniform vec3 baseColor;",
        "uniform vec3 overlayColor;",
        "uniform vec3 highlightColor;",
        "",
        "uniform float coverage;",
        "",
        "uniform float scale;",
        "",
        "uniform float diffusion;",
        "uniform float streakiness;",
        "",
        "uniform float streakLightness;",
        "uniform float cloudLightness;",
        "",
        "uniform float highlightA;",
        "uniform float highlightB;",
        "",
        "uniform vec2 seed;",
        "",
        "/*",
        "const vec3 baseColor = vec3(1.0, 0.0, 0.0);",
        "const vec3 overlayColor = vec3(0.0, 0.0, 1.0);",
        "const vec3 highlightColor = vec3(1.0, 1.0, 1.0);",
        "",
        "const float coverage = 0.3;",
        "const float coverage2 = coverage / 2.0;",
        "",
        "const float scale = 4.0;",
        "",
        "const float diffusion = 3.0;",
        "const float streakiness = 2.0;",
        "",
        "const float streakLightness = 1.0;",
        "const float cloudLightness = 1.0;",
        "",
        "const float highlightA = 0.9;",
        "const float highlightB = 2.2;",
        "",
        "const vec2 seed = vec2(69.0, 42.0);",
        "*/",
        "",
        "const int sharpness = 6;",
        "",
        "float hash(vec2 p)",
        "{",
        "  return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x))));",
        "}",
        "",
        "float noise(vec2 x)",
        "{",
        "  vec2 i = floor(x);",
        "  vec2 f = fract(x);",
        "  float a = hash(i);",
        "  float b = hash(i + vec2(1.0, 0.0));",
        "  float c = hash(i + vec2(0.0, 1.0));",
        "  float d = hash(i + vec2(1.0, 1.0));",
        "  vec2 u = f * f * (3.0 - 2.0 * f);",
        "  return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;",
        "}",
        "",
        "float fbm(vec2 x)",
        "{",
        "  float v = 0.0;",
        "  float a = 0.5;",
        "  vec2 shift = vec2(100);",
        "  mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));",
        "  for (int i = 0; i < sharpness; ++i)",
        "  {",
        "    v += a * noise(x);",
        "    x = rot * x * 2.0 + shift;",
        "    a *= 0.5;",
        "    }",
        "  return v;",
        "}",
        "",
        "float relativeValue(float v, float min, float max)",
        "{",
        "  return (v - min) / (max - min);",
        "}",
        "",
        "float displace(vec2 pos, out vec2 q)",
        "{",
        "  q = vec2(fbm(pos),",
        "    fbm(pos + vec2(23.3, 46.7)));",
        "  return fbm(pos + vec2(q.x * streakiness, q.y));",
        "}",
        "",
        "vec3 colorLayer(vec2 pos, vec3 color)",
        "{",
        "  float v = fbm(pos);",
        "  return mix(vec3(0.0), color, v);",
        "}",
        "",
        "vec3 nebula(vec2 pos, out float volume)",
        "{",
        "  vec2 on = vec2(0.0);",
        "",
        "  volume = displace(pos, on);",
        "  volume = relativeValue(volume, coverage, streakLightness);",
        "  volume += relativeValue(fbm(pos), coverage, cloudLightness);",
        "  volume = pow(volume, diffusion);",
        "",
        "  vec3 c = colorLayer(pos + vec2(42.0, 6.9), baseColor);",
        "  c = mix(c, overlayColor, dot(on.x, on.y));",
        "  c = mix(c, highlightColor, volume *",
        "    smoothstep(highlightA, highlightB, abs(on.x)+abs(on.y)) );",
        "",
        "",
        "  return c * volume;",
        "}",
        "",
        "float star(vec2 pos, float volume)",
        "{",
        "  float genValue = hash(pos);",
        "",
        "  genValue -= volume * 0.01;",
        "",
        "  float color = 0.0;",
        "",
        "  if (genValue < 0.001)",
        "  {",
        "    float r = hash(pos + vec2(4.20, 6.9));",
        "    color = r;",
        "    return color;",
        "  }",
        "  else",
        "  {",
        "    return color;",
        "  }",
        "}",
        "",
        "void main(void)",
        "{",
        "  vec2 pos = gl_FragCoord.xy / 50.0 / scale;",
        "  pos += seed;",
        "  float volume = 0.0;",
        "  vec3 c = nebula(pos, volume);",
        "  c += vec3(star(pos, volume));",
        "",
        "  gl_FragColor = vec4(c, 1.0);",
        "}",
      ]
      export var occupation =
      [
        "precision mediump float;",
        "",
        "uniform vec4 baseColor;",
        "uniform vec4 lineColor;",
        "uniform float gapSize;",
        "uniform vec2 offset;",
        "uniform float zoom;",
        "",
        "void main( void )",
        "{",
        "  vec2 position = gl_FragCoord.xy + offset;",
        "  position.x += position.y;",
        "  float scaled = floor(position.x * 0.1 / zoom);",
        "  float res = mod(scaled, gapSize);",
        "  if(res > 0.0)",
        "  {",
        "    gl_FragColor = mix(gl_FragColor, baseColor, 0.5);",
        "  }",
        "  else",
        "  {",
        "    gl_FragColor = mix(gl_FragColor, lineColor, 0.5);",
        "  }",
        "}",
      ]
      export var shinyparticle =
      [
        "precision mediump float;",
        "",
        "#define DOMAIN 0 // 0 == pixi, 1 == shdr.bkcore.com",
        "",
        "#if DOMAIN == 0",
        "  varying vec2 vTextureCoord;",
        "  uniform sampler2D uSampler;",
        "",
        "  uniform float spikeIntensity;",
        "  uniform float highlightIntensity;",
        "  uniform vec4 spikeColor;",
        "#elif DOMAIN == 1",
        "  uniform vec2 resolution;",
        "",
        "  const float spikeIntensity = 1.0;",
        "  const float highlightIntensity = 0.1;",
        "  const vec4 spikeColor = vec4(0.3686274509803922, 0.792156862745098, 0.6941176470588235, 1.0);",
        "#endif",
        "",
        "",
        "const vec4 highlightColor = vec4(1.0, 1.0, 1.0, 1.0);",
        "const vec2 center = vec2(0.5, 0.5);",
        "const float angle = -0.1 * 3.141592;",
        "",
        "float spike(vec2 q)",
        "{",
        "  vec2 rotated;",
        "  rotated.x = cos(angle) * q.x - sin(angle) * q.y;",
        "  rotated.y = sin(angle) * q.x + cos(angle) * q.y;",
        "",
        "  float xStrength = max(0.5 - abs(rotated.x), 0.0);",
        "  float yStrength = max(0.5 - abs(rotated.y), 0.0);",
        "",
        "  return xStrength + yStrength;",
        "}",
        "",
        "void main()",
        "{",
        "  #if DOMAIN == 0",
        "    vec2 uv = vTextureCoord;",
        "    vec4 color = texture2D(uSampler, uv);",
        "  #elif DOMAIN == 1",
        "    vec2 uv = gl_FragCoord.xy / resolution;",
        "    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);",
        "  #endif",
        "",
        "  vec2 q = uv - 0.5;",
        "  // q *= 2.5;",
        "",
        "  float dist = length(q);",
        "",
        "  float spikeStrength = spike(q);",
        "  spikeStrength -= dist;",
        "  spikeStrength = pow(spikeStrength, 1.5);",
        "  spikeStrength *= spikeIntensity;",
        "",
        "  color += spikeColor * spikeStrength;",
        "",
        "",
        "  // center highlight",
        "  float highlightStrength = 1.0 - dist;",
        "  highlightStrength = pow(highlightStrength, 8.0);",
        "  highlightStrength *= highlightIntensity;",
        "",
        "  color += highlightColor * highlightStrength;",
        "",
        "",
        "  gl_FragColor = color;",
        "}",
      ]
    
  }
}


import idGenerators from "./idGenerators"; // TODO refactor | autogenerated

import app from "./App"; // TODO refactor | autogenerated
import UnitTemplate from "./templateinterfaces/UnitTemplate";
import AbilityTemplate from "./templateinterfaces/AbilityTemplate";
import PortraitTemplate from "./templateinterfaces/PortraitTemplate";
import PassiveSkillTemplate from "./templateinterfaces/PassiveSkillTemplate";
import CultureTemplate from "./templateinterfaces/CultureTemplate";
import AbilityBase from "./templateinterfaces/AbilityBase";
import SFXParams from "./templateinterfaces/SFXParams";
import UnitPassiveEffect from "./templateinterfaces/UnitPassiveEffect";
import UnitDrawingFunctionData from "./UnitDrawingFunctionData";

import DamageType from "./DamageType";
import
{
  default as UnitAttributes,
  UnitAttributeAdjustments
} from "./UnitAttributes";
import
{
  findItemWithKey,
  randInt,
  getRandomArrayItem,
  getAllPropertiesWithKey,
  getRandomArrayItemWithWeights,
  getRandomProperty,
  clamp,
  getItemsFromWeightedProbabilities,
  defaultNameGenerator
} from "./utility";
import Battle from "./Battle";
import Item from "./Item";
import StatusEffect from "./StatusEffect";
import Fleet from "./Fleet";
import Player from "./Player";
import Star from "./Star";
import GuardCoverage from "./GuardCoverage";
import QueuedActionData from "./QueuedActionData";
import UnitBattleStats from "./UnitBattleStats";
import UnitBattleSide from "./UnitBattleSide";
import AbilityUpgradeData from "./AbilityUpgradeData";
import UnitDisplayData from "./UnitDisplayData";
import UnitItems from "./UnitItems";

import UnitSaveData from "./savedata/UnitSaveData";
import UnitItemsSaveData from "./savedata/UnitItemsSaveData";
import UnitBattleStatsSaveData from "./savedata/UnitBattleStatsSaveData";


import Front from "./mapai/Front";


export default class Unit
{
  public template: UnitTemplate;

  public id: number;

  public name: string;
  public portrait: PortraitTemplate;

  public maxHealth: number;
  public currentHealth: number;
  public isSquadron: boolean;

  public currentMovePoints: number;
  public maxMovePoints: number;

  public timesActedThisTurn: number;

  public baseAttributes: UnitAttributes;
  public attributesAreDirty: boolean;
  private cachedAttributes: UnitAttributes;
  public get attributes(): UnitAttributes
  {
    if (this.attributesAreDirty || !this.cachedAttributes)
    {
      this.updateCachedAttributes();
    }

    return this.cachedAttributes;
  }

  public battleStats: UnitBattleStats;
  public drawingFunctionData: UnitDrawingFunctionData;

  private abilities: AbilityTemplate[] = [];
  private passiveSkills: PassiveSkillTemplate[] = [];

  public experienceForCurrentLevel: number;
  public level: number;

  public fleet: Fleet;

  public items: UnitItems;

  private passiveSkillsByPhase:
  {
    atBattleStart?: PassiveSkillTemplate[];
    // beforeAbilityUse?: PassiveSkillTemplate[];
    // afterAbilityUse?: PassiveSkillTemplate[];
    atTurnStart?: PassiveSkillTemplate[];
    inBattlePrep?: PassiveSkillTemplate[];
  } = {};
  private passiveSkillsByPhaseAreDirty: boolean = true;

  public front: Front;

  public uiDisplayIsDirty: boolean = true;
  public lastHealthDrawnAt: number;

  constructor(template: UnitTemplate, id?: number, data?: UnitSaveData)
  {
    this.id = isFinite(id) ? id : idGenerators.unit++;

    this.template = template;
    this.isSquadron = template.isSquadron;
    if (data)
    {
      this.makeFromData(data);
    }
    else
    {
      this.items = this.makeUnitItems(template.itemSlots);
      this.setCulture();
      this.setInitialValues();
    }
  }
  private makeFromData(data: UnitSaveData)
  {
    this.name = data.name;

    this.maxHealth = data.maxHealth;
    this.currentHealth = data.currentHealth;

    this.currentMovePoints = data.currentMovePoints;
    this.maxMovePoints = data.maxMovePoints;

    this.timesActedThisTurn = data.timesActedThisTurn;

    this.baseAttributes = new UnitAttributes(data.baseAttributes);
    this.cachedAttributes = this.baseAttributes.clone();

    this.abilities = data.abilityTemplateTypes.map(function(key: string)
    {
      var template = app.moduleData.Templates.Abilities[key];

      if (!template)
      {
        throw new Error("Couldn't find ability " + key);
      }

      return template;
    });
    
    this.passiveSkills = data.passiveSkillTemplateTypes.map(function(key: string)
    {
      var template = app.moduleData.Templates.PassiveSkills[key];

      if (!template)
      {
        throw new Error("Couldn't find passive skill " + key);
      }

      return template;
    });

    this.experienceForCurrentLevel = data.experienceForCurrentLevel;
    this.level = data.level;

    this.battleStats =
    {
      moveDelay: data.battleStats.moveDelay,
      side: data.battleStats.side,
      position: data.battleStats.position,
      currentActionPoints: data.battleStats.currentActionPoints,
      guardAmount: data.battleStats.guardAmount,
      guardCoverage: data.battleStats.guardCoverage,
      captureChance: data.battleStats.captureChance,
      statusEffects: data.battleStats.statusEffects,
      lastHealthBeforeReceivingDamage: this.currentHealth,
      queuedAction: !data.battleStats.queuedAction ? null :
      {
        ability: app.moduleData.Templates.Abilities[data.battleStats.queuedAction.abilityTemplateKey],
        targetId: data.battleStats.queuedAction.targetId,
        turnsPrepared: data.battleStats.queuedAction.turnsPrepared,
        timesInterrupted: data.battleStats.queuedAction.timesInterrupted
      },
      isAnnihilated: data.battleStats.isAnnihilated
    };

    this.items = this.makeUnitItems(data.items.maxItemSlots);
    if (data.serializedItems)
    {
      data.serializedItems.forEach(itemSaveData =>
      {
        const item = new Item(app.moduleData.Templates.Items[itemSaveData.templateType], itemSaveData.id);
        this.items.addItem(item, -999);
      })
    }

    if (data.portraitKey)
    {
      this.portrait = findItemWithKey<PortraitTemplate>(
        app.moduleData.Templates.Cultures, data.portraitKey, "portraits");
    }
  }
  private setInitialValues()
  {
    this.setBaseHealth();
    this.setAttributes();
    this.resetBattleStats();

    this.maxMovePoints = this.template.maxMovePoints;
    this.resetMovePoints();
    this.setInitialAbilities();
    this.setInitialPassiveSkills();

    this.level = 1;
    this.experienceForCurrentLevel = 0;

    this.timesActedThisTurn = 0;
  }
  public setBaseHealth(multiplier: number = 1)
  {
    var min = 200 * this.template.maxHealth * multiplier;
    var max = 300 * this.template.maxHealth * multiplier;
    this.maxHealth = randInt(min, max);
    
    this.currentHealth = this.maxHealth;
  }
  public setAttributes(baseSkill: number = 1, variance: number = 1)
  {
    var template = this.template;

    var attributes =
    {
      attack: 1,
      defence: 1,
      intelligence: 1,
      speed: 1,
      maxActionPoints: randInt(3, 5)
    }

    for (let attribute in template.attributeLevels)
    {
      var attributeLevel = template.attributeLevels[attribute];

      var min = Math.max(3 * baseSkill * attributeLevel, 1);
      var max = Math.max(5 * baseSkill * attributeLevel + variance, 1);

      attributes[attribute] = randInt(min, max);
      if (attributes[attribute] > 9) attributes[attribute] = 9;
    }

    this.baseAttributes = new UnitAttributes(attributes);
    this.cachedAttributes = this.baseAttributes.clone();
    this.attributesAreDirty = false;
  }
  private setCulture()
  {
    var templateCultures = this.template.cultures;

    var nameGeneratorFN: (unit: Unit) => string;
    var nameGeneratorCandidateCultures: CultureTemplate[] = templateCultures.filter(
      function(cultureTemplate: CultureTemplate)
    {
      return Boolean(cultureTemplate.nameGenerator);
    });

    if (nameGeneratorCandidateCultures.length > 0)
    {
      nameGeneratorFN = getRandomArrayItem(nameGeneratorCandidateCultures).nameGenerator;
    }
    else
    {
      nameGeneratorFN = defaultNameGenerator;
    }

    this.name = nameGeneratorFN(this);


    var portraitCandidateCultures: CultureTemplate[] = templateCultures.filter(
      function(cultureTemplate: CultureTemplate)
    {
      return Boolean(cultureTemplate.portraits);
    });

    if (portraitCandidateCultures.length === 0)
    {
      portraitCandidateCultures = getAllPropertiesWithKey(app.moduleData.Templates.Cultures, "portraits");
      if (portraitCandidateCultures.length === 0)
      {
        console.warn("No culture has portraits specified"); //TODO culture
        return;
      }
    }


    var portraitCandidateCulturesWithWeights: any =
      portraitCandidateCultures.map(function(culture: CultureTemplate)
    {
      return(
      {
        weight: Object.keys(culture.portraits).length,
        culture: culture
      });
    });

    var portraitCulture = getRandomArrayItemWithWeights<any>(portraitCandidateCulturesWithWeights).culture;
    this.portrait = getRandomProperty(portraitCulture.portraits);
  }
  private getBaseMoveDelay()
  {
    return 30 - this.attributes.speed;
  }
  public resetMovePoints()
  {
    this.currentMovePoints = this.maxMovePoints;
  }
  public resetBattleStats()
  {
    this.battleStats =
    {
      moveDelay: this.getBaseMoveDelay(),
      currentActionPoints: this.attributes.maxActionPoints,
      side: null,
      position: null,
      guardAmount: 0,
      guardCoverage: null,
      captureChance: app.moduleData.ruleSet.battle.baseUnitCaptureChance,
      statusEffects: [],
      lastHealthBeforeReceivingDamage: this.currentHealth,
      queuedAction: null,
      isAnnihilated: false
    };
  }
  public setBattlePosition(battle: Battle, side: UnitBattleSide, position: number[])
  {
    this.battleStats.side = side;
    this.battleStats.position = position;
  }
  public addStrength(amount: number)
  {
    this.currentHealth += Math.round(amount);
    if (this.currentHealth > this.maxHealth)
    {
      this.currentHealth = this.maxHealth;
    }

    this.uiDisplayIsDirty = true;
  }
  public removeStrength(amount: number)
  {
    this.currentHealth -= Math.round(amount);
    this.currentHealth = clamp(this.currentHealth, 0, this.maxHealth);

    if (amount > 0)
    {
      this.removeGuard(40);
    }

    if (this.currentHealth === 0)
    {
      this.battleStats.isAnnihilated = true;
    }

    this.uiDisplayIsDirty = true;
  }
  public removeActionPoints(amount: number)
  {
    this.battleStats.currentActionPoints -= amount;
    if (this.battleStats.currentActionPoints < 0)
    {
      this.battleStats.currentActionPoints = 0;
    }

    this.uiDisplayIsDirty = true;
  }
  public addMoveDelay(amount: number)
  {
    this.battleStats.moveDelay += amount;
  }
  public updateStatusEffects()
  {
    for (let i = 0; i < this.battleStats.statusEffects.length; i++)
    {
      this.battleStats.statusEffects[i].processTurnEnd();
      if (this.battleStats.statusEffects[i].duration === 0)
      {
        this.removeStatusEffect(this.battleStats.statusEffects[i]);
      }
    }

    this.uiDisplayIsDirty = true;
  }
  private setQueuedAction(ability: AbilityTemplate, target: Unit)
  {
    this.battleStats.queuedAction =
    {
      ability: ability,
      targetId: target.id,
      turnsPrepared: 0,
      timesInterrupted: 0
    }

    this.uiDisplayIsDirty = true;
  }
  private interruptQueuedAction(interruptStrength: number)
  {
    var action = this.battleStats.queuedAction;
    if (!action)
    {
      return;
    }

    action.timesInterrupted += interruptStrength;
    if (action.timesInterrupted >= action.ability.preparation.interruptsNeeded)
    {
      this.clearQueuedAction();
    }

    this.uiDisplayIsDirty = true;
  }
  private updateQueuedAction()
  {
    var action = this.battleStats.queuedAction;
    if (!action)
    {
      return;
    }

    action.turnsPrepared++;

    this.uiDisplayIsDirty = true;
  }
  private isReadyToUseQueuedAction()
  {
    var action = this.battleStats.queuedAction;

    return (action && action.turnsPrepared >= action.ability.preparation.turnsToPrep);
  }
  private clearQueuedAction()
  {
    this.battleStats.queuedAction = null;
    this.uiDisplayIsDirty = true;
  }
  // TODO gameplay | allow units to become untargetable in battle (cloaking?)
  public isTargetable()
  {
    return this.isActiveInBattle();
  }
  public isActiveInBattle()
  {
    return this.currentHealth > 0 && !this.battleStats.isAnnihilated;
  }

  private makeUnitItems(itemSlots: {[slot: string]: number})
  {
    return new UnitItems(
      itemSlots,
      (item) =>
      {
        item.unit = this;
      },
      (changedItem) =>
      {
        if (changedItem.template.attributeAdjustments)
        {
          this.attributesAreDirty = true;
        }
        if (changedItem.template.passiveSkill)
        {
          this.passiveSkillsByPhaseAreDirty = true;
        }
      }
    );
  }
  // public addItem(item: Item, index: number)
  // {
  //   var itemSlot = item.template.slot;

  //   if (!this.items.hasSlotForItem(item))
  //   {
  //     return false;
  //   }

  //   if (item.unit)
  //   {
  //     item.unit.removeItem(item);
  //   }

  //   this.items.addItem(item, index);
  //   item.unit = this;

    // if (item.template.attributeAdjustments)
    // {
    //   this.attributesAreDirty = true;
    // }
    // if (item.template.passiveSkill)
    // {
    //   this.passiveSkillsByPhaseAreDirty = true;
    // }
  // }
  // public removeItem(item: Item)
  // {
  //   var itemSlot = item.template.slot;

  //   if (!this.items.hasItem(item))
  //   {
  //     return false;
  //   }

  //   this.items.removeItem(item);
  //   item.unit = null;

  //   if (item.template.attributeAdjustments)
  //   {
  //     this.attributesAreDirty = true;
  //   }
  //   if (item.template.passiveSkill)
  //   {
  //     this.passiveSkillsByPhaseAreDirty = true;
  //   }

  //   return true;
  // }
  private getAttributesWithItems()
  {
    return this.baseAttributes.getAdjustedAttributes(this.items.getAttributeAdjustments()).clamp(1, 9);
  }
  public addStatusEffect(statusEffect: StatusEffect)
  {
    if (this.battleStats.statusEffects.indexOf(statusEffect) !== -1)
    {
      throw new Error("Tried to add duplicate status effect to unit " + this.name);
    }
    else if (statusEffect.duration === 0)
    {
      console.warn("Tried to add status effect", statusEffect, "with 0 duration");
      return;
    }

    this.battleStats.statusEffects.push(statusEffect);
    if (statusEffect.template.attributes)
    {
      this.attributesAreDirty = true;
    }

    this.uiDisplayIsDirty = true;
  }
  private removeStatusEffect(statusEffect: StatusEffect)
  {
    var index = this.battleStats.statusEffects.indexOf(statusEffect);
    if (index === -1)
    {
      throw new Error("Tried to remove status effect not active on unit " + this.name);
    }

    this.battleStats.statusEffects.splice(index, 1);
    if (statusEffect.template.attributes)
    {
      this.attributesAreDirty = true;
    }

    this.uiDisplayIsDirty = true;
  }
  private getStatusEffectAttributeAdjustments(): UnitAttributeAdjustments[]
  {
    return this.battleStats.statusEffects.filter(statusEffect =>
    {
      return Boolean(statusEffect.template.attributes);
    }).map(statusEffect =>
    {
      return statusEffect.template.attributes;
    });
  }
  /*
  sort by attribute, positive/negative, additive vs multiplicative
  apply additive, multiplicative
   */
  private getTotalStatusEffectAttributeAdjustments(): UnitAttributeAdjustments
  {
    if (!this.battleStats || !this.battleStats.statusEffects)
    {
      return null;
    }

    var adjustments: UnitAttributeAdjustments = {};
    for (let i = 0; i < this.battleStats.statusEffects.length; i++)
    {
      var statusEffect = this.battleStats.statusEffects[i];
      if (!statusEffect.template.attributes)
      {
        continue;
      }

      for (let attribute in statusEffect.template.attributes)
      {
        adjustments[attribute] = {};
        for (let type in statusEffect.template.attributes[attribute])
        {
          if (!adjustments[attribute][type])
          {
            adjustments[attribute][type] = 0;
          }

          adjustments[attribute][type] += statusEffect.template.attributes[attribute][type];
        }
      }
    }

    return adjustments;
  }
  private getAttributesWithEffects()
  {
    var withItems = this.getAttributesWithItems();

    var adjustments = this.getTotalStatusEffectAttributeAdjustments();
    for (let attribute in adjustments)
    {
      if (adjustments[attribute].flat)
      {
        withItems[attribute] += adjustments[attribute].flat;
      }
      if (adjustments[attribute].multiplier)
      {
        withItems[attribute] *= 1 + adjustments[attribute].multiplier;
      }

      withItems[attribute] = clamp(withItems[attribute], -5, 20);
    }

    return withItems;
  }
  private getAttributesWithEffectsDifference(): UnitAttributes
  {
    const withItems = this.getAttributesWithItems();
    const withEffects = this.getAttributesWithEffects();

    return withEffects.getDifferenceBetween(withItems);
  }
  private updateCachedAttributes()
  {
    this.cachedAttributes = this.getAttributesWithEffects();
    this.attributesAreDirty = false;
  }
  // public removeItemAtSlot(slot: string)
  // {
  //   if (this.items[slot])
  //   {
  //     this.removeItem(this.items[slot]);
  //     return true;
  //   }

  //   return false;
  // }
  private setInitialAbilities()
  {
    this.abilities = getItemsFromWeightedProbabilities<AbilityTemplate>(this.template.possibleAbilities);
  }
  private setInitialPassiveSkills()
  {
    if (this.template.possiblePassiveSkills)
    {
      this.passiveSkills = getItemsFromWeightedProbabilities<PassiveSkillTemplate>(this.template.possiblePassiveSkills);
    }
  }
  public getAllAbilities(): AbilityTemplate[]
  {
    return this.abilities.concat(this.items.getAbilities());
  }
  public getAllPassiveSkills(): PassiveSkillTemplate[]
  {
    var allSkills: PassiveSkillTemplate[] = [];
    
    allSkills = allSkills.concat(this.passiveSkills);
    allSkills = allSkills.concat(this.items.getPassiveSkills());

    return allSkills;
  }
  private updatePassiveSkillsByPhase(): void
  {
    var updatedSkills = {};

    var allSkills = this.getAllPassiveSkills();

    for (let i = 0; i < allSkills.length; i++)
    {
      var skill = allSkills[i];
      ["atBattleStart", "atTurnStart", "inBattlePrep"].forEach(function(phase)
      {
        if (skill[phase])
        {
          if (!updatedSkills[phase])
          {
            updatedSkills[phase] = [];
          }

          if (updatedSkills[phase].indexOf(skill) === -1)
          {
            updatedSkills[phase].push(skill);
          }
        }
      });
    }

    this.passiveSkillsByPhase = updatedSkills;
    this.passiveSkillsByPhaseAreDirty = false;
  }
  public getPassiveSkillsByPhase()
  {
    if (this.passiveSkillsByPhaseAreDirty)
    {
      this.updatePassiveSkillsByPhase();
    }

    return this.passiveSkillsByPhase;
  }
  private getPassiveEffectsForScene(scene: "galaxyMap" | "battle" | "battlePrep"): UnitPassiveEffect[]
  {
    const relevantTemplateKeys: string[] = [];
    switch (scene)
    {
      case "galaxyMap":
        break;
      case "battlePrep":
        relevantTemplateKeys.push("atBattleStart", "inBattlePrep");
        break;
      case "battle":
        relevantTemplateKeys.push("beforeAbilityUse", "afterAbilityUse");
        break;
    }
    
    const effectFilterFN = (passiveEffect: UnitPassiveEffect) =>
    {
      if (passiveEffect.isHidden)
      {
        return false;
      }
      for (let key of relevantTemplateKeys)
      {
        if (passiveEffect[key])
        {
          return true;
        }
      }
      return false;
    }
    
    const relevantStatusEffectTemplates = this.battleStats.statusEffects.map(statusEffect =>
    {
      return statusEffect.template;
    }).filter(effectFilterFN);
    
    const relevantPassiveEffectTemplates = this.getAllPassiveSkills().filter(effectFilterFN);
    
    return relevantStatusEffectTemplates.concat(relevantPassiveEffectTemplates);
  } 
  public receiveDamage(amount: number, damageType: DamageType)
  {
    var damageReduction = this.getReducedDamageFactor(damageType);

    var adjustedDamage = amount * damageReduction;

    this.battleStats.lastHealthBeforeReceivingDamage = this.currentHealth;
    this.removeStrength(adjustedDamage);
  }
  private getAdjustedTroopSize()
  {
    // used so unit will always counter with at least 1/3 strength it had before being attacked
    var balancedHealth = this.currentHealth + this.battleStats.lastHealthBeforeReceivingDamage / 3;
    this.battleStats.lastHealthBeforeReceivingDamage = this.currentHealth;

    var currentHealth = this.isSquadron ?
      balancedHealth :
      Math.min(this.maxHealth, balancedHealth + this.maxHealth * 0.2);

    if (currentHealth <= 500)
    {
      return currentHealth;
    }
    else if (currentHealth <= 2000)
    {
      return currentHealth / 2 + 250;
    }
    else
    {
      return currentHealth / 4 + 750;
    }
  }
  public getAttackDamageIncrease(damageType: DamageType)
  {
    var attackStat: number, attackFactor: number;

    switch (damageType)
    {
      case DamageType.physical:
      {
        attackStat = this.attributes.attack;
        attackFactor = 0.1;
        break;
      }
      case DamageType.magical:
      {
        attackStat = this.attributes.intelligence;
        attackFactor = 0.1;
        break;
      }
    }

    var troopSize = this.getAdjustedTroopSize() / 4;

    return (1 + attackStat * attackFactor) * troopSize;
  }
  private getReducedDamageFactor(damageType: DamageType)
  {
    var defensiveStat: number, defenceFactor: number;
    var finalDamageMultiplier = 1;

    switch (damageType)
    {
      case DamageType.physical:
      {
        defensiveStat = this.attributes.defence;
        defenceFactor = 0.045;

        var guardAmount = Math.min(this.battleStats.guardAmount, 100);
        finalDamageMultiplier = 1 - guardAmount / 200; // 1 - 0.5;
        break;
      }
      case DamageType.magical:
      {
        defensiveStat = this.attributes.intelligence;
        defenceFactor = 0.045;
        break;
      }
    }

    var damageReduction = defensiveStat * defenceFactor;
    var finalDamageFactor = (1 - damageReduction) * finalDamageMultiplier;

    return finalDamageFactor;
  }
  public addToFleet(fleet: Fleet)
  {
    this.fleet = fleet;
  }
  public removeFromFleet()
  {
    this.fleet = null;
  }
  public removeFromPlayer()
  {
    var player = this.fleet.player;

    this.items.destroyAllItems();
    player.removeUnit(this);
    this.fleet.removeUnit(this);

    if (this.front)
    {
      this.front.removeUnit(this);
    }

    this.uiDisplayIsDirty = true;
  }
  public transferToPlayer(newPlayer: Player)
  {
    var oldPlayer = this.fleet.player;
    var location = this.fleet.location;

    this.removeFromPlayer();

    newPlayer.addUnit(this);
    var newFleet = new Fleet(newPlayer, [this], location);
  }
  public removeGuard(amount: number)
  {
    this.battleStats.guardAmount -= amount;
    if (this.battleStats.guardAmount < 0) this.removeAllGuard();

    this.uiDisplayIsDirty = true;
  }
  public addGuard(amount: number, coverage: GuardCoverage)
  {
    this.battleStats.guardAmount += amount;
    this.battleStats.guardCoverage = coverage;

    this.uiDisplayIsDirty = true;
  }
  public removeAllGuard()
  {
    this.battleStats.guardAmount = 0;
    this.battleStats.guardCoverage = null;

    this.uiDisplayIsDirty = true;
  }
  public getCounterAttackStrength()
  {
    return 1; // TODO unit
  }
  public canActThisTurn(): boolean
  {
    return this.timesActedThisTurn < 1 || this.fleet.player.isIndependent;
  }
  public isStealthy(): boolean
  {
    // TODO unit
    return this.template.isStealthy;
  }
  public getVisionRange(): number
  {
    // TODO unit
    return this.template.visionRange;
  }
  public getDetectionRange(): number
  {
    // TODO unit
    return this.template.detectionRange;
  }
  public heal()
  {
    var location = this.fleet.location;

    var baseHealFactor = 0.05;
    var healingFactor =
      baseHealFactor + location.getHealingFactor(this.fleet.player);

    var healAmount = this.maxHealth * healingFactor;

    this.addStrength(healAmount);
  }
  public getStrengthEvaluation()
  {
    // TODO unit TODO ai
    return this.currentHealth;
  }
  public getTotalCost()
  {
    var totalCost = 0;
    totalCost += this.template.buildCost;
    totalCost += this.items.getAllItems().map(item =>
    {
      return item.template.buildCost;
    }).reduce((a, b) =>
    {
      return a + b;
    }, 0);

    return totalCost;
  }
  public getTurnsToReachStar(star: Star)
  {
    var currentLocation = this.fleet.location;
    var distance = currentLocation.getDistanceToStar(star);
    if (distance <= this.currentMovePoints)
    {
      if (this.currentMovePoints === 0)
      {
        return 0;
      }
      else
      {
        return distance / this.currentMovePoints;
      }
    }
    distance -= this.currentMovePoints; // current turn
    return distance / this.maxMovePoints; // future turns
  }
  public getExperienceToNextLevel()
  {
    return (4 + this.level) * 10;
  }
  public addExperience(amount: number)
  {
    this.experienceForCurrentLevel += Math.round(amount);
  }
  public canLevelUp()
  {
    return this.experienceForCurrentLevel >= this.getExperienceToNextLevel();
  }
  public handleLevelUp()
  {
    this.experienceForCurrentLevel -= this.getExperienceToNextLevel();
    this.level++;
  }
  private hasAbility(ability: AbilityBase, allAbilities: AbilityBase[])
  {
    for (let i = 0; i < allAbilities.length; i++)
    {
      if (allAbilities[i].type === ability.type)
      {
        return true;
      }
    }

    return false;
  }
  private getLearnableAbilities(allAbilities: AbilityBase[]): AbilityBase[]
  {
    const abilities: AbilityBase[] = [];

    if (!this.template.learnableAbilities)
    {
      return abilities;
    }

    for (let i = 0; i < this.template.learnableAbilities.length; i++)
    {
      if (Array.isArray(this.template.learnableAbilities[i]))
      {
        const learnableAbilityGroup = <AbilityBase[]> this.template.learnableAbilities[i];
        let hasAbilityFromGroup: boolean = false;
        for (let j = 0; j < learnableAbilityGroup.length; j++)
        {
          if (this.hasAbility(learnableAbilityGroup[j], allAbilities))
          {
            hasAbilityFromGroup = true;
            break;
          }
        }

        if (!hasAbilityFromGroup)
        {
          abilities.push(...learnableAbilityGroup);
        }
      }
      else
      {
        const learnableAbility = <AbilityBase> this.template.learnableAbilities[i];
        if (!this.hasAbility(learnableAbility, allAbilities))
        {
          abilities.push(learnableAbility);
        }
      }
    }

    return abilities;
  }
  private canUpgradeIntoAbility(ability: AbilityBase, allAbilities: AbilityBase[])
  {
    if (ability.onlyAllowExplicitUpgrade)
    {
      if (!this.template.specialAbilityUpgrades || this.template.specialAbilityUpgrades.indexOf(ability) === -1)
      {
        return false;
      }
    }
    if (this.hasAbility(ability, allAbilities))
    {
      return false;
    }

    return true;
  }
  public getAbilityUpgradeData(): AbilityUpgradeData
  {
    const upgradeData: AbilityUpgradeData = {};

    const allAbilities: AbilityBase[] = this.getAllAbilities();
    allAbilities.push(...this.getAllPassiveSkills());
    
    const upgradableAbilities: AbilityBase[] = allAbilities.filter(abilityTemplate =>
    {
      return abilityTemplate.canUpgradeInto && abilityTemplate.canUpgradeInto.length > 0;
    });

    upgradableAbilities.forEach(parentAbility =>
    {
      parentAbility.canUpgradeInto.forEach(childAbility =>
      {
        if (this.canUpgradeIntoAbility(childAbility, allAbilities))
        {
          if (!upgradeData[parentAbility.type])
          {
            upgradeData[parentAbility.type] =
            {
              base: parentAbility,
              possibleUpgrades: []
            }
          }

          upgradeData[parentAbility.type].possibleUpgrades.push(childAbility);
        }
      });
    });

    const learnable = this.getLearnableAbilities(allAbilities);
    if (learnable.length > 0)
    {
      upgradeData["learnable"] =
      {
        base: null,
        possibleUpgrades: learnable
      }
    }

    return upgradeData;
  }
  public upgradeAbility(source: AbilityBase, newAbility: AbilityBase)
  {
    var newAbilityIsPassiveSkill = !newAbility.mainEffect;
    if (source)
    {
      var sourceIsPassiveSkill = !source.mainEffect;
      if (sourceIsPassiveSkill)
      {
        this.passiveSkills.splice(this.passiveSkills.indexOf(source), 1);
      }
      else
      {
        var castedSource = <AbilityTemplate> source;
        this.abilities.splice(this.abilities.indexOf(castedSource), 1);
      }
    }

    if (newAbilityIsPassiveSkill)
    {
      this.passiveSkills.push(newAbility);
    }
    else
    {
      var castedNewAbility = <AbilityTemplate> newAbility;
      this.abilities.push(castedNewAbility);
    }
  }
  public drawBattleScene(params: SFXParams)
  {
    this.template.unitDrawingFN(this, params);
  }
  public getDisplayData(scene: "galaxyMap" | "battle" | "battlePrep"): UnitDisplayData
  {
    return(
    {
      name: this.name,
      facesLeft: this.battleStats.side === "side2",
      
      currentHealth: this.currentHealth,
      maxHealth: this.maxHealth,
      guardAmount: this.battleStats.guardAmount,
      guardType: this.battleStats.guardCoverage,
      currentActionPoints: this.battleStats.currentActionPoints,
      maxActionPoints: this.attributes.maxActionPoints,
      isPreparing: Boolean(this.battleStats.queuedAction),
      isAnnihilated: this.battleStats.isAnnihilated,
      isSquadron: this.isSquadron,
      
      portraitSrc: this.portrait.imageSrc,
      iconSrc: this.template.icon,
      
      attributeChanges: this.getAttributesWithEffectsDifference(),
      passiveEffects: this.getPassiveEffectsForScene(scene),
    });
  }
  public serialize(includeItems: boolean = true, includeFluff: boolean = true): UnitSaveData
  {
    var battleStatsSavedData: UnitBattleStatsSaveData =
    {
      moveDelay: this.battleStats.moveDelay,
      side: this.battleStats.side,
      position: this.battleStats.position,
      currentActionPoints: this.battleStats.currentActionPoints,
      guardAmount: this.battleStats.guardAmount,
      guardCoverage: this.battleStats.guardCoverage,
      captureChance: this.battleStats.captureChance,
      statusEffects: this.battleStats.statusEffects.map(function(statusEffect)
      {
        return statusEffect.clone();
      }),
      queuedAction: !this.battleStats.queuedAction ? null :
      {
        abilityTemplateKey: this.battleStats.queuedAction.ability.type,
        targetId: this.battleStats.queuedAction.targetId,
        turnsPrepared: this.battleStats.queuedAction.turnsPrepared,
        timesInterrupted: this.battleStats.queuedAction.timesInterrupted
      },
      isAnnihilated: this.battleStats.isAnnihilated
    };

    var data: UnitSaveData =
    {
      templateType: this.template.type,
      id: this.id,
      name: this.name,

      maxHealth: this.maxHealth,
      currentHealth: this.currentHealth,

      currentMovePoints: this.currentMovePoints,
      maxMovePoints: this.maxMovePoints,

      timesActedThisTurn: this.timesActedThisTurn,

      baseAttributes: this.baseAttributes.serialize(),
      abilityTemplateTypes: this.abilities.map(function(ability: AbilityTemplate)
      {
        return ability.type;
      }),
      passiveSkillTemplateTypes: this.passiveSkills.map(function(
        passiveSkill: PassiveSkillTemplate)
      {
        return passiveSkill.type;
      }),

      experienceForCurrentLevel: this.experienceForCurrentLevel,
      level: this.level,

      items: this.items.serialize(),
      battleStats: battleStatsSavedData
    };


    if (this.fleet)
    {
      data.fleetId = this.fleet.id;
    }

    if (includeItems)
    {
      data.serializedItems = this.items.serializeItems();
    }

    if (includeFluff)
    {
      data.portraitKey = this.portrait.key;
    }

    return data;
  }
  public makeVirtualClone()
  {
    var data = this.serialize(true, false);
    var clone = new Unit(this.template, this.id, data);

    return clone;
  }
}

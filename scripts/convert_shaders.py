# Assumes uniform types are in typeScriptTypes dict
# Assumes uniforms not in pixiUniforms array should be included
# Assumes no block comments
# if #define DOMAIN, ignores uniforms declared inside block not matching defined DOMAIN

import os
import sys
import re

fileNamesToConvert = sys.argv[1:]
hasSpecifiedFileNames = len(fileNamesToConvert) > 0

# TODO naive
typeScriptTypes = {
  "bool": "boolean",
  "int": "number",
  "float": "number",
  "vec2": "number[]",
  "vec3": "number[]",
  "vec4": "number[]",
  "ivec2": "number[]",
  "ivec3": "number[]",
  "ivec4": "number[]",
  "mat2": "number[][]",
  "mat3": "number[][]",
  "mat4": "number[][]",
  "sampler2D": "PIXI.Texture"
}
pixiTypes = {
  "bool": "bool",
  "int": "1i",
  "float": "1f",
  "vec2": "2fv",
  "vec3": "3fv",
  "vec4": "4fv",
  "ivec2": "2iv",
  "ivec3": "3iv",
  "ivec4": "4iv",
  "mat2": "mat2",
  "mat3": "mat3",
  "mat4": "mat4",
  "sampler2D": "sampler2D"
}

pixiUniforms = [
  "vTextureCoord",
  "uSampler"
]

uniformKeyword = "uniform "
keyWordPattern = re.compile("\w+")
domainPattern = re.compile("\d")

pixiHeaderFile = "../../lib/pixi.d.ts"

def getGLSLUniformTypes(sourceLines):
  uniformTypes = {}
  currentDomain = None
  currentDomainBlock = None

  for line in sourceLines:
    if "#define DOMAIN" in line: # TODO naive
      currentDomain = re.search(domainPattern, line).group(0)
    elif "DOMAIN ==" in line:
      currentDomainBlock = re.search(domainPattern, line).group(0)
    elif currentDomainBlock is not None and "#endif" in line:
      currentDomainBlock = None

    if currentDomainBlock is not None and currentDomainBlock is not currentDomain:
      continue

    keyWordIndex = line.find(uniformKeyword)
    if keyWordIndex != -1:
      isCommented = line.find("//", 0, keyWordIndex) # TODO naive
      if isCommented != -1:
        continue
      splitted = line.strip().split(" ")
      glslType = splitted[1]
      uniformName = re.search(keyWordPattern, splitted[2]).group(0)
      if uniformName in pixiUniforms:
        continue

      uniformTypes[uniformName] = glslType

  return uniformTypes

def getUniformsLines(uniformTypes):
  lines = [
    'export interface Uniforms\n',
    '{\n'
  ]

  for uniformName in sorted(uniformTypes):
    glslType = uniformTypes[uniformName]
    pixiType = pixiTypes[glslType]
    typeScriptType = typeScriptTypes[glslType]
    lines.append('  {0}: {{type: "{1}"; value: {2};}};\n'.format(uniformName, pixiType, typeScriptType))

  lines.append('}\n\n')

  return lines

def getGetUniformTypesLines(uniformTypes, indentationLevel):

  lines = [
    'public static getUniformTypes()\n',
    '{\n',
    '  return(\n',
    '  {\n'
  ]

  for uniformName in sorted(uniformTypes):
    lines.append('    {0}: "{1}",\n'.format(uniformName, uniformTypes[uniformName]))

  lines.extend([
    '  });\n',
    ' }\n'
  ])

  return ["  " * indentationLevel + line for line in lines]

def writeConvertedShader(outFile, sourceLines, shaderName, fileName):
  outFile.writelines([
    '// Autogenerated from "./{0}"\n\n'.format(fileName),
    '/// <reference path="{0}"/>\n\n'.format(pixiHeaderFile)
  ])

  glslUniformTypes = getGLSLUniformTypes(sourceLines)
  uniformsLines = getUniformsLines(glslUniformTypes)
  for line in uniformsLines:
    outFile.write(line)

  outFile.writelines([
    'export default class {0} extends PIXI.AbstractFilter\n'.format(shaderName),
    '{\n',
    '  uniforms: Uniforms\n\n',
    '  constructor(uniforms?: Uniforms)\n',
    '  {\n',
    '    super(null, sourceLines.join("\\n"), uniforms);\n',
    '  }\n'
  ])

  getUniformTypesLines = getGetUniformTypesLines(glslUniformTypes, 1)
  for line in getUniformTypesLines:
    outFile.write(line)

  outFile.writelines([
    '}\n',
    '\n',
    'const sourceLines =\n',
    '[\n'
  ])

  for line in sourceLines:
    outFile.write('  "{0}",\n'.format(line.rstrip()))

  outFile.write(
    ']\n'
  )

os.chdir(os.pardir)
os.chdir("src/shaders")


for fileName in os.listdir("."):
  if fileName.endswith(".glsl") or fileName.endswith(".frag"):
    if hasSpecifiedFileNames and fileName not in fileNamesToConvert:
      continue
    shaderName = fileName[:-5]
    sourceLines = []
    with open(fileName, "r") as inFile:
      sourceLines = inFile.readlines()
    with open(os.path.join("{0}.ts".format(shaderName)), "w") as outFile:
      writeConvertedShader(outFile, sourceLines, shaderName, fileName)

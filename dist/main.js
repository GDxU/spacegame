var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define("src/Point", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("src/VoronoiCell", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var VoronoiCell = (function (_super) {
        __extends(VoronoiCell, _super);
        function VoronoiCell(cell) {
            var _this = _super.call(this, cell.site) || this;
            _this.halfedges = cell.halfedges;
            var bbox = cell.getBbox();
            _this.x = bbox.x;
            _this.y = bbox.y;
            _this.width = bbox.width;
            _this.height = bbox.height;
            _this.vertices = cell.halfedges.map(function (halfEdge) {
                return halfEdge.getStartpoint();
            });
            return _this;
        }
        return VoronoiCell;
    }(Voronoi.prototype.Cell));
    exports.default = VoronoiCell;
});
define("src/FillerPoint", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var FillerPoint = (function () {
        function FillerPoint(x, y) {
            this.x = x;
            this.y = y;
        }
        FillerPoint.prototype.setPosition = function (x, y) {
            this.x = x;
            this.y = y;
        };
        FillerPoint.prototype.serialize = function () {
            return ({
                x: this.x,
                y: this.y,
            });
        };
        return FillerPoint;
    }());
    exports.default = FillerPoint;
});
define("src/ModuleFileLoadingPhase", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ModuleFileLoadingPhase;
    (function (ModuleFileLoadingPhase) {
        ModuleFileLoadingPhase[ModuleFileLoadingPhase["Setup"] = 0] = "Setup";
        ModuleFileLoadingPhase[ModuleFileLoadingPhase["MapGen"] = 1] = "MapGen";
        ModuleFileLoadingPhase[ModuleFileLoadingPhase["Game"] = 2] = "Game";
        ModuleFileLoadingPhase[ModuleFileLoadingPhase["BattlePrep"] = 3] = "BattlePrep";
        ModuleFileLoadingPhase[ModuleFileLoadingPhase["Battle"] = 4] = "Battle";
    })(ModuleFileLoadingPhase || (ModuleFileLoadingPhase = {}));
    exports.default = ModuleFileLoadingPhase;
});
define("src/localization/Language", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("src/FlatAndMultiplierAdjustment", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("src/Trade", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TradeableItemType;
    (function (TradeableItemType) {
        TradeableItemType[TradeableItemType["Money"] = 0] = "Money";
        TradeableItemType[TradeableItemType["Resource"] = 1] = "Resource";
    })(TradeableItemType = exports.TradeableItemType || (exports.TradeableItemType = {}));
    var Trade = (function () {
        function Trade(player) {
            this.stagedItems = {};
            this.player = player;
            this.setAllTradeableItems();
        }
        Trade.prototype.executeTrade = function (otherTrade) {
            this.executeAllStagedTrades(otherTrade.player);
            otherTrade.executeAllStagedTrades(this.player);
            this.updateAfterExecutedTrade();
            otherTrade.updateAfterExecutedTrade();
        };
        Trade.prototype.stageItem = function (key, amount) {
            if (!this.stagedItems[key]) {
                this.stagedItems[key] =
                    {
                        key: key,
                        type: this.allItems[key].type,
                        amount: amount,
                    };
            }
            else {
                this.stagedItems[key].amount += amount;
                if (this.stagedItems[key].amount <= 0) {
                    this.removeStagedItem(key);
                }
            }
        };
        Trade.prototype.setStagedItemAmount = function (key, newAmount) {
            if (newAmount <= 0) {
                this.removeStagedItem(key);
            }
            else {
                var clamped = Math.min(this.allItems[key].amount, newAmount);
                this.stagedItems[key].amount = clamped;
            }
        };
        Trade.prototype.getItemsAvailableForTrade = function () {
            var available = {};
            for (var key in this.allItems) {
                var stagedAmount = this.stagedItems[key] ? this.stagedItems[key].amount : 0;
                available[key] =
                    {
                        key: key,
                        type: this.allItems[key].type,
                        amount: this.allItems[key].amount - stagedAmount,
                    };
            }
            return available;
        };
        Trade.prototype.removeStagedItem = function (key) {
            this.stagedItems[key] = null;
            delete this.stagedItems[key];
        };
        Trade.prototype.removeAllStagedItems = function () {
            for (var key in this.stagedItems) {
                this.removeStagedItem(key);
            }
        };
        Trade.prototype.clone = function () {
            var cloned = new Trade(this.player);
            cloned.copyStagedItemsFrom(this);
            return cloned;
        };
        Trade.prototype.setAllTradeableItems = function () {
            this.allItems =
                {
                    money: {
                        key: "money",
                        type: TradeableItemType.Money,
                        amount: this.player.money,
                    },
                };
        };
        Trade.prototype.handleTradeOfItem = function (key, amount, targetPlayer) {
            switch (key) {
                case "money":
                    {
                        this.player.money -= amount;
                        targetPlayer.money += amount;
                    }
            }
        };
        Trade.prototype.executeAllStagedTrades = function (targetPlayer) {
            for (var key in this.stagedItems) {
                this.handleTradeOfItem(key, this.stagedItems[key].amount, targetPlayer);
            }
        };
        Trade.prototype.updateAfterExecutedTrade = function () {
            this.setAllTradeableItems();
            this.removeAllStagedItems();
        };
        Trade.prototype.copyStagedItemsFrom = function (toCopyFrom) {
            for (var key in toCopyFrom.stagedItems) {
                this.stagedItems[key] =
                    {
                        key: key,
                        type: toCopyFrom.stagedItems[key].type,
                        amount: toCopyFrom.stagedItems[key].amount,
                    };
            }
        };
        return Trade;
    }());
    exports.Trade = Trade;
});
define("src/TradeResponse", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("src/UnitDrawingFunctionData", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function mirrorRectangle(rect, midX) {
        return new PIXI.Rectangle(getMirroredPosition(rect.x, midX) - rect.width, rect.y, rect.width, rect.height);
    }
    function mirrorPoint(point, midX) {
        return { x: getMirroredPosition(point.x, midX), y: point.y };
    }
    function getMirroredPosition(pos, mid) {
        return pos - (pos - mid) * 2;
    }
    function offsetRectangle(rect, offset) {
        return new PIXI.Rectangle(rect.x + offset.x, rect.y + offset.y, rect.width, rect.height);
    }
    function offsetPoint(point, offset) {
        return ({
            x: point.x + offset.x,
            y: point.y + offset.y,
        });
    }
    var UnitDrawingFunctionData = (function () {
        function UnitDrawingFunctionData(props) {
            this.boundingBox = props.boundingBox;
            this.individualUnitBoundingBoxes = props.individualUnitBoundingBoxes;
            this.singleAttackOriginPoint = props.singleAttackOriginPoint;
            this.sequentialAttackOriginPoints = props.sequentialAttackOriginPoints;
        }
        UnitDrawingFunctionData.prototype.normalizeForBattleSFX = function (offset, sceneWidth, side) {
            var cloned = this.clone();
            var padding = 25;
            cloned.offset({ x: padding, y: offset.y });
            if (side === "target") {
                cloned.mirror(sceneWidth / 2);
            }
            return cloned;
        };
        UnitDrawingFunctionData.prototype.clone = function () {
            return new UnitDrawingFunctionData({
                boundingBox: this.boundingBox.clone(),
                individualUnitBoundingBoxes: this.individualUnitBoundingBoxes.map(function (bbox) {
                    return bbox.clone();
                }),
                singleAttackOriginPoint: { x: this.singleAttackOriginPoint.x, y: this.singleAttackOriginPoint.y },
                sequentialAttackOriginPoints: this.sequentialAttackOriginPoints.map(function (point) {
                    return { x: point.x, y: point.y };
                }),
            });
        };
        UnitDrawingFunctionData.prototype.offset = function (offset) {
            this.boundingBox = offsetRectangle(this.boundingBox, offset);
            this.individualUnitBoundingBoxes = this.individualUnitBoundingBoxes.map(function (bbox) {
                return offsetRectangle(bbox, offset);
            });
            this.singleAttackOriginPoint = offsetPoint(this.singleAttackOriginPoint, offset);
            this.sequentialAttackOriginPoints = this.sequentialAttackOriginPoints.map(function (point) {
                return offsetPoint(point, offset);
            });
            return this;
        };
        UnitDrawingFunctionData.prototype.mirror = function (midX) {
            this.boundingBox = mirrorRectangle(this.boundingBox, midX);
            this.individualUnitBoundingBoxes = this.individualUnitBoundingBoxes.map(function (bbox) {
                return mirrorRectangle(bbox, midX);
            });
            this.singleAttackOriginPoint = mirrorPoint(this.singleAttackOriginPoint, midX);
            this.sequentialAttackOriginPoints = this.sequentialAttackOriginPoints.map(function (point) {
                return mirrorPoint(point, midX);
            });
            return this;
        };
        return UnitDrawingFunctionData;
    }());
    exports.default = UnitDrawingFunctionData;
});
define("src/idGenerators", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var IdGenerator = (function () {
        function IdGenerator() {
            this.fleet = 0;
            this.item = 0;
            this.player = 0;
            this.star = 0;
            this.unit = 0;
            this.building = 0;
            this.objective = 0;
            this.statusEffect = 0;
        }
        IdGenerator.prototype.setValues = function (newValues) {
            for (var key in newValues) {
                this[key] = newValues[key];
            }
        };
        IdGenerator.prototype.serialize = function () {
            return ({
                fleet: this.fleet,
                item: this.item,
                player: this.player,
                star: this.star,
                unit: this.unit,
                building: this.building,
                objective: this.objective,
                statusEffect: this.statusEffect,
            });
        };
        return IdGenerator;
    }());
    var idGenerators = new IdGenerator();
    exports.default = idGenerators;
});
define("src/targeting", ["require", "exports", "src/utility"], function (require, exports, utility_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.targetSelf = function (user, battle) {
        return [user];
    };
    exports.targetNextRow = function (user, battle) {
        var ownPosition = user.battleStats.position;
        var increment = user.battleStats.side === "side1" ? 1 : -1;
        var fullFormation = battle.side1.concat(battle.side2);
        return fullFormation[ownPosition[0] + increment].filter(function (unit) { return unit !== null; });
    };
    exports.targetAllies = function (user, battle) {
        return battle.getUnitsForSide(user.battleStats.side);
    };
    exports.targetEnemies = function (user, battle) {
        return battle.getUnitsForSide(utility_1.reverseSide(user.battleStats.side));
    };
    exports.targetAll = function (user, battle) {
        return utility_1.flatten2dArray(battle.side1.concat(battle.side2)).filter(function (unit) { return unit !== null; });
    };
    exports.areaSingle = function (user, target, battle) {
        return [target];
    };
    exports.areaAll = function (user, target, battle) {
        return utility_1.flatten2dArray(battle.side1.concat(battle.side2));
    };
    exports.areaColumn = function (user, target, battle) {
        var allRows = battle.side1.concat(battle.side2);
        var y = target.battleStats.position[1];
        return allRows.map(function (row) { return row[y]; });
    };
    exports.areaRow = function (user, target, battle) {
        var allRows = battle.side1.concat(battle.side2);
        var x = target.battleStats.position[0];
        return allRows[x];
    };
    exports.areaRowNeighbors = function (user, target, battle) {
        var row = exports.areaRow(user, target, battle);
        var y = target.battleStats.position[1];
        var y1 = Math.max(y - 1, 0);
        var y2 = Math.min(y + 1, row.length - 1);
        return row.slice(y1, y2);
    };
    exports.areaOrthogonalNeighbors = function (user, target, battle) {
        var allRows = battle.side1.concat(battle.side2);
        var x = target.battleStats.position[0];
        var y = target.battleStats.position[1];
        var targetLocations = [];
        targetLocations.push([x, y]);
        targetLocations.push([x - 1, y]);
        targetLocations.push([x + 1, y]);
        targetLocations.push([x, y - 1]);
        targetLocations.push([x, y + 1]);
        return utility_1.getFrom2dArray(allRows, targetLocations);
    };
});
define("src/Building", ["require", "exports", "src/activeModuleData", "src/idGenerators"], function (require, exports, activeModuleData_1, idGenerators_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Building = (function () {
        function Building(props) {
            this.template = props.template;
            this.id = (props.id && isFinite(props.id)) ?
                props.id : idGenerators_1.default.building++;
            this.location = props.location;
            this.controller = props.controller || this.location.owner;
            this.upgradeLevel = props.upgradeLevel || 1;
            this.totalCost = props.totalCost || this.template.buildCost || 0;
        }
        Building.prototype.getEffect = function (effect) {
            if (effect === void 0) { effect = {}; }
            if (!this.template.effect)
                return {};
            var multiplier = this.template.effectMultiplierFN ?
                this.template.effectMultiplierFN(this.upgradeLevel) :
                this.upgradeLevel;
            for (var key in this.template.effect) {
                var prop = this.template.effect[key];
                if (isFinite(prop)) {
                    if (!effect[key]) {
                        effect[key] = 0;
                    }
                    effect[key] += prop * multiplier;
                }
                else {
                    if (!effect[key]) {
                        effect[key] = {};
                    }
                    for (var key2 in prop) {
                        if (!effect[key][key2]) {
                            effect[key][key2] = 0;
                        }
                        effect[key][key2] += prop[key2] * multiplier;
                    }
                }
            }
            return effect;
        };
        Building.prototype.getPossibleUpgrades = function () {
            var self = this;
            var upgrades = [];
            if (this.upgradeLevel < this.template.maxUpgradeLevel) {
                upgrades.push({
                    template: this.template,
                    level: this.upgradeLevel + 1,
                    cost: this.template.buildCost * (this.upgradeLevel + 1),
                    parentBuilding: this,
                });
            }
            else if (this.template.upgradeInto && this.template.upgradeInto.length > 0) {
                var templatedUpgrades = this.template.upgradeInto.map(function (upgradeData) {
                    var template = activeModuleData_1.activeModuleData.Templates.Buildings[upgradeData.templateType];
                    return ({
                        level: upgradeData.level,
                        template: template,
                        cost: template.buildCost,
                        parentBuilding: self,
                    });
                });
                upgrades = upgrades.concat(templatedUpgrades);
            }
            return upgrades;
        };
        Building.prototype.upgrade = function () {
        };
        Building.prototype.setController = function (newController) {
            var oldController = this.controller;
            if (oldController === newController)
                return;
            this.controller = newController;
            this.location.updateController();
        };
        Building.prototype.serialize = function () {
            var data = {
                templateType: this.template.type,
                id: this.id,
                locationId: this.location.id,
                controllerId: this.controller.id,
                upgradeLevel: this.upgradeLevel,
                totalCost: this.totalCost,
            };
            return data;
        };
        return Building;
    }());
    exports.default = Building;
});
define("src/GuardCoverage", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("src/getNullFormation", ["require", "exports", "src/activeModuleData"], function (require, exports, activeModuleData_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function getNullFormation() {
        var nullFormation = [];
        var rows = activeModuleData_2.activeModuleData.ruleSet.battle.rowsPerFormation;
        var columns = activeModuleData_2.activeModuleData.ruleSet.battle.cellsPerRow;
        for (var i = 0; i < rows; i++) {
            nullFormation.push([]);
            for (var j = 0; j < columns; j++) {
                nullFormation[i].push(null);
            }
        }
        return nullFormation;
    }
    exports.default = getNullFormation;
});
define("src/BattlePrepFormation", ["require", "exports", "src/getNullFormation", "src/utility"], function (require, exports, getNullFormation_1, utility_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BattlePrepFormation = (function () {
        function BattlePrepFormation(player, units, hasScouted, minUnits, isAttacker) {
            this.placedUnitPositionsById = {};
            this.displayDataIsDirty = true;
            this.player = player;
            this.units = units;
            this.hasScouted = hasScouted;
            this.minUnits = minUnits;
            this.isAttacker = isAttacker;
            this.formation = getNullFormation_1.default();
        }
        BattlePrepFormation.prototype.getPlacedUnits = function () {
            return utility_2.flatten2dArray(this.formation).filter(function (unit) { return Boolean(unit); });
        };
        BattlePrepFormation.prototype.forEachUnitInFormation = function (f) {
            for (var i = 0; i < this.formation.length; i++) {
                for (var j = 0; j < this.formation[i].length; j++) {
                    var unit = this.formation[i][j];
                    if (unit) {
                        f(unit, [i, j]);
                    }
                }
            }
        };
        BattlePrepFormation.prototype.getDisplayData = function () {
            if (this.displayDataIsDirty) {
                this.cachedDisplayData = this.getFormationDisplayData();
                this.displayDataIsDirty = false;
            }
            return this.cachedDisplayData;
        };
        BattlePrepFormation.prototype.setAutoFormation = function (enemyUnits, enemyFormation) {
            var _this = this;
            this.clearFormation();
            this.formation = this.player.AIController.createBattleFormation(this.getAvailableUnits(), this.hasScouted, enemyUnits, enemyFormation);
            this.forEachUnitInFormation(function (unit, pos) {
                _this.placedUnitPositionsById[unit.id] = pos;
            });
            this.displayDataIsDirty = true;
        };
        BattlePrepFormation.prototype.getUnitPosition = function (unit) {
            return this.placedUnitPositionsById[unit.id];
        };
        BattlePrepFormation.prototype.clearFormation = function () {
            this.placedUnitPositionsById = {};
            this.formation = getNullFormation_1.default();
            this.displayDataIsDirty = true;
        };
        BattlePrepFormation.prototype.getFormationValidity = function () {
            var amountOfUnitsPlaced = 0;
            this.forEachUnitInFormation(function (unit) { return amountOfUnitsPlaced += 1; });
            if (this.isAttacker && amountOfUnitsPlaced < 1) {
                return ({
                    isValid: false,
                    description: "Attacker must place at least 1 unit.",
                });
            }
            var availableUnits = this.getAvailableUnits();
            var hasPlacedAllAvailableUnits = amountOfUnitsPlaced === availableUnits.length;
            if (amountOfUnitsPlaced >= this.minUnits || hasPlacedAllAvailableUnits) {
                return ({
                    isValid: true,
                    description: "",
                });
            }
            else {
                return ({
                    isValid: false,
                    description: "Must place at least " + this.minUnits + " units or all available units.",
                });
            }
        };
        BattlePrepFormation.prototype.setUnit = function (unit, position) {
            var unitInTargetPosition = this.getUnitAtPosition(position);
            if (unitInTargetPosition) {
                this.swapUnits(unit, unitInTargetPosition);
            }
            else {
                this.removeUnit(unit);
                this.formation[position[0]][position[1]] = unit;
                this.placedUnitPositionsById[unit.id] = position;
                this.displayDataIsDirty = true;
            }
        };
        BattlePrepFormation.prototype.removeUnit = function (unit) {
            var position = this.getUnitPosition(unit);
            if (!position) {
                return;
            }
            this.formation[position[0]][position[1]] = null;
            delete this.placedUnitPositionsById[unit.id];
            this.displayDataIsDirty = true;
        };
        BattlePrepFormation.prototype.getUnitAtPosition = function (position) {
            return this.formation[position[0]][position[1]];
        };
        BattlePrepFormation.prototype.swapUnits = function (unit1, unit2) {
            if (unit1 === unit2) {
                return;
            }
            var new1Pos = this.getUnitPosition(unit2);
            var new2Pos = this.getUnitPosition(unit1);
            this.removeUnit(unit1);
            this.removeUnit(unit2);
            this.setUnit(unit1, new1Pos);
            this.setUnit(unit2, new2Pos);
        };
        BattlePrepFormation.prototype.getFormationDisplayData = function () {
            var displayDataById = {};
            this.forEachUnitInFormation(function (unit) {
                displayDataById[unit.id] = unit.getDisplayData("battlePrep");
            });
            return displayDataById;
        };
        BattlePrepFormation.prototype.getAvailableUnits = function () {
            return this.isAttacker ?
                this.units.filter(function (unit) { return unit.canFightOffensiveBattle(); }) :
                this.units.slice();
        };
        return BattlePrepFormation;
    }());
    exports.default = BattlePrepFormation;
});
define("src/BattlePrep", ["require", "exports", "src/Battle", "src/BattlePrepFormation"], function (require, exports, Battle_1, BattlePrepFormation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BattlePrep = (function () {
        function BattlePrep(battleData) {
            this.afterBattleFinishCallbacks = [];
            this.attacker = battleData.attacker.player;
            this.defender = battleData.defender.player;
            this.battleData = battleData;
            this.attackerUnits = battleData.attacker.units;
            this.defenderUnits = battleData.defender.units;
            var attackerHasScouted = this.attacker.starIsDetected(battleData.location);
            this.attackerFormation = new BattlePrepFormation_1.default(this.attacker, this.attackerUnits, attackerHasScouted, 1, true);
            var defenderHasScouted = this.defender.starIsDetected(battleData.location);
            this.defenderFormation = new BattlePrepFormation_1.default(this.defender, this.defenderUnits, defenderHasScouted, undefined, false);
            this.resetBattleStats();
            this.minDefenders = this.getInitialMinDefenders();
            this.setHumanAndEnemy();
            if (this.enemyFormation) {
                this.enemyFormation.setAutoFormation(this.humanUnits);
                this.triggerPassiveSkills(this.enemyFormation);
                this.defenderFormation.minUnits = this.minDefenders;
            }
            else {
                this.attackerFormation.setAutoFormation(this.defenderUnits);
                this.triggerPassiveSkills(this.attackerFormation);
                this.defenderFormation.minUnits = this.minDefenders;
                this.defenderFormation.setAutoFormation(this.attackerUnits, this.attackerFormation.formation);
            }
        }
        BattlePrep.prototype.forEachUnit = function (f) {
            this.attackerUnits.forEach(f);
            this.defenderUnits.forEach(f);
        };
        BattlePrep.prototype.isLocationNeutral = function () {
            return (this.battleData.location.owner !== this.attacker &&
                this.battleData.location.owner !== this.defender);
        };
        BattlePrep.prototype.makeBattle = function () {
            var side1Formation = this.humanFormation || this.attackerFormation;
            var side2Formation = this.enemyFormation || this.defenderFormation;
            var side1Player = this.humanPlayer || this.attacker;
            var side2Player = this.enemyPlayer || this.defender;
            var battle = new Battle_1.default({
                battleData: this.battleData,
                side1: side1Formation.formation,
                side2: side2Formation.formation.reverse(),
                side1Player: side1Player,
                side2Player: side2Player,
            });
            battle.afterFinishCallbacks = battle.afterFinishCallbacks.concat(this.afterBattleFinishCallbacks);
            battle.init();
            return battle;
        };
        BattlePrep.prototype.setHumanAndEnemy = function () {
            if (!this.attacker.isAI) {
                this.humanPlayer = this.attacker;
                this.enemyPlayer = this.defender;
                this.humanUnits = this.attackerUnits;
                this.enemyUnits = this.defenderUnits;
                this.humanFormation = this.attackerFormation;
                this.enemyFormation = this.defenderFormation;
            }
            else if (!this.defender.isAI) {
                this.humanPlayer = this.defender;
                this.enemyPlayer = this.attacker;
                this.humanUnits = this.defenderUnits;
                this.enemyUnits = this.attackerUnits;
                this.humanFormation = this.defenderFormation;
                this.enemyFormation = this.attackerFormation;
            }
        };
        BattlePrep.prototype.resetBattleStats = function () {
            this.forEachUnit(function (unit) {
                unit.resetBattleStats();
            });
        };
        BattlePrep.prototype.triggerPassiveSkills = function (formation) {
            var _this = this;
            formation.forEachUnitInFormation(function (unit) {
                var passiveSkillsByPhase = unit.getPassiveSkillsByPhase();
                if (passiveSkillsByPhase.inBattlePrep) {
                    for (var j = 0; j < passiveSkillsByPhase.inBattlePrep.length; j++) {
                        var skill = passiveSkillsByPhase.inBattlePrep[j];
                        for (var k = 0; k < skill.inBattlePrep.length; k++) {
                            skill.inBattlePrep[k](unit, _this);
                        }
                    }
                }
            });
        };
        BattlePrep.prototype.getInitialMinDefenders = function () {
            if (this.isLocationNeutral()) {
                return 1;
            }
            else {
                return 0;
            }
        };
        return BattlePrep;
    }());
    exports.default = BattlePrep;
});
define("src/eventManager", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var eventEmitter = new PIXI.utils.EventEmitter();
    var eventManager = {
        dispatchEvent: eventEmitter.emit.bind(eventEmitter),
        removeEventListener: eventEmitter.removeListener.bind(eventEmitter),
        removeAllListeners: eventEmitter.removeAllListeners.bind(eventEmitter),
        addEventListener: function (eventType, listener) {
            eventEmitter.on(eventType, listener);
            return listener;
        },
    };
    exports.default = eventManager;
});
define("src/DiplomacyState", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DiplomacyState;
    (function (DiplomacyState) {
        DiplomacyState[DiplomacyState["Unmet"] = 0] = "Unmet";
        DiplomacyState[DiplomacyState["Peace"] = 1] = "Peace";
        DiplomacyState[DiplomacyState["ColdWar"] = 2] = "ColdWar";
        DiplomacyState[DiplomacyState["War"] = 3] = "War";
    })(DiplomacyState || (DiplomacyState = {}));
    exports.default = DiplomacyState;
});
define("src/AttitudeModifier", ["require", "exports", "src/utility"], function (require, exports, utility_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AttitudeModifier = (function () {
        function AttitudeModifier(props) {
            this.isOverRidden = false;
            this.template = props.template;
            this.startTurn = props.startTurn;
            this.currentTurn = this.startTurn;
            if (isFinite(props.endTurn)) {
                this.endTurn = props.endTurn;
            }
            else if (isFinite(this.template.duration)) {
                if (this.template.duration < 0) {
                    this.endTurn = -1;
                }
                else {
                    this.endTurn = this.startTurn + this.template.duration;
                }
            }
            else {
                throw new Error("Attitude modifier has no duration or end turn set");
            }
            if (isFinite(this.template.constantEffect)) {
                this.strength = this.template.constantEffect;
            }
            else {
                this.strength = props.strength;
            }
        }
        AttitudeModifier.prototype.updateWithEvaluation = function (evaluation) {
            this.currentTurn = evaluation.currentTurn;
            this.setStrength(evaluation);
        };
        AttitudeModifier.prototype.refresh = function (newModifier) {
            this.startTurn = newModifier.startTurn;
            this.endTurn = newModifier.endTurn;
            this.strength = newModifier.strength;
        };
        AttitudeModifier.prototype.getAdjustedStrength = function (currentTurn) {
            if (currentTurn === void 0) { currentTurn = this.currentTurn; }
            var freshenss = this.getFreshness(currentTurn);
            return Math.round(this.strength * freshenss);
        };
        AttitudeModifier.prototype.shouldEnd = function (evaluation) {
            if (this.hasExpired(evaluation.currentTurn)) {
                return true;
            }
            else if (this.template.endCondition) {
                return this.template.endCondition(evaluation);
            }
            else if (this.template.duration < 0 && this.template.startCondition) {
                return !this.template.startCondition(evaluation);
            }
            else {
                return false;
            }
        };
        AttitudeModifier.prototype.serialize = function () {
            var data = {
                templateType: this.template.type,
                startTurn: this.startTurn,
                endTurn: this.endTurn,
                strength: this.strength,
            };
            return data;
        };
        AttitudeModifier.prototype.setStrength = function (evaluation) {
            if (this.template.constantEffect) {
                this.strength = this.template.constantEffect;
            }
            else if (this.template.getEffectFromEvaluation) {
                this.strength = this.template.getEffectFromEvaluation(evaluation);
            }
            else {
                throw new Error("Attitude modifier has no constant effect " +
                    "or effect from evaluation defined");
            }
            return this.strength;
        };
        AttitudeModifier.prototype.getFreshness = function (currentTurn) {
            if (currentTurn === void 0) { currentTurn = this.currentTurn; }
            if (this.endTurn < 0)
                return 1;
            else {
                return 1 - utility_3.getRelativeValue(currentTurn, this.startTurn, this.endTurn);
            }
        };
        AttitudeModifier.prototype.hasExpired = function (currentTurn) {
            if (currentTurn === void 0) { currentTurn = this.currentTurn; }
            return (this.endTurn >= 0 && currentTurn > this.endTurn);
        };
        return AttitudeModifier;
    }());
    exports.AttitudeModifier = AttitudeModifier;
});
define("src/IdDictionary", ["require", "exports", "src/utility"], function (require, exports, utility_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var IdDictionary = (function () {
        function IdDictionary(keys, getValueFN) {
            var _this = this;
            this.valuesById = {};
            this.keysById = {};
            if (keys) {
                keys.forEach(function (key) {
                    _this.set(key, getValueFN(key));
                });
            }
        }
        IdDictionary.prototype.has = function (key) {
            return Boolean(this.valuesById[key.id]);
        };
        IdDictionary.prototype.get = function (key) {
            return this.valuesById[key.id];
        };
        IdDictionary.prototype.getById = function (id) {
            return this.valuesById[id];
        };
        IdDictionary.prototype.set = function (key, value) {
            this.valuesById[key.id] = value;
            this.keysById[key.id] = key;
        };
        IdDictionary.prototype.setIfDoesntExist = function (key, value) {
            if (!this.keysById[key.id]) {
                this.set(key, value);
            }
        };
        IdDictionary.prototype.delete = function (key) {
            delete this.valuesById[key.id];
            delete this.keysById[key.id];
        };
        IdDictionary.prototype.forEach = function (callback) {
            for (var id in this.keysById) {
                callback(this.keysById[id], this.valuesById[id]);
            }
        };
        IdDictionary.prototype.filter = function (filterFN) {
            var filtered = new this.constructor();
            this.forEach(function (key, value) {
                if (filterFN(key, value)) {
                    filtered.set(key, value);
                }
            });
            return filtered;
        };
        IdDictionary.prototype.zip = function (keyName, valueName) {
            var zipped = [];
            for (var id in this.keysById) {
                var zippedPair = (_a = {},
                    _a[keyName] = this.keysById[id],
                    _a[valueName] = this.valuesById[id],
                    _a);
                zipped.push(zippedPair);
            }
            return zipped;
            var _a;
        };
        IdDictionary.prototype.toObject = function () {
            return utility_4.shallowCopy(this.valuesById);
        };
        IdDictionary.prototype.sort = function (sortingFN) {
            var _this = this;
            var keys = [];
            for (var id in this.keysById) {
                keys.push(this.keysById[id]);
            }
            keys.sort(function (a, b) {
                var sortingValue = sortingFN(_this.valuesById[a.id], _this.valuesById[b.id]);
                if (sortingValue) {
                    return sortingValue;
                }
                else {
                    return b.id - a.id;
                }
            });
            return keys;
        };
        IdDictionary.prototype.mapToArray = function (mapFN) {
            var mapped = [];
            this.forEach(function (k, v) {
                mapped.push(mapFN(k, v));
            });
            return mapped;
        };
        IdDictionary.prototype.merge = function (mergeFN) {
            var toMerge = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                toMerge[_i - 1] = arguments[_i];
            }
            var merged = this.constructor();
            toMerge.forEach(function (dictToMerge) {
                dictToMerge.filter(function (k, v) {
                    return !merged.has(k);
                }).forEach(function (key) {
                    var allValues = toMerge.filter(function (dictToCheck) {
                        return dictToCheck.has(key);
                    }).map(function (dictWithKey) {
                        return dictWithKey.get(key);
                    });
                    merged.set(key, mergeFN.apply(void 0, allValues));
                });
            });
            return merged;
        };
        IdDictionary.prototype.find = function (filterFN) {
            for (var id in this.keysById) {
                if (filterFN(this.keysById[id], this.valuesById[id])) {
                    return this.keysById[id];
                }
            }
            return null;
        };
        IdDictionary.prototype.some = function (filterFN) {
            return Boolean(this.find(filterFN));
        };
        return IdDictionary;
    }());
    exports.IdDictionary = IdDictionary;
});
define("src/ValuesByPlayer", ["require", "exports", "src/IdDictionary"], function (require, exports, IdDictionary_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ValuesByPlayer = (function (_super) {
        __extends(ValuesByPlayer, _super);
        function ValuesByPlayer(players, getValueFN) {
            return _super.call(this, players, getValueFN) || this;
        }
        return ValuesByPlayer;
    }(IdDictionary_1.IdDictionary));
    exports.default = ValuesByPlayer;
});
define("src/DiplomacyStatus", ["require", "exports", "src/App", "src/activeModuleData", "src/eventManager", "src/AttitudeModifier", "src/DiplomacyState", "src/ValuesByPlayer"], function (require, exports, App_1, activeModuleData_3, eventManager_1, AttitudeModifier_1, DiplomacyState_1, ValuesByPlayer_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DiplomacyStatus = (function () {
        function DiplomacyStatus(player, allPlayersInGame) {
            var _this = this;
            this.listeners = {};
            this.player = player;
            this.addEventListeners();
            var validPlayers = allPlayersInGame.filter(function (gamePlayer) { return _this.canDoDiplomacyWithPlayer(gamePlayer); });
            this.statusByPlayer = new ValuesByPlayer_1.default(validPlayers, function () {
                return DiplomacyState_1.default.Unmet;
            });
            this.attitudeModifiersByPlayer = new ValuesByPlayer_1.default(validPlayers, function () {
                return [];
            });
        }
        DiplomacyStatus.prototype.destroy = function () {
            for (var key in this.listeners) {
                for (var i = 0; i < this.listeners[key].length; i++) {
                    eventManager_1.default.removeEventListener(key, this.listeners[key][i]);
                }
            }
        };
        DiplomacyStatus.prototype.getBaseOpinion = function () {
            if (isFinite(this.baseOpinion)) {
                return this.baseOpinion;
            }
            var friendliness = this.player.AIController.personality.friendliness;
            this.baseOpinion = Math.round((friendliness - 0.5) * 10);
            return this.baseOpinion;
        };
        DiplomacyStatus.prototype.getOpinionOf = function (player) {
            var baseOpinion = this.getBaseOpinion();
            var attitudeModifiers = this.attitudeModifiersByPlayer.get(player);
            var modifierOpinion = attitudeModifiers.map(function (modifier) {
                return modifier.getAdjustedStrength();
            }).reduce(function (totalOpinion, currentOpinion) {
                return totalOpinion + currentOpinion;
            }, 0);
            return Math.round(baseOpinion + modifierOpinion);
        };
        DiplomacyStatus.prototype.canDoDiplomacyWithPlayer = function (player) {
            return player !== this.player &&
                !player.isIndependent &&
                !player.isDead;
        };
        DiplomacyStatus.prototype.hasMetPlayer = function (player) {
            return this.statusByPlayer.get(player) > DiplomacyState_1.default.Unmet;
        };
        DiplomacyStatus.prototype.meetPlayerIfNeeded = function (player) {
            if (!this.hasMetPlayer(player) && this.canDoDiplomacyWithPlayer(player)) {
                this.triggerMeetingWithPlayer(player);
                player.diplomacyStatus.triggerMeetingWithPlayer(this.player);
            }
        };
        DiplomacyStatus.prototype.getMetPlayers = function () {
            return this.statusByPlayer.filter(function (player, state) {
                return state > DiplomacyState_1.default.Unmet;
            }).mapToArray(function (player) {
                return player;
            });
        };
        DiplomacyStatus.prototype.hasAnUnmetPlayer = function () {
            return this.statusByPlayer.some(function (player, state) {
                return state === DiplomacyState_1.default.Unmet;
            });
        };
        DiplomacyStatus.prototype.canDeclareWarOn = function (player) {
            return this.hasMetPlayer(player) && this.statusByPlayer.get(player) < DiplomacyState_1.default.War;
        };
        DiplomacyStatus.prototype.canMakePeaceWith = function (player) {
            return this.hasMetPlayer(player) && this.statusByPlayer.get(player) > DiplomacyState_1.default.Peace;
        };
        DiplomacyStatus.prototype.declareWarOn = function (targetPlayer) {
            var _this = this;
            if (this.statusByPlayer.get(targetPlayer) >= DiplomacyState_1.default.War) {
                console.error("Players " + this.player.id + " and " + targetPlayer.id + " are already at war");
                return;
            }
            this.statusByPlayer.set(targetPlayer, DiplomacyState_1.default.War);
            targetPlayer.diplomacyStatus.statusByPlayer.set(this.player, DiplomacyState_1.default.War);
            eventManager_1.default.dispatchEvent("addDeclaredWarAttitudeModifier", targetPlayer, this.player);
            activeModuleData_3.activeModuleData.scripts.diplomacy.onWarDeclaration.forEach(function (script) {
                script(_this.player, targetPlayer);
            });
        };
        DiplomacyStatus.prototype.makePeaceWith = function (player) {
            if (!this.canMakePeaceWith(player)) {
                throw new Error("Players " + this.player.id + " and " + player.id + " can't delcare peace.");
            }
            this.statusByPlayer.set(player, DiplomacyState_1.default.Peace);
            player.diplomacyStatus.statusByPlayer.set(this.player, DiplomacyState_1.default.Peace);
        };
        DiplomacyStatus.prototype.canAttackFleetOfPlayer = function (player) {
            if (player.isIndependent) {
                return true;
            }
            if (this.statusByPlayer.get(player) >= DiplomacyState_1.default.ColdWar) {
                return true;
            }
            return false;
        };
        DiplomacyStatus.prototype.canAttackBuildingOfPlayer = function (player) {
            if (player.isIndependent) {
                return true;
            }
            if (this.statusByPlayer.get(player) >= DiplomacyState_1.default.War) {
                return true;
            }
            return false;
        };
        DiplomacyStatus.prototype.addAttitudeModifier = function (player, modifier) {
            var sameType = this.getModifierOfSameType(player, modifier);
            if (sameType) {
                sameType.refresh(modifier);
                return;
            }
            this.attitudeModifiersByPlayer.get(player).push(modifier);
        };
        DiplomacyStatus.prototype.processAttitudeModifiersForPlayer = function (player, evaluation) {
            var allModifiers = activeModuleData_3.activeModuleData.Templates.AttitudeModifiers;
            var modifiersForPlayer = this.attitudeModifiersByPlayer.get(player);
            var activeModifiers = {};
            var modifiersAdded = {};
            var modifiersRemoved = {};
            for (var i = modifiersForPlayer.length - 1; i >= 0; i--) {
                var modifier = modifiersForPlayer[i];
                if (modifier.shouldEnd(evaluation)) {
                    modifiersForPlayer.splice(i, 1);
                    modifiersRemoved[modifier.template.type] = modifier;
                }
                else {
                    activeModifiers[modifier.template.type] = modifier;
                }
            }
            for (var modifierType in allModifiers) {
                var template = allModifiers[modifierType];
                var modifier = void 0;
                modifier = activeModifiers[template.type];
                var alreadyHasModifierOfType = modifier;
                if (!alreadyHasModifierOfType && !template.triggers) {
                    if (!template.startCondition) {
                        throw new Error("Attitude modifier has no start condition or triggers");
                    }
                    else {
                        var shouldStart = template.startCondition(evaluation);
                        if (shouldStart) {
                            modifier = new AttitudeModifier_1.AttitudeModifier({
                                template: template,
                                startTurn: evaluation.currentTurn,
                            });
                            modifiersForPlayer.push(modifier);
                            modifiersAdded[template.type] = modifier;
                        }
                    }
                }
                if (modifier) {
                    modifier.updateWithEvaluation(evaluation);
                }
            }
        };
        DiplomacyStatus.prototype.serialize = function () {
            var attitudeModifiersByPlayer = {};
            this.attitudeModifiersByPlayer.forEach(function (player, modifiers) {
                attitudeModifiersByPlayer[player.id] = modifiers.map(function (modifier) { return modifier.serialize(); });
            });
            var data = {
                statusByPlayer: this.statusByPlayer.toObject(),
                attitudeModifiersByPlayer: attitudeModifiersByPlayer,
            };
            return data;
        };
        DiplomacyStatus.prototype.addEventListeners = function () {
            for (var key in activeModuleData_3.activeModuleData.Templates.AttitudeModifiers) {
                var template = activeModuleData_3.activeModuleData.Templates.AttitudeModifiers[key];
                if (template.triggers) {
                    for (var i = 0; i < template.triggers.length; i++) {
                        var listenerKey = template.triggers[i];
                        var listener = eventManager_1.default.addEventListener(listenerKey, this.triggerAttitudeModifier.bind(this, template));
                        if (!this.listeners[listenerKey]) {
                            this.listeners[listenerKey] = [];
                        }
                        this.listeners[listenerKey].push(listener);
                    }
                }
            }
        };
        DiplomacyStatus.prototype.getModifierOfSameType = function (player, modifier) {
            var modifiers = this.attitudeModifiersByPlayer.get(player);
            for (var i = 0; i < modifiers.length; i++) {
                if (modifiers[i].template.type === modifier.template.type) {
                    return modifiers[i];
                }
            }
            return null;
        };
        DiplomacyStatus.prototype.triggerAttitudeModifier = function (template, player, source) {
            if (player !== this.player) {
                return;
            }
            var modifier = new AttitudeModifier_1.AttitudeModifier({
                template: template,
                startTurn: App_1.default.game.turnNumber,
            });
            this.addAttitudeModifier(source, modifier);
        };
        DiplomacyStatus.prototype.triggerMeetingWithPlayer = function (player) {
            this.statusByPlayer.set(player, DiplomacyState_1.default.ColdWar);
        };
        return DiplomacyStatus;
    }());
    exports.default = DiplomacyStatus;
});
define("src/Color", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Color = (function () {
        function Color(r, g, b) {
            this.r = r;
            this.g = g;
            this.b = b;
        }
        Color.fromHex = function (hex) {
            return new Color((hex >> 16 & 0xFF) / 255, (hex >> 8 & 0xFF) / 255, (hex & 0xFF) / 255);
        };
        Color.fromHexString = function (hexString) {
            var hexDigits;
            if (hexString.charAt(0) === "#") {
                hexDigits = hexString.substring(1, 7);
            }
            else {
                hexDigits = hexString;
            }
            return Color.fromHex(parseInt(hexDigits, 16));
        };
        Color.fromHSV = function (h, s, v) {
            var r, g, b, i, f, p, q, t;
            i = Math.floor(h * 6);
            f = h * 6 - i;
            p = v * (1 - s);
            q = v * (1 - f * s);
            t = v * (1 - (1 - f) * s);
            switch (i % 6) {
                case 0:
                    r = v, g = t, b = p;
                    break;
                case 1:
                    r = q, g = v, b = p;
                    break;
                case 2:
                    r = p, g = v, b = t;
                    break;
                case 3:
                    r = p, g = q, b = v;
                    break;
                case 4:
                    r = t, g = p, b = v;
                    break;
                case 5:
                    r = v, g = p, b = q;
                    break;
            }
            return new Color(r, g, b);
        };
        Color.fromHSL = function (h, s, l) {
            var r, g, b;
            function hue2rgb(p, q, t) {
                if (t < 0)
                    t += 1;
                if (t > 1)
                    t -= 1;
                if (t < 1 / 6)
                    return p + (q - p) * 6 * t;
                if (t < 1 / 2)
                    return q;
                if (t < 2 / 3)
                    return p + (q - p) * (2 / 3 - t) * 6;
                return p;
            }
            if (s == 0) {
                r = g = b = l;
            }
            else {
                var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                var p = 2 * l - q;
                r = hue2rgb(p, q, h + 1 / 3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1 / 3);
            }
            return new Color(r, g, b);
        };
        Color.fromHUSL = function (h, s, l) {
            var RGB = HUSL.toRGB(h * 360, s * 100, l * 100);
            return new Color(RGB[0], RGB[1], RGB[2]);
        };
        Color.convertScalarsToDegrees = function (s) {
            return [s[0] * 360, s[1] * 100, s[2] * 100];
        };
        Color.convertDegreesToScalars = function (d) {
            return [d[0] / 360, d[1] / 100, d[2] / 100];
        };
        Color.prototype.getRGB = function () {
            return [this.r, this.g, this.b];
        };
        Color.prototype.getRGBA = function (alpha) {
            return [this.r, this.g, this.b, alpha];
        };
        Color.prototype.get8BitRGB = function () {
            return this.getRGB().map(function (x) { return x * 255; });
        };
        Color.prototype.getHex = function () {
            return (this.r * 255 << 16) + (this.g * 255 << 8) + this.b * 255;
        };
        Color.prototype.getHexString = function () {
            var hex = Math.round(this.getHex());
            var converted = hex.toString(16);
            return "000000".substr(0, 6 - converted.length) + converted;
        };
        Color.prototype.getHUSL = function () {
            var husl = HUSL.fromRGB(this.r, this.g, this.b);
            return [husl[0] / 360, husl[1] / 100, husl[2] / 100];
        };
        Color.prototype.getHSV = function () {
            var r = this.r;
            var g = this.g;
            var b = this.b;
            var max = Math.max(r, g, b), min = Math.min(r, g, b);
            var h, s, v = max;
            var d = max - min;
            s = max == 0 ? 0 : d / max;
            if (max == min) {
                h = 0;
            }
            else {
                switch (max) {
                    case r:
                        h = (g - b) / d + (g < b ? 6 : 0);
                        break;
                    case g:
                        h = (b - r) / d + 2;
                        break;
                    case b:
                        h = (r - g) / d + 4;
                        break;
                }
                h /= 6;
            }
            return [h, s, v];
        };
        Color.prototype.saturate = function (amount) {
            var husl = this.getHUSL();
            husl[1] += amount;
            return Color.fromHUSL.apply(null, husl);
        };
        Color.prototype.serialize = function () {
            return this.getRGB();
        };
        Color.deSerialize = function (saveData) {
            if (!saveData) {
                return undefined;
            }
            return new Color(saveData[0], saveData[1], saveData[2]);
        };
        Color.prototype.clone = function () {
            return Color.deSerialize(this.serialize());
        };
        return Color;
    }());
    exports.default = Color;
});
define("src/Range", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("src/rangeOperations", ["require", "exports", "src/utility"], function (require, exports, utility_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function excludeFromRanges(ranges, toExclude) {
        var intersecting = getIntersectingRanges(ranges, toExclude);
        var newRanges = ranges.slice(0);
        for (var i = 0; i < intersecting.length; i++) {
            newRanges.splice(newRanges.indexOf(intersecting[i]), 1);
            var intersectedRanges = excludeFromRange(intersecting[i], toExclude);
            if (intersectedRanges) {
                newRanges = newRanges.concat(intersectedRanges);
            }
        }
        return newRanges;
    }
    exports.excludeFromRanges = excludeFromRanges;
    function getIntersectingRanges(ranges, toIntersectWith) {
        var intersecting = [];
        for (var i = 0; i < ranges.length; i++) {
            var range = ranges[i];
            if (toIntersectWith.max < range.min || toIntersectWith.min > range.max) {
                continue;
            }
            intersecting.push(range);
        }
        return intersecting;
    }
    exports.getIntersectingRanges = getIntersectingRanges;
    function rangesHaveOverlap() {
        var ranges = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            ranges[_i] = arguments[_i];
        }
        var sorted = ranges.sort(function (a, b) {
            return a.min - b.min;
        });
        for (var i = 0; i < sorted.length - 1; i++) {
            if (sorted[i].max > sorted[i + 1].min) {
                return true;
            }
        }
        return false;
    }
    exports.rangesHaveOverlap = rangesHaveOverlap;
    function excludeFromRange(range, toExclude) {
        if (toExclude.max < range.min || toExclude.min > range.max) {
            return null;
        }
        else if (toExclude.min < range.min && toExclude.max > range.max) {
            return null;
        }
        if (toExclude.min <= range.min) {
            return ([{ min: toExclude.max, max: range.max }]);
        }
        else if (toExclude.max >= range.max) {
            return ([{ min: range.min, max: toExclude.min }]);
        }
        return ([
            {
                min: range.min,
                max: toExclude.min,
            },
            {
                min: toExclude.max,
                max: range.max,
            },
        ]);
    }
    exports.excludeFromRange = excludeFromRange;
    function randomSelectFromRanges(ranges) {
        var totalWeight = 0;
        var currentRelativeWeight = 0;
        var rangesByRelativeWeight = {};
        for (var i = 0; i < ranges.length; i++) {
            var range = ranges[i];
            if (!isFinite(range.max))
                range.max = 1;
            if (!isFinite(range.min))
                range.min = 0;
            var weight = range.max - range.min;
            totalWeight += weight;
        }
        for (var i = 0; i < ranges.length; i++) {
            var range = ranges[i];
            var relativeWeight = (range.max - range.min) / totalWeight;
            if (totalWeight === 0)
                relativeWeight = 1;
            currentRelativeWeight += relativeWeight;
            rangesByRelativeWeight[currentRelativeWeight] = range;
        }
        var rand = Math.random();
        var sortedWeights = Object.keys(rangesByRelativeWeight).map(function (w) {
            return parseFloat(w);
        }).sort();
        for (var i = 0; i < sortedWeights.length; i++) {
            if (rand < sortedWeights[i]) {
                var selectedRange = rangesByRelativeWeight[sortedWeights[i]];
                return utility_5.randRange(selectedRange.min, selectedRange.max);
            }
        }
        throw new Error("Couldn't select from ranges.");
    }
    exports.randomSelectFromRanges = randomSelectFromRanges;
});
define("src/colorGeneration", ["require", "exports", "src/Color", "src/rangeOperations", "src/utility"], function (require, exports, Color_1, rangeOperations_1, utility_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeRandomVibrantColor() {
        var hRanges = [
            { min: 0, max: 90 / 360 },
            { min: 120 / 360, max: 150 / 360 },
            { min: 180 / 360, max: 290 / 360 },
            { min: 320 / 360, max: 1 },
        ];
        var h = rangeOperations_1.randomSelectFromRanges(hRanges);
        var s = utility_6.randRange(0.8, 0.9);
        var v = utility_6.randRange(0.88, 0.92);
        return Color_1.default.fromHSV(h, s, v);
    }
    function makeRandomDeepColor() {
        var randomValue = Math.random();
        if (randomValue < 0.88) {
            var hRanges = [
                { min: 0 / 360, max: 30 / 360 },
                { min: 100 / 360, max: 360 / 360 },
            ];
            var h = rangeOperations_1.randomSelectFromRanges(hRanges);
            var s = utility_6.randRange(0.9, 1.0);
            var v = utility_6.randRange(0.6, 0.75);
            return Color_1.default.fromHSV(h, s, v);
        }
        else if (randomValue < 0.96) {
            return makeRandomColor({
                h: [{ min: 46 / 360, max: 60 / 360 }],
                s: [{ min: 1, max: 1 }],
                l: [{ min: 0.72, max: 0.8 }],
            });
        }
        else {
            return makeRandomColor({
                h: [{ min: 15 / 360, max: 80 / 360 }],
                s: [{ min: 1, max: 1 }],
                l: [{ min: 0.45, max: 0.55 }],
            });
        }
    }
    function makeRandomLightVibrantColor() {
        return Color_1.default.fromHSV(utility_6.randRange(0, 1), utility_6.randRange(0.55, 0.65), 1);
    }
    function makeRandomPastelColor() {
        return makeRandomColor({
            s: [{ min: 0.4, max: 0.6 }],
            l: [{ min: 0.88, max: 1 }],
        });
    }
    function makeRandomColor(props) {
        var hRanges = props.h || [{ min: 0, max: 1 }];
        var sRanges = props.s || [{ min: 0, max: 1 }];
        var lRanges = props.l || [{ min: 0, max: 1 }];
        var h = rangeOperations_1.randomSelectFromRanges(hRanges);
        var s = rangeOperations_1.randomSelectFromRanges(sRanges);
        var l = rangeOperations_1.randomSelectFromRanges(lRanges);
        return Color_1.default.fromHUSL(h, s, l);
    }
    function generateMainColor() {
        var randomValue = Math.random();
        if (randomValue < 0.6) {
            return makeRandomDeepColor();
        }
        else if (randomValue < 0.725) {
            return makeRandomVibrantColor();
        }
        else if (randomValue < 0.85) {
            return makeRandomLightVibrantColor();
        }
        else {
            return makeRandomPastelColor();
        }
    }
    exports.generateMainColor = generateMainColor;
    function makeContrastingColor(toContrastWith, colorGenProps) {
        var props = colorGenProps || {};
        var initialRanges = props.initialRanges || {};
        var hRange = initialRanges.h || { min: 0.0, max: 1.0 };
        var sRange = initialRanges.s || { min: 0.5, max: 1.0 };
        var lRange = initialRanges.l || { min: 0.0, max: 1.0 };
        var minDifference = props.minDifference || {};
        var hMinDifference = isFinite(minDifference.h) ? minDifference.h : 0.1;
        var sMinDifference = isFinite(minDifference.s) ? minDifference.s : 0.0;
        var lMinDifference = isFinite(minDifference.l) ? minDifference.l : 0.3;
        var maxDifference = props.maxDifference || {};
        var hMaxDifference = isFinite(maxDifference.h) ? maxDifference.h : 1.0;
        var toContrastWithHUSL = toContrastWith.getHUSL();
        var hExclusionRange = {
            min: (toContrastWithHUSL[0] - hMinDifference) % 1.0,
            max: (toContrastWithHUSL[0] + hMinDifference) % 1.0,
        };
        var hRangeWithMinExclusion = rangeOperations_1.excludeFromRange(hRange, hExclusionRange);
        var candidateHValue = rangeOperations_1.randomSelectFromRanges(hRangeWithMinExclusion);
        var h = utility_6.clamp(candidateHValue, toContrastWithHUSL[0] - hMaxDifference, toContrastWithHUSL[0] + hMaxDifference);
        var sExclusionRangeMin = utility_6.clamp(toContrastWithHUSL[1] - sMinDifference, sRange.min, 1.0);
        var sExclusionRange = {
            min: sExclusionRangeMin,
            max: utility_6.clamp(toContrastWithHUSL[1] + sMinDifference, sExclusionRangeMin, 1.0),
        };
        var lExclusionRangeMin = utility_6.clamp(toContrastWithHUSL[2] - lMinDifference, lRange.min, 1.0);
        var lExclusionRange = {
            min: lExclusionRangeMin,
            max: utility_6.clamp(toContrastWithHUSL[2] + lMinDifference, lExclusionRangeMin, 1.0),
        };
        return makeRandomColor({
            h: [{ min: h, max: h }],
            s: rangeOperations_1.excludeFromRange(sRange, sExclusionRange),
            l: rangeOperations_1.excludeFromRange(lRange, lExclusionRange),
        });
    }
    function generateSecondaryColor(mainColor) {
        return makeContrastingColor(mainColor, {
            minDifference: {
                h: 0.1,
                l: 0.3,
            },
        });
    }
    exports.generateSecondaryColor = generateSecondaryColor;
    function generateColorScheme(mainColor) {
        var main = mainColor || generateMainColor();
        return ({
            main: main,
            secondary: generateSecondaryColor(main),
        });
    }
    exports.generateColorScheme = generateColorScheme;
});
define("src/Emblem", ["require", "exports", "src/App", "src/activeModuleData", "src/colorGeneration", "src/utility"], function (require, exports, App_2, activeModuleData_4, colorGeneration_1, utility_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Emblem = (function () {
        function Emblem(colors, template, alpha) {
            if (alpha === void 0) { alpha = 1; }
            this.colors = colors;
            this.alpha = alpha;
            this.template = template;
        }
        Emblem.generateRandom = function (backgroundColor, colors, minAlpha, seed) {
            if (colors === void 0) { colors = []; }
            if (minAlpha === void 0) { minAlpha = 1; }
            var _rng = new RNG(seed);
            var templates = Emblem.getAvailableTemplatesForRandomGeneration();
            var template = utility_7.getSeededRandomArrayItem(templates, _rng);
            var _colors;
            if (template.generateColors) {
                _colors = template.generateColors(backgroundColor, colors);
            }
            else {
                if (colors.length > 0) {
                    _colors = colors.slice(0);
                }
                else {
                    if (backgroundColor) {
                        _colors = [colorGeneration_1.generateSecondaryColor(backgroundColor)];
                    }
                    else {
                        _colors = [colorGeneration_1.generateMainColor()];
                    }
                }
            }
            var alpha = utility_7.randRange(minAlpha, 1);
            return new Emblem(_colors, template, alpha);
        };
        Emblem.getAvailableTemplatesForRandomGeneration = function () {
            return Object.keys(activeModuleData_4.activeModuleData.Templates.SubEmblems).map(function (key) {
                return activeModuleData_4.activeModuleData.Templates.SubEmblems[key];
            }).filter(function (template) {
                return !template.disallowRandomGeneration;
            });
        };
        Emblem.prototype.isDrawable = function () {
            var amountOfColorsIsWithinRange = this.colors.length > 0;
            return this.alpha > 0 && amountOfColorsIsWithinRange;
        };
        Emblem.prototype.draw = function (maxWidth, maxHeight, stretch) {
            var image = App_2.default.images[this.template.src];
            var width = image.width;
            var height = image.height;
            if (stretch) {
                var widthRatio = width / maxWidth;
                var heightRatio = height / maxHeight;
                var largestRatio = Math.max(widthRatio, heightRatio);
                width /= largestRatio;
                height /= largestRatio;
            }
            else {
                width = Math.min(width, maxWidth);
                height = Math.max(height, maxHeight);
            }
            var canvas = document.createElement("canvas");
            canvas.width = width;
            canvas.height = height;
            var ctx = canvas.getContext("2d");
            ctx.drawImage(image, 0, 0, width, height);
            ctx.globalCompositeOperation = "source-in";
            ctx.fillStyle = "#" + this.colors[0].getHexString();
            ctx.fillRect(0, 0, width, height);
            return canvas;
        };
        Emblem.prototype.serialize = function () {
            var data = {
                alpha: this.alpha,
                colors: this.colors.map(function (color) { return color.serialize(); }),
                templateKey: this.template.key,
            };
            return data;
        };
        return Emblem;
    }());
    exports.default = Emblem;
});
define("src/Flag", ["require", "exports", "src/Emblem", "src/colorGeneration", "src/utility"], function (require, exports, Emblem_1, colorGeneration_2, utility_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Flag = (function () {
        function Flag(backgroundColor, emblems) {
            var _this = this;
            this.emblems = [];
            this.cachedCanvases = {};
            this.backgroundColor = backgroundColor;
            if (emblems) {
                emblems.forEach(function (emblem) { return _this.addEmblem(emblem); });
            }
        }
        Flag.generateRandom = function (backgroundColor, secondaryColor, seed) {
            if (backgroundColor === void 0) { backgroundColor = colorGeneration_2.generateMainColor(); }
            if (secondaryColor === void 0) { secondaryColor = colorGeneration_2.generateSecondaryColor(backgroundColor); }
            var flag = new Flag(backgroundColor);
            flag.seed = seed;
            flag.addRandomEmblem(secondaryColor, seed);
            return flag;
        };
        Flag.prototype.generateRandomEmblem = function (secondaryColor, seed) {
            return Emblem_1.default.generateRandom(this.backgroundColor, [secondaryColor], 1, seed);
        };
        Flag.prototype.addRandomEmblem = function (secondaryColor, seed) {
            this.addEmblem(this.generateRandomEmblem(secondaryColor, seed));
        };
        Flag.prototype.addEmblem = function (emblem) {
            this.emblems.push(emblem);
        };
        Flag.prototype.setCustomImage = function (imageData) {
        };
        Flag.prototype.getCanvas = function (width, height, stretch, useCache) {
            if (stretch === void 0) { stretch = true; }
            if (useCache === void 0) { useCache = true; }
            if (useCache) {
                var sizeString = "" + width + "," + height + stretch;
                if (!this.cachedCanvases[sizeString]) {
                    var canvas_1 = this.draw(width, height, stretch);
                    this.cachedCanvases[sizeString] = canvas_1;
                }
                var cachedCanvas = this.cachedCanvases[sizeString];
                var canvas = utility_8.drawElementToCanvas(cachedCanvas);
                return canvas;
            }
            else {
                var canvas = this.draw(width, height, stretch);
                return canvas;
            }
        };
        Flag.prototype.isDrawable = function () {
            return true;
        };
        Flag.prototype.serialize = function () {
            var data = {
                mainColor: this.backgroundColor.serialize(),
                emblems: this.emblems.map(function (emblem) { return emblem.serialize(); }),
            };
            return data;
        };
        Flag.prototype.draw = function (width, height, stretch) {
            if (stretch === void 0) { stretch = true; }
            var canvas = document.createElement("canvas");
            canvas.width = width;
            canvas.height = height;
            var ctx = canvas.getContext("2d");
            ctx.globalCompositeOperation = "source-over";
            if (this.backgroundColor) {
                ctx.fillStyle = "#" + this.backgroundColor.getHexString();
                ctx.fillRect(0, 0, width, height);
            }
            this.emblems.forEach(function (emblem) {
                if (emblem.isDrawable()) {
                    var foreground = emblem.draw(width, height, stretch);
                    var x = (width - foreground.width) / 2;
                    var y = (height - foreground.height) / 2;
                    ctx.drawImage(foreground, x, y);
                }
            });
            return canvas;
        };
        return Flag;
    }());
    exports.Flag = Flag;
});
define("src/Name", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Name = (function () {
        function Name(fullName, isPlural) {
            if (isPlural === void 0) { isPlural = false; }
            this.isPlural = false;
            this.hasBeenCustomized = false;
            this.fullName = fullName;
            this.isPlural = isPlural;
        }
        Name.fromData = function (data) {
            var name = new Name(data.fullName, data.isPlural);
            name.hasBeenCustomized = data.hasBeenCustomized;
            return name;
        };
        Name.prototype.setName = function (name, isPlural) {
            if (isPlural === void 0) { isPlural = false; }
            this.fullName = name;
            this.isPlural = isPlural;
        };
        Name.prototype.customizeName = function (name, isPlural) {
            if (isPlural === void 0) { isPlural = false; }
            this.hasBeenCustomized = true;
            this.setName(name, isPlural);
        };
        Name.prototype.toString = function () {
            return this.fullName;
        };
        Name.prototype.getPossessive = function () {
            var standard = this.toString();
            var lastChar = standard[standard.length - 1];
            if (lastChar.toLocaleLowerCase() === "s") {
                return standard + "'";
            }
            else {
                return standard + "'s";
            }
        };
        Name.prototype.pluralizeVerb = function (singularVerb, pluralVerb) {
            if (this.isPlural) {
                return pluralVerb;
            }
            else {
                return singularVerb;
            }
        };
        Name.prototype.pluralizeVerbWithS = function (sourceVerb) {
            if (sourceVerb.charAt(sourceVerb.length - 1) === "s") {
                return this.pluralizeVerb(sourceVerb + "s", sourceVerb);
            }
            else {
                return this.pluralizeVerb(sourceVerb, sourceVerb + "s");
            }
        };
        Name.prototype.serialize = function () {
            return ({
                fullName: this.fullName,
                isPlural: this.isPlural,
                hasBeenCustomized: this.hasBeenCustomized,
            });
        };
        return Name;
    }());
    exports.default = Name;
});
define("src/PriorityQueue", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PriorityQueue = (function () {
        function PriorityQueue() {
            this.items = {};
        }
        PriorityQueue.prototype.isEmpty = function () {
            if (Object.keys(this.items).length > 0)
                return false;
            else
                return true;
        };
        PriorityQueue.prototype.push = function (priority, data) {
            if (!this.items[priority]) {
                this.items[priority] = [];
            }
            this.items[priority].push(data);
        };
        PriorityQueue.prototype.pop = function () {
            var highestPriority = Math.min.apply(null, Object.keys(this.items));
            var toReturn = this.items[highestPriority].pop();
            if (this.items[highestPriority].length < 1) {
                delete this.items[highestPriority];
            }
            return toReturn;
        };
        PriorityQueue.prototype.peek = function () {
            var highestPriority = Math.min.apply(null, Object.keys(this.items));
            var toReturn = this.items[highestPriority][0];
            return [highestPriority, toReturn.mapPosition[1], toReturn.mapPosition[2]];
        };
        return PriorityQueue;
    }());
    exports.default = PriorityQueue;
});
define("src/pathFinding", ["require", "exports", "src/PriorityQueue"], function (require, exports, PriorityQueue_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function backTrace(graph, target) {
        var parent = graph[target.id];
        if (!parent)
            return [];
        var path = [
            {
                star: target,
                cost: parent.cost,
            },
        ];
        while (parent) {
            path.push({
                star: parent.star,
                cost: parent.cost,
            });
            parent = graph[parent.star.id];
        }
        path.reverse();
        path[0].cost = null;
        return path;
    }
    exports.backTrace = backTrace;
    function aStar(start, target) {
        var frontier = new PriorityQueue_1.default();
        frontier.push(0, start);
        var cameFrom = {};
        var costSoFar = {};
        cameFrom[start.id] = null;
        costSoFar[start.id] = 0;
        while (!frontier.isEmpty()) {
            var current = frontier.pop();
            if (current === target) {
                return { came: cameFrom, cost: costSoFar };
            }
            var neighbors = current.getAllLinks();
            for (var i = 0; i < neighbors.length; i++) {
                var neigh = neighbors[i];
                if (!neigh)
                    continue;
                var moveCost = 1;
                var newCost = costSoFar[current.id] + moveCost;
                if (costSoFar[neigh.id] === undefined || newCost < costSoFar[neigh.id]) {
                    costSoFar[neigh.id] = newCost;
                    var priority = newCost;
                    frontier.push(priority, neigh);
                    cameFrom[neigh.id] =
                        {
                            star: current,
                            cost: moveCost,
                        };
                }
            }
        }
        return null;
    }
    exports.aStar = aStar;
});
define("src/Fleet", ["require", "exports", "src/App", "src/Name", "src/eventManager", "src/idGenerators", "src/pathFinding"], function (require, exports, App_3, Name_1, eventManager_2, idGenerators_2, pathFinding_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Fleet = (function () {
        function Fleet(units, id) {
            var _this = this;
            this.units = [];
            this.visionIsDirty = true;
            this.visibleStars = [];
            this.detectedStars = [];
            this.id = isFinite(id) ? id : idGenerators_2.default.fleet++;
            this.name = new Name_1.default("Fleet " + this.id);
            units.forEach(function (unitToAdd) {
                _this.addUnit(unitToAdd);
            });
            eventManager_2.default.dispatchEvent("renderLayer", "fleets", this.location);
        }
        Fleet.createFleetsFromUnits = function (units) {
            var stealthyUnits = units.filter(function (unit) { return unit.isStealthy(); });
            var nonStealthyUnits = units.filter(function (unit) { return !unit.isStealthy(); });
            var fleets = [stealthyUnits, nonStealthyUnits].filter(function (unitsInGroup) {
                return unitsInGroup.length > 0;
            }).map(function (unitsInGroup) {
                return new Fleet(unitsInGroup);
            });
            return fleets;
        };
        Fleet.createFleet = function (units, id) {
            return new Fleet(units, id);
        };
        Fleet.sortByImportance = function (a, b) {
            var customNameSort = Number(b.name.hasBeenCustomized) - Number(a.name.hasBeenCustomized);
            if (customNameSort) {
                return customNameSort;
            }
            var unitCountSort = b.units.length - a.units.length;
            if (unitCountSort) {
                return unitCountSort;
            }
            return a.id - b.id;
        };
        Fleet.makeAlreadyInFleetError = function (unit) {
            return new Error("Unit " + unit.name + " is already part of fleet " + unit.fleet.name.toString());
        };
        Fleet.makeNotInFleetError = function (unit, fleet) {
            return new Error("Unit " + unit.name + " is not part of fleet " + fleet.name.toString());
        };
        Fleet.prototype.deleteFleet = function (shouldRender) {
            if (shouldRender === void 0) { shouldRender = true; }
            this.location.removeFleet(this);
            this.player.removeFleet(this);
            if (shouldRender) {
                eventManager_2.default.dispatchEvent("renderLayer", "fleets", this.location);
            }
        };
        Fleet.prototype.mergeWith = function (fleetToMergeWith, shouldRender) {
            if (shouldRender === void 0) { shouldRender = true; }
            if (fleetToMergeWith.isStealthy !== this.isStealthy) {
                throw new Error("Tried to merge stealthy fleet with non stealthy or other way around");
            }
            for (var i = this.units.length - 1; i >= 0; i--) {
                var unit = this.units[i];
                this.transferUnit(fleetToMergeWith, unit);
            }
            this.deleteFleet();
        };
        Fleet.prototype.addUnit = function (unit) {
            if (unit.fleet) {
                throw Fleet.makeAlreadyInFleetError(unit);
            }
            if (this.units.length === 0) {
                this.isStealthy = unit.isStealthy();
            }
            else if (unit.isStealthy() !== this.isStealthy) {
                throw new Error("Tried to add stealthy unit to non stealthy fleet or other way around");
            }
            this.units.push(unit);
            unit.fleet = this;
            this.visionIsDirty = true;
        };
        Fleet.prototype.removeUnit = function (unit) {
            var index = this.units.indexOf(unit);
            if (index < 0) {
                throw Fleet.makeNotInFleetError(unit, this);
            }
            this.units.splice(index, 1);
            unit.fleet = null;
            this.visionIsDirty = true;
        };
        Fleet.prototype.transferUnit = function (receivingFleet, unitToTransfer, shouldRender) {
            if (shouldRender === void 0) { shouldRender = true; }
            if (receivingFleet === this) {
                throw new Error("Tried to transfer unit into unit's current fleet");
            }
            this.removeUnit(unitToTransfer);
            receivingFleet.addUnit(unitToTransfer);
            if (shouldRender) {
                eventManager_2.default.dispatchEvent("renderLayer", "fleets", this.location);
            }
        };
        Fleet.prototype.split = function () {
            var newFleet = new Fleet([]);
            this.player.addFleet(newFleet);
            this.location.addFleet(newFleet);
            return newFleet;
        };
        Fleet.prototype.getMinCurrentMovePoints = function () {
            return this.units.map(function (unit) {
                return unit.currentMovePoints;
            }).reduce(function (minMovePoints, currentUnitMovePoints) {
                return Math.min(minMovePoints, currentUnitMovePoints);
            }, Infinity);
        };
        Fleet.prototype.getMinMaxMovePoints = function () {
            return this.units.map(function (unit) {
                return unit.maxMovePoints;
            }).reduce(function (minMovePoints, currentUnitMovePoints) {
                return Math.min(minMovePoints, currentUnitMovePoints);
            }, Infinity);
        };
        Fleet.prototype.hasEnoughMovePointsToMoveTo = function (target) {
            return this.getMinCurrentMovePoints() >= this.location.getDistanceToStar(target);
        };
        Fleet.prototype.getPathTo = function (newLocation) {
            var a = pathFinding_1.aStar(this.location, newLocation);
            if (!a) {
                throw new Error("Couldn't find path between " + this.location.name + " and " + newLocation.name);
            }
            var path = pathFinding_1.backTrace(a.came, newLocation);
            return path;
        };
        Fleet.prototype.pathFind = function (newLocation, onMove, afterMove) {
            var _this = this;
            var path = this.getPathTo(newLocation);
            var interval = window.setInterval(function () {
                if (!path || path.length <= 0) {
                    window.clearInterval(interval);
                    if (afterMove) {
                        afterMove();
                    }
                    return;
                }
                var move = path.shift();
                _this.move(move.star);
                if (onMove) {
                    onMove();
                }
            }, 10);
        };
        Fleet.prototype.getTotalCurrentHealth = function () {
            return this.units.map(function (unit) {
                return unit.currentHealth;
            }).reduce(function (total, current) {
                return total + current;
            }, 0);
        };
        Fleet.prototype.getTotalMaxHealth = function () {
            return this.units.map(function (unit) {
                return unit.maxHealth;
            }).reduce(function (total, current) {
                return total + current;
            }, 0);
        };
        Fleet.prototype.getVisibleStars = function () {
            if (this.visionIsDirty) {
                this.updateVisibleStars();
            }
            return this.visibleStars;
        };
        Fleet.prototype.getDetectedStars = function () {
            if (this.visionIsDirty) {
                this.updateVisibleStars();
            }
            return this.detectedStars;
        };
        Fleet.prototype.serialize = function () {
            var data = {
                id: this.id,
                name: this.name.serialize(),
                locationId: this.location.id,
                playerId: this.player.id,
                unitIds: this.units.map(function (unit) { return unit.id; }),
            };
            return data;
        };
        Fleet.prototype.canMove = function () {
            return this.units.every(function (unit) { return unit.currentMovePoints > 0; });
        };
        Fleet.prototype.move = function (newLocation) {
            var _this = this;
            if (newLocation === this.location) {
                return;
            }
            if (!this.canMove()) {
                return;
            }
            var oldLocation = this.location;
            oldLocation.removeFleet(this);
            this.location = newLocation;
            newLocation.addFleet(this);
            this.units.forEach(function (unit) { return unit.currentMovePoints -= 1; });
            this.visionIsDirty = true;
            this.player.visionIsDirty = true;
            App_3.default.game.getLiveMajorPlayers().forEach(function (player) {
                if (player !== _this.player) {
                    player.updateAllVisibilityInStar(newLocation);
                }
            });
            eventManager_2.default.dispatchEvent("renderLayer", "fleets", this.location);
            eventManager_2.default.dispatchEvent("updateSelection", null);
        };
        Fleet.prototype.updateVisibleStars = function () {
            var highestVisionRange = 0;
            var highestDetectionRange = -1;
            for (var i = 0; i < this.units.length; i++) {
                highestVisionRange = Math.max(this.units[i].getVisionRange(), highestVisionRange);
                highestDetectionRange = Math.max(this.units[i].getDetectionRange(), highestDetectionRange);
            }
            var inVision = this.location.getLinkedInRange(highestVisionRange);
            var inDetection = this.location.getLinkedInRange(highestDetectionRange);
            this.visibleStars = inVision.all;
            this.detectedStars = inDetection.all;
            this.visionIsDirty = false;
        };
        return Fleet;
    }());
    exports.Fleet = Fleet;
});
define("src/Item", ["require", "exports", "src/idGenerators"], function (require, exports, idGenerators_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Item = (function () {
        function Item(template, id) {
            this.id = isFinite(id) ? id : idGenerators_3.default.item++;
            this.template = template;
        }
        Item.prototype.serialize = function () {
            var data = {
                id: this.id,
                templateType: this.template.type,
            };
            if (this.unit) {
                data.positionInUnit = this.positionInUnit;
            }
            return data;
        };
        return Item;
    }());
    exports.default = Item;
});
define("src/Manufactory", ["require", "exports", "src/activeModuleData", "src/Fleet", "src/Item", "src/Unit", "src/eventManager"], function (require, exports, activeModuleData_5, Fleet_1, Item_1, Unit_1, eventManager_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Manufactory = (function () {
        function Manufactory(star, serializedData) {
            this.buildQueue = [];
            this.unitStatsModifier = 1;
            this.unitHealthModifier = 1;
            this.star = star;
            this.player = star.owner;
            if (serializedData) {
                this.makeFromData(serializedData);
            }
            else {
                this.capacity = activeModuleData_5.activeModuleData.ruleSet.manufactory.startingCapacity;
                this.maxCapacity = activeModuleData_5.activeModuleData.ruleSet.manufactory.maxCapacity;
            }
        }
        Manufactory.getBuildCost = function () {
            return activeModuleData_5.activeModuleData.ruleSet.manufactory.buildCost;
        };
        Manufactory.prototype.makeFromData = function (data) {
            this.capacity = data.capacity;
            this.maxCapacity = data.maxCapacity;
            this.unitStatsModifier = data.unitStatsModifier;
            this.unitHealthModifier = data.unitHealthModifier;
            this.buildQueue = data.buildQueue.map(function (savedThing) {
                var templatesString;
                switch (savedThing.type) {
                    case "unit":
                        {
                            templatesString = "Units";
                            break;
                        }
                    case "item":
                        {
                            templatesString = "Items";
                        }
                }
                return ({
                    type: savedThing.type,
                    template: activeModuleData_5.activeModuleData.Templates[templatesString][savedThing.templateType],
                });
            });
        };
        Manufactory.prototype.queueIsFull = function () {
            return this.buildQueue.length >= this.capacity;
        };
        Manufactory.prototype.addThingToQueue = function (template, type) {
            this.buildQueue.push({ type: type, template: template });
            this.player.money -= template.buildCost;
        };
        Manufactory.prototype.removeThingAtIndex = function (index) {
            var template = this.buildQueue[index].template;
            this.player.money += template.buildCost;
            this.buildQueue.splice(index, 1);
        };
        Manufactory.prototype.buildAllThings = function () {
            var _this = this;
            var units = [];
            var toBuild = this.buildQueue.slice(0, this.capacity);
            this.buildQueue = this.buildQueue.slice(this.capacity);
            while (toBuild.length > 0) {
                var thingData = toBuild.pop();
                switch (thingData.type) {
                    case "unit":
                        {
                            var unitTemplate = thingData.template;
                            var unit = Unit_1.default.fromTemplate({
                                template: unitTemplate,
                                race: this.star.race,
                                attributeMultiplier: this.unitStatsModifier,
                                healthMultiplier: this.unitHealthModifier,
                            });
                            units.push(unit);
                            this.player.addUnit(unit);
                            break;
                        }
                    case "item":
                        {
                            var itemTemplate = thingData.template;
                            var item = new Item_1.default(itemTemplate);
                            this.player.addItem(item);
                            break;
                        }
                }
            }
            if (units.length > 0) {
                var fleets = Fleet_1.Fleet.createFleetsFromUnits(units);
                fleets.forEach(function (fleet) {
                    _this.player.addFleet(fleet);
                    _this.star.addFleet(fleet);
                });
            }
            if (!this.player.isAI) {
                eventManager_3.default.dispatchEvent("playerManufactoryBuiltThings");
            }
        };
        Manufactory.prototype.getLocalUnitTypes = function () {
            return this.star.race.getBuildableUnitTypes(this.player);
        };
        Manufactory.prototype.getLocalItemTypes = function () {
            return [];
        };
        Manufactory.prototype.getUniqueLocalUnitTypes = function (alreadyAdded) {
            if (alreadyAdded === void 0) { alreadyAdded = []; }
            return this.getUniqueLocalManufacturableThings(alreadyAdded, "unit");
        };
        Manufactory.prototype.getUniqueLocalItemTypes = function (alreadyAdded) {
            if (alreadyAdded === void 0) { alreadyAdded = []; }
            return this.getUniqueLocalManufacturableThings(alreadyAdded, "item");
        };
        Manufactory.prototype.getUniqueLocalManufacturableThings = function (alreadyAdded, type) {
            var alreadyAddedTypes = {};
            alreadyAdded.forEach(function (manufacturableThing) {
                alreadyAddedTypes[manufacturableThing.type] = true;
            });
            var localManufacturableThings = this.getManufacturableThingsForType(type);
            return localManufacturableThings.filter(function (manufacturableThing) {
                return !alreadyAddedTypes[manufacturableThing.type];
            });
        };
        Manufactory.prototype.getManufacturableThingsForType = function (type) {
            switch (type) {
                case "item":
                    {
                        return this.getLocalItemTypes();
                    }
                case "unit":
                    {
                        return this.getLocalUnitTypes();
                    }
            }
        };
        Manufactory.prototype.canManufactureThing = function (template, type) {
            var manufacturableThings = this.getManufacturableThingsForType(type);
            return manufacturableThings.indexOf(template) !== -1;
        };
        Manufactory.prototype.handleOwnerChange = function () {
            while (this.buildQueue.length > 0) {
                this.removeThingAtIndex(this.buildQueue.length - 1);
            }
            this.player = this.star.owner;
            this.capacity = Math.max(1, this.capacity - 1);
        };
        Manufactory.prototype.getCapacityUpgradeCost = function () {
            return activeModuleData_5.activeModuleData.ruleSet.manufactory.buildCost * this.capacity;
        };
        Manufactory.prototype.upgradeCapacity = function (amount) {
            this.player.money -= this.getCapacityUpgradeCost();
            this.capacity = Math.min(this.capacity + amount, this.maxCapacity);
        };
        Manufactory.prototype.getUnitUpgradeCost = function () {
            var totalUpgrades = (this.unitStatsModifier + this.unitHealthModifier - 2) / 0.1;
            return Math.round((totalUpgrades + 1) * 100);
        };
        Manufactory.prototype.upgradeUnitStatsModifier = function (amount) {
            this.player.money -= this.getUnitUpgradeCost();
            this.unitStatsModifier += amount;
        };
        Manufactory.prototype.upgradeUnitHealthModifier = function (amount) {
            this.player.money -= this.getUnitUpgradeCost();
            this.unitHealthModifier += amount;
        };
        Manufactory.prototype.serialize = function () {
            var buildQueue = this.buildQueue.map(function (thingData) {
                return ({
                    type: thingData.type,
                    templateType: thingData.template.type,
                });
            });
            return ({
                capacity: this.capacity,
                maxCapacity: this.maxCapacity,
                unitStatsModifier: this.unitStatsModifier,
                unitHealthModifier: this.unitHealthModifier,
                buildQueue: buildQueue,
            });
        };
        return Manufactory;
    }());
    exports.default = Manufactory;
});
define("src/Notification", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Notification = (function () {
        function Notification(args) {
            this.hasBeenRead = false;
            this.template = args.template;
            this.props = args.props;
            this.turn = args.turn;
            this.involvedPlayers = args.involvedPlayers;
            this.witnessingPlayers = args.witnessingPlayers;
        }
        Notification.prototype.makeMessage = function () {
            return this.template.messageConstructor(this.props);
        };
        Notification.prototype.getTitle = function () {
            return this.template.getTitle(this.props);
        };
        Notification.prototype.serialize = function () {
            var data = {
                templateKey: this.template.key,
                hasBeenRead: this.hasBeenRead,
                turn: this.turn,
                involvedPlayerIds: this.involvedPlayers.map(function (player) { return player.id; }),
                witnessingPlayerIds: this.witnessingPlayers.map(function (player) { return player.id; }),
                props: this.template.serializeProps(this.props),
            };
            return data;
        };
        return Notification;
    }());
    exports.default = Notification;
});
define("src/UnitBattleSide", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnitBattleSides = ["side1", "side2"];
});
define("src/GameLoader", ["require", "exports", "src/AIController", "src/activeModuleData", "src/activeNotificationLog", "src/AttitudeModifier", "src/Building", "src/Color", "src/Emblem", "src/FillerPoint", "src/Flag", "src/Fleet", "src/Game", "src/Item", "src/Manufactory", "src/MapGenResult", "src/Name", "src/Notification", "src/NotificationLog", "src/Player", "src/Star", "src/StatusEffect", "src/Unit"], function (require, exports, AIController_1, activeModuleData_6, activeNotificationLog_1, AttitudeModifier_2, Building_1, Color_2, Emblem_2, FillerPoint_1, Flag_1, Fleet_2, Game_1, Item_2, Manufactory_1, MapGenResult_1, Name_2, Notification_1, NotificationLog_1, Player_1, Star_1, StatusEffect_1, Unit_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var GameLoader = (function () {
        function GameLoader() {
            this.players = [];
            this.playersById = {};
            this.starsById = {};
            this.unitsById = {};
            this.buildingsByControllerId = {};
            this.itemsById = {};
        }
        GameLoader.prototype.deserializeGame = function (data) {
            var _this = this;
            this.map = this.deserializeMap(data.galaxyMap);
            data.items.forEach(function (itemSaveData) {
                _this.itemsById[itemSaveData.id] = _this.deserializeItem(itemSaveData);
            });
            data.units.forEach(function (unitSaveData) {
                _this.unitsById[unitSaveData.id] = _this.deserializeUnit(unitSaveData);
            });
            data.units.forEach(function (unitSaveData) {
                var unit = _this.unitsById[unitSaveData.id];
                unitSaveData.battleStats.statusEffects.forEach(function (statusEffectSaveData) {
                    unit.addStatusEffect(_this.deserializeStatusEffect(statusEffectSaveData));
                });
            });
            for (var i = 0; i < data.players.length; i++) {
                var playerData = data.players[i];
                var id = playerData.id;
                var player = this.playersById[id] = this.deserializePlayer(playerData);
                this.players.push(player);
            }
            this.deserializeBuildings(data.galaxyMap);
            var game = this.game = new Game_1.default(this.map, this.players);
            game.turnNumber = data.turnNumber;
            data.players.forEach(function (playerData) {
                var player = _this.playersById[playerData.id];
                if (player.diplomacyStatus && playerData.diplomacyStatus) {
                    _this.deserializeDiplomacyStatus(player, playerData.diplomacyStatus);
                }
            });
            if (data.notificationLog) {
                activeNotificationLog_1.setActiveNotificationLog(this.deserializeNotificationLog(data.notificationLog));
            }
            data.players.forEach(function (playerData) {
                var player = _this.playersById[playerData.id];
                if (playerData.AIController) {
                    player.AIController = _this.deserializeAIController(playerData.AIController, player, game);
                }
            });
            return game;
        };
        GameLoader.prototype.deserializeNotificationLog = function (data) {
            var _this = this;
            var notificationLog = new NotificationLog_1.default(this.game.getLiveMajorPlayers());
            data.notifications.forEach(function (notificationData) {
                var template = activeModuleData_6.activeModuleData.Templates.Notifications[notificationData.templateKey];
                var notification = new Notification_1.default({
                    template: activeModuleData_6.activeModuleData.Templates.Notifications[notificationData.templateKey],
                    props: template.deserializeProps(notificationData.props, _this),
                    turn: notificationData.turn,
                    involvedPlayers: notificationData.involvedPlayerIds.map(function (id) { return _this.playersById[id]; }),
                    witnessingPlayers: notificationData.witnessingPlayerIds.map(function (id) { return _this.playersById[id]; }),
                });
                notification.hasBeenRead = notificationData.hasBeenRead;
                notificationLog.notifications.push(notification);
            });
            return notificationLog;
        };
        GameLoader.prototype.deserializeMap = function (data) {
            var stars = [];
            for (var i = 0; i < data.stars.length; i++) {
                var star = this.deserializeStar(data.stars[i]);
                stars.push(star);
                this.starsById[star.id] = star;
            }
            for (var i = 0; i < data.stars.length; i++) {
                var dataStar = data.stars[i];
                var realStar = this.starsById[dataStar.id];
                for (var j = 0; j < dataStar.linksToIds.length; j++) {
                    var linkId = dataStar.linksToIds[j];
                    var linkStar = this.starsById[linkId];
                    realStar.addLink(linkStar);
                }
            }
            var fillerPoints = [];
            for (var i = 0; i < data.fillerPoints.length; i++) {
                var dataPoint = data.fillerPoints[i];
                fillerPoints.push(new FillerPoint_1.default(dataPoint.x, dataPoint.y));
            }
            var mapGenResult = new MapGenResult_1.default({
                stars: stars,
                fillerPoints: fillerPoints,
                width: data.width,
                height: data.height,
                seed: data.seed,
                independents: null,
            });
            var galaxyMap = mapGenResult.makeMap();
            return galaxyMap;
        };
        GameLoader.prototype.deserializeStar = function (data) {
            var star = new Star_1.default({
                x: data.x,
                y: data.y,
                id: data.id,
                name: data.name,
                race: activeModuleData_6.activeModuleData.Templates.Races[data.raceType],
            });
            star.baseIncome = data.baseIncome;
            star.seed = data.seed;
            if (data.resourceType) {
                star.setResource(activeModuleData_6.activeModuleData.Templates.Resources[data.resourceType]);
            }
            return star;
        };
        GameLoader.prototype.deserializeBuildings = function (data) {
            for (var i = 0; i < data.stars.length; i++) {
                var starData = data.stars[i];
                var star = this.starsById[starData.id];
                for (var category in starData.buildings) {
                    for (var j = 0; j < starData.buildings[category].length; j++) {
                        var buildingData = starData.buildings[category][j];
                        var building = this.deserializeBuilding(buildingData);
                        star.addBuilding(building);
                    }
                }
                if (starData.manufactory) {
                    star.manufactory = new Manufactory_1.default(star, starData.manufactory);
                }
            }
        };
        GameLoader.prototype.deserializeBuilding = function (data) {
            var template = activeModuleData_6.activeModuleData.Templates.Buildings[data.templateType];
            var building = new Building_1.default({
                template: template,
                location: this.starsById[data.locationId],
                controller: this.playersById[data.controllerId],
                upgradeLevel: data.upgradeLevel,
                totalCost: data.totalCost,
                id: data.id,
            });
            return building;
        };
        GameLoader.prototype.deserializePlayer = function (data) {
            var _this = this;
            var player = new Player_1.default({
                isAI: data.isAI,
                isIndependent: data.isIndependent,
                isDead: data.isDead,
                race: activeModuleData_6.activeModuleData.Templates.Races[data.raceKey],
                money: data.money,
                id: data.id,
                name: Name_2.default.fromData(data.name),
                color: {
                    main: Color_2.default.deSerialize(data.color),
                    secondary: Color_2.default.deSerialize(data.secondaryColor),
                    alpha: data.colorAlpha,
                },
                flag: this.deserializeFlag(data.flag),
                resources: data.resources,
            });
            data.unitIds.forEach(function (unitId) {
                player.addUnit(_this.unitsById[unitId]);
            });
            for (var i = 0; i < data.fleets.length; i++) {
                var fleet = data.fleets[i];
                player.addFleet(this.deserializeFleet(player, fleet));
            }
            for (var i = 0; i < data.controlledLocationIds.length; i++) {
                player.addStar(this.starsById[data.controlledLocationIds[i]]);
            }
            data.itemIds.forEach(function (itemId) {
                player.addItem(_this.itemsById[itemId]);
            });
            for (var i = 0; i < data.revealedStarIds.length; i++) {
                var id = data.revealedStarIds[i];
                player.revealedStars[id] = this.starsById[id];
            }
            data.identifiedUnitIds.forEach(function (unitId) {
                if (_this.unitsById[unitId]) {
                    player.identifyUnit(_this.unitsById[unitId]);
                }
            });
            return player;
        };
        GameLoader.prototype.deserializeDiplomacyStatus = function (player, data) {
            var _this = this;
            for (var playerId in data.statusByPlayer) {
                player.diplomacyStatus.statusByPlayer.set(this.playersById[playerId], data.statusByPlayer[playerId]);
            }
            for (var playerId in data.attitudeModifiersByPlayer) {
                var modifiers = data.attitudeModifiersByPlayer[playerId];
                modifiers.forEach(function (modifierData) {
                    var template = activeModuleData_6.activeModuleData.Templates.AttitudeModifiers[modifierData.templateType];
                    var modifier = new AttitudeModifier_2.AttitudeModifier({
                        template: template,
                        startTurn: modifierData.startTurn,
                        endTurn: modifierData.endTurn,
                        strength: modifierData.strength,
                    });
                    player.diplomacyStatus.addAttitudeModifier(_this.playersById[playerId], modifier);
                });
            }
        };
        GameLoader.prototype.deserializeEmblem = function (emblemData) {
            return new Emblem_2.default(emblemData.colors.map(function (colorData) { return Color_2.default.deSerialize(colorData); }), activeModuleData_6.activeModuleData.Templates.SubEmblems[emblemData.templateKey], emblemData.alpha);
        };
        GameLoader.prototype.deserializeFlag = function (data) {
            var _this = this;
            var emblems = data.emblems.map(function (emblemSaveData) {
                return _this.deserializeEmblem(emblemSaveData);
            });
            var flag = new Flag_1.Flag(Color_2.default.deSerialize(data.mainColor), emblems);
            return flag;
        };
        GameLoader.prototype.deserializeFleet = function (player, data) {
            var _this = this;
            var units = data.unitIds.map(function (unitId) { return _this.unitsById[unitId]; });
            var location = this.starsById[data.locationId];
            var fleet = Fleet_2.Fleet.createFleet(units, data.id);
            player.addFleet(fleet);
            location.addFleet(fleet);
            fleet.name = Name_2.default.fromData(data.name);
            return fleet;
        };
        GameLoader.prototype.deserializeUnit = function (data) {
            var _this = this;
            var unit = Unit_2.default.fromSaveData(data);
            data.items.itemIds.forEach(function (itemId) {
                var item = _this.itemsById[itemId];
                unit.items.addItemAtPosition(item, item.positionInUnit);
            });
            return unit;
        };
        GameLoader.prototype.deserializeItem = function (data) {
            var template = activeModuleData_6.activeModuleData.Templates.Items[data.templateType];
            var item = new Item_2.default(template, data.id);
            item.positionInUnit = data.positionInUnit;
            return item;
        };
        GameLoader.prototype.deserializeAIController = function (data, player, game) {
            var templateConstructor = activeModuleData_6.activeModuleData.Templates.AITemplateConstructors[data.templateType];
            var template = templateConstructor.construct({
                game: game,
                player: player,
                saveData: data.templateData,
                personality: data.personality,
            });
            var controller = new AIController_1.AIController(template);
            return controller;
        };
        GameLoader.prototype.deserializeStatusEffect = function (data) {
            return new StatusEffect_1.default({
                id: data.id,
                template: activeModuleData_6.activeModuleData.Templates.StatusEffects[data.templateType],
                turnsToStayActiveFor: data.turnsToStayActiveFor,
                turnsHasBeenActiveFor: data.turnsHasBeenActiveFor,
                sourceUnit: this.unitsById[data.sourceUnitId],
            });
        };
        return GameLoader;
    }());
    exports.default = GameLoader;
});
define("src/NotificationFilterState", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var NotificationFilterState;
    (function (NotificationFilterState) {
        NotificationFilterState[NotificationFilterState["AlwaysShow"] = 0] = "AlwaysShow";
        NotificationFilterState[NotificationFilterState["ShowIfInvolved"] = 1] = "ShowIfInvolved";
        NotificationFilterState[NotificationFilterState["NeverShow"] = 2] = "NeverShow";
    })(NotificationFilterState || (NotificationFilterState = {}));
    exports.default = NotificationFilterState;
});
define("src/NotificationWitnessCriterion", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var NotificationWitnessCriterion;
    (function (NotificationWitnessCriterion) {
        NotificationWitnessCriterion[NotificationWitnessCriterion["Always"] = 0] = "Always";
        NotificationWitnessCriterion[NotificationWitnessCriterion["IsInvolved"] = 1] = "IsInvolved";
        NotificationWitnessCriterion[NotificationWitnessCriterion["MetOneInvolvedPlayer"] = 2] = "MetOneInvolvedPlayer";
        NotificationWitnessCriterion[NotificationWitnessCriterion["MetAllInvolvedPlayers"] = 3] = "MetAllInvolvedPlayers";
        NotificationWitnessCriterion[NotificationWitnessCriterion["LocationIsRevealed"] = 4] = "LocationIsRevealed";
        NotificationWitnessCriterion[NotificationWitnessCriterion["LocationIsVisible"] = 5] = "LocationIsVisible";
        NotificationWitnessCriterion[NotificationWitnessCriterion["LocationIsDetected"] = 6] = "LocationIsDetected";
    })(NotificationWitnessCriterion = exports.NotificationWitnessCriterion || (exports.NotificationWitnessCriterion = {}));
});
define("src/activePlayer", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function setActivePlayer(player) {
        exports.activePlayer = player;
    }
    exports.setActivePlayer = setActivePlayer;
});
define("src/NotificationFilter", ["require", "exports", "src/activeModuleData", "src/activePlayer", "src/NotificationFilterState", "src/utility"], function (require, exports, activeModuleData_7, activePlayer_1, NotificationFilterState_1, utility_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var NotificationFilter = (function () {
        function NotificationFilter() {
            this.filters = {};
            this.setDefaultFilterStates();
            this.load();
        }
        NotificationFilter.prototype.setDefaultFilterStates = function () {
            var notifications = activeModuleData_7.activeModuleData.Templates.Notifications;
            for (var key in notifications) {
                var notificationTemplate = notifications[key];
                this.filters[key] = notificationTemplate.defaultFilterState.slice(0);
            }
        };
        NotificationFilter.prototype.shouldDisplayNotification = function (notification) {
            var filterStates = this.filters[notification.template.key];
            if (filterStates.indexOf(NotificationFilterState_1.default.AlwaysShow) !== -1) {
                return true;
            }
            else if (filterStates.indexOf(NotificationFilterState_1.default.NeverShow) !== -1) {
                return false;
            }
            var activePlayerWasInvolved = notification.involvedPlayers.indexOf(activePlayer_1.activePlayer) !== -1;
            if (activePlayerWasInvolved) {
                return filterStates.indexOf(NotificationFilterState_1.default.ShowIfInvolved) !== -1;
            }
            return false;
        };
        NotificationFilter.prototype.getCompatibleFilterStates = function (filterState) {
            switch (filterState) {
                case NotificationFilterState_1.default.AlwaysShow:
                    {
                        return [];
                    }
                case NotificationFilterState_1.default.ShowIfInvolved:
                    {
                        return [];
                    }
                case NotificationFilterState_1.default.NeverShow:
                    {
                        return [];
                    }
            }
        };
        NotificationFilter.prototype.handleFilterStateChange = function (filterKey, state) {
            var stateIndex = this.filters[filterKey].indexOf(state);
            if (stateIndex !== -1) {
                if (this.filters[filterKey].length === 1) {
                    this.filters[filterKey] = [NotificationFilterState_1.default.NeverShow];
                }
                else {
                    this.filters[filterKey].splice(stateIndex, 1);
                }
            }
            else {
                var newState = [state];
                var compatibleStates = this.getCompatibleFilterStates(state);
                for (var i = 0; i < this.filters[filterKey].length; i++) {
                    if (compatibleStates.indexOf(this.filters[filterKey][i]) !== -1) {
                        newState.push(this.filters[filterKey][i]);
                    }
                }
                this.filters[filterKey] = newState;
            }
        };
        NotificationFilter.prototype.getFiltersByCategory = function () {
            var filtersByCategory = {};
            var notifications = activeModuleData_7.activeModuleData.Templates.Notifications;
            for (var key in this.filters) {
                var notificationTemplate = notifications[key];
                if (notificationTemplate) {
                    if (!filtersByCategory[notificationTemplate.category]) {
                        filtersByCategory[notificationTemplate.category] = [];
                    }
                    filtersByCategory[notificationTemplate.category].push({
                        notificationTemplate: notificationTemplate,
                        filterState: this.filters[key],
                    });
                }
            }
            return filtersByCategory;
        };
        NotificationFilter.prototype.setDefaultFilterStatesForCategory = function (category) {
            var byCategory = this.getFiltersByCategory();
            var forSelectedCategory = byCategory[category];
            for (var i = 0; i < forSelectedCategory.length; i++) {
                var template = forSelectedCategory[i].notificationTemplate;
                this.filters[template.key] = template.defaultFilterState.slice(0);
            }
        };
        NotificationFilter.prototype.load = function (slot) {
            var baseString = "NotificationFilter.";
            var parsedData;
            if (slot && localStorage[baseString + slot]) {
                parsedData = JSON.parse(localStorage.getItem(baseString + slot));
            }
            else {
                parsedData = utility_9.getMatchingLocalstorageItemsByDate(baseString)[0];
            }
            if (parsedData) {
                this.filters = utility_9.extendObject(parsedData.filters, this.filters, false);
            }
        };
        NotificationFilter.prototype.save = function (slot) {
            if (slot === void 0) { slot = 0; }
            var data = JSON.stringify({
                filters: this.filters,
                date: new Date(),
            });
            localStorage.setItem("NotificationFilter." + slot, data);
        };
        return NotificationFilter;
    }());
    exports.default = NotificationFilter;
});
define("src/NotificationLog", ["require", "exports", "src/Notification", "src/NotificationFilter", "src/NotificationWitnessCriterion", "src/eventManager"], function (require, exports, Notification_2, NotificationFilter_1, NotificationWitnessCriterion_1, eventManager_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var NotificationLog = (function () {
        function NotificationLog(subscribedPlayers) {
            this.notifications = [];
            this.subscribedPlayers = [];
            (_a = this.subscribedPlayers).push.apply(_a, subscribedPlayers);
            this.notificationFilter = new NotificationFilter_1.default();
            var _a;
        }
        NotificationLog.prototype.makeNotification = function (args) {
            var notification = new Notification_2.default({
                template: args.template,
                props: args.props,
                involvedPlayers: args.involvedPlayers,
                witnessingPlayers: this.getWitnessingPlayers(args.template.witnessCriteria, args.involvedPlayers, args.location),
                turn: this.currentTurn,
            });
            this.notifications.push(notification);
            eventManager_4.default.dispatchEvent("updateNotificationLog");
        };
        NotificationLog.prototype.filterNotifications = function (notifications) {
            var _this = this;
            return notifications.filter(function (notification) {
                return _this.notificationFilter.shouldDisplayNotification(notification);
            });
        };
        NotificationLog.prototype.serialize = function () {
            return ({
                notifications: this.notifications.map(function (notification) { return notification.serialize(); }),
            });
        };
        NotificationLog.prototype.getWitnessingPlayers = function (witnessCriteria, involvedPlayers, location) {
            var _this = this;
            return this.subscribedPlayers.filter(function (witnessingPlayer) {
                var oneCriteriaGroupIsSatisfied = witnessCriteria.some(function (criteriaGroup) {
                    var allCriteriaInGroupAreSatisfied = criteriaGroup.every(function (criterion) {
                        var criterionIsSatisfied = _this.witnessCriterionIsSatisfied(criterion, involvedPlayers, witnessingPlayer, location);
                        return criterionIsSatisfied;
                    });
                    return allCriteriaInGroupAreSatisfied;
                });
                return oneCriteriaGroupIsSatisfied;
            });
        };
        NotificationLog.prototype.witnessCriterionIsSatisfied = function (criterion, involvedPlayers, witnessingPlayer, location) {
            switch (criterion) {
                case NotificationWitnessCriterion_1.NotificationWitnessCriterion.Always:
                    {
                        return true;
                    }
                case NotificationWitnessCriterion_1.NotificationWitnessCriterion.IsInvolved:
                    {
                        return involvedPlayers.indexOf(witnessingPlayer) !== -1;
                    }
                case NotificationWitnessCriterion_1.NotificationWitnessCriterion.MetOneInvolvedPlayer:
                    {
                        return involvedPlayers.some(function (involvedPlayer) {
                            return witnessingPlayer.diplomacyStatus.hasMetPlayer(involvedPlayer);
                        });
                    }
                case NotificationWitnessCriterion_1.NotificationWitnessCriterion.MetAllInvolvedPlayers:
                    {
                        return involvedPlayers.every(function (involvedPlayer) {
                            return witnessingPlayer.diplomacyStatus.hasMetPlayer(involvedPlayer);
                        });
                    }
                case NotificationWitnessCriterion_1.NotificationWitnessCriterion.LocationIsRevealed:
                    {
                        return witnessingPlayer.starIsRevealed(location);
                    }
                case NotificationWitnessCriterion_1.NotificationWitnessCriterion.LocationIsVisible:
                    {
                        return witnessingPlayer.starIsVisible(location);
                    }
                case NotificationWitnessCriterion_1.NotificationWitnessCriterion.LocationIsDetected:
                    {
                        return witnessingPlayer.starIsDetected(location);
                    }
            }
        };
        return NotificationLog;
    }());
    exports.default = NotificationLog;
});
define("src/activeNotificationLog", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function setActiveNotificationLog(notificationLog) {
        exports.activeNotificationLog = notificationLog;
    }
    exports.setActiveNotificationLog = setActiveNotificationLog;
});
define("src/Game", ["require", "exports", "src/App", "src/DiplomacyStatus", "src/activeNotificationLog", "src/activePlayer", "src/eventManager", "src/idGenerators"], function (require, exports, App_4, DiplomacyStatus_1, activeNotificationLog_2, activePlayer_2, eventManager_5, idGenerators_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Game = (function () {
        function Game(map, players) {
            var _this = this;
            this.players = [];
            this.hasEnded = false;
            this.actingPlayerIndex = 0;
            this.galaxyMap = map;
            this.players = players.slice();
            this.playerToAct = players[0];
            if (map.independents) {
                (_a = this.players).push.apply(_a, map.independents);
                map.independents = null;
                delete map.independents;
            }
            this.players.filter(function (player) {
                return !player.isIndependent && !player.isDead;
            }).forEach(function (player) {
                player.diplomacyStatus = new DiplomacyStatus_1.default(player, _this.players);
            });
            this.turnNumber = 1;
            var _a;
        }
        Game.prototype.destroy = function () {
            this.players.forEach(function (player) {
                player.destroy();
            });
        };
        Game.prototype.endTurn = function () {
            this.processPlayerEndTurn(this.playerToAct);
            this.setNextPlayer();
            while (this.playerToAct.isDead) {
                if (this.playerToAct === activePlayer_2.activePlayer) {
                    this.endGame();
                    return;
                }
                this.setNextPlayer();
            }
            this.processPlayerStartTurn(this.playerToAct);
            if (this.playerToAct.isIndependent) {
                this.endTurn();
                return;
            }
            eventManager_5.default.dispatchEvent("endTurn", null);
            eventManager_5.default.dispatchEvent("updateSelection", null);
            if (this.playerToAct.isAI) {
                this.playerToAct.AIController.processTurn(this.endTurn.bind(this));
            }
        };
        Game.prototype.save = function (name) {
            var saveString = "Rance.Save." + name;
            this.gameStorageKey = saveString;
            var date = new Date();
            var gameData = this.serialize();
            var fullSaveData = {
                name: name,
                date: date,
                gameData: gameData,
                idGenerators: idGenerators_4.default.serialize(),
                cameraLocation: App_4.default.renderer.camera.getCenterPosition(),
            };
            var stringified = JSON.stringify(fullSaveData);
            localStorage.setItem(saveString, stringified);
        };
        Game.prototype.getLiveMajorPlayers = function () {
            return this.players.filter(function (player) {
                return !player.isDead && !player.isIndependent;
            });
        };
        Game.prototype.processPlayerStartTurn = function (player) {
            player.units.forEach(function (unit) {
                unit.addHealth(unit.getHealingForGameTurnStart());
                var passiveSkillsByPhase = unit.getPassiveSkillsByPhase();
                if (passiveSkillsByPhase.atTurnStart) {
                    for (var i = 0; i < passiveSkillsByPhase.atTurnStart.length; i++) {
                        var skill = passiveSkillsByPhase.atTurnStart[i];
                        for (var j = 0; j < skill.atTurnStart.length; j++) {
                            skill.atTurnStart[j](unit);
                        }
                    }
                }
                unit.resetMovePoints();
                unit.offensiveBattlesFoughtThisTurn = 0;
            });
            if (!player.isIndependent) {
                player.money += player.getIncome();
                var allResourceIncomeData = player.getResourceIncome();
                for (var resourceType in allResourceIncomeData) {
                    var resourceData = allResourceIncomeData[resourceType];
                    player.addResource(resourceData.resource, resourceData.amount);
                }
                player.playerTechnology.allocateResearchPoints(player.getResearchSpeed());
            }
        };
        Game.prototype.processPlayerEndTurn = function (player) {
            if (!player.isIndependent) {
                player.getAllManufactories().forEach(function (manufactory) {
                    manufactory.buildAllThings();
                });
            }
        };
        Game.prototype.processNewRoundOfPlayStart = function () {
            this.turnNumber++;
            activeNotificationLog_2.activeNotificationLog.currentTurn = this.turnNumber;
        };
        Game.prototype.setNextPlayer = function () {
            this.actingPlayerIndex = (this.actingPlayerIndex + 1) % this.players.length;
            this.playerToAct = this.players[this.actingPlayerIndex];
            if (this.actingPlayerIndex === 0) {
                this.processNewRoundOfPlayStart();
            }
        };
        Game.prototype.serialize = function () {
            var data = {
                turnNumber: this.turnNumber,
                galaxyMap: this.galaxyMap.serialize(),
                players: this.players.map(function (player) {
                    return player.serialize();
                }),
                notificationLog: activeNotificationLog_2.activeNotificationLog.serialize(),
                units: this.players.map(function (player) {
                    return player.units.map(function (unit) {
                        return unit.serialize();
                    });
                }).reduce(function (allUnits, playerUnits) {
                    return allUnits.concat(playerUnits);
                }, []),
                items: this.players.map(function (player) {
                    return player.items.map(function (item) { return item.serialize(); });
                }).reduce(function (allItems, playerItems) {
                    return allItems.concat(playerItems);
                }, []),
            };
            return data;
        };
        Game.prototype.endGame = function () {
            this.hasEnded = true;
        };
        return Game;
    }());
    exports.default = Game;
});
define("src/AbilityUpgradeData", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("src/UnitItems", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var UnitItems = (function () {
        function UnitItems(itemSlots, addItemToUnit, updateUnit) {
            this.items = [];
            this.itemSlots = itemSlots;
            this.addItemToUnit = addItemToUnit;
            this.updateUnit = updateUnit;
        }
        UnitItems.prototype.getAllItems = function () {
            return this.items;
        };
        UnitItems.prototype.getItemsBySlot = function () {
            var itemsBySlot = {};
            var allItems = this.getAllItems();
            allItems.forEach(function (item) {
                if (!itemsBySlot[item.template.slot]) {
                    itemsBySlot[item.template.slot] = [];
                }
                itemsBySlot[item.template.slot].push(item);
            });
            var itemsBySlotWithEmptySlots = {};
            for (var slot in this.itemSlots) {
                itemsBySlotWithEmptySlots[slot] = itemsBySlot[slot] || [];
            }
            return itemsBySlotWithEmptySlots;
        };
        UnitItems.prototype.getItemsForSlot = function (slot) {
            return this.getItemsBySlot()[slot];
        };
        UnitItems.prototype.getAmountOfAvailableItemSlots = function (slot) {
            return this.itemSlots[slot] - this.getItemsForSlot(slot).length;
        };
        UnitItems.prototype.getAttributeAdjustments = function () {
            return this.getAllItems().filter(function (item) {
                return Boolean(item.template.attributeAdjustments);
            }).map(function (item) {
                return item.template.attributeAdjustments;
            });
        };
        UnitItems.prototype.getAbilities = function () {
            return this.getAllItems().filter(function (item) {
                return Boolean(item.template.ability);
            }).map(function (item) {
                return item.template.ability;
            });
        };
        UnitItems.prototype.getPassiveSkills = function () {
            return this.getAllItems().filter(function (item) {
                return Boolean(item.template.passiveSkill);
            }).map(function (item) {
                return item.template.passiveSkill;
            });
        };
        UnitItems.prototype.hasSlotForItem = function (item) {
            return this.getAmountOfAvailableItemSlots(item.template.slot) > 0;
        };
        UnitItems.prototype.getItemAtPosition = function (slot, position) {
            var itemsForSlot = this.getItemsBySlot()[slot];
            for (var i = 0; i < itemsForSlot.length; i++) {
                if (itemsForSlot[i].positionInUnit === position) {
                    return itemsForSlot[i];
                }
            }
            return null;
        };
        UnitItems.prototype.hasItem = function (item) {
            return this.indexOf(item) !== -1;
        };
        UnitItems.prototype.addItemAtPosition = function (toAdd, position) {
            var oldItemAtTargetPosition = this.getItemAtPosition(toAdd.template.slot, position);
            if (this.hasItem(toAdd)) {
                var oldPositionForItem = toAdd.positionInUnit;
                if (oldItemAtTargetPosition) {
                    this.moveItem(oldItemAtTargetPosition, oldPositionForItem);
                }
                this.moveItem(toAdd, position);
            }
            else {
                if (toAdd.unit) {
                    toAdd.unit.items.removeItem(toAdd);
                }
                if (oldItemAtTargetPosition) {
                    this.removeItem(oldItemAtTargetPosition);
                }
                if (!this.hasSlotForItem(toAdd)) {
                    throw new Error("");
                }
                this.items.push(toAdd);
                toAdd.positionInUnit = position;
                this.addItemToUnit(toAdd);
                this.updateUnit(toAdd);
            }
        };
        UnitItems.prototype.addItem = function (toAdd) {
            this.addItemAtPosition(toAdd, this.getFirstAvailablePositionForItem(toAdd));
        };
        UnitItems.prototype.moveItem = function (toMove, newPosition) {
            toMove.positionInUnit = newPosition;
        };
        UnitItems.prototype.removeItem = function (toRemove) {
            if (!this.hasItem(toRemove)) {
                throw new Error("");
            }
            this.items.splice(this.indexOf(toRemove), 1);
            toRemove.unit = null;
            toRemove.positionInUnit = null;
            this.updateUnit(toRemove);
        };
        UnitItems.prototype.destroyAllItems = function () {
            this.getAllItems().forEach(function (item) {
                item.unit.fleet.player.removeItem(item);
            });
        };
        UnitItems.prototype.serialize = function () {
            return ({
                maxItemSlots: this.itemSlots,
                itemIds: this.items.map(function (item) { return item.id; }),
            });
        };
        UnitItems.prototype.indexOf = function (item) {
            return this.items.indexOf(item);
        };
        UnitItems.prototype.getFirstAvailablePositionForItem = function (item) {
            if (!this.hasSlotForItem(item)) {
                return null;
            }
            else {
                var itemsForSlot = this.getItemsForSlot(item.template.slot).sort(function (a, b) {
                    return a.positionInUnit - b.positionInUnit;
                });
                var maxPosition = this.itemSlots[item.template.slot] - 1;
                for (var i = 0; i < maxPosition; i++) {
                    if (itemsForSlot[i].positionInUnit !== i) {
                        return i;
                    }
                }
            }
            throw new Error("Couldn't find available slot for item");
        };
        return UnitItems;
    }());
    exports.default = UnitItems;
});
define("src/Unit", ["require", "exports", "src/activeModuleData", "src/idGenerators", "src/Fleet", "src/UnitAttributes", "src/UnitItems", "src/utility"], function (require, exports, activeModuleData_8, idGenerators_5, Fleet_3, UnitAttributes_1, UnitItems_1, utility_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Unit = (function () {
        function Unit(props) {
            var _this = this;
            this.attributesAreDirty = false;
            this.abilities = [];
            this.passiveSkills = [];
            this.passiveSkillsByPhase = {};
            this.passiveSkillsByPhaseAreDirty = true;
            this.uiDisplayIsDirty = true;
            this.template = props.template;
            this.id = props.id;
            this.name = props.name;
            this.maxHealth = props.maxHealth;
            this.currentHealth = props.currentHealth;
            this.baseAttributes = new UnitAttributes_1.UnitAttributes(props.attributes).clamp(1, 9);
            this.cachedAttributes = this.baseAttributes.clone();
            this.currentMovePoints = props.currentMovePoints;
            this.maxMovePoints = props.maxMovePoints;
            this.offensiveBattlesFoughtThisTurn = props.offensiveBattlesFoughtThisTurn;
            this.abilities = props.abilities.slice(0);
            this.passiveSkills = props.passiveSkills.slice(0);
            this.level = props.level;
            this.experienceForCurrentLevel = props.experienceForCurrentLevel;
            if (props.battleStats) {
                this.battleStats =
                    {
                        moveDelay: props.battleStats.moveDelay,
                        side: props.battleStats.side,
                        position: props.battleStats.position,
                        currentActionPoints: props.battleStats.currentActionPoints,
                        guardAmount: props.battleStats.guardAmount,
                        guardCoverage: props.battleStats.guardCoverage,
                        captureChance: props.battleStats.captureChance,
                        statusEffects: props.battleStats.statusEffects.map(function (statusEffect) {
                            return statusEffect.clone();
                        }),
                        lastHealthBeforeReceivingDamage: this.currentHealth,
                        queuedAction: props.battleStats.queuedAction ?
                            {
                                ability: props.battleStats.queuedAction.ability,
                                targetId: props.battleStats.queuedAction.targetId,
                                turnsPrepared: props.battleStats.queuedAction.turnsPrepared,
                                timesInterrupted: props.battleStats.queuedAction.timesInterrupted,
                            } :
                            null,
                        isAnnihilated: props.battleStats.isAnnihilated,
                    };
            }
            else {
                this.resetBattleStats();
            }
            this.items = this.makeUnitItems(props.maxItemSlots);
            props.items.forEach(function (item) {
                if (isFinite(item.positionInUnit)) {
                    _this.items.addItemAtPosition(item, item.positionInUnit);
                }
                else {
                    _this.items.addItem(item);
                }
            });
            this.race = props.race;
            this.portrait = props.portrait;
        }
        Object.defineProperty(Unit.prototype, "attributes", {
            get: function () {
                if (this.attributesAreDirty || !this.cachedAttributes) {
                    this.updateCachedAttributes();
                }
                return this.cachedAttributes;
            },
            enumerable: true,
            configurable: true
        });
        Unit.fromTemplate = function (props) {
            var template = props.template;
            var race = props.race;
            var attributeMultiplier = isFinite(props.attributeMultiplier) ? props.attributeMultiplier : 1;
            var healthMultiplier = isFinite(props.healthMultiplier) ? props.healthMultiplier : 1;
            var baseAttributeValue = activeModuleData_8.activeModuleData.ruleSet.units.baseAttributeValue * attributeMultiplier;
            var attributeVariance = activeModuleData_8.activeModuleData.ruleSet.units.attributeVariance;
            var baseHealthValue = activeModuleData_8.activeModuleData.ruleSet.units.baseHealthValue * healthMultiplier;
            var healthVariance = activeModuleData_8.activeModuleData.ruleSet.units.healthVariance;
            var baseHealth = baseHealthValue * template.maxHealth;
            var health = utility_10.randInt(baseHealth - healthVariance, baseHealth + healthVariance);
            var unit = new Unit({
                template: template,
                id: idGenerators_5.default.unit++,
                name: props.name || race.getUnitName(template),
                maxHealth: health,
                currentHealth: health,
                attributes: Unit.getRandomAttributesFromTemplate(template, baseAttributeValue, attributeVariance),
                currentMovePoints: template.maxMovePoints,
                maxMovePoints: template.maxMovePoints,
                offensiveBattlesFoughtThisTurn: 0,
                abilities: utility_10.getItemsFromWeightedProbabilities(template.possibleAbilities),
                passiveSkills: template.possiblePassiveSkills ?
                    utility_10.getItemsFromWeightedProbabilities(template.possiblePassiveSkills) :
                    [],
                level: 1,
                experienceForCurrentLevel: 0,
                maxItemSlots: template.itemSlots,
                items: [],
                portrait: race.getUnitPortrait(template, activeModuleData_8.activeModuleData.Templates.Portraits),
                race: race,
            });
            return unit;
        };
        Unit.fromSaveData = function (data) {
            var unit = new Unit({
                template: activeModuleData_8.activeModuleData.Templates.Units[data.templateType],
                id: data.id,
                name: data.name,
                maxHealth: data.maxHealth,
                currentHealth: data.currentHealth,
                attributes: data.baseAttributes,
                currentMovePoints: data.currentMovePoints,
                maxMovePoints: data.maxMovePoints,
                offensiveBattlesFoughtThisTurn: data.offensiveBattlesFoughtThisTurn,
                abilities: data.abilityTemplateTypes.map(function (templateType) {
                    return activeModuleData_8.activeModuleData.Templates.Abilities[templateType];
                }),
                passiveSkills: data.passiveSkillTemplateTypes.map(function (templateType) {
                    return activeModuleData_8.activeModuleData.Templates.PassiveSkills[templateType];
                }),
                level: data.level,
                experienceForCurrentLevel: data.experienceForCurrentLevel,
                battleStats: {
                    moveDelay: data.battleStats.moveDelay,
                    side: data.battleStats.side,
                    position: data.battleStats.position,
                    currentActionPoints: data.battleStats.currentActionPoints,
                    guardAmount: data.battleStats.guardAmount,
                    guardCoverage: data.battleStats.guardCoverage,
                    captureChance: data.battleStats.captureChance,
                    isAnnihilated: data.battleStats.isAnnihilated,
                    lastHealthBeforeReceivingDamage: data.currentHealth,
                    statusEffects: [],
                    queuedAction: data.battleStats.queuedAction ?
                        {
                            ability: activeModuleData_8.activeModuleData.Templates.Abilities[data.battleStats.queuedAction.abilityTemplateKey],
                            targetId: data.battleStats.queuedAction.targetId,
                            turnsPrepared: data.battleStats.queuedAction.turnsPrepared,
                            timesInterrupted: data.battleStats.queuedAction.timesInterrupted,
                        } :
                        null,
                },
                maxItemSlots: data.items.maxItemSlots,
                items: [],
                portrait: data.portraitKey ?
                    activeModuleData_8.activeModuleData.Templates.Portraits[data.portraitKey] :
                    null,
                race: data.raceKey ?
                    activeModuleData_8.activeModuleData.Templates.Races[data.raceKey] :
                    null,
            });
            return unit;
        };
        Unit.getRandomValueFromAttributeLevel = function (level, baseValue, variance) {
            var baseValueForLevel = baseValue * level;
            return utility_10.randInt(baseValueForLevel - variance, baseValueForLevel + variance);
        };
        Unit.getRandomAttributesFromTemplate = function (template, baseValue, variance) {
            return ({
                attack: Unit.getRandomValueFromAttributeLevel(template.attributeLevels.attack, baseValue, variance),
                defence: Unit.getRandomValueFromAttributeLevel(template.attributeLevels.defence, baseValue, variance),
                intelligence: Unit.getRandomValueFromAttributeLevel(template.attributeLevels.intelligence, baseValue, variance),
                speed: Unit.getRandomValueFromAttributeLevel(template.attributeLevels.speed, baseValue, variance),
                maxActionPoints: utility_10.randInt(3, 5),
            });
        };
        Unit.prototype.getBaseMoveDelay = function () {
            return 30 - this.attributes.speed;
        };
        Unit.prototype.resetMovePoints = function () {
            this.currentMovePoints = this.maxMovePoints;
        };
        Unit.prototype.resetBattleStats = function () {
            this.battleStats =
                {
                    moveDelay: this.getBaseMoveDelay(),
                    currentActionPoints: this.attributes.maxActionPoints,
                    side: null,
                    position: null,
                    guardAmount: 0,
                    guardCoverage: null,
                    captureChance: activeModuleData_8.activeModuleData.ruleSet.battle.baseUnitCaptureChance,
                    statusEffects: [],
                    lastHealthBeforeReceivingDamage: this.currentHealth,
                    queuedAction: null,
                    isAnnihilated: false,
                };
            this.attributesAreDirty = true;
            this.uiDisplayIsDirty = true;
        };
        Unit.prototype.setBattlePosition = function (battle, side, position) {
            this.battleStats.side = side;
            this.battleStats.position = position;
        };
        Unit.prototype.addMaxHealth = function (amountToAdd) {
            this.maxHealth += Math.max(0, Math.round(amountToAdd));
            if (this.currentHealth > this.maxHealth) {
                this.currentHealth = this.maxHealth;
            }
            this.uiDisplayIsDirty = true;
        };
        Unit.prototype.addHealth = function (amountToAdd) {
            var newHealth = this.currentHealth + Math.round(amountToAdd);
            this.currentHealth = utility_10.clamp(newHealth, 0, this.maxHealth);
            if (this.currentHealth <= 0) {
                this.battleStats.isAnnihilated = true;
            }
            this.uiDisplayIsDirty = true;
        };
        Unit.prototype.removeHealth = function (amountToRemove) {
            this.addHealth(-amountToRemove);
        };
        Unit.prototype.removeActionPoints = function (amount) {
            this.battleStats.currentActionPoints -= amount;
            if (this.battleStats.currentActionPoints < 0) {
                this.battleStats.currentActionPoints = 0;
            }
            this.uiDisplayIsDirty = true;
        };
        Unit.prototype.addMoveDelay = function (amount) {
            this.battleStats.moveDelay += amount;
        };
        Unit.prototype.updateStatusEffects = function () {
            for (var i = this.battleStats.statusEffects.length - 1; i >= 0; i--) {
                var statusEffect = this.battleStats.statusEffects[i];
                statusEffect.processTurnEnd();
                if (statusEffect.turnsHasBeenActiveFor >= statusEffect.turnsToStayActiveFor) {
                    this.removeStatusEffect(statusEffect);
                }
            }
            this.uiDisplayIsDirty = true;
        };
        Unit.prototype.setQueuedAction = function (ability, target) {
            this.battleStats.queuedAction =
                {
                    ability: ability,
                    targetId: target.id,
                    turnsPrepared: 0,
                    timesInterrupted: 0,
                };
            this.uiDisplayIsDirty = true;
        };
        Unit.prototype.interruptQueuedAction = function (interruptStrength) {
            var action = this.battleStats.queuedAction;
            if (!action) {
                return;
            }
            action.timesInterrupted += interruptStrength;
            if (action.timesInterrupted >= action.ability.preparation.interruptsNeeded) {
                this.clearQueuedAction();
            }
            this.uiDisplayIsDirty = true;
        };
        Unit.prototype.updateQueuedAction = function () {
            var action = this.battleStats.queuedAction;
            if (!action) {
                return;
            }
            action.turnsPrepared++;
            this.uiDisplayIsDirty = true;
        };
        Unit.prototype.isReadyToUseQueuedAction = function () {
            var action = this.battleStats.queuedAction;
            return (action && action.turnsPrepared >= action.ability.preparation.turnsToPrep);
        };
        Unit.prototype.clearQueuedAction = function () {
            this.battleStats.queuedAction = null;
            this.uiDisplayIsDirty = true;
        };
        Unit.prototype.isTargetable = function () {
            return this.isActiveInBattle();
        };
        Unit.prototype.isActiveInBattle = function () {
            return this.currentHealth > 0 && !this.battleStats.isAnnihilated;
        };
        Unit.prototype.makeUnitItems = function (itemSlots) {
            var _this = this;
            return new UnitItems_1.default(itemSlots, function (item) {
                item.unit = _this;
            }, function (changedItem) {
                if (changedItem.template.attributeAdjustments) {
                    _this.attributesAreDirty = true;
                }
                if (changedItem.template.passiveSkill) {
                    _this.passiveSkillsByPhaseAreDirty = true;
                }
            });
        };
        Unit.prototype.getAttributesWithItems = function () {
            return (_a = this.baseAttributes).getAdjustedAttributes.apply(_a, this.items.getAttributeAdjustments()).clamp(1, 9);
            var _a;
        };
        Unit.prototype.addStatusEffect = function (statusEffect) {
            if (this.battleStats.statusEffects.indexOf(statusEffect) !== -1) {
                throw new Error("Tried to add duplicate status effect to unit " + this.name);
            }
            else if (statusEffect.turnsToStayActiveFor === 0) {
                console.warn("Tried to add status effect", statusEffect, "with 0 duration");
                return;
            }
            this.battleStats.statusEffects.push(statusEffect);
            if (statusEffect.template.attributes) {
                this.attributesAreDirty = true;
            }
            this.uiDisplayIsDirty = true;
        };
        Unit.prototype.removeStatusEffect = function (statusEffect) {
            var index = this.battleStats.statusEffects.indexOf(statusEffect);
            if (index === -1) {
                throw new Error("Tried to remove status effect not active on unit " + this.name);
            }
            this.battleStats.statusEffects.splice(index, 1);
            if (statusEffect.template.attributes) {
                this.attributesAreDirty = true;
            }
            this.uiDisplayIsDirty = true;
        };
        Unit.prototype.getStatusEffectAttributeAdjustments = function () {
            if (!this.battleStats || !this.battleStats.statusEffects) {
                return [];
            }
            return this.battleStats.statusEffects.filter(function (statusEffect) {
                return Boolean(statusEffect.template.attributes);
            }).map(function (statusEffect) {
                return statusEffect.template.attributes;
            });
        };
        Unit.prototype.getAttributesWithItemsAndEffects = function () {
            var itemAdjustments = this.items.getAttributeAdjustments();
            var effectAdjustments = this.getStatusEffectAttributeAdjustments();
            return (_a = this.baseAttributes).getAdjustedAttributes.apply(_a, itemAdjustments.concat(effectAdjustments));
            var _a;
        };
        Unit.prototype.getAttributesWithEffectsDifference = function () {
            var withItems = this.getAttributesWithItems();
            var withEffects = this.getAttributesWithItemsAndEffects();
            return withEffects.getDifferenceBetween(withItems);
        };
        Unit.prototype.updateCachedAttributes = function () {
            this.cachedAttributes = this.getAttributesWithItemsAndEffects();
            this.attributesAreDirty = false;
        };
        Unit.prototype.getAllAbilities = function () {
            return this.abilities.concat(this.items.getAbilities());
        };
        Unit.prototype.getAllPassiveSkills = function () {
            var allSkills = [];
            allSkills = allSkills.concat(this.passiveSkills);
            allSkills = allSkills.concat(this.items.getPassiveSkills());
            return allSkills;
        };
        Unit.prototype.updatePassiveSkillsByPhase = function () {
            var updatedSkills = {};
            var allSkills = this.getAllPassiveSkills();
            var _loop_1 = function (i) {
                var skill = allSkills[i];
                ["atBattleStart", "atTurnStart", "inBattlePrep"].forEach(function (phase) {
                    if (skill[phase]) {
                        if (!updatedSkills[phase]) {
                            updatedSkills[phase] = [];
                        }
                        if (updatedSkills[phase].indexOf(skill) === -1) {
                            updatedSkills[phase].push(skill);
                        }
                    }
                });
            };
            for (var i = 0; i < allSkills.length; i++) {
                _loop_1(i);
            }
            this.passiveSkillsByPhase = updatedSkills;
            this.passiveSkillsByPhaseAreDirty = false;
        };
        Unit.prototype.getPassiveSkillsByPhase = function () {
            if (this.passiveSkillsByPhaseAreDirty) {
                this.updatePassiveSkillsByPhase();
            }
            return this.passiveSkillsByPhase;
        };
        Unit.prototype.getPassiveEffectsForScene = function (scene) {
            var relevantTemplateKeys = [];
            switch (scene) {
                case "galaxyMap":
                    break;
                case "battlePrep":
                    relevantTemplateKeys.push("atBattleStart", "inBattlePrep");
                    break;
                case "battle":
                    relevantTemplateKeys.push("beforeAbilityUse", "afterAbilityUse");
                    break;
            }
            var effectFilterFN = function (passiveEffect) {
                if (passiveEffect.isHidden) {
                    return false;
                }
                for (var _i = 0, relevantTemplateKeys_1 = relevantTemplateKeys; _i < relevantTemplateKeys_1.length; _i++) {
                    var key = relevantTemplateKeys_1[_i];
                    if (passiveEffect[key]) {
                        return true;
                    }
                }
                return false;
            };
            var relevantStatusEffectTemplates = this.battleStats.statusEffects.map(function (statusEffect) {
                return statusEffect.template;
            }).filter(effectFilterFN);
            var relevantPassiveEffectTemplates = this.getAllPassiveSkills().filter(effectFilterFN);
            return relevantStatusEffectTemplates.concat(relevantPassiveEffectTemplates);
        };
        Unit.prototype.receiveDamage = function (amount) {
            this.battleStats.lastHealthBeforeReceivingDamage = this.currentHealth;
            this.addHealth(-amount);
        };
        Unit.prototype.removeFromPlayer = function () {
            var _this = this;
            var fleet = this.fleet;
            var player = fleet.player;
            this.items.destroyAllItems();
            player.removeUnit(this);
            fleet.removeUnit(this);
            if (fleet.units.length <= 0) {
                fleet.deleteFleet();
            }
            activeModuleData_8.activeModuleData.scripts.unit.removeFromPlayer.forEach(function (scriptFN) {
                scriptFN(_this);
            });
            this.uiDisplayIsDirty = true;
        };
        Unit.prototype.transferToPlayer = function (newPlayer) {
            var location = this.fleet.location;
            this.removeFromPlayer();
            newPlayer.addUnit(this);
            var fleet = Fleet_3.Fleet.createFleet([this]);
            newPlayer.addFleet(fleet);
            location.addFleet(fleet);
        };
        Unit.prototype.removeGuard = function (amount) {
            this.battleStats.guardAmount -= amount;
            if (this.battleStats.guardAmount < 0)
                this.removeAllGuard();
            this.uiDisplayIsDirty = true;
        };
        Unit.prototype.addGuard = function (amount, coverage) {
            this.battleStats.guardAmount += amount;
            this.battleStats.guardCoverage = coverage;
            this.uiDisplayIsDirty = true;
        };
        Unit.prototype.removeAllGuard = function () {
            this.battleStats.guardAmount = 0;
            this.battleStats.guardCoverage = null;
            this.uiDisplayIsDirty = true;
        };
        Unit.prototype.getCounterAttackStrength = function () {
            return 1;
        };
        Unit.prototype.getMaxOffensiveBattlesPerTurn = function () {
            return this.template.maxOffensiveBattlesPerTurn;
        };
        Unit.prototype.canFightOffensiveBattle = function () {
            return this.offensiveBattlesFoughtThisTurn < this.getMaxOffensiveBattlesPerTurn();
        };
        Unit.prototype.isStealthy = function () {
            return this.template.isStealthy;
        };
        Unit.prototype.getVisionRange = function () {
            return this.template.visionRange;
        };
        Unit.prototype.getDetectionRange = function () {
            return this.template.detectionRange;
        };
        Unit.prototype.getHealingForGameTurnStart = function () {
            var location = this.fleet.location;
            var baseHealFactor = 0.05;
            var healingFactor = baseHealFactor + location.getHealingFactor(this.fleet.player);
            var healAmount = this.maxHealth * healingFactor;
            return healAmount;
        };
        Unit.prototype.getTotalCost = function () {
            var totalCost = 0;
            totalCost += this.template.buildCost;
            totalCost += this.items.getAllItems().map(function (item) {
                return item.template.buildCost;
            }).reduce(function (a, b) {
                return a + b;
            }, 0);
            return totalCost;
        };
        Unit.prototype.getTurnsToReachStar = function (star) {
            var currentLocation = this.fleet.location;
            var distance = currentLocation.getDistanceToStar(star);
            if (distance <= this.currentMovePoints) {
                if (this.currentMovePoints === 0) {
                    return 0;
                }
                else {
                    return distance / this.currentMovePoints;
                }
            }
            distance -= this.currentMovePoints;
            return distance / this.maxMovePoints;
        };
        Unit.prototype.getExperienceToNextLevel = function () {
            return (4 + this.level) * 10;
        };
        Unit.prototype.addExperience = function (amount) {
            this.experienceForCurrentLevel += Math.round(amount);
        };
        Unit.prototype.canLevelUp = function () {
            return this.experienceForCurrentLevel >= this.getExperienceToNextLevel();
        };
        Unit.prototype.handleLevelUp = function () {
            this.experienceForCurrentLevel -= this.getExperienceToNextLevel();
            this.level++;
        };
        Unit.prototype.hasAbility = function (ability, allAbilities) {
            for (var i = 0; i < allAbilities.length; i++) {
                if (allAbilities[i].type === ability.type) {
                    return true;
                }
            }
            return false;
        };
        Unit.prototype.getLearnableAbilities = function (allAbilities) {
            var abilities = [];
            if (!this.template.learnableAbilities) {
                return abilities;
            }
            for (var i = 0; i < this.template.learnableAbilities.length; i++) {
                if (Array.isArray(this.template.learnableAbilities[i])) {
                    var learnableAbilityGroup = this.template.learnableAbilities[i];
                    var hasAbilityFromGroup = false;
                    for (var j = 0; j < learnableAbilityGroup.length; j++) {
                        if (this.hasAbility(learnableAbilityGroup[j], allAbilities)) {
                            hasAbilityFromGroup = true;
                            break;
                        }
                    }
                    if (!hasAbilityFromGroup) {
                        abilities.push.apply(abilities, learnableAbilityGroup);
                    }
                }
                else {
                    var learnableAbility = this.template.learnableAbilities[i];
                    if (!this.hasAbility(learnableAbility, allAbilities)) {
                        abilities.push(learnableAbility);
                    }
                }
            }
            return abilities;
        };
        Unit.prototype.canUpgradeIntoAbility = function (ability, allAbilities) {
            if (ability.onlyAllowExplicitUpgrade) {
                if (!this.template.specialAbilityUpgrades || this.template.specialAbilityUpgrades.indexOf(ability) === -1) {
                    return false;
                }
            }
            if (this.hasAbility(ability, allAbilities)) {
                return false;
            }
            return true;
        };
        Unit.prototype.getAbilityUpgradeData = function () {
            var _this = this;
            var upgradeData = {};
            var allAbilities = this.getAllAbilities();
            allAbilities.push.apply(allAbilities, this.getAllPassiveSkills());
            var upgradableAbilities = allAbilities.filter(function (abilityTemplate) {
                return abilityTemplate.canUpgradeInto && abilityTemplate.canUpgradeInto.length > 0;
            });
            upgradableAbilities.forEach(function (parentAbility) {
                parentAbility.canUpgradeInto.forEach(function (childAbility) {
                    if (_this.canUpgradeIntoAbility(childAbility, allAbilities)) {
                        if (!upgradeData[parentAbility.type]) {
                            upgradeData[parentAbility.type] =
                                {
                                    base: parentAbility,
                                    possibleUpgrades: [],
                                };
                        }
                        upgradeData[parentAbility.type].possibleUpgrades.push(childAbility);
                    }
                });
            });
            var learnable = this.getLearnableAbilities(allAbilities);
            if (learnable.length > 0) {
                upgradeData["learnable"] =
                    {
                        base: null,
                        possibleUpgrades: learnable,
                    };
            }
            return upgradeData;
        };
        Unit.prototype.upgradeAbility = function (source, newAbility) {
            var newAbilityIsPassiveSkill = !newAbility.mainEffect;
            if (source) {
                var sourceIsPassiveSkill = !source.mainEffect;
                if (sourceIsPassiveSkill) {
                    this.passiveSkills.splice(this.passiveSkills.indexOf(source), 1);
                }
                else {
                    var castedSource = source;
                    this.abilities.splice(this.abilities.indexOf(castedSource), 1);
                }
            }
            if (newAbilityIsPassiveSkill) {
                this.passiveSkills.push(newAbility);
            }
            else {
                var castedNewAbility = newAbility;
                this.abilities.push(castedNewAbility);
            }
        };
        Unit.prototype.drawBattleScene = function (params) {
            this.template.unitDrawingFN(this, params);
        };
        Unit.prototype.getDisplayData = function (scene) {
            return ({
                name: this.name,
                facesLeft: this.battleStats.side === "side2",
                currentHealth: this.currentHealth,
                maxHealth: this.maxHealth,
                guardAmount: this.battleStats.guardAmount,
                guardType: this.battleStats.guardCoverage,
                currentActionPoints: this.battleStats.currentActionPoints,
                maxActionPoints: this.attributes.maxActionPoints,
                isPreparing: Boolean(this.battleStats.queuedAction),
                isAnnihilated: this.battleStats.isAnnihilated,
                isSquadron: this.template.isSquadron,
                portraitSrc: this.portrait.imageSrc,
                iconSrc: this.template.icon,
                attributeChanges: this.getAttributesWithEffectsDifference().serialize(),
                passiveEffects: this.getPassiveEffectsForScene(scene),
            });
        };
        Unit.prototype.serialize = function () {
            var battleStatsSavedData = {
                moveDelay: this.battleStats.moveDelay,
                side: this.battleStats.side,
                position: this.battleStats.position,
                currentActionPoints: this.battleStats.currentActionPoints,
                guardAmount: this.battleStats.guardAmount,
                guardCoverage: this.battleStats.guardCoverage,
                captureChance: this.battleStats.captureChance,
                statusEffects: this.battleStats.statusEffects.map(function (statusEffect) {
                    return statusEffect.serialize();
                }),
                queuedAction: !this.battleStats.queuedAction ? null :
                    {
                        abilityTemplateKey: this.battleStats.queuedAction.ability.type,
                        targetId: this.battleStats.queuedAction.targetId,
                        turnsPrepared: this.battleStats.queuedAction.turnsPrepared,
                        timesInterrupted: this.battleStats.queuedAction.timesInterrupted,
                    },
                isAnnihilated: this.battleStats.isAnnihilated,
            };
            var data = {
                templateType: this.template.type,
                id: this.id,
                name: this.name,
                maxHealth: this.maxHealth,
                currentHealth: this.currentHealth,
                currentMovePoints: this.currentMovePoints,
                maxMovePoints: this.maxMovePoints,
                offensiveBattlesFoughtThisTurn: this.offensiveBattlesFoughtThisTurn,
                baseAttributes: this.baseAttributes.serialize(),
                abilityTemplateTypes: this.abilities.map(function (ability) {
                    return ability.type;
                }),
                passiveSkillTemplateTypes: this.passiveSkills.map(function (passiveSkill) {
                    return passiveSkill.type;
                }),
                experienceForCurrentLevel: this.experienceForCurrentLevel,
                level: this.level,
                items: this.items.serialize(),
                battleStats: battleStatsSavedData,
                portraitKey: this.portrait.key,
                raceKey: this.race.type,
            };
            if (this.fleet) {
                data.fleetId = this.fleet.id;
            }
            return data;
        };
        Unit.prototype.makeVirtualClone = function () {
            var clone = new Unit({
                template: this.template,
                id: this.id,
                name: this.name,
                maxHealth: this.maxHealth,
                currentHealth: this.currentHealth,
                attributes: this.baseAttributes.clone(),
                currentMovePoints: this.currentMovePoints,
                maxMovePoints: this.maxMovePoints,
                offensiveBattlesFoughtThisTurn: this.offensiveBattlesFoughtThisTurn,
                abilities: this.abilities,
                passiveSkills: this.passiveSkills,
                level: this.level,
                experienceForCurrentLevel: this.experienceForCurrentLevel,
                battleStats: this.battleStats,
                maxItemSlots: this.items.itemSlots,
                items: this.items.items,
                portrait: this.portrait,
                race: this.race,
            });
            return clone;
        };
        return Unit;
    }());
    exports.default = Unit;
});
define("src/AIController", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AIController = (function () {
        function AIController(template) {
            this.template = template;
            this.personality = template.personality;
        }
        AIController.prototype.processTurn = function (afterFinishedCallback) {
            this.template.processTurn(afterFinishedCallback);
        };
        AIController.prototype.createBattleFormation = function (availableUnits, hasScouted, enemyUnits, enemyFormation) {
            return this.template.createBattleFormation(availableUnits, hasScouted, enemyUnits, enemyFormation);
        };
        AIController.prototype.respondToTradeOffer = function (receivedOffer) {
            return this.template.respondToTradeOffer(receivedOffer);
        };
        AIController.prototype.serialize = function () {
            return ({
                templateType: this.template.type,
                templateData: this.template.serialize(),
                personality: this.personality,
            });
        };
        return AIController;
    }());
    exports.AIController = AIController;
});
define("src/battleAbilityTargeting", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function getTargetsForAllAbilities(battle, user) {
        if (!user || !battle.activeUnit) {
            throw new Error();
        }
        var allTargets = {};
        var abilities = user.getAllAbilities();
        for (var i = 0; i < abilities.length; i++) {
            var ability = abilities[i];
            var targets = getPotentialTargets(battle, user, ability);
            for (var j = 0; j < targets.length; j++) {
                var target = targets[j];
                if (!allTargets[target.id]) {
                    allTargets[target.id] = [];
                }
                allTargets[target.id].push(ability);
            }
        }
        return allTargets;
    }
    exports.getTargetsForAllAbilities = getTargetsForAllAbilities;
    function isTargetableFilterFN(unit) {
        return unit && unit.isTargetable();
    }
    function getPotentialTargets(battle, user, ability) {
        var targetsInRange = ability.getPossibleTargets(user, battle);
        var targets = targetsInRange.filter(isTargetableFilterFN);
        return targets;
    }
});
define("src/battleAbilityProcessing", ["require", "exports", "src/targeting"], function (require, exports, targeting_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function getAbilityEffectDataByPhase(battle, abilityUseData) {
        abilityUseData.actualTarget = getTargetOrGuard(battle, abilityUseData);
        var beforeUse = getAbilityEffectDataFromEffectTemplates(battle, abilityUseData, getBeforeAbilityUseEffectTemplates(abilityUseData), abilityUseData.actualTarget);
        beforeUse.push.apply(beforeUse, getDefaultBeforeUseEffects(abilityUseData));
        var abilityEffects = getAbilityEffectDataFromEffectTemplates(battle, abilityUseData, getAbilityUseEffectTemplates(abilityUseData), abilityUseData.actualTarget);
        var afterUse = getAbilityEffectDataFromEffectTemplates(battle, abilityUseData, getAfterAbilityUseEffectTemplates(abilityUseData), abilityUseData.actualTarget);
        afterUse.push.apply(afterUse, getDefaultAfterUseEffects(abilityUseData));
        return ({
            beforeUse: beforeUse,
            abilityEffects: abilityEffects,
            afterUse: afterUse,
        });
    }
    exports.getAbilityEffectDataByPhase = getAbilityEffectDataByPhase;
    function getUnitsInEffectArea(effect, battle, user, target) {
        var inArea = effect.getUnitsInArea(user, target, battle);
        return inArea.filter(activeUnitsFilterFN);
    }
    exports.getUnitsInEffectArea = getUnitsInEffectArea;
    function getTargetOrGuard(battle, abilityUseData) {
        if (abilityUseData.ability.targetCannotBeDiverted) {
            return abilityUseData.intendedTarget;
        }
        var guarding = getGuarders(battle, abilityUseData);
        guarding = guarding.sort(function (a, b) {
            return a.battleStats.guardAmount - b.battleStats.guardAmount;
        });
        for (var i = 0; i < guarding.length; i++) {
            var guardRoll = Math.random() * 100;
            if (guardRoll <= guarding[i].battleStats.guardAmount) {
                return guarding[i];
            }
        }
        return abilityUseData.intendedTarget;
    }
    function canUnitGuardTarget(unit, intendedTarget) {
        if (unit.battleStats.guardAmount > 0 && unit.isTargetable()) {
            if (unit.battleStats.guardCoverage === 1) {
                return true;
            }
            else if (unit.battleStats.guardCoverage === 0) {
                if (unit.battleStats.position[0] === intendedTarget.battleStats.position[0]) {
                    return true;
                }
            }
        }
        return false;
    }
    function getGuarders(battle, abilityUseData) {
        var userSide = abilityUseData.user.battleStats.side;
        var targetSide = abilityUseData.intendedTarget.battleStats.side;
        if (userSide === targetSide) {
            return [];
        }
        var allEnemies = battle.getUnitsForSide(targetSide);
        var guarders = allEnemies.filter(function (unit) {
            return canUnitGuardTarget(unit, abilityUseData.intendedTarget);
        });
        return guarders;
    }
    function activeUnitsFilterFN(unit) {
        return unit && unit.isActiveInBattle();
    }
    function getAbilityEffectDataFromEffectTemplate(battle, abilityUseData, effectTemplate, target, sourceStatusEffect) {
        var effectData = [];
        var unitsInEffectArea = getUnitsInEffectArea(effectTemplate, battle, abilityUseData.user, target);
        unitsInEffectArea.forEach(function (unitInEffectArea) {
            effectData.push({
                sourceAbility: abilityUseData.ability,
                effectTemplate: effectTemplate,
                user: abilityUseData.user,
                target: unitInEffectArea,
                trigger: effectTemplate.trigger,
                sourceStatusEffect: sourceStatusEffect,
            });
            var attachedEffects = effectTemplate.attachedEffects || [];
            attachedEffects.forEach(function (attachedEffectTemplate) {
                effectData.push.apply(effectData, getAbilityEffectDataFromEffectTemplate(battle, abilityUseData, attachedEffectTemplate, unitInEffectArea, sourceStatusEffect));
            });
        });
        return effectData;
    }
    function getAbilityEffectDataFromEffectTemplates(battle, abilityUseData, effectTemplatesWithSource, target) {
        var effectData = [];
        effectTemplatesWithSource.forEach(function (effectTemplateWithSource) {
            effectData.push.apply(effectData, getAbilityEffectDataFromEffectTemplate(battle, abilityUseData, effectTemplateWithSource.template, target, effectTemplateWithSource.sourceStatusEffect));
        });
        return effectData;
    }
    function getBeforeAbilityUseEffectTemplates(abilityUseData) {
        var beforeUseEffects = [];
        if (abilityUseData.ability.beforeUse) {
            beforeUseEffects.push.apply(beforeUseEffects, abilityUseData.ability.beforeUse.map(function (effectTemplate) {
                return ({
                    template: effectTemplate,
                    sourceStatusEffect: null,
                });
            }));
        }
        abilityUseData.user.battleStats.statusEffects.forEach(function (statusEffect) {
            if (statusEffect.template.beforeAbilityUse) {
                beforeUseEffects.push.apply(beforeUseEffects, statusEffect.template.beforeAbilityUse.map(function (effectTemplate) {
                    return ({
                        template: effectTemplate,
                        sourceStatusEffect: statusEffect,
                    });
                }));
            }
        });
        return beforeUseEffects;
    }
    function getAbilityUseEffectTemplates(abilityUseData) {
        var abilityUseEffects = [];
        abilityUseEffects.push(abilityUseData.ability.mainEffect);
        if (abilityUseData.ability.secondaryEffects) {
            abilityUseEffects = abilityUseEffects.concat(abilityUseData.ability.secondaryEffects);
        }
        return abilityUseEffects.map(function (effectTemplate) {
            return ({
                template: effectTemplate,
                sourceStatusEffect: null,
            });
        });
    }
    function getAfterAbilityUseEffectTemplates(abilityUseData) {
        var afterUseEffects = [];
        if (abilityUseData.ability.afterUse) {
            afterUseEffects.push.apply(afterUseEffects, abilityUseData.ability.afterUse.map(function (effectTemplate) {
                return ({
                    template: effectTemplate,
                    sourceStatusEffect: null,
                });
            }));
        }
        abilityUseData.user.battleStats.statusEffects.forEach(function (statusEffect) {
            if (statusEffect.template.afterAbilityUse) {
                afterUseEffects.push.apply(afterUseEffects, statusEffect.template.afterAbilityUse.map(function (effectTemplate) {
                    return ({
                        template: effectTemplate,
                        sourceStatusEffect: statusEffect,
                    });
                }));
            }
        });
        return afterUseEffects;
    }
    function makeSelfAbilityEffectData(user, name, actionFN) {
        return ({
            sourceAbility: null,
            sourceStatusEffect: null,
            effectTemplate: {
                id: name,
                getUnitsInArea: targeting_1.areaSingle,
                executeAction: actionFN,
            },
            user: user,
            target: user,
            trigger: null,
        });
    }
    function getDefaultBeforeUseEffects(abilityUseData) {
        var effects = [];
        if (!abilityUseData.ability.doesNotRemoveUserGuard) {
            effects.push(makeSelfAbilityEffectData(abilityUseData.user, "removeGuard", function (user) { return user.removeAllGuard(); }));
        }
        effects.push(makeSelfAbilityEffectData(abilityUseData.user, "removeActionPoints", function (user) { return user.removeActionPoints(abilityUseData.ability.actionsUse); }));
        return effects;
    }
    function getDefaultAfterUseEffects(abilityUseData) {
        var effects = [];
        effects.push(makeSelfAbilityEffectData(abilityUseData.user, "addMoveDelay", function (user) { return user.addMoveDelay(abilityUseData.ability.moveDelay); }));
        effects.push(makeSelfAbilityEffectData(abilityUseData.user, "updateStatusEffects", function (user) { return user.updateStatusEffects(); }));
        return effects;
    }
});
define("src/battleAbilityUsage", ["require", "exports", "src/battleAbilityProcessing"], function (require, exports, battleAbilityProcessing_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function useAbility(battle, ability, user, target) {
        var effectDataByPhase = battleAbilityProcessing_1.getAbilityEffectDataByPhase(battle, {
            ability: ability,
            user: user,
            intendedTarget: target,
        });
        executeFullAbilityEffects(battle, effectDataByPhase);
    }
    exports.useAbility = useAbility;
    function useAbilityAndGetUseEffects(battle, ability, user, target) {
        var effectDataByPhase = battleAbilityProcessing_1.getAbilityEffectDataByPhase(battle, {
            ability: ability,
            user: user,
            intendedTarget: target,
        });
        var useData = executeFullAbilityEffectsAndGetUseEffects(battle, effectDataByPhase);
        return useData;
    }
    exports.useAbilityAndGetUseEffects = useAbilityAndGetUseEffects;
    function executeFullAbilityEffects(battle, abilityEffectDataByPhase) {
        var executedEffectsResult = {};
        [
            abilityEffectDataByPhase.beforeUse,
            abilityEffectDataByPhase.abilityEffects,
            abilityEffectDataByPhase.afterUse,
        ].forEach(function (effectDataForPhase) {
            effectDataForPhase.forEach(function (effectData) {
                executeAbilityEffectData(battle, effectData, executedEffectsResult);
            });
        });
    }
    function executeFullAbilityEffectsAndGetUseEffects(battle, abilityEffectDataByPhase) {
        var useEffects = [];
        var executedEffectsResult = {};
        [
            abilityEffectDataByPhase.beforeUse,
            abilityEffectDataByPhase.abilityEffects,
            abilityEffectDataByPhase.afterUse,
        ].forEach(function (effectDataForPhase) {
            effectDataForPhase.forEach(function (effectData) {
                var useEffect = executeAbilityEffectDataAndGetUseEffect(battle, effectData, executedEffectsResult);
                if (useEffect) {
                    useEffects.push(useEffect);
                }
            });
        });
        return useEffects;
    }
    function shouldEffectActionTrigger(abilityEffectData, battle, executedEffectsResult) {
        if (!abilityEffectData.trigger) {
            return true;
        }
        return abilityEffectData.trigger(abilityEffectData.user, abilityEffectData.target, battle, executedEffectsResult, abilityEffectData.sourceStatusEffect);
    }
    function executeAbilityEffectData(battle, abilityEffectData, executedEffectsResult) {
        if (!shouldEffectActionTrigger(abilityEffectData, battle, executedEffectsResult)) {
            return false;
        }
        abilityEffectData.effectTemplate.executeAction(abilityEffectData.user, abilityEffectData.target, battle, executedEffectsResult, abilityEffectData.sourceStatusEffect);
        return true;
    }
    function getIdForAbilityUseEffect(abilityEffectData) {
        var sourceString = "";
        if (abilityEffectData.sourceStatusEffect) {
            sourceString = abilityEffectData.sourceStatusEffect.template.type + ".";
        }
        else if (abilityEffectData.sourceAbility) {
            sourceString = abilityEffectData.sourceAbility.type + ".";
        }
        return "" + sourceString + abilityEffectData.effectTemplate.id;
    }
    function executeAbilityEffectDataAndGetUseEffect(battle, abilityEffectData, executedEffectsResult) {
        var didTriggerAction = executeAbilityEffectData(battle, abilityEffectData, executedEffectsResult);
        if (!didTriggerAction) {
            return null;
        }
        var unitDisplayData = {};
        unitDisplayData[abilityEffectData.user.id] = abilityEffectData.user.getDisplayData("battle");
        unitDisplayData[abilityEffectData.target.id] = abilityEffectData.target.getDisplayData("battle");
        return ({
            effectId: getIdForAbilityUseEffect(abilityEffectData),
            changedUnitDisplayDataById: unitDisplayData,
            sfx: abilityEffectData.effectTemplate.sfx,
            sfxUser: abilityEffectData.user,
            sfxTarget: abilityEffectData.target,
            newEvaluation: battle.getEvaluation(),
        });
    }
});
define("src/MCTreeNode", ["require", "exports", "src/activeModuleData", "src/battleAbilityTargeting", "src/battleAbilityUsage", "src/utility"], function (require, exports, activeModuleData_9, battleAbilityTargeting_1, battleAbilityUsage_1, utility_11) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MCTreeNode = (function () {
        function MCTreeNode(battle, move) {
            this.depth = 0;
            this.children = [];
            this.visits = 0;
            this.wins = 0;
            this.winRate = 0;
            this.totalScore = 0;
            this.averageScore = 0;
            this.uctIsDirty = true;
            this.battle = battle;
            this.sideId = battle.activeUnit.battleStats.side;
            this.move = move;
            this.isBetweenAI = battle.side1Player.isAI && battle.side2Player.isAI;
            this.currentScore = battle.getEvaluation();
        }
        MCTreeNode.prototype.getPossibleMoves = function () {
            if (!this.battle.activeUnit) {
                return [];
            }
            var targets = battleAbilityTargeting_1.getTargetsForAllAbilities(this.battle, this.battle.activeUnit);
            var actions = [];
            for (var id in targets) {
                var targetActions = targets[id];
                for (var i = 0; i < targetActions.length; i++) {
                    if (!this.isBetweenAI || !targetActions[i].disableInAIBattles) {
                        actions.push({
                            targetId: parseInt(id),
                            ability: targetActions[i],
                        });
                    }
                }
            }
            return actions;
        };
        MCTreeNode.prototype.addChild = function (possibleMovesIndex) {
            if (!this.possibleMoves) {
                this.possibleMoves = this.getPossibleMoves();
            }
            var move;
            if (isFinite(possibleMovesIndex)) {
                move = this.possibleMoves.splice(possibleMovesIndex, 1)[0];
            }
            else {
                move = this.possibleMoves.pop();
            }
            var battle = this.battle.makeVirtualClone();
            var child = new MCTreeNode(battle, move);
            child.parent = this;
            child.depth = this.depth + 1;
            this.children.push(child);
            battleAbilityUsage_1.useAbility(battle, move.ability, battle.activeUnit, battle.unitsById[move.targetId]);
            child.currentScore = battle.getEvaluation();
            battle.endTurn();
            return child;
        };
        MCTreeNode.prototype.getChildForMove = function (move) {
            for (var i = 0; i < this.children.length; i++) {
                var child = this.children[i];
                if (child.move.targetId === move.targetId &&
                    child.move.ability.type === move.ability.type) {
                    return child;
                }
            }
            if (!this.possibleMoves) {
                this.possibleMoves = this.getPossibleMoves();
            }
            for (var i = 0; i < this.possibleMoves.length; i++) {
                var possibleMove = this.possibleMoves[i];
                if (possibleMove.targetId === move.targetId &&
                    possibleMove.ability.type === move.ability.type) {
                    return this.addChild(i);
                }
            }
            return null;
        };
        MCTreeNode.prototype.updateResult = function (result) {
            this.visits++;
            this.totalScore += result;
            if (this.sideId === "side1") {
                if (result > 0)
                    this.wins++;
            }
            if (this.sideId === "side2") {
                if (result < 0)
                    this.wins++;
            }
            this.averageScore = this.totalScore / this.visits;
            this.winRate = this.wins / this.visits;
            this.uctIsDirty = true;
            if (this.parent)
                this.parent.updateResult(result);
        };
        MCTreeNode.prototype.pickRandomAbilityAndTarget = function (actions) {
            var prioritiesByAbilityAndTarget = {};
            for (var targetId in actions) {
                var abilities = actions[targetId];
                for (var i = 0; i < abilities.length; i++) {
                    var priority = isFinite(abilities[i].AIEvaluationPriority) ? abilities[i].AIEvaluationPriority : 1;
                    prioritiesByAbilityAndTarget["" + targetId + ":" + abilities[i].type] = priority;
                }
            }
            var selected = utility_11.getRandomKeyWithWeights(prioritiesByAbilityAndTarget);
            var separatorIndex = selected.indexOf(":");
            return ({
                targetId: parseInt(selected.slice(0, separatorIndex)),
                abilityType: selected.slice(separatorIndex + 1),
            });
        };
        MCTreeNode.prototype.simulateOnce = function (battle) {
            var actions = battleAbilityTargeting_1.getTargetsForAllAbilities(battle, battle.activeUnit);
            var targetData = this.pickRandomAbilityAndTarget(actions);
            var ability = activeModuleData_9.activeModuleData.Templates.Abilities[targetData.abilityType];
            var target = battle.unitsById[targetData.targetId];
            battleAbilityUsage_1.useAbility(battle, ability, battle.activeUnit, target);
            battle.endTurn();
        };
        MCTreeNode.prototype.simulateToEnd = function () {
            var battle = this.battle.makeVirtualClone();
            while (!battle.ended) {
                this.simulateOnce(battle);
            }
            this.updateResult(battle.getEvaluation());
        };
        MCTreeNode.prototype.clearResult = function () {
            this.visits = 0;
            this.wins = 0;
            this.averageScore = 0;
            this.totalScore = 0;
        };
        MCTreeNode.prototype.getCombinedScore = function () {
            var sign = this.sideId === "side1" ? 1 : -1;
            var baseScore = this.averageScore * sign / 2;
            var winRate = this.winRate;
            var aiAdjust = this.move.ability.AIScoreAdjust || 0;
            return (baseScore + winRate) + aiAdjust * 1.5;
        };
        MCTreeNode.prototype.setUct = function () {
            if (!this.parent) {
                this.uctEvaluation = -1;
                this.uctIsDirty = false;
                return;
            }
            this.uctEvaluation = this.getCombinedScore() + Math.sqrt(2 * Math.log(this.parent.visits) / this.visits);
            if (this.move.ability.AIEvaluationPriority) {
                this.uctEvaluation *= this.move.ability.AIEvaluationPriority;
            }
            this.uctIsDirty = false;
        };
        MCTreeNode.prototype.getHighestUctChild = function () {
            var highest = this.children[0];
            for (var i = 0; i < this.children.length; i++) {
                var child = this.children[i];
                if (child.uctIsDirty) {
                    child.setUct();
                }
                if (child.uctEvaluation > highest.uctEvaluation) {
                    highest = child;
                }
            }
            return highest;
        };
        MCTreeNode.prototype.getRecursiveBestUctChild = function () {
            if (this.battle.ended) {
                return this;
            }
            if (!this.possibleMoves) {
                this.possibleMoves = this.getPossibleMoves();
            }
            if (this.possibleMoves && this.possibleMoves.length > 0) {
                return this.addChild();
            }
            else if (this.children.length === 1) {
                return this.children[0];
            }
            else if (this.children.length > 1) {
                return this.getHighestUctChild().getRecursiveBestUctChild();
            }
            else {
                throw new Error("MCTreeNode has no children despite battle not having ended");
            }
        };
        return MCTreeNode;
    }());
    exports.default = MCTreeNode;
});
define("src/MCTree", ["require", "exports", "src/MCTreeNode"], function (require, exports, MCTreeNode_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MCTree = (function () {
        function MCTree(battle, sideId, fastMode) {
            if (fastMode === void 0) { fastMode = false; }
            var cloned = battle.makeVirtualClone();
            this.rootNode = new MCTreeNode_1.default(cloned);
            this.actualBattle = battle;
            this.sideId = sideId;
            if (fastMode) {
                this.countVisitsAsIterations = true;
            }
        }
        MCTree.prototype.sortByWinRateFN = function (a, b) {
            return b.winRate - a.winRate;
        };
        MCTree.prototype.sortByCombinedScoreFN = function (a, b) {
            if (a.sideId !== b.sideId)
                debugger;
            return b.getCombinedScore() - a.getCombinedScore();
        };
        MCTree.prototype.evaluate = function (iterations) {
            var root = this.rootNode;
            if (!root.possibleMoves)
                root.possibleMoves = root.getPossibleMoves();
            if (this.rootSimulationNeedsToBeRemade()) {
                this.remakeSimulation();
                root = this.rootNode;
            }
            var iterationStart = this.countVisitsAsIterations ? Math.min(iterations - 1, root.visits - root.depth) : 0;
            for (var i = iterationStart; i < iterations; i++) {
                var toSimulateFrom = root.getRecursiveBestUctChild();
                toSimulateFrom.simulateToEnd();
            }
            var sortedMoves = root.children.sort(this.sortByCombinedScoreFN.bind(this));
            var best = sortedMoves[0];
            if (!best) {
                debugger;
            }
            return best;
        };
        MCTree.prototype.getChildForMove = function (move) {
            return this.rootNode.getChildForMove(move);
        };
        MCTree.prototype.rootSimulationNeedsToBeRemade = function () {
            var scoreVariationTolerance = 0.1;
            var scoreVariance = Math.abs(this.actualBattle.getEvaluation() - this.rootNode.currentScore);
            if (scoreVariance > scoreVariationTolerance) {
                return true;
            }
            else if (this.actualBattle.activeUnit !== this.rootNode.battle.activeUnit) {
                return true;
            }
            else if (this.rootNode.children.length === 0) {
                if (!this.rootNode.possibleMoves) {
                    this.rootNode.possibleMoves = this.rootNode.getPossibleMoves();
                }
                if (this.rootNode.possibleMoves.length === 0) {
                    return true;
                }
            }
            return false;
        };
        MCTree.prototype.remakeSimulation = function () {
            this.rootNode = new MCTreeNode_1.default(this.actualBattle.makeVirtualClone());
            return this.rootNode;
        };
        MCTree.prototype.advanceMove = function (move) {
            this.rootNode = this.getChildForMove(move);
            if (!this.rootNode) {
                this.remakeSimulation();
            }
        };
        MCTree.prototype.getBestMoveAndAdvance = function (iterations) {
            var best = this.evaluate(iterations);
            this.rootNode = best;
            return best.move;
        };
        MCTree.prototype.printToConsole = function (nodes) {
            var consoleRows = [];
            for (var i = 0; i < nodes.length; i++) {
                var node = nodes[i];
                var row = {
                    visits: node.visits,
                    uctEvaluation: node.uctEvaluation,
                    winRate: node.winRate,
                    currentScore: node.currentScore,
                    averageScore: node.averageScore,
                    finalScore: node.getCombinedScore(),
                    abilityName: node.move.ability.displayName,
                    targetId: node.move.targetId,
                };
                consoleRows.push(row);
            }
            var _ = window;
            if (_.console.table) {
                _.console.table(consoleRows);
            }
            console.log(nodes);
        };
        return MCTree;
    }());
    exports.default = MCTree;
});
define("src/Options", ["require", "exports", "src/eventManager", "src/utility"], function (require, exports, eventManager_6, utility_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var OptionsCategories = [
        "battleAnimationTiming", "debug", "ui", "display",
    ];
    var defaultOptionsValues = {
        battleAnimationTiming: {
            before: 750,
            effectDuration: 1,
            after: 1500,
            unitEnter: 200,
            unitExit: 100,
            turnTransition: 1000,
        },
        debug: {
            enabled: false,
            battleSimulationDepth: 20,
        },
        ui: {
            noHamburger: false,
        },
        display: {
            borderWidth: 8,
        },
    };
    var Options = (function () {
        function Options() {
            this.setDefaults();
        }
        Options.prototype.setDefaultForCategory = function (category) {
            var shouldReRenderUI = false;
            var shouldReRenderMap = false;
            switch (category) {
                case "battleAnimationTiming":
                    this.battleAnimationTiming = utility_12.shallowCopy(defaultOptionsValues.battleAnimationTiming);
                    break;
                case "debug":
                    this.debug = utility_12.shallowCopy(defaultOptionsValues.debug);
                    if (this.debug.enabled !== defaultOptionsValues.debug.enabled) {
                        shouldReRenderUI = true;
                        shouldReRenderMap = true;
                    }
                    break;
                case "ui":
                    this.ui = utility_12.shallowCopy(defaultOptionsValues.ui);
                    break;
                case "display":
                    this.display = utility_12.shallowCopy(defaultOptionsValues.display);
                    if (this.display.borderWidth !== defaultOptionsValues.display.borderWidth) {
                        shouldReRenderMap = true;
                    }
                    break;
            }
            if (shouldReRenderUI) {
                eventManager_6.default.dispatchEvent("renderUI");
            }
            if (shouldReRenderMap) {
                eventManager_6.default.dispatchEvent("renderMap");
            }
        };
        Options.prototype.setDefaults = function () {
            var _this = this;
            OptionsCategories.forEach(function (category) {
                _this.setDefaultForCategory(category);
            });
        };
        Options.prototype.save = function (slot) {
            if (slot === void 0) { slot = 0; }
            var data = JSON.stringify({
                options: this.serialize(),
                date: new Date(),
            });
            var saveName = "Rance.Options." + slot;
            localStorage.setItem(saveName, data);
        };
        Options.prototype.load = function (slot) {
            this.setDefaults();
            var parsedData = this.getParsedDataForSlot(slot);
            var parsedOptions = this.serialize();
            if (parsedData) {
                var optionsToResetIfSetEarlierThan = {};
                var dateOptionsWereSaved = Date.parse(parsedData.date);
                for (var key in parsedData.options) {
                    if (parsedOptions[key] !== undefined) {
                        if (optionsToResetIfSetEarlierThan[key] && dateOptionsWereSaved <= optionsToResetIfSetEarlierThan[key]) {
                            console.log("Reset option: " + key);
                        }
                        else {
                            parsedOptions[key] = utility_12.deepMerge(parsedOptions[key], parsedData.options[key]);
                        }
                    }
                }
                this.deSerialize(parsedOptions);
            }
        };
        Options.prototype.getParsedDataForSlot = function (slot) {
            var baseString = "Rance.Options.";
            var parsedData;
            if (isFinite(slot)) {
                if (!localStorage[baseString + slot]) {
                    throw new Error("No options saved in that slot");
                }
                parsedData = JSON.parse(localStorage.getItem(baseString + slot));
            }
            else {
                parsedData = utility_12.getMatchingLocalstorageItemsByDate(baseString)[0];
            }
            return parsedData;
        };
        Options.prototype.serialize = function () {
            return ({
                battleAnimationTiming: this.battleAnimationTiming,
                debug: this.debug,
                ui: this.ui,
                display: this.display,
            });
        };
        Options.prototype.deSerialize = function (data) {
            this.battleAnimationTiming = utility_12.deepMerge(this.battleAnimationTiming, data.battleAnimationTiming, true);
            this.debug = utility_12.deepMerge(this.debug, data.debug, true);
            this.ui = utility_12.deepMerge(this.ui, data.ui, true);
            this.display = utility_12.deepMerge(this.display, data.display, true);
        };
        return Options;
    }());
    var options = new Options();
    exports.default = options;
});
define("src/BattleSimulator", ["require", "exports", "src/MCTree", "src/Options", "src/battleAbilityUsage"], function (require, exports, MCTree_1, Options_1, battleAbilityUsage_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BattleSimulator = (function () {
        function BattleSimulator(battle) {
            this.hasEnded = false;
            this.battle = battle;
            battle.isSimulated = true;
            if (!battle.ended) {
                this.tree = new MCTree_1.default(this.battle, this.battle.activeUnit.battleStats.side, true);
            }
        }
        BattleSimulator.prototype.simulateBattle = function () {
            while (!this.battle.ended) {
                this.simulateMove();
            }
        };
        BattleSimulator.prototype.simulateMove = function () {
            if (!this.battle.activeUnit || this.battle.ended) {
                throw new Error("Simulated battle already ended");
            }
            var move = this.tree.getBestMoveAndAdvance(Options_1.default.debug.battleSimulationDepth);
            var target = this.battle.unitsById[move.targetId];
            this.simulateAbility(move.ability, target);
            this.battle.endTurn();
        };
        BattleSimulator.prototype.simulateAbility = function (ability, target) {
            battleAbilityUsage_2.useAbility(this.battle, ability, this.battle.activeUnit, target);
        };
        BattleSimulator.prototype.finishBattle = function () {
            this.battle.finishBattle();
        };
        return BattleSimulator;
    }());
    exports.default = BattleSimulator;
});
define("src/PlayerTechnology", ["require", "exports", "src/activeModuleData", "src/eventManager"], function (require, exports, activeModuleData_10, eventManager_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PlayerTechnology = (function () {
        function PlayerTechnology(getResearchSpeed, raceTechnologyValues, savedData) {
            var _this = this;
            this.tempOverflowedResearchAmount = 0;
            this.getResearchSpeed = getResearchSpeed;
            this.technologies = {};
            raceTechnologyValues.forEach(function (raceValue) {
                var techKey = raceValue.tech.key;
                var technology = activeModuleData_10.activeModuleData.Templates.Technologies[techKey];
                _this.technologies[techKey] =
                    {
                        technology: technology,
                        totalResearch: 0,
                        level: 0,
                        maxLevel: raceValue.maxLevel,
                        priority: undefined,
                        priorityIsLocked: false,
                    };
                if (savedData && savedData[techKey]) {
                    _this.addResearchTowardsTechnology(technology, savedData[techKey].totalResearch);
                    _this.technologies[techKey].priority = savedData[techKey].priority;
                    _this.technologies[techKey].priorityIsLocked = savedData[techKey].priorityIsLocked;
                }
                else {
                    _this.technologies[techKey].level = raceValue.startingLevel;
                    _this.technologies[techKey].totalResearch =
                        _this.getResearchNeededForTechnologyLevel(raceValue.startingLevel);
                }
            });
            this.initPriorities();
        }
        PlayerTechnology.prototype.initPriorities = function () {
            var _this = this;
            var priorityToAllocate = 1;
            var techsToInit = [];
            for (var key in this.technologies) {
                var techData = this.technologies[key];
                if (techData.priority === undefined) {
                    techsToInit.push(techData.technology);
                }
                else {
                    priorityToAllocate -= techData.priority;
                }
            }
            techsToInit.sort(function (a, b) {
                return _this.technologies[b.key].maxLevel - _this.technologies[a.key].maxLevel;
            });
            while (techsToInit.length > 0) {
                var averagePriority = priorityToAllocate / techsToInit.length;
                var technology = techsToInit.pop();
                var maxNeededPriority = this.getMaxNeededPriority(technology);
                var priorityForTech = Math.min(averagePriority, maxNeededPriority);
                this.technologies[technology.key].priority = priorityForTech;
                priorityToAllocate -= priorityForTech;
            }
        };
        PlayerTechnology.prototype.allocateResearchPoints = function (amount, iteration) {
            if (iteration === void 0) { iteration = 0; }
            var totalPriority = 0;
            for (var key in this.technologies) {
                totalPriority += this.technologies[key].priority;
            }
            for (var key in this.technologies) {
                var techData = this.technologies[key];
                var relativePriority = techData.priority / totalPriority;
                if (relativePriority > 0) {
                    this.addResearchTowardsTechnology(techData.technology, relativePriority * amount);
                }
            }
            if (this.tempOverflowedResearchAmount) {
                if (iteration > 10) {
                    throw new RangeError("Maximum call stack size exceeded");
                }
                this.allocateOverflowedResearchPoints(iteration);
            }
            else {
                this.capTechnologyPrioritiesToMaxNeeded();
            }
        };
        PlayerTechnology.prototype.allocateOverflowedResearchPoints = function (iteration) {
            if (iteration === void 0) { iteration = 0; }
            var overflow = this.tempOverflowedResearchAmount;
            this.tempOverflowedResearchAmount = 0;
            this.allocateResearchPoints(overflow, ++iteration);
        };
        PlayerTechnology.prototype.getResearchNeededForTechnologyLevel = function (level) {
            if (level <= 0)
                return 0;
            if (level === 1)
                return 40;
            var a = 20;
            var b = 40;
            var swap;
            var total = 0;
            for (var i = 0; i < level; i++) {
                swap = a;
                a = b;
                b = swap + b;
                total += a;
            }
            return total;
        };
        PlayerTechnology.prototype.addResearchTowardsTechnology = function (technology, amount) {
            var tech = this.technologies[technology.key];
            var overflow = 0;
            if (tech.level >= tech.maxLevel) {
                return;
            }
            else {
                tech.totalResearch += amount;
                while (tech.level < tech.maxLevel &&
                    this.getResearchNeededForTechnologyLevel(tech.level + 1) <= tech.totalResearch) {
                    tech.level++;
                }
                if (tech.level === tech.maxLevel) {
                    var neededForMaxLevel = this.getResearchNeededForTechnologyLevel(tech.level);
                    overflow += tech.totalResearch - neededForMaxLevel;
                    tech.totalResearch -= overflow;
                    this.setTechnologyPriority(technology, 0, true);
                    tech.priorityIsLocked = true;
                }
            }
            this.tempOverflowedResearchAmount += overflow;
        };
        PlayerTechnology.prototype.getMaxNeededPriority = function (technology) {
            var tech = this.technologies[technology.key];
            var researchUntilMaxed = this.getResearchNeededForTechnologyLevel(tech.maxLevel) - tech.totalResearch;
            return researchUntilMaxed / this.getResearchSpeed();
        };
        PlayerTechnology.prototype.getOpenTechnologiesPriority = function () {
            var openPriority = 0;
            for (var key in this.technologies) {
                var techData = this.technologies[key];
                if (!techData.priorityIsLocked) {
                    openPriority += techData.priority;
                }
            }
            return openPriority;
        };
        PlayerTechnology.prototype.getRelativeOpenTechnologyPriority = function (technology) {
            var totalOpenPriority = this.getOpenTechnologiesPriority();
            if (this.technologies[technology.key].priorityIsLocked || !totalOpenPriority) {
                return 0;
            }
            return this.technologies[technology.key].priority / totalOpenPriority;
        };
        PlayerTechnology.prototype.setTechnologyPriority = function (technology, priority, force) {
            if (force === void 0) { force = false; }
            var remainingPriority = 1;
            var totalOtherPriority = 0;
            var totalOtherPriorityWasZero = false;
            var totalOthersCount = 0;
            for (var key in this.technologies) {
                if (key !== technology.key) {
                    if (this.technologies[key].priorityIsLocked) {
                        remainingPriority -= this.technologies[key].priority;
                    }
                    else {
                        totalOtherPriority += this.technologies[key].priority;
                        totalOthersCount++;
                    }
                }
            }
            if (totalOthersCount === 0) {
                if (force) {
                    this.technologies[technology.key].priority = priority;
                    eventManager_7.default.dispatchEvent("technologyPrioritiesUpdated");
                }
                return;
            }
            if (remainingPriority < 0.0001) {
                remainingPriority = 0;
            }
            if (priority > remainingPriority) {
                priority = remainingPriority;
            }
            var priorityNeededForMaxLevel = this.getMaxNeededPriority(technology);
            var maxNeededPriority = Math.min(priorityNeededForMaxLevel, priority);
            this.technologies[technology.key].priority = maxNeededPriority;
            remainingPriority -= maxNeededPriority;
            if (totalOtherPriority === 0) {
                totalOtherPriority = 1;
                totalOtherPriorityWasZero = true;
            }
            for (var key in this.technologies) {
                if (key !== technology.key && !this.technologies[key].priorityIsLocked) {
                    var techData = this.technologies[key];
                    if (totalOtherPriorityWasZero) {
                        techData.priority = 1 / totalOthersCount;
                    }
                    var maxNeededPriorityForOtherTech = this.getMaxNeededPriority(techData.technology);
                    var relativePriority = techData.priority / totalOtherPriority;
                    var reservedPriority = relativePriority * remainingPriority;
                    if (reservedPriority > maxNeededPriorityForOtherTech) {
                        techData.priority = maxNeededPriorityForOtherTech;
                        var priorityOverflow = reservedPriority - maxNeededPriorityForOtherTech;
                        remainingPriority += priorityOverflow;
                    }
                    else {
                        techData.priority = reservedPriority;
                    }
                }
            }
            eventManager_7.default.dispatchEvent("technologyPrioritiesUpdated");
        };
        PlayerTechnology.prototype.capTechnologyPrioritiesToMaxNeeded = function () {
            var overflowPriority = 0;
            for (var key in this.technologies) {
                var techData = this.technologies[key];
                var maxNeededPriorityForOtherTech = this.getMaxNeededPriority(techData.technology);
                if (techData.priority > maxNeededPriorityForOtherTech) {
                    overflowPriority += techData.priority - maxNeededPriorityForOtherTech;
                    this.setTechnologyPriority(techData.technology, maxNeededPriorityForOtherTech, true);
                    break;
                }
            }
        };
        PlayerTechnology.prototype.serialize = function () {
            var data = {};
            for (var key in this.technologies) {
                data[key] =
                    {
                        totalResearch: this.technologies[key].totalResearch,
                        priority: this.technologies[key].priority,
                        priorityIsLocked: this.technologies[key].priorityIsLocked,
                    };
            }
            return data;
        };
        return PlayerTechnology;
    }());
    exports.default = PlayerTechnology;
});
define("src/ValuesByStar", ["require", "exports", "src/IdDictionary"], function (require, exports, IdDictionary_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ValuesByStar = (function (_super) {
        __extends(ValuesByStar, _super);
        function ValuesByStar(stars, getValueFN) {
            return _super.call(this, stars, getValueFN) || this;
        }
        return ValuesByStar;
    }(IdDictionary_2.IdDictionary));
    exports.default = ValuesByStar;
});
define("src/Player", ["require", "exports", "src/AIController", "src/App", "src/activeModuleData", "src/BattlePrep", "src/BattleSimulator", "src/Flag", "src/Name", "src/Options", "src/PlayerTechnology", "src/ValuesByStar", "src/colorGeneration", "src/eventManager", "src/idGenerators", "src/utility"], function (require, exports, AIController_2, App_5, activeModuleData_11, BattlePrep_1, BattleSimulator_1, Flag_2, Name_3, Options_2, PlayerTechnology_1, ValuesByStar_1, colorGeneration_3, eventManager_8, idGenerators_6, utility_13) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Player = (function () {
        function Player(props) {
            this.units = [];
            this.resources = {};
            this.fleets = [];
            this.items = [];
            this.isAI = false;
            this.isIndependent = false;
            this.isDead = false;
            this.controlledLocations = [];
            this.visionIsDirty = true;
            this.visibleStars = {};
            this.revealedStars = {};
            this.detectedStars = {};
            this.identifiedUnits = {};
            this.tempOverflowedResearchAmount = 0;
            this.listeners = {};
            this.isAI = props.isAI;
            this.isIndependent = props.isIndependent;
            this.isDead = props.isDead || false;
            this.race = props.race;
            this.money = props.money;
            this.id = isFinite(props.id) ? props.id : idGenerators_6.default.player++;
            if (props.name) {
                if (typeof props.name === "string") {
                    var castedStringName = props.name;
                    this.name = new Name_3.default(castedStringName);
                }
                else {
                    var castedName = props.name;
                    this.name = castedName;
                }
            }
            else {
                this.name = new Name_3.default("Player " + this.id);
            }
            if (props.color) {
                this.color = props.color.main;
                this.secondaryColor = props.color.secondary || colorGeneration_3.generateSecondaryColor(this.color);
                this.colorAlpha = isFinite(props.color.alpha) ? props.color.alpha : 1;
            }
            else {
                var colorScheme = colorGeneration_3.generateColorScheme();
                this.color = colorScheme.main;
                this.secondaryColor = colorScheme.secondary;
                this.colorAlpha = 1;
            }
            if (props.flag) {
                this.flag = props.flag;
            }
            else {
                this.flag = this.makeRandomFlag();
            }
            if (props.resources) {
                this.resources = utility_13.extendObject(props.resources);
            }
            if (!this.isIndependent) {
                if (this.race.isNotPlayable) {
                    console.warn("Race " + this.race.displayName + " is marked as unplayable, but was assigned to player " + this.name);
                }
                this.initTechnologies(props.technologyData);
            }
        }
        Object.defineProperty(Player.prototype, "money", {
            get: function () {
                return this._money;
            },
            set: function (amount) {
                this._money = amount;
                if (!this.isAI) {
                    eventManager_8.default.dispatchEvent("playerMoneyUpdated");
                }
            },
            enumerable: true,
            configurable: true
        });
        Player.createDummyPlayer = function () {
            return new Player({
                isAI: false,
                isIndependent: false,
                id: -9999,
                name: "Dummy",
                race: {
                    type: null,
                    displayName: null,
                    description: null,
                    technologies: [],
                    distributionData: {
                        weight: 0,
                        distributionGroups: [],
                    },
                    getBuildableUnitTypes: function () { return []; },
                    getUnitName: function () { return ""; },
                    getUnitPortrait: function () { return null; },
                    generateIndependentPlayer: function () { return null; },
                    generateIndependentFleets: function () { return null; },
                    getAITemplateConstructor: function (player) { return null; },
                },
                money: 0,
            });
        };
        Player.prototype.destroy = function () {
            if (this.diplomacyStatus) {
                this.diplomacyStatus.destroy();
                this.diplomacyStatus = null;
            }
            this.AIController = null;
            for (var key in this.listeners) {
                eventManager_8.default.removeEventListener(key, this.listeners[key]);
            }
        };
        Player.prototype.shouldDie = function () {
            return this.controlledLocations.length === 0;
        };
        Player.prototype.die = function () {
            var _this = this;
            this.isDead = true;
            for (var i = this.fleets.length - 1; i >= 0; i--) {
                this.fleets[i].deleteFleet(false);
            }
            activeModuleData_11.activeModuleData.scripts.player.onDeath.forEach(function (script) {
                script(_this);
            });
        };
        Player.prototype.initTechnologies = function (savedData) {
            var race = this.race;
            this.playerTechnology = new PlayerTechnology_1.default(this.getResearchSpeed.bind(this), race.technologies, savedData);
            this.listeners["builtBuildingWithEffect_research"] = eventManager_8.default.addEventListener("builtBuildingWithEffect_research", this.playerTechnology.capTechnologyPrioritiesToMaxNeeded.bind(this.playerTechnology));
        };
        Player.prototype.makeRandomFlag = function (seed) {
            if (!this.color || !this.secondaryColor) {
                throw new Error("Player has no color specified");
            }
            var flag = new Flag_2.Flag(this.color);
            flag.addRandomEmblem(this.secondaryColor, seed);
            return flag;
        };
        Player.prototype.makeRandomAIController = function (game) {
            var race = this.race;
            var templateConstructor = race.getAITemplateConstructor(this);
            var template = templateConstructor.construct({
                player: this,
                game: game,
                personality: utility_13.makeRandomPersonality(),
            });
            return new AIController_2.AIController(template);
        };
        Player.prototype.addUnit = function (unit) {
            this.units.push(unit);
            this.identifyUnit(unit);
        };
        Player.prototype.removeUnit = function (toRemove) {
            var index = this.units.indexOf(toRemove);
            this.units.splice(index, 1);
        };
        Player.prototype.getFleetIndex = function (fleet) {
            return this.fleets.indexOf(fleet);
        };
        Player.prototype.addFleet = function (fleet) {
            if (this.getFleetIndex(fleet) >= 0) {
                return;
            }
            fleet.player = this;
            this.fleets.push(fleet);
            this.visionIsDirty = true;
        };
        Player.prototype.removeFleet = function (fleet) {
            var fleetIndex = this.getFleetIndex(fleet);
            if (fleetIndex < 0) {
                return;
            }
            this.fleets.splice(fleetIndex, 1);
            this.visionIsDirty = true;
        };
        Player.prototype.getFleetsWithPositions = function () {
            var positions = [];
            for (var i = 0; i < this.fleets.length; i++) {
                var fleet = this.fleets[i];
                positions.push({
                    position: fleet.location,
                    data: fleet,
                });
            }
            return positions;
        };
        Player.prototype.hasStar = function (star) {
            return (this.controlledLocations.indexOf(star) >= 0);
        };
        Player.prototype.addStar = function (star) {
            if (this.hasStar(star)) {
                throw new Error("Player " + this.name + " already has star " + star.name);
            }
            star.owner = this;
            this.controlledLocations.push(star);
            this.visionIsDirty = true;
        };
        Player.prototype.removeStar = function (star) {
            var index = this.controlledLocations.indexOf(star);
            if (index < 0) {
                throw new Error("Player " + this.name + " doesn't have star " + star.name);
            }
            star.owner = null;
            this.controlledLocations.splice(index, 1);
            this.visionIsDirty = true;
            if (this.shouldDie()) {
                this.die();
            }
        };
        Player.prototype.getIncome = function () {
            return this.controlledLocations.reduce(function (total, star) {
                return total + star.getIncome();
            }, 0);
        };
        Player.prototype.addResource = function (resource, amount) {
            if (!this.resources[resource.type]) {
                this.resources[resource.type] = 0;
            }
            this.resources[resource.type] += amount;
        };
        Player.prototype.getResourceIncome = function () {
            var incomeByResource = {};
            for (var i = 0; i < this.controlledLocations.length; i++) {
                var star = this.controlledLocations[i];
                var starIncome = star.getResourceIncome();
                if (!starIncome)
                    continue;
                if (!incomeByResource[starIncome.resource.type]) {
                    incomeByResource[starIncome.resource.type] =
                        {
                            resource: starIncome.resource,
                            amount: 0,
                        };
                }
                incomeByResource[starIncome.resource.type].amount += starIncome.amount;
            }
            return incomeByResource;
        };
        Player.prototype.getNeighboringStars = function () {
            var stars = {};
            for (var i = 0; i < this.controlledLocations.length; i++) {
                var currentOwned = this.controlledLocations[i];
                var frontier = currentOwned.getLinkedInRange(1).all;
                for (var j = 0; j < frontier.length; j++) {
                    if (stars[frontier[j].id]) {
                        continue;
                    }
                    else if (frontier[j].owner.id === this.id) {
                        continue;
                    }
                    else {
                        stars[frontier[j].id] = frontier[j];
                    }
                }
            }
            var allStars = [];
            for (var id in stars) {
                allStars.push(stars[id]);
            }
            return allStars;
        };
        Player.prototype.getNeighboringPlayers = function () {
            var alreadyAddedPlayersById = {};
            var neighboringStars = this.getNeighboringStars();
            neighboringStars.forEach(function (star) {
                alreadyAddedPlayersById[star.owner.id] = star.owner;
            });
            return Object.keys(alreadyAddedPlayersById).map(function (playerId) {
                return alreadyAddedPlayersById[playerId];
            });
        };
        Player.prototype.updateVisionInStar = function (star) {
            if (this.diplomacyStatus && this.diplomacyStatus.hasAnUnmetPlayer()) {
                this.meetPlayersInStarByVisibility(star, "visible");
            }
        };
        Player.prototype.updateDetectionInStar = function (star) {
            if (this.diplomacyStatus && this.diplomacyStatus.hasAnUnmetPlayer()) {
                this.meetPlayersInStarByVisibility(star, "stealthy");
            }
            var unitsToIdentify = star.getUnits();
            for (var i = 0; i < unitsToIdentify.length; i++) {
                this.identifyUnit(unitsToIdentify[i]);
            }
        };
        Player.prototype.updateAllVisibilityInStar = function (star) {
            if (this.starIsVisible(star)) {
                this.updateVisionInStar(star);
            }
            if (this.starIsDetected(star)) {
                this.updateDetectionInStar(star);
            }
        };
        Player.prototype.meetPlayersInStarByVisibility = function (star, visibility) {
            var presentPlayersByVisibility = star.getPresentPlayersByVisibility();
            for (var playerId in presentPlayersByVisibility[visibility]) {
                var player = presentPlayersByVisibility[visibility][playerId];
                this.diplomacyStatus.meetPlayerIfNeeded(player);
            }
        };
        Player.prototype.updateVisibleStars = function () {
            var previousVisibleStars = utility_13.extendObject(this.visibleStars);
            var previousDetectedStars = utility_13.extendObject(this.detectedStars);
            var newVisibleStars = [];
            var newDetectedStars = [];
            var visibilityHasChanged = false;
            var detectionHasChanged = false;
            this.visibleStars = {};
            this.detectedStars = {};
            var allVisible = [];
            var allDetected = [];
            for (var i = 0; i < this.controlledLocations.length; i++) {
                allVisible = allVisible.concat(this.controlledLocations[i].getVision());
                allDetected = allDetected.concat(this.controlledLocations[i].getDetection());
            }
            for (var i = 0; i < this.fleets.length; i++) {
                allVisible = allVisible.concat(this.fleets[i].getVisibleStars());
                allDetected = allDetected.concat(this.fleets[i].getDetectedStars());
            }
            for (var i = 0; i < allVisible.length; i++) {
                var star = allVisible[i];
                if (!this.visibleStars[star.id]) {
                    this.visibleStars[star.id] = star;
                    if (!previousVisibleStars[star.id]) {
                        visibilityHasChanged = true;
                        newVisibleStars.push(star);
                    }
                    if (!this.revealedStars[star.id]) {
                        this.revealedStars[star.id] = star;
                    }
                }
            }
            for (var i = 0; i < allDetected.length; i++) {
                var star = allDetected[i];
                if (!this.detectedStars[star.id]) {
                    this.detectedStars[star.id] = star;
                    if (!previousDetectedStars[star.id]) {
                        detectionHasChanged = true;
                        newDetectedStars.push(star);
                    }
                }
            }
            this.visionIsDirty = false;
            if (!visibilityHasChanged) {
                visibilityHasChanged = (Object.keys(this.visibleStars).length !==
                    Object.keys(previousVisibleStars).length);
            }
            if (!visibilityHasChanged && !detectionHasChanged) {
                detectionHasChanged = (Object.keys(this.detectedStars).length !==
                    Object.keys(previousDetectedStars).length);
            }
            for (var i = 0; i < newVisibleStars.length; i++) {
                this.updateVisionInStar(newVisibleStars[i]);
            }
            for (var i = 0; i < newDetectedStars.length; i++) {
                this.updateDetectionInStar(newDetectedStars[i]);
            }
            if (visibilityHasChanged && !this.isAI) {
                eventManager_8.default.dispatchEvent("renderMap");
            }
            if (detectionHasChanged && !this.isAI) {
                eventManager_8.default.dispatchEvent("renderLayer", "fleets");
            }
        };
        Player.prototype.getDebugVisibleStars = function () {
            if (this.controlledLocations.length > 0) {
                return this.controlledLocations[0].getAllLinkedStars();
            }
            else if (Object.keys(this.revealedStars).length > 0) {
                var initialStar = this.revealedStars[Object.keys(this.revealedStars)[0]];
                return initialStar.getAllLinkedStars();
            }
            else {
                return [];
            }
        };
        Player.prototype.getVisibleStars = function () {
            if (!this.isAI && Options_2.default.debug.enabled) {
                return this.getDebugVisibleStars();
            }
            if (this.visionIsDirty) {
                this.updateVisibleStars();
            }
            var visible = [];
            for (var id in this.visibleStars) {
                var star = this.visibleStars[id];
                visible.push(star);
            }
            return visible;
        };
        Player.prototype.getRevealedStars = function () {
            if (!this.isAI && Options_2.default.debug.enabled) {
                return this.getDebugVisibleStars();
            }
            if (this.visionIsDirty) {
                this.updateVisibleStars();
            }
            var toReturn = [];
            for (var id in this.revealedStars) {
                toReturn.push(this.revealedStars[id]);
            }
            return toReturn;
        };
        Player.prototype.getRevealedButNotVisibleStars = function () {
            if (this.visionIsDirty) {
                this.updateVisibleStars();
            }
            var toReturn = [];
            for (var id in this.revealedStars) {
                if (!this.visibleStars[id]) {
                    toReturn.push(this.revealedStars[id]);
                }
            }
            return toReturn;
        };
        Player.prototype.getDetectedStars = function () {
            if (!this.isAI && Options_2.default.debug.enabled) {
                return this.getDebugVisibleStars();
            }
            if (this.visionIsDirty) {
                this.updateVisibleStars();
            }
            var toReturn = [];
            for (var id in this.detectedStars) {
                toReturn.push(this.detectedStars[id]);
            }
            return toReturn;
        };
        Player.prototype.starIsVisible = function (star) {
            if (!this.isAI && Options_2.default.debug.enabled)
                return true;
            if (this.visionIsDirty) {
                this.updateVisibleStars();
            }
            return Boolean(this.visibleStars[star.id]);
        };
        Player.prototype.starIsRevealed = function (star) {
            if (!this.isAI && Options_2.default.debug.enabled)
                return true;
            if (this.visionIsDirty) {
                this.updateVisibleStars();
            }
            return Boolean(this.revealedStars[star.id]);
        };
        Player.prototype.starIsDetected = function (star) {
            if (!this.isAI && Options_2.default.debug.enabled)
                return true;
            if (this.visionIsDirty) {
                this.updateVisibleStars();
            }
            return Boolean(this.detectedStars[star.id]);
        };
        Player.prototype.getLinksToUnRevealedStars = function () {
            if (this.visionIsDirty) {
                this.updateVisibleStars();
            }
            var linksBySourceStar = new ValuesByStar_1.default();
            for (var starId in this.revealedStars) {
                var star = this.revealedStars[starId];
                var links = star.getAllLinks();
                for (var i = 0; i < links.length; i++) {
                    var linkedStar = links[i];
                    if (!this.revealedStars[linkedStar.id]) {
                        if (!linksBySourceStar.has(star)) {
                            linksBySourceStar.set(star, [linkedStar]);
                        }
                        else {
                            linksBySourceStar.get(star).push(linkedStar);
                        }
                    }
                }
            }
            return linksBySourceStar;
        };
        Player.prototype.identifyUnit = function (unit) {
            if (!this.identifiedUnits[unit.id]) {
                this.identifiedUnits[unit.id] = unit;
            }
        };
        Player.prototype.unitIsIdentified = function (unit) {
            if (Options_2.default.debug.enabled && !this.isAI) {
                return true;
            }
            else {
                return Boolean(this.identifiedUnits[unit.id]);
            }
        };
        Player.prototype.fleetIsFullyIdentified = function (fleet) {
            if (Options_2.default.debug.enabled && !this.isAI) {
                return true;
            }
            for (var i = 0; i < fleet.units.length; i++) {
                if (!this.identifiedUnits[fleet.units[i].id]) {
                    return false;
                }
            }
            return true;
        };
        Player.prototype.addItem = function (item) {
            this.items.push(item);
        };
        Player.prototype.removeItem = function (item) {
            var index = this.items.indexOf(item);
            if (index === -1) {
                throw new Error("Player " + this.name + " has no item " + item.id);
            }
            this.items.splice(index, 1);
        };
        Player.prototype.getNearestOwnedStarTo = function (star) {
            var self = this;
            var isOwnedByThisFN = function (star) {
                return star.owner === self;
            };
            return star.getNearestStarForQualifier(isOwnedByThisFN);
        };
        Player.prototype.attackTarget = function (location, target, battleFinishCallback) {
            var _this = this;
            var battleData = {
                location: location,
                building: target.building,
                attacker: {
                    player: this,
                    units: location.getUnits(function (player) { return player === _this; }),
                },
                defender: {
                    player: target.enemy,
                    units: target.units,
                },
            };
            var battlePrep = new BattlePrep_1.default(battleData);
            if (battlePrep.humanPlayer) {
                App_5.default.reactUI.battlePrep = battlePrep;
                if (battleFinishCallback) {
                    battlePrep.afterBattleFinishCallbacks.push(battleFinishCallback);
                }
                App_5.default.reactUI.switchScene("battlePrep");
            }
            else {
                var battle = battlePrep.makeBattle();
                battle.afterFinishCallbacks.push(battleFinishCallback);
                var simulator = new BattleSimulator_1.default(battle);
                simulator.simulateBattle();
                simulator.finishBattle();
            }
        };
        Player.prototype.getResearchSpeed = function () {
            var research = 0;
            research += activeModuleData_11.activeModuleData.ruleSet.research.baseResearchSpeed;
            for (var i = 0; i < this.controlledLocations.length; i++) {
                research += this.controlledLocations[i].getResearchPoints();
            }
            return research;
        };
        Player.prototype.getAllManufactories = function () {
            var manufactories = [];
            for (var i = 0; i < this.controlledLocations.length; i++) {
                if (this.controlledLocations[i].manufactory) {
                    manufactories.push(this.controlledLocations[i].manufactory);
                }
            }
            return manufactories;
        };
        Player.prototype.meetsTechnologyRequirements = function (requirements) {
            if (!this.playerTechnology) {
                return false;
            }
            for (var i = 0; i < requirements.length; i++) {
                var requirement = requirements[i];
                if (this.playerTechnology.technologies[requirement.technology.key].level < requirement.level) {
                    return false;
                }
            }
            return true;
        };
        Player.prototype.getGloballyBuildableUnits = function () {
            return this.race.getBuildableUnitTypes(this);
        };
        Player.prototype.getGloballyBuildableItems = function () {
            var itemTypes = [];
            for (var key in activeModuleData_11.activeModuleData.Templates.Items) {
                itemTypes.push(activeModuleData_11.activeModuleData.Templates.Items[key]);
            }
            return itemTypes;
        };
        Player.prototype.getManufacturingCapacityFor = function (template, type) {
            var totalCapacity = 0;
            var capacityByStar = [];
            var isGloballyBuildable;
            switch (type) {
                case "item":
                    {
                        var globallyBuildableItems = this.getGloballyBuildableItems();
                        isGloballyBuildable = globallyBuildableItems.indexOf(template) !== -1;
                        break;
                    }
                case "unit":
                    {
                        var globallyBuildableUnits = this.getGloballyBuildableUnits();
                        isGloballyBuildable = globallyBuildableUnits.indexOf(template) !== -1;
                        break;
                    }
            }
            var manufactories = this.getAllManufactories();
            for (var i = 0; i < manufactories.length; i++) {
                var manufactory = manufactories[i];
                var isBuildable = !manufactory.queueIsFull() &&
                    (isGloballyBuildable || manufactory.canManufactureThing(template, type));
                if (isBuildable) {
                    var capacity = manufactory.capacity - manufactory.buildQueue.length;
                    totalCapacity += capacity;
                    capacityByStar.push({
                        star: manufactory.star,
                        capacity: capacity,
                    });
                }
            }
            return totalCapacity;
        };
        Player.prototype.serialize = function () {
            var revealedStarIds = [];
            for (var id in this.revealedStars) {
                revealedStarIds.push(this.revealedStars[id].id);
            }
            var identifiedUnitIds = [];
            for (var id in this.identifiedUnits) {
                identifiedUnitIds.push(this.identifiedUnits[id].id);
            }
            var data = {
                id: this.id,
                name: this.name.serialize(),
                color: this.color.serialize(),
                colorAlpha: this.colorAlpha,
                secondaryColor: this.secondaryColor.serialize(),
                isIndependent: this.isIndependent,
                isAI: this.isAI,
                resources: utility_13.extendObject(this.resources),
                fleets: this.fleets.map(function (fleet) { return fleet.serialize(); }),
                money: this.money,
                controlledLocationIds: this.controlledLocations.map(function (star) { return star.id; }),
                itemIds: this.items.map(function (item) { return item.id; }),
                unitIds: this.units.map(function (unit) { return unit.id; }),
                revealedStarIds: revealedStarIds,
                identifiedUnitIds: identifiedUnitIds,
                raceKey: this.race.type,
                isDead: this.isDead,
                diplomacyStatus: this.diplomacyStatus ? this.diplomacyStatus.serialize() : null,
                researchByTechnology: this.playerTechnology ? this.playerTechnology.serialize() : null,
                flag: this.flag ? this.flag.serialize() : null,
                AIController: this.AIController ? this.AIController.serialize() : null,
            };
            return data;
        };
        return Player;
    }());
    exports.default = Player;
});
define("src/utility", ["require", "exports", "react", "src/activeModuleData"], function (require, exports, React, activeModuleData_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function randInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1) + min);
    }
    exports.randInt = randInt;
    function randRange(min, max) {
        return Math.random() * (max - min) + min;
    }
    exports.randRange = randRange;
    function getRandomArrayKey(target) {
        return Math.floor(Math.random() * (target.length));
    }
    exports.getRandomArrayKey = getRandomArrayKey;
    function getRandomArrayItem(target) {
        var _rnd = Math.floor(Math.random() * (target.length));
        return target[_rnd];
    }
    exports.getRandomArrayItem = getRandomArrayItem;
    function getSeededRandomArrayItem(array, rng) {
        var _rnd = Math.floor(rng.uniform() * array.length);
        return array[_rnd];
    }
    exports.getSeededRandomArrayItem = getSeededRandomArrayItem;
    function getRandomKey(target) {
        var _targetKeys = Object.keys(target);
        var _rnd = Math.floor(Math.random() * (_targetKeys.length));
        return _targetKeys[_rnd];
    }
    exports.getRandomKey = getRandomKey;
    function getObjectKeysSortedByValue(obj, order) {
        return Object.keys(obj).sort(function (a, b) {
            if (order === "asc") {
                return obj[a] - obj[b];
            }
            else
                return obj[b] - obj[a];
        });
    }
    exports.getObjectKeysSortedByValue = getObjectKeysSortedByValue;
    function getObjectKeysSortedByValueOfProp(obj, prop, order) {
        return Object.keys(obj).sort(function (a, b) {
            if (order === "asc") {
                return obj[a][prop] - obj[b][prop];
            }
            else
                return obj[b][prop] - obj[a][prop];
        });
    }
    exports.getObjectKeysSortedByValueOfProp = getObjectKeysSortedByValueOfProp;
    function sortObjectsByProperty(objects, prop, order) {
        return objects.sort(function (a, b) {
            if (order === "asc") {
                return a[prop] - b[prop];
            }
            else
                return b[prop] - a[prop];
        });
    }
    exports.sortObjectsByProperty = sortObjectsByProperty;
    function getRandomProperty(target) {
        var _rndProp = target[getRandomKey(target)];
        return _rndProp;
    }
    exports.getRandomProperty = getRandomProperty;
    function getAllPropertiesWithKey(target, keyToFind) {
        var matchingProperties = [];
        for (var key in target) {
            if (target[key][keyToFind]) {
                matchingProperties.push(target[key]);
            }
        }
        return matchingProperties;
    }
    exports.getAllPropertiesWithKey = getAllPropertiesWithKey;
    function getRandomPropertyWithKey(target, keyToFind) {
        var keys = Object.keys(target);
        while (keys.length > 0) {
            var key = getRandomArrayItem(keys);
            var prop = target[key];
            if (prop[keyToFind]) {
                return prop;
            }
            else {
                keys.splice(keys.indexOf(key), 1);
            }
        }
        return null;
    }
    exports.getRandomPropertyWithKey = getRandomPropertyWithKey;
    function getRandomKeyWithWeights(target) {
        var totalWeight = 0;
        for (var prop in target) {
            totalWeight += target[prop];
        }
        var selection = randRange(0, totalWeight);
        for (var prop in target) {
            selection -= target[prop];
            if (selection <= 0) {
                return prop;
            }
        }
        throw new Error();
    }
    exports.getRandomKeyWithWeights = getRandomKeyWithWeights;
    function getRandomArrayItemWithWeights(arr) {
        var totalWeight = 0;
        for (var i = 0; i < arr.length; i++) {
            totalWeight += arr[i].weight;
        }
        var selection = randRange(0, totalWeight);
        for (var i = 0; i < arr.length; i++) {
            selection -= arr[i].weight;
            if (selection <= 0) {
                return arr[i];
            }
        }
        throw new Error();
    }
    exports.getRandomArrayItemWithWeights = getRandomArrayItemWithWeights;
    function findItemWithKey(source, keyToFind, parentKey, _hasParentKey) {
        if (_hasParentKey === void 0) { _hasParentKey = false; }
        var hasParentKey = _hasParentKey;
        if (source[keyToFind]) {
            if (!parentKey || hasParentKey) {
                return source[keyToFind];
            }
        }
        ;
        for (var key in source) {
            if (key === parentKey) {
                hasParentKey = true;
            }
            if (source[key][keyToFind]) {
                if (!parentKey || hasParentKey) {
                    return source[key][keyToFind];
                }
            }
            else if (typeof source[key] === "object") {
                return findItemWithKey(source[key], keyToFind, parentKey, hasParentKey);
            }
        }
        return null;
    }
    exports.findItemWithKey = findItemWithKey;
    function getFrom2dArray(target, arr) {
        var result = [];
        for (var i = 0; i < arr.length; i++) {
            if ((arr[i] !== undefined) &&
                (arr[i][0] >= 0 && arr[i][0] < target.length) &&
                (arr[i][1] >= 0 && arr[i][1] < target[0].length)) {
                result.push(target[arr[i][0]][arr[i][1]]);
            }
            else {
                result.push(null);
            }
        }
        ;
        return result;
    }
    exports.getFrom2dArray = getFrom2dArray;
    function flatten2dArray(toFlatten) {
        var flattened = [];
        for (var i = 0; i < toFlatten.length; i++) {
            for (var j = 0; j < toFlatten[i].length; j++) {
                flattened.push(toFlatten[i][j]);
            }
        }
        return flattened;
    }
    exports.flatten2dArray = flatten2dArray;
    function reverseSide(side) {
        switch (side) {
            case "side1":
                {
                    return "side2";
                }
            case "side2":
                {
                    return "side1";
                }
            default:
                {
                    throw new Error("Invalid side");
                }
        }
    }
    exports.reverseSide = reverseSide;
    function sortByManufactoryCapacityFN(a, b) {
        var aLevel = (a.manufactory ? a.manufactory.capacity : -1);
        var bLevel = (b.manufactory ? b.manufactory.capacity : -1);
        if (bLevel !== aLevel) {
            return bLevel - aLevel;
        }
        var _a = a.name.toLowerCase();
        var _b = b.name.toLowerCase();
        if (_a > _b)
            return 1;
        else if (_a < _b)
            return -1;
        else
            return 0;
    }
    exports.sortByManufactoryCapacityFN = sortByManufactoryCapacityFN;
    function rectContains(rect, point) {
        var x = point.x;
        var y = point.y;
        var x1 = Math.min(rect.x1, rect.x2);
        var x2 = Math.max(rect.x1, rect.x2);
        var y1 = Math.min(rect.y1, rect.y2);
        var y2 = Math.max(rect.y1, rect.y2);
        return ((x >= x1 && x <= x2) &&
            (y >= y1 && y <= y2));
    }
    exports.rectContains = rectContains;
    function hexToString(hex) {
        hex = Math.round(hex);
        var converted = hex.toString(16);
        return "000000".substr(0, 6 - converted.length) + converted;
    }
    exports.hexToString = hexToString;
    function stringToHex(text) {
        if (text.charAt(0) === "#") {
            text = text.substring(1, 7);
        }
        return parseInt(text, 16);
    }
    exports.stringToHex = stringToHex;
    function drawElementToCanvas(toClone) {
        var canvas = document.createElement("canvas");
        canvas.width = toClone.width;
        canvas.height = toClone.height;
        var ctx = canvas.getContext("2d");
        ctx.drawImage(toClone, 0, 0);
        return canvas;
    }
    exports.drawElementToCanvas = drawElementToCanvas;
    function colorImageInPlayerColor(image, player) {
        var canvas = document.createElement("canvas");
        canvas.width = image.width;
        canvas.height = image.height;
        var ctx = canvas.getContext("2d");
        ctx.drawImage(image, 0, 0, image.width, image.height);
        ctx.globalCompositeOperation = "source-in";
        ctx.fillStyle = "#" + player.color.getHexString();
        ctx.fillRect(0, 0, image.width, image.height);
        return canvas.toDataURL();
    }
    exports.colorImageInPlayerColor = colorImageInPlayerColor;
    function extendObject(from, to, onlyExtendAlreadyPresent) {
        if (onlyExtendAlreadyPresent === void 0) { onlyExtendAlreadyPresent = false; }
        if (from == null || typeof from != "object")
            return from;
        if (from.constructor != Object && from.constructor != Array)
            return from;
        if (from.constructor == Date || from.constructor == RegExp || from.constructor == Function ||
            from.constructor == String || from.constructor == Number || from.constructor == Boolean)
            return new from.constructor(from);
        to = to || new from.constructor();
        var toIterateOver = onlyExtendAlreadyPresent ? to : from;
        for (var name_1 in toIterateOver) {
            if (!onlyExtendAlreadyPresent || from.hasOwnProperty(name_1)) {
                to[name_1] = extendObject(from[name_1], null);
            }
        }
        return to;
    }
    exports.extendObject = extendObject;
    function shallowCopy(toCopy) {
        return shallowExtend(toCopy);
    }
    exports.shallowCopy = shallowCopy;
    function shallowExtend() {
        var sources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            sources[_i] = arguments[_i];
        }
        var merged = {};
        sources.forEach(function (source) {
            for (var key in source) {
                merged[key] = source[key];
            }
        });
        return merged;
    }
    exports.shallowExtend = shallowExtend;
    function deepMerge(target, src, excludeKeysNotInTarget) {
        if (excludeKeysNotInTarget === void 0) { excludeKeysNotInTarget = false; }
        if (excludeKeysNotInTarget) {
            var merged = deepMerge(target, src, false);
            return deletePropertiesNotSharedWithTarget(merged, target);
        }
        var array = Array.isArray(src);
        var dst = array && [] || {};
        if (array) {
            target = target || [];
            dst = dst.concat(target);
            src.forEach(function (e, i) {
                if (typeof dst[i] === "undefined") {
                    dst[i] = e;
                }
                else if (typeof e === "object") {
                    dst[i] = deepMerge(target[i], e);
                }
                else {
                    if (target.indexOf(e) === -1) {
                        dst.push(e);
                    }
                }
            });
        }
        else {
            if (target && typeof target === "object") {
                Object.keys(target).forEach(function (key) {
                    dst[key] = target[key];
                });
            }
            Object.keys(src).forEach(function (key) {
                if (typeof src[key] !== "object" || !src[key]) {
                    dst[key] = src[key];
                }
                else {
                    if (!target[key]) {
                        dst[key] = src[key];
                    }
                    else {
                        dst[key] = deepMerge(target[key], src[key]);
                    }
                }
            });
        }
        return dst;
    }
    exports.deepMerge = deepMerge;
    function deletePropertiesNotSharedWithTarget(source, target) {
        var dst = {};
        for (var key in target) {
            if (typeof target[key] !== "object" || !target[key]) {
                dst[key] = source[key];
            }
            else {
                dst[key] = deletePropertiesNotSharedWithTarget(source[key], target[key]);
            }
        }
        return dst;
    }
    exports.deletePropertiesNotSharedWithTarget = deletePropertiesNotSharedWithTarget;
    function recursiveRemoveAttribute(parent, attribute) {
        parent.removeAttribute(attribute);
        for (var i = 0; i < parent.children.length; i++) {
            var child = parent.children[i];
            recursiveRemoveAttribute(child, attribute);
        }
    }
    exports.recursiveRemoveAttribute = recursiveRemoveAttribute;
    function clamp(value, min, max) {
        if (value < min)
            return min;
        else if (value > max)
            return max;
        else
            return value;
    }
    exports.clamp = clamp;
    function roundToNearestMultiple(value, multiple) {
        var resto = value % multiple;
        if (resto <= (multiple / 2)) {
            return value - resto;
        }
        else {
            return value + multiple - resto;
        }
    }
    exports.roundToNearestMultiple = roundToNearestMultiple;
    function getAngleBetweenDegrees(degA, degB) {
        var angle = Math.abs(degB - degA) % 360;
        var distance = Math.min(360 - angle, angle);
        return distance;
    }
    exports.getAngleBetweenDegrees = getAngleBetweenDegrees;
    function prettifyDate(date) {
        return ([
            [
                date.getDate(),
                date.getMonth() + 1,
                date.getFullYear().toString().slice(2, 4),
            ].join("/"),
            [
                date.getHours(),
                date.getMinutes().toString().length < 2 ? "0" + date.getMinutes() : date.getMinutes().toString(),
            ].join(":"),
        ].join(" "));
    }
    exports.prettifyDate = prettifyDate;
    function getMatchingLocalstorageItemsByDate(stringToMatch) {
        var allKeys = Object.keys(localStorage);
        var matchingItems = [];
        for (var i = 0; i < allKeys.length; i++) {
            if (allKeys[i].indexOf(stringToMatch) !== -1) {
                var item = localStorage.getItem(allKeys[i]);
                var parsed = JSON.parse(item);
                if (parsed.date) {
                    matchingItems.push(parsed);
                }
            }
        }
        matchingItems.sort(function (a, b) {
            return Date.parse(b.date) - Date.parse(a.date);
        });
        return matchingItems;
    }
    exports.getMatchingLocalstorageItemsByDate = getMatchingLocalstorageItemsByDate;
    function shuffleArray(toShuffle, seed) {
        var rng = new RNG(seed);
        var resultArray = toShuffle.slice(0);
        var i = resultArray.length;
        while (i > 0) {
            i--;
            var n = rng.random(0, i);
            var temp = resultArray[i];
            resultArray[i] = resultArray[n];
            resultArray[n] = temp;
        }
        return resultArray;
    }
    exports.shuffleArray = shuffleArray;
    function getRelativeValue(value, min, max, inverse) {
        if (inverse === void 0) { inverse = false; }
        if (inverse) {
            if (min === max)
                return 0;
            else {
                return 1 - ((value - min) / (max - min));
            }
        }
        else {
            if (min === max)
                return 1;
            else {
                return (value - min) / (max - min);
            }
        }
    }
    exports.getRelativeValue = getRelativeValue;
    function getRelativeWeightsFromObject(byCount, inverse) {
        var relativeWeights = {};
        var min = 0;
        var max;
        for (var prop in byCount) {
            var count = byCount[prop];
            max = isFinite(max) ? Math.max(max, count) : count;
        }
        for (var prop in byCount) {
            var count = byCount[prop];
            relativeWeights[prop] = getRelativeValue(count, min, max);
        }
        return relativeWeights;
    }
    exports.getRelativeWeightsFromObject = getRelativeWeightsFromObject;
    function getDropTargetAtLocation(x, y) {
        var dropTargets = document.getElementsByClassName("drop-target");
        var point = {
            x: x,
            y: y,
        };
        for (var i = 0; i < dropTargets.length; i++) {
            var node = dropTargets[i];
            var nodeBounds = node.getBoundingClientRect();
            var rect = {
                x1: nodeBounds.left,
                x2: nodeBounds.right,
                y1: nodeBounds.top,
                y2: nodeBounds.bottom,
            };
            if (rectContains(rect, point)) {
                return node;
            }
        }
        return null;
    }
    exports.getDropTargetAtLocation = getDropTargetAtLocation;
    function onDOMLoaded(onLoaded) {
        if (document.readyState === "interactive" || document.readyState === "complete") {
            onLoaded();
        }
        else {
            document.addEventListener("DOMContentLoaded", onLoaded);
        }
    }
    exports.onDOMLoaded = onDOMLoaded;
    function getItemsFromWeightedProbabilities(probabilities) {
        var allItems = [];
        if (probabilities.length === 0) {
            return allItems;
        }
        if (probabilities[0].weight) {
            var selected = getRandomArrayItemWithWeights(probabilities);
            var firstItem = selected.probabilityItems[0];
            if (firstItem.probabilityItems) {
                var probabilityItems = selected.probabilityItems;
                allItems = allItems.concat(getItemsFromWeightedProbabilities(probabilityItems));
            }
            else {
                var toAdd = selected.probabilityItems;
                allItems = allItems.concat(toAdd);
            }
        }
        else {
            for (var i = 0; i < probabilities.length; i++) {
                var selected = probabilities[i];
                if (Math.random() < selected.flatProbability) {
                    var firstItem = selected.probabilityItems[0];
                    if (firstItem.probabilityItems) {
                        var probabilityItems = selected.probabilityItems;
                        allItems = allItems.concat(getItemsFromWeightedProbabilities(probabilityItems));
                    }
                    else {
                        var toAdd = selected.probabilityItems;
                        allItems = allItems.concat(toAdd);
                    }
                }
            }
        }
        return allItems;
    }
    exports.getItemsFromWeightedProbabilities = getItemsFromWeightedProbabilities;
    function transformMat3(a, m) {
        var x = m[0] * a.x + m[3] * a.y + m[6];
        var y = m[1] * a.x + m[4] * a.y + m[7];
        return { x: x, y: y };
    }
    exports.transformMat3 = transformMat3;
    function findEasingFunctionHighPoint(easingFunction, resolution, maxIterations, startIndex, endIndex, iteration) {
        if (resolution === void 0) { resolution = 10; }
        if (maxIterations === void 0) { maxIterations = 4; }
        if (startIndex === void 0) { startIndex = 0; }
        if (endIndex === void 0) { endIndex = 1; }
        if (iteration === void 0) { iteration = 0; }
        if (iteration >= maxIterations) {
            return (startIndex + endIndex) / 2;
        }
        var highestValue;
        var highestValueIndex;
        var step = (endIndex - startIndex) / resolution;
        for (var i = 0; i < resolution; i++) {
            var currentIndex = startIndex + i * step;
            var currentValue = easingFunction(currentIndex);
            if (!isFinite(highestValue) || currentValue > highestValue) {
                highestValue = currentValue;
                highestValueIndex = currentIndex;
            }
        }
        return findEasingFunctionHighPoint(easingFunction, resolution, maxIterations, highestValueIndex - step / 2, highestValueIndex + step / 2, iteration + 1);
    }
    exports.findEasingFunctionHighPoint = findEasingFunctionHighPoint;
    function pointsEqual(p1, p2) {
        return (p1.x === p2.x && p1.y === p2.y);
    }
    exports.pointsEqual = pointsEqual;
    function makeRandomPersonality() {
        var unitCompositionPreference = {};
        for (var archetype in activeModuleData_12.activeModuleData.Templates.UnitArchetypes) {
            unitCompositionPreference[archetype] = Math.random();
        }
        return ({
            expansiveness: Math.random(),
            aggressiveness: Math.random(),
            friendliness: Math.random(),
            unitCompositionPreference: unitCompositionPreference,
        });
    }
    exports.makeRandomPersonality = makeRandomPersonality;
    function splitMultilineText(text) {
        if (Array.isArray(text)) {
            var returnArr = [];
            for (var i = 0; i < text.length; i++) {
                returnArr.push(text[i]);
                returnArr.push(React.DOM.br({
                    key: "" + i,
                }));
            }
            return returnArr;
        }
        else {
            return text;
        }
    }
    exports.splitMultilineText = splitMultilineText;
    function mergeReactAttributes() {
        var toMerge = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            toMerge[_i] = arguments[_i];
        }
        var merged = shallowExtend.apply(void 0, [{}].concat(toMerge));
        var stringProps = ["className", "id"];
        stringProps.forEach(function (prop) {
            var joined = toMerge.filter(function (attributes) {
                return Boolean(attributes[prop]);
            }).map(function (attributes) {
                return attributes[prop];
            }).join(" ");
            merged[prop] = joined;
        });
        return merged;
    }
    exports.mergeReactAttributes = mergeReactAttributes;
});
define("src/UnitAttributes", ["require", "exports", "src/utility"], function (require, exports, utility_14) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var UnitAttribute;
    (function (UnitAttribute) {
        UnitAttribute[UnitAttribute["Attack"] = 0] = "Attack";
        UnitAttribute[UnitAttribute["Defence"] = 1] = "Defence";
        UnitAttribute[UnitAttribute["Intelligence"] = 2] = "Intelligence";
        UnitAttribute[UnitAttribute["Speed"] = 3] = "Speed";
    })(UnitAttribute = exports.UnitAttribute || (exports.UnitAttribute = {}));
    var UnitAttributes = (function () {
        function UnitAttributes(initialAttributes) {
            for (var key in initialAttributes) {
                this[key] = initialAttributes[key];
            }
        }
        UnitAttributes.createBlank = function () {
            return new UnitAttributes({
                maxActionPoints: 0,
                attack: 0,
                defence: 0,
                intelligence: 0,
                speed: 0,
            });
        };
        UnitAttributes.squashAdjustments = function () {
            var toSquash = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                toSquash[_i] = arguments[_i];
            }
            var squashed = {};
            toSquash.forEach(function (adjustment) {
                for (var attribute in adjustment) {
                    if (!squashed[attribute]) {
                        squashed[attribute] = {};
                    }
                    if (adjustment[attribute].flat) {
                        if (!isFinite(squashed[attribute].flat)) {
                            squashed[attribute].flat = 0;
                        }
                        squashed[attribute].flat += adjustment[attribute].flat;
                    }
                    if (isFinite(adjustment[attribute].multiplier)) {
                        if (!isFinite(squashed[attribute].multiplier)) {
                            squashed[attribute].multiplier = 0;
                        }
                        squashed[attribute].multiplier += adjustment[attribute].multiplier;
                    }
                }
            });
            return squashed;
        };
        UnitAttributes.prototype.clone = function () {
            return new UnitAttributes(this);
        };
        UnitAttributes.prototype.applyAdjustment = function (adjustment) {
            for (var attribute in adjustment) {
                if (adjustment[attribute].flat) {
                    this[attribute] += adjustment[attribute].flat;
                }
                if (isFinite(adjustment[attribute].multiplier)) {
                    this[attribute] *= 1 + adjustment[attribute].multiplier;
                }
            }
            return this;
        };
        UnitAttributes.prototype.clamp = function (min, max) {
            var _this = this;
            this.forEachAttribute(function (attribute) {
                _this[attribute] = utility_14.clamp(_this[attribute], min, max);
            });
            return this;
        };
        UnitAttributes.prototype.getAdjustedAttributes = function () {
            var adjustments = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                adjustments[_i] = arguments[_i];
            }
            var squashedAdjustments = UnitAttributes.squashAdjustments.apply(UnitAttributes, adjustments);
            var cloned = this.clone();
            cloned.applyAdjustment(squashedAdjustments);
            return cloned;
        };
        UnitAttributes.prototype.getDifferenceBetween = function (toCompare) {
            return new UnitAttributes({
                maxActionPoints: this.maxActionPoints - toCompare.maxActionPoints,
                attack: this.attack - toCompare.attack,
                defence: this.defence - toCompare.defence,
                intelligence: this.intelligence - toCompare.intelligence,
                speed: this.speed - toCompare.speed,
            });
        };
        UnitAttributes.prototype.getAttributesTypesSortedForDisplay = function () {
            return ([
                "maxActionPoints",
                "attack",
                "defence",
                "intelligence",
                "speed",
            ]);
        };
        UnitAttributes.prototype.modifyValueByAttributes = function (base, modifierPerStat) {
            if (base === void 0) { base = 0; }
            if (modifierPerStat === void 0) { modifierPerStat = {}; }
            var totalFlat = base;
            var totalMultiplier = 1;
            for (var attribute in modifierPerStat) {
                var flatAdjustment = modifierPerStat[attribute].flat || 0;
                totalFlat += flatAdjustment * this[attribute];
                var multiplier = modifierPerStat[attribute].multiplier || 0;
                totalMultiplier += multiplier * this[attribute];
            }
            return totalFlat * totalMultiplier;
        };
        UnitAttributes.prototype.serialize = function () {
            return JSON.parse(JSON.stringify(this));
        };
        UnitAttributes.prototype.forEachAttribute = function (cb) {
            [
                "maxActionPoints",
                "attack",
                "defence",
                "intelligence",
                "speed",
            ].forEach(function (attribute) {
                cb(attribute);
            });
        };
        return UnitAttributes;
    }());
    exports.UnitAttributes = UnitAttributes;
});
define("src/StatusEffect", ["require", "exports", "src/idGenerators"], function (require, exports, idGenerators_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var StatusEffect = (function () {
        function StatusEffect(props) {
            this.turnsHasBeenActiveFor = 0;
            this.id = isFinite(props.id) ? props.id : idGenerators_7.default.statusEffect++;
            this.template = props.template;
            this.turnsToStayActiveFor = props.turnsToStayActiveFor;
            this.turnsHasBeenActiveFor = props.turnsHasBeenActiveFor || 0;
            this.sourceUnit = props.sourceUnit;
        }
        StatusEffect.prototype.clone = function () {
            var effect = new StatusEffect({
                template: this.template,
                turnsToStayActiveFor: this.turnsToStayActiveFor,
                turnsHasBeenActiveFor: this.turnsHasBeenActiveFor,
                id: this.id,
                sourceUnit: this.sourceUnit,
            });
            return effect;
        };
        StatusEffect.prototype.processTurnEnd = function () {
            this.turnsHasBeenActiveFor++;
        };
        StatusEffect.prototype.serialize = function () {
            return ({
                id: this.id,
                templateType: this.template.type,
                turnsToStayActiveFor: this.turnsToStayActiveFor,
                turnsHasBeenActiveFor: this.turnsHasBeenActiveFor,
                sourceUnitId: this.sourceUnit.id,
            });
        };
        return StatusEffect;
    }());
    exports.default = StatusEffect;
});
define("src/BattleTurnOrder", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BattleTurnOrder = (function () {
        function BattleTurnOrder() {
            this.allUnits = [];
            this.orderedUnits = [];
        }
        BattleTurnOrder.prototype.destroy = function () {
            this.allUnits = null;
            this.orderedUnits = null;
        };
        BattleTurnOrder.prototype.addUnit = function (unit) {
            if (this.hasUnit(unit)) {
                throw new Error("Unit " + unit.name + " is already part of turn order");
            }
            this.allUnits.push(unit);
            this.orderedUnits.push(unit);
        };
        BattleTurnOrder.prototype.update = function () {
            this.orderedUnits = this.allUnits.filter(BattleTurnOrder.turnOrderFilterFN);
            this.orderedUnits.sort(BattleTurnOrder.turnOrderSortFN);
        };
        BattleTurnOrder.prototype.getActiveUnit = function () {
            return this.orderedUnits[0];
        };
        BattleTurnOrder.prototype.getDisplayData = function () {
            return this.orderedUnits.map(BattleTurnOrder.getDisplayDataFromUnit);
        };
        BattleTurnOrder.prototype.getGhostIndex = function (ghostMoveDelay, ghostId) {
            for (var i = 0; i < this.orderedUnits.length; i++) {
                var unit = this.orderedUnits[i];
                var unitMoveDelay = unit.battleStats.moveDelay;
                if (ghostMoveDelay < unitMoveDelay) {
                    return i;
                }
                else if (ghostMoveDelay === unitMoveDelay && ghostId < unit.id) {
                    return i;
                }
            }
            return this.orderedUnits.length;
        };
        BattleTurnOrder.prototype.hasUnit = function (unit) {
            return this.allUnits.indexOf(unit) !== -1;
        };
        BattleTurnOrder.turnOrderFilterFN = function (unit) {
            if (unit.battleStats.currentActionPoints <= 0) {
                return false;
            }
            if (unit.currentHealth <= 0) {
                return false;
            }
            return true;
        };
        BattleTurnOrder.turnOrderSortFN = function (a, b) {
            if (a.battleStats.moveDelay !== b.battleStats.moveDelay) {
                return a.battleStats.moveDelay - b.battleStats.moveDelay;
            }
            else {
                return a.id - b.id;
            }
        };
        BattleTurnOrder.getDisplayDataFromUnit = function (unit) {
            return ({
                moveDelay: unit.battleStats.moveDelay,
                unit: unit,
                displayName: unit.name,
            });
        };
        return BattleTurnOrder;
    }());
    exports.default = BattleTurnOrder;
});
define("src/Camera", ["require", "exports", "src/centerCameraOnPosition", "src/eventManager", "src/utility"], function (require, exports, centerCameraOnPosition_1, eventManager_9, utility_15) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Camera = (function () {
        function Camera(container) {
            this.container = container;
            this.setSize = this.setSize.bind(this);
            this.setSize();
            this.addEventListeners();
            centerCameraOnPosition_1.registerActiveCamera(this);
        }
        Camera.prototype.destroy = function () {
            centerCameraOnPosition_1.registerActiveCamera(null);
            window.removeEventListener("resize", this.setSize);
            this.getBoundsObjectBoundsFN = null;
        };
        Camera.prototype.move = function (x, y) {
            this.container.pivot.set(x, y);
            this.clampEdges();
            this.onMove();
        };
        Camera.prototype.deltaMove = function (deltaX, deltaY) {
            this.move(this.container.pivot.x + deltaX, this.container.pivot.y + deltaY);
        };
        Camera.prototype.startScroll = function (position) {
            this.scrollPosition = { x: position.x, y: position.y };
        };
        Camera.prototype.scrollMove = function (position) {
            this.deltaMove((this.scrollPosition.x - position.x) / this.container.scale.x, (this.scrollPosition.y - position.y) / this.container.scale.y);
            this.scrollPosition = { x: position.x, y: position.y };
        };
        Camera.prototype.zoom = function (zoomAmount) {
            this.container.scale.set(zoomAmount, zoomAmount);
            this.onMove();
            this.onZoom();
        };
        Camera.prototype.deltaZoom = function (delta, scale) {
            if (delta === 0) {
                return;
            }
            var direction = delta < 0 ? "out" : "in";
            var adjDelta = 1 + Math.abs(delta) * scale;
            if (direction === "out") {
                this.zoom(this.container.scale.x / adjDelta);
            }
            else {
                this.zoom(this.container.scale.x * adjDelta);
            }
        };
        Camera.prototype.getCenterPosition = function () {
            return { x: this.container.pivot.x, y: this.container.pivot.y };
        };
        Camera.prototype.centerOnPosition = function (x, y) {
            this.container.pivot.set(x, y);
        };
        Camera.prototype.addEventListeners = function () {
            window.addEventListener("resize", this.setSize, false);
        };
        Camera.prototype.onMove = function () {
            eventManager_9.default.dispatchEvent("cameraMoved", this.container.position.x, this.container.position.y);
        };
        Camera.prototype.onZoom = function () {
            eventManager_9.default.dispatchEvent("cameraZoomed", this.container.scale.x);
        };
        Camera.prototype.setSize = function () {
            var container = document.getElementById("pixi-container");
            if (!container) {
                throw new Error("Camera has no container element");
            }
            var style = window.getComputedStyle(container, null);
            this.width = parseInt(style.width);
            this.height = parseInt(style.height);
            this.container.position.set(this.width / 2, this.height / 2);
        };
        Camera.prototype.clampEdges = function () {
            var bounds = this.getBoundsObjectBoundsFN();
            this.container.pivot.x = utility_15.clamp(this.container.pivot.x, bounds.x, bounds.x + bounds.width);
            this.container.pivot.y = utility_15.clamp(this.container.pivot.y, bounds.y, bounds.y + bounds.height);
        };
        return Camera;
    }());
    exports.default = Camera;
});
define("src/centerCameraOnPosition", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var activeCamera;
    var deferredPositionToCenterOn;
    function centerCameraOnPosition(position) {
        if (activeCamera) {
            activeCamera.centerOnPosition(position.x, position.y);
        }
        else {
            deferredPositionToCenterOn = { x: position.x, y: position.y };
        }
    }
    exports.centerCameraOnPosition = centerCameraOnPosition;
    function registerActiveCamera(camera) {
        activeCamera = camera;
        if (deferredPositionToCenterOn) {
            centerCameraOnPosition(deferredPositionToCenterOn);
        }
        deferredPositionToCenterOn = null;
    }
    exports.registerActiveCamera = registerActiveCamera;
});
define("src/Battle", ["require", "exports", "src/activeModuleData", "src/BattleTurnOrder", "src/UnitBattleSide", "src/centerCameraOnPosition", "src/eventManager", "src/utility"], function (require, exports, activeModuleData_13, BattleTurnOrder_1, UnitBattleSide_1, centerCameraOnPosition_2, eventManager_10, utility_16) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Battle = (function () {
        function Battle(props) {
            this.unitsById = {};
            this.unitsBySide = {
                side1: [],
                side2: [],
            };
            this.isVirtual = false;
            this.isSimulated = false;
            this.ended = false;
            this.afterFinishCallbacks = [];
            this.evaluation = {};
            this.side1 = props.side1;
            this.side1Player = props.side1Player;
            this.side2 = props.side2;
            this.side2Player = props.side2Player;
            this.battleData = props.battleData;
            this.turnOrder = new BattleTurnOrder_1.default();
        }
        Battle.prototype.init = function () {
            var self = this;
            UnitBattleSide_1.UnitBattleSides.forEach(function (sideId) {
                var side = self[sideId];
                for (var i = 0; i < side.length; i++) {
                    for (var j = 0; j < side[i].length; j++) {
                        if (side[i][j]) {
                            self.unitsById[side[i][j].id] = side[i][j];
                            self.unitsBySide[sideId].push(side[i][j]);
                            var pos = Battle.getAbsolutePositionFromSidePosition([i, j], sideId);
                            self.initUnit(side[i][j], sideId, pos);
                        }
                    }
                }
            });
            this.currentTurn = 0;
            this.maxTurns = 24;
            this.turnsLeft = this.maxTurns;
            this.updateTurnOrder();
            this.startHealth =
                {
                    side1: this.getTotalCurrentHealthForSide("side1"),
                    side2: this.getTotalCurrentHealthForSide("side2"),
                };
            if (this.shouldBattleEnd()) {
                this.endBattle();
            }
            else {
                this.shiftRowsIfNeeded();
            }
            this.triggerBattleStartAbilities();
        };
        Battle.prototype.forEachUnit = function (callBack) {
            for (var id in this.unitsById) {
                callBack(this.unitsById[id]);
            }
        };
        Battle.prototype.endTurn = function () {
            this.currentTurn++;
            this.turnsLeft--;
            this.updateTurnOrder();
            var shouldEnd = this.shouldBattleEnd();
            if (shouldEnd) {
                this.endBattle();
            }
            else {
                this.shiftRowsIfNeeded();
            }
        };
        Battle.prototype.getActivePlayer = function () {
            if (!this.activeUnit) {
                return null;
            }
            var side = this.activeUnit.battleStats.side;
            return this.getPlayerForSide(side);
        };
        Battle.prototype.initUnit = function (unit, side, position) {
            unit.resetBattleStats();
            unit.setBattlePosition(this, side, position);
            this.turnOrder.addUnit(unit);
            var isAttacking = this.battleData.attacker.units.indexOf(unit) !== -1;
            if (isAttacking) {
                unit.offensiveBattlesFoughtThisTurn += 1;
            }
        };
        Battle.prototype.triggerBattleStartAbilities = function () {
            var _this = this;
            this.forEachUnit(function (unit) {
                var passiveSkillsByPhase = unit.getPassiveSkillsByPhase();
                if (passiveSkillsByPhase.atBattleStart) {
                    var executedEffectsResult = {};
                    var skills = passiveSkillsByPhase.atBattleStart;
                    for (var i = 0; i < skills.length; i++) {
                        for (var j = 0; j < skills[i].atBattleStart.length; j++) {
                            var effect = skills[i].atBattleStart[j];
                            effect.executeAction(unit, unit, _this, executedEffectsResult, null);
                        }
                    }
                }
            });
        };
        Battle.prototype.getPlayerForSide = function (side) {
            if (side === "side1") {
                return this.side1Player;
            }
            else if (side === "side2") {
                return this.side2Player;
            }
            else {
                throw new Error("invalid side");
            }
        };
        Battle.prototype.getSideForPlayer = function (player) {
            if (this.side1Player === player) {
                return "side1";
            }
            else if (this.side2Player === player) {
                return "side2";
            }
            else {
                throw new Error("invalid player");
            }
        };
        Battle.prototype.getOtherPlayer = function (player) {
            if (player === this.side1Player) {
                return this.side2Player;
            }
            else if (player === this.side2Player) {
                return this.side1Player;
            }
            else {
                throw new Error("Invalid player");
            }
        };
        Battle.prototype.getRowByPosition = function (position) {
            var rowsPerSide = activeModuleData_13.activeModuleData.ruleSet.battle.rowsPerFormation;
            var side = position < rowsPerSide ? "side1" : "side2";
            var relativePosition = position % rowsPerSide;
            return this[side][relativePosition];
        };
        Battle.prototype.getAllUnits = function () {
            var allUnits = [];
            this.forEachUnit(function (unit) { return allUnits.push(unit); });
            return allUnits;
        };
        Battle.prototype.getUnitsForSide = function (side) {
            return this.unitsBySide[side].slice(0);
        };
        Battle.prototype.finishBattle = function (forcedVictor) {
            var _this = this;
            this.victor = forcedVictor || this.getVictor();
            this.loser = this.getOtherPlayer(this.victor);
            for (var i = 0; i < this.deadUnits.length; i++) {
                this.deadUnits[i].removeFromPlayer();
            }
            var experienceGainedPerSide = {
                side1: this.getExperienceGainedForSide("side1"),
                side2: this.getExperienceGainedForSide("side2"),
            };
            this.forEachUnit(function (unit) {
                unit.addExperience(experienceGainedPerSide[unit.battleStats.side]);
                unit.resetBattleStats();
                if (unit.currentHealth < Math.round(unit.maxHealth * 0.1)) {
                    unit.currentHealth = Math.round(unit.maxHealth * 0.1);
                }
                _this.side1Player.identifyUnit(unit);
                _this.side2Player.identifyUnit(unit);
            });
            if (this.victor) {
                this.capturedUnits.forEach(function (unit) {
                    activeModuleData_13.activeModuleData.scripts.unit.onCapture.forEach(function (script) {
                        script(unit, _this.loser, _this.victor);
                    });
                });
            }
            if (this.battleData.building) {
                if (this.victor) {
                    this.battleData.building.setController(this.victor);
                }
            }
            if (this.isSimulated) {
                eventManager_10.default.dispatchEvent("renderLayer", "fleets", this.battleData.location);
            }
            else {
                centerCameraOnPosition_2.centerCameraOnPosition(this.battleData.location);
                eventManager_10.default.dispatchEvent("selectFleets", []);
                eventManager_10.default.dispatchEvent("switchScene", "galaxyMap");
            }
            activeModuleData_13.activeModuleData.scripts.battle.battleFinish.forEach(function (script) {
                script(_this);
            });
            for (var i = 0; i < this.afterFinishCallbacks.length; i++) {
                this.afterFinishCallbacks[i]();
            }
        };
        Battle.prototype.getVictor = function () {
            var evaluation = this.getEvaluation();
            if (evaluation > 0) {
                return this.side1Player;
            }
            else if (evaluation < 0) {
                return this.side2Player;
            }
            else {
                return this.battleData.defender.player;
            }
        };
        Battle.prototype.getCapturedUnits = function (victor, maxCapturedUnits) {
            if (!victor || victor.isIndependent) {
                return [];
            }
            var winningSide = this.getSideForPlayer(victor);
            var losingSide = utility_16.reverseSide(winningSide);
            var losingUnits = this.getUnitsForSide(losingSide);
            losingUnits.sort(function (a, b) {
                var captureChanceSort = b.battleStats.captureChance - a.battleStats.captureChance;
                if (captureChanceSort) {
                    return captureChanceSort;
                }
                else {
                    return utility_16.randInt(0, 1) * 2 - 1;
                }
            });
            var capturedUnits = [];
            for (var i = 0; i < losingUnits.length; i++) {
                if (capturedUnits.length >= maxCapturedUnits) {
                    break;
                }
                var unit = losingUnits[i];
                if (unit.currentHealth <= 0 &&
                    Math.random() <= unit.battleStats.captureChance) {
                    capturedUnits.push(unit);
                }
            }
            return capturedUnits;
        };
        Battle.prototype.getUnitDeathChance = function (unit, victor) {
            var player = unit.fleet.player;
            var deathChance;
            if (player.isIndependent) {
                deathChance = activeModuleData_13.activeModuleData.ruleSet.battle.independentUnitDeathChance;
            }
            else if (player.isAI) {
                deathChance = activeModuleData_13.activeModuleData.ruleSet.battle.aiUnitDeathChance;
            }
            else {
                deathChance = activeModuleData_13.activeModuleData.ruleSet.battle.humanUnitDeathChance;
            }
            var playerDidLose = (victor && player !== victor);
            if (playerDidLose) {
                deathChance += activeModuleData_13.activeModuleData.ruleSet.battle.loserUnitExtraDeathChance;
            }
            return deathChance;
        };
        Battle.prototype.getDeadUnits = function (capturedUnits, victor) {
            var _this = this;
            var deadUnits = [];
            this.forEachUnit(function (unit) {
                if (unit.currentHealth <= 0) {
                    var wasCaptured = capturedUnits.indexOf(unit) >= 0;
                    if (!wasCaptured) {
                        var deathChance = _this.getUnitDeathChance(unit, victor);
                        if (Math.random() < deathChance) {
                            deadUnits.push(unit);
                        }
                    }
                }
            });
            return deadUnits;
        };
        Battle.prototype.getUnitValueForExperienceGainedCalculation = function (unit) {
            return unit.level + 1;
        };
        Battle.prototype.getSideValueForExperienceGainedCalculation = function (side) {
            var _this = this;
            return this.getUnitsForSide(side).map(function (unit) {
                return _this.getUnitValueForExperienceGainedCalculation(unit);
            }).reduce(function (total, value) {
                return total + value;
            }, 0);
        };
        Battle.prototype.getExperienceGainedForSide = function (side) {
            var ownSideValue = this.getSideValueForExperienceGainedCalculation(side);
            var enemySideValue = this.getSideValueForExperienceGainedCalculation(utility_16.reverseSide(side));
            return (enemySideValue / ownSideValue) * 10;
        };
        Battle.prototype.shouldBattleEnd = function () {
            if (!this.activeUnit) {
                return true;
            }
            if (this.turnsLeft <= 0) {
                return true;
            }
            if (this.getTotalCurrentHealthForSide("side1") <= 0 ||
                this.getTotalCurrentHealthForSide("side2") <= 0) {
                return true;
            }
            return false;
        };
        Battle.prototype.endBattle = function () {
            this.ended = true;
            if (this.isVirtual) {
                return;
            }
            this.activeUnit = null;
            var victor = this.getVictor();
            var maxCapturedUnits = activeModuleData_13.activeModuleData.ruleSet.battle.baseMaxCapturedUnits;
            this.capturedUnits = this.getCapturedUnits(victor, maxCapturedUnits);
            this.deadUnits = this.getDeadUnits(this.capturedUnits, victor);
        };
        Battle.prototype.getEvaluation = function () {
            var _this = this;
            var evaluation = 0;
            UnitBattleSide_1.UnitBattleSides.forEach(function (side) {
                var sign = side === "side1" ? 1 : -1;
                var currentHealth = _this.getTotalCurrentHealthForSide(side);
                if (currentHealth <= 0) {
                    evaluation -= 999 * sign;
                    return;
                }
                var currentHealthFactor = currentHealth / _this.startHealth[side];
                _this.getUnitsForSide(side).forEach(function (unit) {
                    if (unit.currentHealth <= 0) {
                        evaluation -= 0.2 * sign;
                    }
                });
                var defenderMultiplier = 1;
                if (_this.battleData.building) {
                    var template = _this.battleData.building.template;
                    var isDefender = _this.battleData.defender.player === _this.getPlayerForSide(side);
                    if (isDefender) {
                        defenderMultiplier += template.defenderAdvantage;
                    }
                }
                evaluation += currentHealthFactor * defenderMultiplier * sign;
            });
            evaluation = utility_16.clamp(evaluation, -1, 1);
            this.evaluation[this.currentTurn] = evaluation;
            return this.evaluation[this.currentTurn];
        };
        Battle.prototype.getTotalCurrentHealthForRow = function (position) {
            return this.getRowByPosition(position).map(function (unit) {
                return unit ? unit.currentHealth : 0;
            }).reduce(function (total, value) {
                return total + value;
            }, 0);
        };
        Battle.prototype.getTotalCurrentHealthForSide = function (side) {
            return this.getUnitsForSide(side).map(function (unit) { return unit.currentHealth; }).reduce(function (total, value) {
                return total + value;
            }, 0);
        };
        Battle.getAbsolutePositionFromSidePosition = function (relativePosition, side) {
            if (side === "side1") {
                return relativePosition;
            }
            else {
                var rowsPerSide = activeModuleData_13.activeModuleData.ruleSet.battle.rowsPerFormation;
                return [relativePosition[0] + rowsPerSide, relativePosition[1]];
            }
        };
        Battle.prototype.updateBattlePositions = function (side) {
            var units = this[side];
            for (var i = 0; i < units.length; i++) {
                var row = this[side][i];
                for (var j = 0; j < row.length; j++) {
                    var pos = Battle.getAbsolutePositionFromSidePosition([i, j], side);
                    var unit = row[j];
                    if (unit) {
                        unit.setBattlePosition(this, side, pos);
                    }
                }
            }
        };
        Battle.prototype.shiftRowsForSide = function (side) {
            var formation = this[side];
            if (side === "side1") {
                formation.reverse();
            }
            var nextHealthyRowIndex;
            for (var i = 1; i < formation.length; i++) {
                var absoluteRow = side === "side1" ? i : i + activeModuleData_13.activeModuleData.ruleSet.battle.rowsPerFormation;
                if (this.getTotalCurrentHealthForRow(absoluteRow) > 0) {
                    nextHealthyRowIndex = i;
                    break;
                }
            }
            if (!isFinite(nextHealthyRowIndex)) {
                throw new Error("Tried to shift battle rows when all rows are defeated");
            }
            var rowsToShift = formation.splice(0, nextHealthyRowIndex);
            formation = formation.concat(rowsToShift);
            if (side === "side1") {
                formation.reverse();
            }
            this[side] = formation;
            this.updateBattlePositions(side);
        };
        Battle.prototype.shiftRowsIfNeeded = function () {
            var rowsPerSide = activeModuleData_13.activeModuleData.ruleSet.battle.rowsPerFormation;
            var side1FrontRowHealth = this.getTotalCurrentHealthForRow(rowsPerSide - 1);
            if (side1FrontRowHealth <= 0) {
                this.shiftRowsForSide("side1");
            }
            var side2FrontRowHealth = this.getTotalCurrentHealthForRow(rowsPerSide);
            if (side2FrontRowHealth <= 0) {
                this.shiftRowsForSide("side2");
            }
        };
        Battle.prototype.makeVirtualClone = function () {
            var battleData = this.battleData;
            function cloneUnits(units) {
                var clones = [];
                for (var i = 0; i < units.length; i++) {
                    var row = [];
                    for (var j = 0; j < units[i].length; j++) {
                        var unit = units[i][j];
                        if (!unit) {
                            row.push(unit);
                        }
                        else {
                            row.push(unit.makeVirtualClone());
                        }
                    }
                    clones.push(row);
                }
                return clones;
            }
            var side1 = cloneUnits(this.side1);
            var side2 = cloneUnits(this.side2);
            var side1Player = this.side1Player;
            var side2Player = this.side2Player;
            var clone = new Battle({
                battleData: battleData,
                side1: side1,
                side2: side2,
                side1Player: side1Player,
                side2Player: side2Player,
            });
            [side1, side2].forEach(function (side) {
                for (var i = 0; i < side.length; i++) {
                    for (var j = 0; j < side[i].length; j++) {
                        if (!side[i][j]) {
                            continue;
                        }
                        clone.turnOrder.addUnit(side[i][j]);
                        clone.unitsById[side[i][j].id] = side[i][j];
                        clone.unitsBySide[side[i][j].battleStats.side].push(side[i][j]);
                    }
                }
            });
            clone.isVirtual = true;
            clone.currentTurn = this.currentTurn;
            clone.maxTurns = this.maxTurns;
            clone.turnsLeft = this.turnsLeft;
            clone.startHealth = this.startHealth;
            clone.updateTurnOrder();
            if (clone.shouldBattleEnd()) {
                clone.endBattle();
            }
            else {
                clone.shiftRowsIfNeeded();
            }
            return clone;
        };
        Battle.prototype.updateTurnOrder = function () {
            this.turnOrder.update();
            this.activeUnit = this.turnOrder.getActiveUnit();
        };
        return Battle;
    }());
    exports.default = Battle;
});
define("src/ModuleScripts", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ModuleScripts = (function () {
        function ModuleScripts() {
            this.scriptsWithData = {
                battle: {
                    battleFinish: [],
                },
                diplomacy: {
                    onWarDeclaration: [],
                },
                game: {
                    afterInit: [],
                },
                player: {
                    onDeath: [],
                },
                unit: {
                    removeFromPlayer: [],
                    onCapture: [],
                },
            };
            this.battle = ModuleScripts.makeAccessorObject(this.scriptsWithData.battle);
            this.diplomacy = ModuleScripts.makeAccessorObject(this.scriptsWithData.diplomacy);
            this.game = ModuleScripts.makeAccessorObject(this.scriptsWithData.game);
            this.player = ModuleScripts.makeAccessorObject(this.scriptsWithData.player);
            this.unit = ModuleScripts.makeAccessorObject(this.scriptsWithData.unit);
        }
        ModuleScripts.merge = function () {
            var toMerge = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                toMerge[_i] = arguments[_i];
            }
            var merged = new ModuleScripts();
            toMerge.forEach(function (moduleScripts) {
                merged.add(moduleScripts.scriptsWithData);
            });
            return merged;
        };
        ModuleScripts.sort = function (a, b) {
            return b.priority - a.priority;
        };
        ModuleScripts.makeAccessorObject = function (scriptsWithData) {
            var accessorObject = {};
            var _loop_2 = function (scriptKey) {
                Object.defineProperty(accessorObject, scriptKey, {
                    get: function () { return scriptsWithData[scriptKey].sort(ModuleScripts.sort).map(function (scriptData) { return scriptData.script; }); },
                });
            };
            for (var scriptKey in scriptsWithData) {
                _loop_2(scriptKey);
            }
            return accessorObject;
        };
        ModuleScripts.prototype.add = function () {
            var _this = this;
            var allScriptData = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                allScriptData[_i] = arguments[_i];
            }
            allScriptData.forEach(function (toAdd) {
                for (var category in toAdd) {
                    for (var scriptKey in toAdd[category]) {
                        (_a = _this.scriptsWithData[category][scriptKey]).push.apply(_a, toAdd[category][scriptKey]);
                    }
                }
                var _a;
            });
        };
        ModuleScripts.prototype.remove = function (toRemove) {
            var _loop_3 = function (category) {
                var _loop_4 = function (scriptKey) {
                    this_1.scriptsWithData[category][scriptKey] =
                        this_1.scriptsWithData[category][scriptKey].filter(function (scriptData) {
                            return toRemove[category][scriptKey].indexOf(scriptData) !== -1;
                        });
                };
                for (var scriptKey in toRemove[category]) {
                    _loop_4(scriptKey);
                }
            };
            var this_1 = this;
            for (var category in toRemove) {
                _loop_3(category);
            }
        };
        return ModuleScripts;
    }());
    exports.default = ModuleScripts;
});
define("src/ModuleData", ["require", "exports", "src/ModuleScripts", "src/utility"], function (require, exports, ModuleScripts_1, utility_17) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ModuleData = (function () {
        function ModuleData() {
            this.moduleFiles = [];
            this.Templates = {
                Abilities: {},
                AITemplateConstructors: {},
                AttitudeModifiers: {},
                BattleSFX: {},
                Buildings: {},
                Items: {},
                MapGen: {},
                MapRendererLayers: {},
                MapRendererMapModes: {},
                Notifications: {},
                PassiveSkills: {},
                Personalities: {},
                Portraits: {},
                Races: {},
                Resources: {},
                StatusEffects: {},
                SubEmblems: {},
                Technologies: {},
                UnitArchetypes: {},
                Units: {},
            };
            this.ruleSet = {};
            this.scripts = new ModuleScripts_1.default();
        }
        ModuleData.prototype.copyTemplates = function (source, category) {
            if (!this.Templates[category]) {
                console.warn("Tried to copy templates in invalid category \"" + category +
                    "\". Category must be one of: " + Object.keys(this.Templates).join(", "));
                return;
            }
            for (var templateType in source) {
                if (this.Templates[category][templateType]) {
                    console.warn("Duplicate template identifier for " + templateType + " in " + category);
                    continue;
                }
                this.Templates[category][templateType] = source[templateType];
            }
        };
        ModuleData.prototype.copyAllTemplates = function (source) {
            for (var category in this.Templates) {
                if (source[category]) {
                    this.copyTemplates(source[category], category);
                }
            }
        };
        ModuleData.prototype.addSubModule = function (moduleFile) {
            this.moduleFiles.push(moduleFile);
        };
        ModuleData.prototype.getDefaultMap = function () {
            if (this.defaultMap) {
                return this.defaultMap;
            }
            else if (Object.keys(this.Templates.MapGen).length > 0) {
                return utility_17.getRandomProperty(this.Templates.MapGen);
            }
            else {
                throw new Error("No modules have map generators registered.");
            }
        };
        ModuleData.prototype.applyRuleSet = function (ruleSetValuesToCopy) {
            this.ruleSet = utility_17.deepMerge(this.ruleSet, ruleSetValuesToCopy);
        };
        return ModuleData;
    }());
    exports.default = ModuleData;
});
define("src/activeModuleData", ["require", "exports", "src/ModuleData"], function (require, exports, ModuleData_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.activeModuleData = new ModuleData_1.default();
});
define("src/Star", ["require", "exports", "src/App", "src/activeModuleData", "src/activePlayer", "src/Manufactory", "src/eventManager", "src/idGenerators", "src/pathFinding"], function (require, exports, App_6, activeModuleData_14, activePlayer_3, Manufactory_2, eventManager_11, idGenerators_8, pathFinding_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Star = (function () {
        function Star(props) {
            this.linksTo = [];
            this.linksFrom = [];
            this.fleets = {};
            this.buildings = {};
            this.buildingsEffectIsDirty = true;
            this.indexedNeighborsInRange = {};
            this.indexedDistanceToStar = {};
            this.x = props.x;
            this.y = props.y;
            this.id = isFinite(props.id) ? props.id : idGenerators_8.default.star++;
            this.name = props.name || "Star " + this.id;
            this.race = props.race;
        }
        Star.getIslandForQualifier = function (initialStars, earlyReturnSize, qualifier) {
            var visited = {};
            var connected = {};
            var sizeFound = 1;
            var frontier = initialStars.slice(0);
            initialStars.forEach(function (star) {
                visited[star.id] = true;
            });
            while (frontier.length > 0) {
                var current = frontier.pop();
                connected[current.id] = current;
                var neighbors = current.getLinkedInRange(1).all;
                for (var i = 0; i < neighbors.length; i++) {
                    var neighbor = neighbors[i];
                    if (visited[neighbor.id]) {
                        continue;
                    }
                    visited[neighbor.id] = true;
                    if (qualifier(current, neighbor)) {
                        sizeFound++;
                        frontier.push(neighbor);
                    }
                }
                if (earlyReturnSize && sizeFound >= earlyReturnSize) {
                    for (var i = 0; i < frontier.length; i++) {
                        connected[frontier[i].id] = frontier[i];
                    }
                    break;
                }
            }
            var island = [];
            for (var starId in connected) {
                island.push(connected[starId]);
            }
            return island;
        };
        Star.prototype.addBuilding = function (building) {
            if (!this.buildings[building.template.category]) {
                this.buildings[building.template.category] = [];
            }
            var buildings = this.buildings[building.template.category];
            if (buildings.indexOf(building) >= 0) {
                throw new Error("Already has building");
            }
            buildings.push(building);
            this.buildingsEffectIsDirty = true;
            if (building.template.category === "defence") {
                this.sortDefenceBuildings();
                eventManager_11.default.dispatchEvent("renderLayer", "nonFillerStars", this);
            }
            if (building.template.category === "vision") {
                this.owner.updateVisibleStars();
            }
            if (this.owner === activePlayer_3.activePlayer) {
                for (var key in building.template.effect) {
                    eventManager_11.default.dispatchEvent("builtBuildingWithEffect_" + key);
                }
                eventManager_11.default.dispatchEvent("humanPlayerBuiltBuilding");
            }
        };
        Star.prototype.removeBuilding = function (building) {
            if (!this.buildings[building.template.category] ||
                this.buildings[building.template.category].indexOf(building) < 0) {
                throw new Error("Location doesn't have building");
            }
            var buildings = this.buildings[building.template.category];
            this.buildings[building.template.category].splice(buildings.indexOf(building), 1);
            this.buildingsEffectIsDirty = true;
        };
        Star.prototype.sortDefenceBuildings = function () {
            this.buildings["defence"].sort(function (a, b) {
                if (a.template.maxPerType === 1) {
                    return -1;
                }
                else if (b.template.maxPerType === 1) {
                    return 1;
                }
                if (a.upgradeLevel !== b.upgradeLevel) {
                    return b.upgradeLevel - a.upgradeLevel;
                }
                return a.id - b.id;
            });
        };
        Star.prototype.getSecondaryController = function () {
            if (!this.buildings["defence"]) {
                return null;
            }
            var defenceBuildings = this.buildings["defence"];
            for (var i = 0; i < defenceBuildings.length; i++) {
                if (defenceBuildings[i].controller !== this.owner) {
                    return defenceBuildings[i].controller;
                }
            }
            return null;
        };
        Star.prototype.updateController = function () {
            if (!this.buildings["defence"])
                return;
            var oldOwner = this.owner;
            var newOwner = this.buildings["defence"][0].controller;
            if (oldOwner) {
                if (oldOwner === newOwner)
                    return;
                oldOwner.removeStar(this);
            }
            newOwner.addStar(this);
            if (this.manufactory) {
                this.manufactory.handleOwnerChange();
            }
            eventManager_11.default.dispatchEvent("renderLayer", "nonFillerStars", this);
            eventManager_11.default.dispatchEvent("renderLayer", "starOwners", this);
            eventManager_11.default.dispatchEvent("renderLayer", "ownerBorders", this);
        };
        Star.prototype.updateBuildingsEffect = function () {
            var effect = {};
            for (var category in this.buildings) {
                for (var i = 0; i < this.buildings[category].length; i++) {
                    var building = this.buildings[category][i];
                    building.getEffect(effect);
                }
            }
            this.buildingsEffect = effect;
            this.buildingsEffectIsDirty = false;
        };
        Star.prototype.getBuildingsEffect = function () {
            if (this.buildingsEffectIsDirty) {
                this.updateBuildingsEffect();
            }
            return this.buildingsEffect;
        };
        Star.prototype.getEffectWithBuildingsEffect = function (base, effectType) {
            var effect = base;
            var buildingsEffect = this.getBuildingsEffect()[effectType];
            if (isFinite(buildingsEffect)) {
                return effect + buildingsEffect;
            }
            else if (buildingsEffect) {
                effect += (buildingsEffect.flat || 0);
                effect *= (isFinite(buildingsEffect.multiplier) ? 1 + buildingsEffect.multiplier : 1);
            }
            return effect;
        };
        Star.prototype.getIncome = function () {
            return this.getEffectWithBuildingsEffect(this.baseIncome, "income");
        };
        Star.prototype.getResourceIncome = function () {
            if (!this.resource)
                return null;
            return ({
                resource: this.resource,
                amount: this.getEffectWithBuildingsEffect(0, "resourceIncome"),
            });
        };
        Star.prototype.getResearchPoints = function () {
            return this.getEffectWithBuildingsEffect(0, "research");
        };
        Star.prototype.getAllBuildings = function () {
            var buildings = [];
            for (var category in this.buildings) {
                buildings = buildings.concat(this.buildings[category]);
            }
            return buildings;
        };
        Star.prototype.getBuildingsForPlayer = function (player) {
            var allBuildings = this.getAllBuildings();
            return allBuildings.filter(function (building) {
                return building.controller.id === player.id;
            });
        };
        Star.prototype.getBuildingsByFamily = function (buildingTemplate) {
            var propToCheck = buildingTemplate.family ? "family" : "type";
            var categoryBuildings = this.buildings[buildingTemplate.category];
            var buildings = [];
            if (categoryBuildings) {
                for (var i = 0; i < categoryBuildings.length; i++) {
                    if (categoryBuildings[i].template[propToCheck] === buildingTemplate[propToCheck]) {
                        buildings.push(categoryBuildings[i]);
                    }
                }
            }
            return buildings;
        };
        Star.prototype.getBuildableBuildings = function () {
            var canBuild = [];
            for (var buildingType in activeModuleData_14.activeModuleData.Templates.Buildings) {
                var template = activeModuleData_14.activeModuleData.Templates.Buildings[buildingType];
                var alreadyBuilt = void 0;
                if (template.category === "mine" && !this.resource) {
                    continue;
                }
                alreadyBuilt = this.getBuildingsByFamily(template);
                if (alreadyBuilt.length < template.maxPerType && !template.upgradeOnly) {
                    canBuild.push(template);
                }
            }
            return canBuild;
        };
        Star.prototype.getBuildingUpgrades = function () {
            var allUpgrades = {};
            var self = this;
            var ownerBuildings = this.getBuildingsForPlayer(this.owner);
            for (var i = 0; i < ownerBuildings.length; i++) {
                var building = ownerBuildings[i];
                var upgrades = building.getPossibleUpgrades();
                upgrades = upgrades.filter(function (upgradeData) {
                    var parent = upgradeData.parentBuilding.template;
                    var template = upgradeData.template;
                    if (parent.type === template.type) {
                        return true;
                    }
                    else {
                        var isSameFamily = (template.family && parent.family === template.family);
                        var maxAllowed = template.maxPerType;
                        if (isSameFamily) {
                            maxAllowed += 1;
                        }
                        var alreadyBuilt = self.getBuildingsByFamily(template);
                        return alreadyBuilt.length < maxAllowed;
                    }
                });
                if (upgrades.length > 0) {
                    allUpgrades[building.id] = upgrades;
                }
            }
            return allUpgrades;
        };
        Star.prototype.getFleets = function (playerFilter) {
            var allFleets = [];
            for (var playerId in this.fleets) {
                var playerFleets = this.fleets[playerId];
                if (playerFleets.length > 0) {
                    var player = this.fleets[playerId][0].player;
                    if (!playerFilter || playerFilter(player) === true) {
                        allFleets.push.apply(allFleets, playerFleets);
                    }
                }
            }
            return allFleets;
        };
        Star.prototype.getUnits = function (playerFilter) {
            var fleets = this.getFleets(playerFilter);
            var units = [];
            fleets.forEach(function (fleet) {
                units.push.apply(units, fleet.units);
            });
            return units;
        };
        Star.prototype.getFleetOwners = function () {
            var fleetOwners = [];
            for (var playerId in this.fleets) {
                if (this.fleets[playerId].length > 0) {
                    fleetOwners.push(this.fleets[playerId][0].player);
                }
            }
            return fleetOwners;
        };
        Star.prototype.getFleetIndex = function (fleet) {
            if (!this.fleets[fleet.player.id])
                return -1;
            return this.fleets[fleet.player.id].indexOf(fleet);
        };
        Star.prototype.hasFleet = function (fleet) {
            return this.getFleetIndex(fleet) >= 0;
        };
        Star.prototype.addFleet = function (fleet) {
            if (!this.fleets[fleet.player.id]) {
                this.fleets[fleet.player.id] = [];
            }
            if (this.hasFleet(fleet)) {
                throw new Error("Star " + this.name + " already has fleet " + fleet.name);
            }
            fleet.location = this;
            this.fleets[fleet.player.id].push(fleet);
        };
        Star.prototype.removeFleet = function (fleet) {
            var fleetIndex = this.getFleetIndex(fleet);
            if (fleetIndex < 0) {
                throw new Error("Star " + this.name + " doesn't have fleet " + fleet.name);
            }
            this.fleets[fleet.player.id].splice(fleetIndex, 1);
            if (this.fleets[fleet.player.id].length === 0) {
                delete this.fleets[fleet.player.id];
            }
        };
        Star.prototype.getTargetsForPlayer = function (player) {
            var buildingTarget = this.getFirstEnemyDefenceBuilding(player);
            var buildingController = buildingTarget ? buildingTarget.controller : null;
            var diplomacyStatus = player.diplomacyStatus;
            var targets = [];
            if (buildingTarget &&
                (player === this.owner ||
                    diplomacyStatus.canAttackBuildingOfPlayer(buildingTarget.controller))) {
                targets.push({
                    type: "building",
                    enemy: buildingTarget.controller,
                    building: buildingTarget,
                    units: this.getUnits(function (player) { return player === buildingTarget.controller; }),
                });
            }
            var hostileFleetOwners = this.getFleetOwners().filter(function (fleetOwner) {
                if (fleetOwner === buildingController) {
                    return false;
                }
                else {
                    return player.diplomacyStatus.canAttackFleetOfPlayer(fleetOwner);
                }
            });
            var _loop_5 = function (i) {
                if (diplomacyStatus.canAttackFleetOfPlayer(hostileFleetOwners[i])) {
                    targets.push({
                        type: "fleet",
                        enemy: hostileFleetOwners[i],
                        building: null,
                        units: this_2.getUnits(function (player) { return player === hostileFleetOwners[i]; }),
                    });
                }
            };
            var this_2 = this;
            for (var i = 0; i < hostileFleetOwners.length; i++) {
                _loop_5(i);
            }
            return targets;
        };
        Star.prototype.hasBuildingTargetForPlayer = function (player) {
            return this.getTargetsForPlayer(player).some(function (target) {
                return target.type === "building";
            });
        };
        Star.prototype.getFirstEnemyDefenceBuilding = function (player) {
            if (!this.buildings["defence"]) {
                return null;
            }
            var defenceBuildings = this.buildings["defence"].slice(0);
            if (this.owner === player) {
                defenceBuildings = defenceBuildings.reverse();
            }
            for (var i = defenceBuildings.length - 1; i >= 0; i--) {
                if (defenceBuildings[i].controller.id !== player.id) {
                    return defenceBuildings[i];
                }
            }
            return null;
        };
        Star.prototype.setResource = function (resource) {
            this.resource = resource;
        };
        Star.prototype.hasLink = function (linkTo) {
            return this.linksTo.indexOf(linkTo) >= 0 || this.linksFrom.indexOf(linkTo) >= 0;
        };
        Star.prototype.addLink = function (linkTo) {
            if (this.hasLink(linkTo))
                return;
            this.linksTo.push(linkTo);
            linkTo.linksFrom.push(this);
        };
        Star.prototype.removeLink = function (linkTo, removeOpposite) {
            if (removeOpposite === void 0) { removeOpposite = true; }
            if (!this.hasLink(linkTo)) {
                throw new Error("Tried to remove nonexistant link between stars: " + this.id + " <-> " + linkTo.id);
            }
            var toIndex = this.linksTo.indexOf(linkTo);
            if (toIndex >= 0) {
                this.linksTo.splice(toIndex, 1);
            }
            else {
                this.linksFrom.splice(this.linksFrom.indexOf(linkTo), 1);
            }
            if (removeOpposite) {
                linkTo.removeLink(this, false);
            }
        };
        Star.prototype.getAllLinks = function () {
            return this.linksTo.concat(this.linksFrom);
        };
        Star.prototype.getEdgeWith = function (neighbor) {
            for (var i = 0; i < this.voronoiCell.halfedges.length; i++) {
                var edge = this.voronoiCell.halfedges[i].edge;
                if ((edge.lSite && edge.lSite === neighbor) ||
                    (edge.rSite && edge.rSite === neighbor)) {
                    return edge;
                }
            }
            return null;
        };
        Star.prototype.getSharedNeighborsWith = function (neighbor) {
            var ownNeighbors = this.getNeighbors();
            var neighborNeighbors = neighbor.getNeighbors();
            var sharedNeighbors = [];
            for (var i = 0; i < ownNeighbors.length; i++) {
                var star = ownNeighbors[i];
                if (star !== neighbor && neighborNeighbors.indexOf(star) !== -1) {
                    sharedNeighbors.push(star);
                }
            }
            return sharedNeighbors;
        };
        Star.prototype.getNeighbors = function () {
            var neighbors = [];
            for (var i = 0; i < this.voronoiCell.halfedges.length; i++) {
                var edge = this.voronoiCell.halfedges[i].edge;
                if (edge.lSite !== null && edge.lSite.id !== this.id) {
                    neighbors.push(edge.lSite);
                }
                else if (edge.rSite !== null && edge.rSite.id !== this.id) {
                    neighbors.push(edge.rSite);
                }
            }
            return neighbors;
        };
        Star.prototype.getAllLinkedStars = function () {
            return this.getLinkedInRange(99999).all;
        };
        Star.prototype.getLinkedInRange = function (range) {
            if (this.indexedNeighborsInRange[range]) {
                return this.indexedNeighborsInRange[range];
            }
            var visited = {};
            var visitedByRange = {};
            if (range >= 0) {
                visited[this.id] = this;
            }
            var current = [];
            var frontier = [this];
            for (var i = 0; i < range; i++) {
                current = frontier.slice(0);
                if (current.length <= 0)
                    break;
                frontier = [];
                visitedByRange[i + 1] = [];
                for (var j = 0; j < current.length; j++) {
                    var neighbors = current[j].getAllLinks();
                    for (var k = 0; k < neighbors.length; k++) {
                        if (visited[neighbors[k].id])
                            continue;
                        visited[neighbors[k].id] = neighbors[k];
                        visitedByRange[i + 1].push(neighbors[k]);
                        frontier.push(neighbors[k]);
                        this.indexedDistanceToStar[neighbors[k].id] = i;
                    }
                }
            }
            var allVisited = [];
            for (var id in visited) {
                allVisited.push(visited[id]);
            }
            this.indexedNeighborsInRange[range] =
                {
                    all: allVisited,
                    byRange: visitedByRange,
                };
            return ({
                all: allVisited,
                byRange: visitedByRange,
            });
        };
        Star.prototype.getNearestStarForQualifier = function (qualifier) {
            if (qualifier(this))
                return this;
            var visited = {};
            var frontier = [this];
            visited[this.id] = true;
            while (frontier.length > 0) {
                var current = frontier.shift();
                var neighbors = current.getLinkedInRange(1).all;
                for (var i = 0; i < neighbors.length; i++) {
                    var neighbor = neighbors[i];
                    if (visited[neighbor.id])
                        continue;
                    visited[neighbor.id] = true;
                    if (qualifier(neighbor)) {
                        return neighbor;
                    }
                    else {
                        frontier.push(neighbor);
                    }
                }
            }
            return null;
        };
        Star.prototype.getDistanceToStar = function (target) {
            if (!App_6.default.game) {
                var a = pathFinding_2.aStar(this, target);
                return a.cost[target.id];
            }
            if (!this.indexedDistanceToStar[target.id]) {
                var a = pathFinding_2.aStar(this, target);
                if (!a) {
                    this.indexedDistanceToStar[target.id] = -1;
                }
                else {
                    for (var id in a.cost) {
                        this.indexedDistanceToStar[id] = a.cost[id];
                    }
                }
            }
            return this.indexedDistanceToStar[target.id];
        };
        Star.prototype.getVisionRange = function () {
            return this.getEffectWithBuildingsEffect(1, "vision");
        };
        Star.prototype.getVision = function () {
            return this.getLinkedInRange(this.getVisionRange()).all;
        };
        Star.prototype.getDetectionRange = function () {
            return this.getEffectWithBuildingsEffect(0, "detection");
        };
        Star.prototype.getDetection = function () {
            return this.getLinkedInRange(this.getDetectionRange()).all;
        };
        Star.prototype.getHealingFactor = function (player) {
            var factor = 0;
            if (player === this.owner) {
                factor += 0.15;
            }
            return factor;
        };
        Star.prototype.getPresentPlayersByVisibility = function () {
            var byVisibilityAndId = {
                visible: {},
                stealthy: {},
                all: {},
            };
            byVisibilityAndId.visible[this.owner.id] = this.owner;
            var secondaryController = this.getSecondaryController();
            if (secondaryController) {
                byVisibilityAndId.visible[secondaryController.id] = secondaryController;
            }
            for (var playerId in this.fleets) {
                var fleets = this.fleets[playerId];
                for (var i = 0; i < fleets.length; i++) {
                    var fleetPlayer = fleets[i].player;
                    if (byVisibilityAndId.stealthy[fleetPlayer.id] && byVisibilityAndId.visible[fleetPlayer.id]) {
                        break;
                    }
                    byVisibilityAndId.all[fleetPlayer.id] = fleetPlayer;
                    if (fleets[i].isStealthy) {
                        byVisibilityAndId.stealthy[fleetPlayer.id] = fleetPlayer;
                    }
                    else {
                        byVisibilityAndId.visible[fleetPlayer.id] = fleetPlayer;
                    }
                }
            }
            return byVisibilityAndId;
        };
        Star.prototype.getSeed = function () {
            if (!this.seed) {
                var bgString = "";
                bgString += Math.round(this.x);
                bgString += Math.round(this.y);
                bgString += new Date().getTime();
                this.seed = bgString;
            }
            return this.seed;
        };
        Star.prototype.buildManufactory = function () {
            this.manufactory = new Manufactory_2.default(this);
        };
        Star.prototype.serialize = function () {
            var buildings = {};
            for (var category in this.buildings) {
                buildings[category] = [];
                for (var i = 0; i < this.buildings[category].length; i++) {
                    buildings[category].push(this.buildings[category][i].serialize());
                }
            }
            var data = {
                id: this.id,
                x: this.basisX,
                y: this.basisY,
                baseIncome: this.baseIncome,
                name: this.name,
                ownerId: this.owner ? this.owner.id : null,
                linksToIds: this.linksTo.map(function (star) { return star.id; }),
                linksFromIds: this.linksFrom.map(function (star) { return star.id; }),
                seed: this.seed,
                buildings: buildings,
                raceType: this.race.type,
            };
            if (this.resource) {
                data.resourceType = this.resource.type;
            }
            if (this.manufactory) {
                data.manufactory = this.manufactory.serialize();
            }
            return data;
        };
        return Star;
    }());
    exports.default = Star;
});
define("src/MapVoronoiInfo", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MapVoronoiInfo = (function () {
        function MapVoronoiInfo() {
            this.nonFillerLines = {};
        }
        MapVoronoiInfo.prototype.getNonFillerVoronoiLines = function (visibleStars) {
            if (!this.diagram)
                return [];
            var indexString = "";
            if (!visibleStars)
                indexString = "all";
            else {
                var ids = visibleStars.map(function (star) { return star.id; });
                ids.sort();
                indexString = ids.join();
            }
            if (!this.nonFillerLines[indexString] ||
                this.nonFillerLines[indexString].length <= 0) {
                this.nonFillerLines[indexString] =
                    this.diagram.edges.filter(function (edge) {
                        var adjacentSites = [edge.lSite, edge.rSite];
                        var adjacentFillerSites = 0;
                        var maxAllowedFillerSites = 2;
                        for (var i = 0; i < adjacentSites.length; i++) {
                            var site = adjacentSites[i];
                            if (!site) {
                                maxAllowedFillerSites--;
                                if (adjacentFillerSites >= maxAllowedFillerSites) {
                                    return false;
                                }
                                continue;
                            }
                            ;
                            if (visibleStars && visibleStars.indexOf(site) < 0) {
                                maxAllowedFillerSites--;
                                if (adjacentFillerSites >= maxAllowedFillerSites) {
                                    return false;
                                }
                                continue;
                            }
                            ;
                            var castedSite = site;
                            var isFiller = !isFinite(castedSite.id);
                            if (isFiller) {
                                adjacentFillerSites++;
                                if (adjacentFillerSites >= maxAllowedFillerSites) {
                                    return false;
                                }
                            }
                            ;
                        }
                        return true;
                    });
            }
            return this.nonFillerLines[indexString];
        };
        MapVoronoiInfo.prototype.getStarAtPoint = function (point) {
            var items = this.treeMap.retrieve(point);
            for (var i = 0; i < items.length; i++) {
                if (items[i].pointIntersection(point.x, point.y) > -1) {
                    return items[i].site;
                }
            }
            return null;
        };
        return MapVoronoiInfo;
    }());
    exports.default = MapVoronoiInfo;
});
define("src/voronoi", ["require", "exports", "src/VoronoiCell"], function (require, exports, VoronoiCell_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeVoronoi(points, width, height) {
        var boundingBox = {
            xl: 0,
            xr: width,
            yt: 0,
            yb: height,
        };
        var voronoi = new Voronoi();
        var diagram = voronoi.compute(points, boundingBox);
        return diagram;
    }
    exports.makeVoronoi = makeVoronoi;
    function relaxVoronoi(diagram, getRelaxAmountFN) {
        for (var i = 0; i < diagram.cells.length; i++) {
            var cell = diagram.cells[i];
            var point = cell.site;
            var vertices = cell.halfedges.map(function (halfEdge) {
                return halfEdge.getStartpoint();
            });
            var centroid = getPolygonCentroid(vertices);
            if (getRelaxAmountFN) {
                var dampeningValue = getRelaxAmountFN(point);
                var xDelta = (centroid.x - point.x) * dampeningValue;
                var yDelta = (centroid.y - point.y) * dampeningValue;
                point.x = point.x + xDelta;
                point.y = point.y + yDelta;
            }
            else {
                point.x = centroid.x;
                point.y = centroid.y;
            }
        }
    }
    exports.relaxVoronoi = relaxVoronoi;
    function setVoronoiCells(cells) {
        cells.forEach(function (cell) {
            var castedSite = cell.site;
            var isFiller = !isFinite(castedSite.id);
            if (isFiller) {
                cell.site.voronoiCell = new VoronoiCell_1.default(cell);
            }
            else {
                cell.site.voronoiCell = new VoronoiCell_1.default(cell);
            }
        });
    }
    exports.setVoronoiCells = setVoronoiCells;
    function getPolygonCentroid(vertices) {
        var signedArea = 0;
        var x = 0;
        var y = 0;
        var x0;
        var y0;
        var x1;
        var y1;
        var a;
        var i = 0;
        for (i = 0; i < vertices.length - 1; i++) {
            x0 = vertices[i].x;
            y0 = vertices[i].y;
            x1 = vertices[i + 1].x;
            y1 = vertices[i + 1].y;
            a = x0 * y1 - x1 * y0;
            signedArea += a;
            x += (x0 + x1) * a;
            y += (y0 + y1) * a;
        }
        x0 = vertices[i].x;
        y0 = vertices[i].y;
        x1 = vertices[0].x;
        y1 = vertices[0].y;
        a = x0 * y1 - x1 * y0;
        signedArea += a;
        x += (x0 + x1) * a;
        y += (y0 + y1) * a;
        signedArea *= 0.5;
        x /= (6.0 * signedArea);
        y /= (6.0 * signedArea);
        return ({
            x: x,
            y: y,
        });
    }
});
define("src/MapGenResult", ["require", "exports", "src/GalaxyMap", "src/MapVoronoiInfo", "src/voronoi"], function (require, exports, GalaxyMap_1, MapVoronoiInfo_1, voronoi_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MapGenResult = (function () {
        function MapGenResult(props) {
            this.stars = props.stars;
            this.fillerPoints = props.fillerPoints;
            this.width = props.width;
            this.height = props.height;
            this.seed = props.seed;
            this.independents = props.independents;
        }
        MapGenResult.prototype.makeMap = function () {
            this.voronoiInfo = this.makeVoronoiInfo();
            var map = new GalaxyMap_1.default(this);
            return map;
        };
        MapGenResult.prototype.getAllPoints = function () {
            var castedFillerPoints = this.fillerPoints;
            return castedFillerPoints.concat(this.stars);
        };
        MapGenResult.prototype.makeVoronoiInfo = function () {
            var voronoiInfo = new MapVoronoiInfo_1.default();
            voronoiInfo.diagram = voronoi_1.makeVoronoi(this.getAllPoints(), this.width, this.height);
            voronoi_1.setVoronoiCells(voronoiInfo.diagram.cells);
            voronoiInfo.treeMap = this.makeVoronoiTreeMap();
            voronoiInfo.bounds =
                {
                    x1: 0,
                    x2: this.width,
                    y1: 0,
                    y2: this.height,
                };
            for (var i = 0; i < this.stars.length; i++) {
                var star = this.stars[i];
                star.basisX = star.x;
                star.basisY = star.y;
            }
            voronoi_1.relaxVoronoi(voronoiInfo.diagram, function (point) {
                var castedPoint = point;
                var isFiller = !isFinite(castedPoint.id);
                return isFiller ? 0 : 1;
            });
            return voronoiInfo;
        };
        MapGenResult.prototype.makeVoronoiTreeMap = function () {
            var treeMap = new QuadTree({
                x: 0,
                y: 0,
                width: this.width,
                height: this.height,
            });
            this.stars.forEach(function (star) {
                treeMap.insert(star.voronoiCell);
            });
            return treeMap;
        };
        return MapGenResult;
    }());
    exports.default = MapGenResult;
});
define("src/GalaxyMap", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var GalaxyMap = (function () {
        function GalaxyMap(mapGen) {
            this.width = mapGen.width;
            this.height = mapGen.height;
            this.seed = mapGen.seed;
            this.stars = mapGen.stars;
            this.fillerPoints = mapGen.fillerPoints;
            this.independents = mapGen.independents;
            this.voronoi = mapGen.voronoiInfo;
        }
        GalaxyMap.prototype.getIncomeBounds = function () {
            var min, max;
            for (var i = 0; i < this.stars.length; i++) {
                var star = this.stars[i];
                var income = star.getIncome();
                if (!min)
                    min = max = income;
                else {
                    if (income < min)
                        min = income;
                    else if (income > max)
                        max = income;
                }
            }
            return ({
                min: min,
                max: max,
            });
        };
        GalaxyMap.prototype.serialize = function () {
            var data = {
                stars: this.stars.map(function (star) {
                    return star.serialize();
                }),
                fillerPoints: this.fillerPoints.map(function (fillerPoint) {
                    return fillerPoint.serialize();
                }),
                width: this.width,
                height: this.height,
                seed: this.seed,
            };
            return data;
        };
        return GalaxyMap;
    }());
    exports.default = GalaxyMap;
});
define("src/MapRendererLayer", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MapRendererLayer = (function () {
        function MapRendererLayer(template) {
            this.isDirty = true;
            this.template = template;
            this.container = new PIXI.Container();
            this.container.interactiveChildren = template.interactive;
            this.alpha = template.alpha || 1;
        }
        Object.defineProperty(MapRendererLayer.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (newAlpha) {
                this._alpha = newAlpha;
                this.container.alpha = newAlpha;
            },
            enumerable: true,
            configurable: true
        });
        MapRendererLayer.prototype.resetAlpha = function () {
            this.alpha = this.template.alpha || 1;
        };
        MapRendererLayer.prototype.draw = function (map, mapRenderer) {
            if (!this.isDirty) {
                return;
            }
            this.container.removeChildren();
            this.container.addChild(this.template.drawingFunction(map, mapRenderer.player));
            this.isDirty = false;
        };
        MapRendererLayer.prototype.destroy = function () {
            if (this.template.destroy) {
                this.template.destroy();
            }
        };
        return MapRendererLayer;
    }());
    exports.default = MapRendererLayer;
});
define("src/MapRendererMapMode", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MapRendererMapMode = (function () {
        function MapRendererMapMode(template) {
            this.layers = [];
            this.activeLayers = {};
            this.template = template;
            this.displayName = template.displayName;
        }
        MapRendererMapMode.prototype.addLayer = function (layer, isActive) {
            if (isActive === void 0) { isActive = true; }
            if (this.hasLayer(layer)) {
                throw new Error("Tried to add duplicate layer " + layer.template.key);
            }
            this.layers.push(layer);
            this.activeLayers[layer.template.key] = isActive;
        };
        MapRendererMapMode.prototype.hasLayer = function (layer) {
            return this.layers.indexOf(layer) !== -1;
        };
        MapRendererMapMode.prototype.getLayerIndexInContainer = function (layer) {
            var index = -1;
            for (var i = 0; i < this.layers.length; i++) {
                if (this.activeLayers[this.layers[i].template.key]) {
                    index++;
                }
                if (this.layers[i] === layer)
                    return index;
            }
            throw new Error("Map mode doesn't have layer " + layer.template.key);
        };
        MapRendererMapMode.prototype.toggleLayer = function (layer) {
            this.activeLayers[layer.template.key] = !this.activeLayers[layer.template.key];
            if (!this.hasLayer(layer)) {
                this.addLayer(layer);
            }
        };
        MapRendererMapMode.prototype.moveLayer = function (toInsert, target, position) {
            var indexAdjust = (position === "top" ? 0 : 1);
            var prevIndex = this.layers.indexOf(toInsert);
            this.layers.splice(prevIndex, 1);
            var newIndex = this.layers.indexOf(target) + indexAdjust;
            this.layers.splice(newIndex, 0, toInsert);
        };
        MapRendererMapMode.prototype.getActiveLayers = function () {
            var self = this;
            return (this.layers.filter(function (layer) {
                return self.activeLayers[layer.template.key];
            }));
        };
        MapRendererMapMode.prototype.resetLayers = function () {
            var layersByKey = {};
            var newLayers = [];
            var newActive = {};
            for (var i = 0; i < this.layers.length; i++) {
                var layer = this.layers[i];
                layersByKey[layer.template.key] = layer;
            }
            for (var i = 0; i < this.template.layers.length; i++) {
                var layerTemplate = this.template.layers[i];
                var layer = layersByKey[layerTemplate.key];
                newLayers.push(layer);
                newActive[layerTemplate.key] = true;
                delete layersByKey[layerTemplate.key];
            }
            for (var key in layersByKey) {
                var layer = layersByKey[key];
                newLayers.push(layer);
                newActive[key] = false;
            }
            this.layers = newLayers;
            this.activeLayers = newActive;
            for (var i = 0; i < this.layers.length; i++) {
                this.layers[i].resetAlpha();
            }
        };
        return MapRendererMapMode;
    }());
    exports.default = MapRendererMapMode;
});
define("src/MapRenderer", ["require", "exports", "src/activeModuleData", "src/MapRendererLayer", "src/MapRendererMapMode", "src/Options", "src/eventManager"], function (require, exports, activeModuleData_15, MapRendererLayer_1, MapRendererMapMode_1, Options_3, eventManager_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MapRenderer = (function () {
        function MapRenderer(map, player) {
            this.layers = {};
            this.mapModes = {};
            this.isDirty = true;
            this.preventRender = false;
            this.listeners = {};
            this.container = new PIXI.Container();
            this.galaxyMap = map;
            this.player = player;
        }
        MapRenderer.prototype.destroy = function () {
            this.preventRender = true;
            this.container.renderable = false;
            for (var name_2 in this.listeners) {
                eventManager_12.default.removeEventListener(name_2, this.listeners[name_2]);
            }
            this.container.removeChildren();
            this.parent.removeChild(this.container);
            this.player = null;
            this.container = null;
            this.parent = null;
            for (var layerName in this.layers) {
                this.layers[layerName].destroy();
            }
        };
        MapRenderer.prototype.init = function () {
            this.initLayers();
            this.initMapModes();
            this.addEventListeners();
        };
        MapRenderer.prototype.addEventListeners = function () {
            var self = this;
            this.listeners["renderMap"] =
                eventManager_12.default.addEventListener("renderMap", this.setAllLayersAsDirty.bind(this));
            this.listeners["renderLayer"] =
                eventManager_12.default.addEventListener("renderLayer", function (layerName, star) {
                    var passesStarVisibilityCheck = true;
                    if (star) {
                        switch (layerName) {
                            case "fleets":
                                {
                                    passesStarVisibilityCheck = self.player.starIsVisible(star);
                                    break;
                                }
                            default:
                                {
                                    passesStarVisibilityCheck = self.player.starIsRevealed(star);
                                    break;
                                }
                        }
                    }
                    if (passesStarVisibilityCheck || Options_3.default.debug.enabled) {
                        self.setLayerAsDirty(layerName);
                    }
                });
        };
        MapRenderer.prototype.setPlayer = function (player) {
            this.player = player;
            this.setAllLayersAsDirty();
        };
        MapRenderer.prototype.initLayers = function () {
            for (var layerKey in activeModuleData_15.activeModuleData.Templates.MapRendererLayers) {
                var template = activeModuleData_15.activeModuleData.Templates.MapRendererLayers[layerKey];
                var layer = new MapRendererLayer_1.default(template);
                this.layers[layerKey] = layer;
            }
        };
        MapRenderer.prototype.initMapModes = function () {
            var _this = this;
            var buildMapMode = function (mapModeKey, template) {
                var alreadyAdded = {};
                var mapMode = new MapRendererMapMode_1.default(template);
                for (var i = 0; i < template.layers.length; i++) {
                    var layer = template.layers[i];
                    mapMode.addLayer(_this.layers[layer.key], true);
                    alreadyAdded[layer.key] = true;
                }
                for (var layerKey in _this.layers) {
                    if (!alreadyAdded[layerKey]) {
                        mapMode.addLayer(_this.layers[layerKey], false);
                        alreadyAdded[layerKey] = true;
                    }
                }
                _this.mapModes[mapModeKey] = mapMode;
            };
            for (var mapModeKey in activeModuleData_15.activeModuleData.Templates.MapRendererMapModes) {
                var template = activeModuleData_15.activeModuleData.Templates.MapRendererMapModes[mapModeKey];
                buildMapMode(mapModeKey, template);
            }
        };
        MapRenderer.prototype.setParent = function (newParent) {
            var oldParent = this.parent;
            if (oldParent) {
                oldParent.removeChild(this.container);
            }
            this.parent = newParent;
            newParent.addChild(this.container);
        };
        MapRenderer.prototype.resetContainer = function () {
            this.container.removeChildren();
        };
        MapRenderer.prototype.getMapBoundsForCamera = function () {
            var boundsLayers = this.currentMapMode.getActiveLayers().filter(function (layer) {
                return layer.container.width && layer.container.height && layer.template.isUsedForCameraBounds;
            });
            if (boundsLayers.length > 0) {
                return boundsLayers.map(function (layer) {
                    return layer.container.getLocalBounds();
                }).reduce(function (finalBounds, bounds) {
                    if (!finalBounds) {
                        return bounds.clone();
                    }
                    else {
                        finalBounds.enlarge(bounds);
                        return finalBounds;
                    }
                });
            }
            else {
                return this.container.getLocalBounds();
            }
        };
        MapRenderer.prototype.setLayerAsDirty = function (layerName) {
            var layer = this.layers[layerName];
            layer.isDirty = true;
            this.isDirty = true;
            this.render();
        };
        MapRenderer.prototype.setAllLayersAsDirty = function () {
            for (var i = 0; i < this.currentMapMode.layers.length; i++) {
                this.currentMapMode.layers[i].isDirty = true;
            }
            this.isDirty = true;
            this.render();
        };
        MapRenderer.prototype.updateMapModeLayers = function (updatedLayers) {
            for (var i = 0; i < updatedLayers.length; i++) {
                var layer = updatedLayers[i];
                var childIndex = this.container.children.indexOf(layer.container);
                var mapModeLayerIndex = this.currentMapMode.getLayerIndexInContainer(layer);
                if (childIndex === -1) {
                    this.container.addChildAt(layer.container, mapModeLayerIndex);
                }
                else {
                    this.container.removeChildAt(mapModeLayerIndex + 1);
                }
                this.setLayerAsDirty(layer.template.key);
            }
        };
        MapRenderer.prototype.resetMapModeLayersPosition = function () {
            this.resetContainer();
            var layerData = this.currentMapMode.getActiveLayers();
            for (var i = 0; i < layerData.length; i++) {
                var layer = layerData[i];
                this.container.addChild(layer.container);
            }
        };
        MapRenderer.prototype.setMapModeByKey = function (key) {
            this.setMapMode(this.mapModes[key]);
        };
        MapRenderer.prototype.setMapMode = function (newMapMode) {
            if (!this.mapModes[newMapMode.template.key]) {
                throw new Error("Invalid mapmode " + newMapMode.template.key);
            }
            if (this.currentMapMode && this.currentMapMode === newMapMode) {
                return;
            }
            this.currentMapMode = newMapMode;
            this.resetContainer();
            var layerData = this.currentMapMode.getActiveLayers();
            for (var i = 0; i < layerData.length; i++) {
                var layer = layerData[i];
                this.container.addChild(layer.container);
            }
            this.setAllLayersAsDirty();
        };
        MapRenderer.prototype.render = function () {
            if (this.preventRender || !this.isDirty)
                return;
            var layerData = this.currentMapMode.getActiveLayers();
            for (var i = 0; i < layerData.length; i++) {
                var layer = layerData[i];
                layer.draw(this.galaxyMap, this);
            }
            this.isDirty = false;
        };
        return MapRenderer;
    }());
    exports.default = MapRenderer;
});
define("src/ModuleLoader", ["require", "exports", "src/ModuleFileLoadingPhase", "src/eventManager"], function (require, exports, ModuleFileLoadingPhase_1, eventManager_13) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ModuleLoader = (function () {
        function ModuleLoader(moduleData) {
            this.moduleFilesByKey = {};
            this.moduleFilesByPhase = {};
            this.hasLoaded = {};
            this.moduleLoadStart = {};
            this.moduleLoadFinishCallbacks = {};
            this.moduleData = moduleData;
            eventManager_13.default.addEventListener("loadModulesNeededForPhase", this.loadModulesNeededForPhase.bind(this));
        }
        ModuleLoader.prototype.addModuleFile = function (moduleFile) {
            if (this.moduleFilesByKey[moduleFile.key]) {
                throw new Error("Duplicate module key " + moduleFile.key);
            }
            this.moduleFilesByKey[moduleFile.key] = moduleFile;
            this.hasLoaded[moduleFile.key] = false;
            if (!this.moduleFilesByPhase[moduleFile.needsToBeLoadedBefore]) {
                this.moduleFilesByPhase[moduleFile.needsToBeLoadedBefore] = [];
            }
            this.moduleFilesByPhase[moduleFile.needsToBeLoadedBefore].push(moduleFile);
        };
        ModuleLoader.prototype.loadModuleFile = function (moduleFile, afterLoaded) {
            var _this = this;
            if (!this.moduleFilesByKey[moduleFile.key]) {
                this.addModuleFile(moduleFile);
            }
            if (this.hasLoaded[moduleFile.key]) {
                afterLoaded();
                return;
            }
            if (!this.moduleLoadFinishCallbacks[moduleFile.key]) {
                this.moduleLoadFinishCallbacks[moduleFile.key] = [];
            }
            this.moduleLoadFinishCallbacks[moduleFile.key].push(afterLoaded);
            if (isFinite(this.moduleLoadStart[moduleFile.key])) {
                return;
            }
            console.log("start loading module '", moduleFile.key, "'");
            this.moduleLoadStart[moduleFile.key] = Date.now();
            if (moduleFile.loadAssets) {
                moduleFile.loadAssets(function () {
                    _this.finishLoadingModuleFile(moduleFile);
                });
            }
            else {
                this.finishLoadingModuleFile(moduleFile);
            }
        };
        ModuleLoader.prototype.loadModuleFiles = function (moduleFilesToLoad, afterLoaded) {
            var _this = this;
            if (!moduleFilesToLoad || moduleFilesToLoad.length < 1) {
                if (afterLoaded) {
                    afterLoaded();
                }
                return;
            }
            var loadedModuleFiles = [];
            var executeIfAllLoaded = function () {
                if (loadedModuleFiles.length === moduleFilesToLoad.length) {
                    afterLoaded();
                }
            };
            moduleFilesToLoad.forEach(function (moduleFile) {
                _this.loadModuleFile(moduleFile, function () {
                    loadedModuleFiles.push(moduleFile);
                    if (afterLoaded) {
                        executeIfAllLoaded();
                    }
                });
            });
        };
        ModuleLoader.prototype.loadAll = function (afterLoaded) {
            var allModuleFiles = [];
            for (var key in this.moduleFilesByKey) {
                allModuleFiles.push(this.moduleFilesByKey[key]);
            }
            this.loadModuleFiles(allModuleFiles, afterLoaded);
        };
        ModuleLoader.prototype.loadModulesForPhase = function (phase, afterLoaded) {
            var moduleFilesToLoad = this.moduleFilesByPhase[phase];
            this.loadModuleFiles(moduleFilesToLoad, afterLoaded);
        };
        ModuleLoader.prototype.loadModulesNeededForPhase = function (phase, afterLoaded) {
            var moduleFilesNeededForPhase = [];
            for (var keyString in this.moduleFilesByPhase) {
                if (parseInt(keyString) <= phase) {
                    moduleFilesNeededForPhase.push.apply(moduleFilesNeededForPhase, this.moduleFilesByPhase[keyString]);
                }
            }
            this.loadModuleFiles(moduleFilesNeededForPhase, afterLoaded);
        };
        ModuleLoader.prototype.progressivelyLoadModulesByPhase = function (startingPhase) {
            var _this = this;
            this.loadModulesForPhase(startingPhase, function () {
                if (ModuleFileLoadingPhase_1.default[startingPhase + 1]) {
                    _this.progressivelyLoadModulesByPhase(startingPhase + 1);
                }
            });
        };
        ModuleLoader.prototype.finishLoadingModuleFile = function (moduleFile) {
            this.hasLoaded[moduleFile.key] = true;
            this.constructModuleFile(moduleFile);
            var loadTime = Date.now() - this.moduleLoadStart[moduleFile.key];
            console.log("Module '" + moduleFile.key + "' finished loading in " + loadTime + "ms");
            while (this.moduleLoadFinishCallbacks[moduleFile.key].length > 0) {
                var afterLoadedCallback = this.moduleLoadFinishCallbacks[moduleFile.key].pop();
                afterLoadedCallback();
            }
        };
        ModuleLoader.prototype.constructModuleFile = function (moduleFile) {
            if (moduleFile.constructModule) {
                moduleFile.constructModule(this.moduleData);
            }
            this.moduleData.addSubModule(moduleFile);
        };
        return ModuleLoader;
    }());
    exports.default = ModuleLoader;
});
define("src/RectangleSelect", ["require", "exports", "src/eventManager"], function (require, exports, eventManager_14) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var RectangleSelect = (function () {
        function RectangleSelect(gfxContainer, targetLayer) {
            this.minimumSizeThreshhold = 5;
            this.gfxContainer = gfxContainer;
            this.targetLayer = targetLayer;
            this.graphics = new PIXI.Graphics();
            gfxContainer.addChild(this.graphics);
            this.addEventListeners();
        }
        RectangleSelect.prototype.destroy = function () {
            this.gfxContainer.removeChild(this.graphics);
            this.gfxContainer = null;
            this.graphics = null;
            this.toSelectFrom = null;
            this.getSelectionTargetsFN = null;
        };
        RectangleSelect.prototype.startSelection = function (point) {
            this.selecting = true;
            this.startLocal = this.targetLayer.worldTransform.applyInverse(new PIXI.Point(point.x, point.y));
            this.currentGlobal = { x: point.x, y: point.y };
        };
        RectangleSelect.prototype.moveSelection = function (point) {
            this.currentGlobal = { x: point.x, y: point.y };
            this.drawSelectionRectangle();
        };
        RectangleSelect.prototype.endSelection = function () {
            var bounds = this.getBounds();
            if (bounds.width < this.minimumSizeThreshhold || bounds.height < this.minimumSizeThreshhold) {
                return;
            }
            this.setSelectionTargets();
            var inSelection = this.getAllInSelection();
            eventManager_14.default.dispatchEvent("selectFleets", inSelection);
            this.clearSelection();
        };
        RectangleSelect.prototype.clearSelection = function () {
            this.selecting = false;
            this.graphics.clear();
            this.startLocal = null;
            this.currentGlobal = null;
        };
        RectangleSelect.prototype.handleTargetLayerShift = function () {
            var _this = this;
            window.requestAnimationFrame(function () {
                _this.drawSelectionRectangle();
            });
        };
        RectangleSelect.prototype.addEventListeners = function () {
            eventManager_14.default.dispatchEvent("setRectangleSelectTargetFN", this);
        };
        RectangleSelect.prototype.drawSelectionRectangle = function () {
            if (!this.currentGlobal) {
                return;
            }
            var bounds = this.getBounds();
            this.graphics.clear();
            this.graphics.lineStyle(1, 0xFFFFFF, 1);
            this.graphics.beginFill(0x000000, 0);
            this.graphics.drawRect(bounds.left, bounds.top, bounds.width, bounds.height);
            this.graphics.endFill();
        };
        RectangleSelect.prototype.setSelectionTargets = function () {
            if (!this.getSelectionTargetsFN) {
                return;
            }
            this.toSelectFrom = this.getSelectionTargetsFN();
        };
        RectangleSelect.prototype.getBounds = function () {
            var startGlobal = this.targetLayer.worldTransform.apply(this.startLocal);
            var x1 = Math.round(Math.min(startGlobal.x, this.currentGlobal.x));
            var x2 = Math.round(Math.max(startGlobal.x, this.currentGlobal.x));
            var y1 = Math.round(Math.min(startGlobal.y, this.currentGlobal.y));
            var y2 = Math.round(Math.max(startGlobal.y, this.currentGlobal.y));
            return ({
                left: x1,
                top: y1,
                right: x2,
                bottom: y2,
                width: x2 - x1,
                height: y2 - y1,
            });
        };
        RectangleSelect.prototype.getAllInSelection = function () {
            var toReturn = [];
            for (var i = 0; i < this.toSelectFrom.length; i++) {
                if (this.selectionContains(this.toSelectFrom[i].position)) {
                    toReturn.push(this.toSelectFrom[i].data);
                }
            }
            return toReturn;
        };
        RectangleSelect.prototype.selectionContains = function (point) {
            var pixiPoint = new PIXI.Point(point.x, point.y);
            var transformedPoint = this.targetLayer.worldTransform.apply(pixiPoint);
            var x = transformedPoint.x;
            var y = transformedPoint.y;
            var bounds = this.getBounds();
            return ((x >= bounds.left && x <= bounds.right) &&
                (y >= bounds.top && y <= bounds.bottom));
        };
        return RectangleSelect;
    }());
    exports.default = RectangleSelect;
});
define("src/PlayerControl", ["require", "exports", "src/eventManager"], function (require, exports, eventManager_15) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PlayerControl = (function () {
        function PlayerControl(player) {
            this.selectedFleets = [];
            this.inspectedFleets = [];
            this.currentlyReorganizing = [];
            this.lastSelectedFleetsIds = {};
            this.preventingGhost = false;
            this.listeners = {};
            this.player = player;
            this.addEventListeners();
        }
        PlayerControl.prototype.destroy = function () {
            this.removeEventListeners();
            this.player = null;
            this.selectedFleets = null;
            this.currentlyReorganizing = null;
            this.currentAttackTargets = null;
            this.selectedStar = null;
        };
        PlayerControl.prototype.removeEventListener = function (name) {
            eventManager_15.default.removeEventListener(name, this.listeners[name]);
        };
        PlayerControl.prototype.removeEventListeners = function () {
            for (var name_3 in this.listeners) {
                this.removeEventListener(name_3);
            }
        };
        PlayerControl.prototype.addEventListener = function (name, handler) {
            this.listeners[name] = handler;
            eventManager_15.default.addEventListener(name, handler);
        };
        PlayerControl.prototype.addEventListeners = function () {
            var self = this;
            this.addEventListener("updateSelection", function () {
                self.updateSelection();
            });
            this.addEventListener("selectFleets", function (fleets) {
                self.selectFleets(fleets);
            });
            this.addEventListener("deselectFleet", function (fleet) {
                self.deselectFleet(fleet);
            });
            this.addEventListener("mergeFleets", function () {
                self.mergeFleets();
            });
            this.addEventListener("splitFleet", function (fleet) {
                self.splitFleet(fleet);
            });
            this.addEventListener("startReorganizingFleets", function (fleets) {
                self.startReorganizingFleets(fleets);
            });
            this.addEventListener("endReorganizingFleets", function () {
                self.endReorganizingFleets();
            });
            this.addEventListener("starClick", function (star) {
                self.selectStar(star);
            });
            this.addEventListener("moveFleets", function (star) {
                self.moveFleets(star);
            });
            this.addEventListener("setRectangleSelectTargetFN", function (rectangleSelect) {
                rectangleSelect.getSelectionTargetsFN =
                    self.player.getFleetsWithPositions.bind(self.player);
            });
            this.addEventListener("attackTarget", function (target) {
                self.attackTarget(target);
            });
        };
        PlayerControl.prototype.preventGhost = function (delay) {
            this.preventingGhost = true;
            var self = this;
            var timeout = window.setTimeout(function () {
                self.preventingGhost = false;
                window.clearTimeout(timeout);
            }, delay);
        };
        PlayerControl.prototype.clearSelection = function () {
            this.selectedFleets = [];
            this.inspectedFleets = [];
            this.selectedStar = null;
        };
        PlayerControl.prototype.updateSelection = function (endReorganizingFleets) {
            if (endReorganizingFleets === void 0) { endReorganizingFleets = true; }
            if (endReorganizingFleets)
                this.endReorganizingFleets();
            this.currentAttackTargets = this.getCurrentAttackTargets();
            eventManager_15.default.dispatchEvent("playerControlUpdated", null);
            eventManager_15.default.dispatchEvent("clearPossibleActions", null);
        };
        PlayerControl.prototype.areAllFleetsInSameLocation = function () {
            if (this.selectedFleets.length <= 0)
                return false;
            for (var i = 1; i < this.selectedFleets.length; i++) {
                if (this.selectedFleets[i].location !== this.selectedFleets[i - 1].location) {
                    return false;
                }
            }
            return true;
        };
        PlayerControl.prototype.selectFleets = function (fleets) {
            if (fleets.length < 1) {
                this.clearSelection();
                this.updateSelection();
                return;
            }
            var playerFleets = [];
            var otherFleets = [];
            for (var i = 0; i < fleets.length; i++) {
                if (fleets[i].player === this.player) {
                    playerFleets.push(fleets[i]);
                }
                else {
                    otherFleets.push(fleets[i]);
                }
            }
            if (playerFleets.length > 0) {
                this.selectPlayerFleets(playerFleets);
            }
            else {
                this.selectOtherFleets(otherFleets);
            }
            this.updateSelection();
            this.preventGhost(15);
        };
        PlayerControl.prototype.selectPlayerFleets = function (fleets) {
            this.clearSelection();
            for (var i = 0; i < fleets.length; i++) {
                if (fleets[i].units.length < 1) {
                    if (this.currentlyReorganizing.indexOf(fleets[i]) >= 0)
                        continue;
                    fleets[i].deleteFleet();
                    fleets.splice(i, 1);
                }
            }
            this.selectedFleets = fleets;
        };
        PlayerControl.prototype.selectOtherFleets = function (fleets) {
            this.inspectedFleets = fleets;
        };
        PlayerControl.prototype.deselectFleet = function (fleet) {
            var fleetsContainer = this.selectedFleets.length > 0 ? this.selectedFleets : this.inspectedFleets;
            var fleetIndex = fleetsContainer.indexOf(fleet);
            if (fleetIndex < 0)
                return;
            fleetsContainer.splice(fleetIndex, 1);
            if (fleetsContainer.length < 1) {
                this.selectedStar = fleet.location;
            }
            this.updateSelection();
        };
        PlayerControl.prototype.getMasterFleetForMerge = function (fleets) {
            return fleets[0];
        };
        PlayerControl.prototype.mergeFleetsOfSameType = function (fleets) {
            if (fleets.length === 0)
                return [];
            var master = this.getMasterFleetForMerge(fleets);
            fleets.splice(fleets.indexOf(master), 1);
            var slaves = fleets;
            for (var i = 0; i < slaves.length; i++) {
                slaves[i].mergeWith(master, i === slaves.length - 1);
            }
            return [master];
        };
        PlayerControl.prototype.mergeFleets = function () {
            var allFleets = this.selectedFleets;
            var normalFleets = [];
            var stealthyFleets = [];
            for (var i = 0; i < allFleets.length; i++) {
                if (allFleets[i].isStealthy) {
                    stealthyFleets.push(allFleets[i]);
                }
                else {
                    normalFleets.push(allFleets[i]);
                }
            }
            this.clearSelection();
            this.selectedFleets =
                this.mergeFleetsOfSameType(normalFleets).concat(this.mergeFleetsOfSameType(stealthyFleets));
            this.updateSelection();
        };
        PlayerControl.prototype.selectStar = function (star) {
            if (this.preventingGhost || this.selectedStar === star)
                return;
            this.clearSelection();
            this.selectedStar = star;
            this.updateSelection();
        };
        PlayerControl.prototype.moveFleets = function (star) {
            for (var i = 0; i < this.selectedFleets.length; i++) {
                this.selectedFleets[i].pathFind(star);
            }
        };
        PlayerControl.prototype.splitFleet = function (fleet) {
            if (fleet.units.length <= 0)
                return;
            this.endReorganizingFleets();
            var newFleet = fleet.split();
            this.currentlyReorganizing = [fleet, newFleet];
            this.selectedFleets = [fleet, newFleet];
            this.updateSelection(false);
        };
        PlayerControl.prototype.startReorganizingFleets = function (fleets) {
            if (fleets.length !== 2 ||
                fleets[0].location !== fleets[1].location ||
                this.selectedFleets.length !== 2 ||
                this.selectedFleets.indexOf(fleets[0]) < 0 ||
                this.selectedFleets.indexOf(fleets[1]) < 0) {
                throw new Error("cant reorganize fleets");
            }
            this.currentlyReorganizing = fleets;
            this.updateSelection(false);
        };
        PlayerControl.prototype.endReorganizingFleets = function () {
            for (var i = 0; i < this.currentlyReorganizing.length; i++) {
                var fleet = this.currentlyReorganizing[i];
                if (fleet.units.length <= 0) {
                    var selectedIndex = this.selectedFleets.indexOf(fleet);
                    if (selectedIndex >= 0) {
                        this.selectedFleets.splice(selectedIndex, 1);
                    }
                    fleet.deleteFleet();
                }
            }
            this.currentlyReorganizing = [];
        };
        PlayerControl.prototype.getCurrentAttackTargets = function () {
            if (this.selectedFleets.length < 1)
                return [];
            if (!this.areAllFleetsInSameLocation())
                return [];
            var location = this.selectedFleets[0].location;
            var possibleTargets = location.getTargetsForPlayer(this.player);
            return possibleTargets;
        };
        PlayerControl.prototype.attackTarget = function (target) {
            if (this.currentAttackTargets.indexOf(target) < 0) {
                throw new Error("Invalid attack target");
            }
            var currentLocation = this.selectedFleets[0].location;
            this.player.attackTarget(currentLocation, target);
        };
        return PlayerControl;
    }());
    exports.default = PlayerControl;
});
define("src/ReactUIScene", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("src/pixiWrapperFunctions", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function createDummySpriteForShader(x, y, width, height) {
        var texture = getDummyTextureForShader();
        var sprite = new PIXI.Sprite(texture);
        if (x || y) {
            sprite.position = new PIXI.Point(x || 0, y || 0);
        }
        if (width) {
            sprite.width = width;
        }
        if (height) {
            sprite.height = height;
        }
        return sprite;
    }
    exports.createDummySpriteForShader = createDummySpriteForShader;
    function getDummyTextureForShader() {
        var canvas = document.createElement("canvas");
        canvas._pixiId = "dummyShaderTexture";
        canvas.width = 1;
        canvas.height = 1;
        return PIXI.Texture.fromCanvas(canvas);
    }
    exports.getDummyTextureForShader = getDummyTextureForShader;
    function makeShaderSprite(shader, x, y, width, height) {
        var sprite = createDummySpriteForShader(x, y, width, height);
        attachShaderToSprite(sprite, shader);
        return sprite;
    }
    exports.makeShaderSprite = makeShaderSprite;
    function attachShaderToSprite(sprite, shader) {
        sprite.filters = [shader];
        sprite.filterArea = sprite.getBounds();
    }
    exports.attachShaderToSprite = attachShaderToSprite;
    function convertClientRectToPixiRect(rect) {
        return new PIXI.Rectangle(rect.left, rect.top, rect.width, rect.height);
    }
    exports.convertClientRectToPixiRect = convertClientRectToPixiRect;
    function generateTextureWithBounds(renderer, displayObject, scaleMode, resolution, customBounds) {
        var bounds = customBounds;
        var renderTexture = PIXI.RenderTexture.create(bounds.width || 0, bounds.height || 0, scaleMode, resolution);
        var tempMatrix = new PIXI.Matrix();
        tempMatrix.tx = -bounds.x;
        tempMatrix.ty = -bounds.y;
        renderer.render(displayObject, renderTexture, false, tempMatrix, true);
        return renderTexture;
    }
    exports.generateTextureWithBounds = generateTextureWithBounds;
    function makePolygonFromPoints(points) {
        var pointPositions = [];
        points.forEach(function (point) {
            pointPositions.push(point.x, point.y);
        });
        return new PIXI.Polygon(pointPositions);
    }
    exports.makePolygonFromPoints = makePolygonFromPoints;
});
define("src/BackgroundDrawer", ["require", "exports", "src/pixiWrapperFunctions"], function (require, exports, pixiWrapperFunctions_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BackgroundDrawer = (function () {
        function BackgroundDrawer(props) {
            this.resizeBuffer = {
                width: 15,
                height: 15,
            };
            this.layers = {
                bg: null,
                blur: null,
            };
            this.drawBackgroundFN = props.drawBackgroundFN;
            this.seed = props.seed;
            this.blurFilter = new PIXI.filters.BlurFilter();
            this.blurFilter.blur = 1;
            this.pixiContainer = new PIXI.Container();
            this.setExternalRenderer(props.renderer);
        }
        BackgroundDrawer.prototype.setExternalRenderer = function (renderer) {
            this.renderer = renderer;
            this.hasExternalRenderer = Boolean(renderer);
        };
        BackgroundDrawer.prototype.destroy = function () {
            if (!this.hasExternalRenderer) {
                this.renderer.destroy(true);
                this.renderer = null;
            }
            this.containerElement = null;
            this.destroyOldBackground();
            this.pixiContainer.removeChildren();
            this.blurFilter = null;
        };
        BackgroundDrawer.prototype.bindRendererView = function (containerElement) {
            if (this.hasExternalRenderer) {
                this.containerElement = containerElement;
                return;
            }
            if (this.containerElement) {
                this.containerElement.removeChild(this.renderer.view);
            }
            this.containerElement = containerElement;
            if (!this.renderer) {
                this.renderer = this.createRenderer();
            }
            this.containerElement.appendChild(this.renderer.view);
        };
        BackgroundDrawer.prototype.handleResize = function () {
            if (!this.containerElement) {
                return;
            }
            var containerElementRect = this.getContainerElementRect();
            if (!this.hasExternalRenderer) {
                this.renderer.resize(containerElementRect.width, containerElementRect.height);
            }
            if (!this.cachedBackgroundSize ||
                this.isRectBiggerThanCachedBackground(containerElementRect)) {
                this.drawScene();
            }
            if (this.blurArea) {
                this.setBlurMask();
            }
            if (!this.hasExternalRenderer) {
                this.renderer.render(this.pixiContainer);
            }
        };
        BackgroundDrawer.prototype.drawBackground = function () {
            var backgroundSize = this.getDesiredBackgroundSize();
            var bg = this.drawBackgroundFN(this.seed, backgroundSize, this.renderer);
            this.destroyBackgroundFN = bg.destroy;
            this.cachedBackgroundSize = backgroundSize;
            return bg.displayObject;
        };
        BackgroundDrawer.prototype.drawBlurredBackground = function (background) {
            background.filters = [this.blurFilter];
            var blurTextureSize = this.getDesiredBlurSize();
            var blurTexture = pixiWrapperFunctions_1.generateTextureWithBounds(this.renderer, background, PIXI.settings.SCALE_MODE, this.renderer.resolution, blurTextureSize);
            background.filters = null;
            var blurSprite = new PIXI.Sprite(blurTexture);
            return blurSprite;
        };
        BackgroundDrawer.prototype.drawScene = function () {
            this.pixiContainer.removeChildren();
            this.destroyOldBackground();
            this.layers.bg = this.drawBackground();
            this.pixiContainer.addChild(this.layers.bg);
            if (this.blurArea) {
                this.layers.blur = this.drawBlurredBackground(this.layers.bg);
                this.pixiContainer.addChild(this.layers.blur);
            }
        };
        BackgroundDrawer.prototype.setBlurMask = function () {
            if (!this.layers.blur.mask) {
                this.layers.blur.mask = new PIXI.Graphics();
            }
            var mask = this.layers.blur.mask;
            mask.clear();
            mask.beginFill(0x000000);
            mask.drawShape(this.blurArea);
            mask.endFill();
        };
        BackgroundDrawer.prototype.destroyOldBackground = function () {
            if (this.destroyBackgroundFN) {
                this.destroyBackgroundFN();
                this.destroyBackgroundFN = null;
            }
        };
        BackgroundDrawer.prototype.createRenderer = function () {
            var renderer = PIXI.autoDetectRenderer(this.containerElement.clientWidth, this.containerElement.clientHeight, {
                autoResize: false,
                resolution: window.devicePixelRatio,
            });
            renderer.view.setAttribute("id", "pixi-canvas");
            return renderer;
        };
        BackgroundDrawer.prototype.addBufferToRect = function (rect) {
            var cloned = rect.clone();
            cloned.width += this.resizeBuffer.width;
            cloned.height += this.resizeBuffer.height;
            return cloned;
        };
        BackgroundDrawer.prototype.getDesiredBackgroundSize = function () {
            return this.addBufferToRect(this.getContainerElementRect());
        };
        BackgroundDrawer.prototype.getDesiredBlurSize = function () {
            return this.cachedBackgroundSize;
        };
        BackgroundDrawer.prototype.getContainerElementRect = function () {
            var w = this.containerElement.clientWidth;
            var h = this.containerElement.clientHeight;
            return new PIXI.Rectangle(0, 0, w, h);
        };
        BackgroundDrawer.prototype.isRectBiggerThanCachedBackground = function (toCheck) {
            return (toCheck.width > this.cachedBackgroundSize.width ||
                toCheck.height > this.cachedBackgroundSize.height);
        };
        return BackgroundDrawer;
    }());
    exports.default = BackgroundDrawer;
});
define("src/MouseEventHandler", ["require", "exports", "src/RectangleSelect", "src/eventManager"], function (require, exports, RectangleSelect_1, eventManager_16) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MouseButtons;
    (function (MouseButtons) {
        MouseButtons[MouseButtons["None"] = 0] = "None";
        MouseButtons[MouseButtons["Left"] = 1] = "Left";
        MouseButtons[MouseButtons["Right"] = 2] = "Right";
        MouseButtons[MouseButtons["Middle"] = 4] = "Middle";
    })(MouseButtons || (MouseButtons = {}));
    var MouseEventHandler = (function () {
        function MouseEventHandler(interactionManager, camera, selectionLayer, mainLayer) {
            this.currentActions = {
                pan: false,
                select: false,
                fleetMove: false,
            };
            this.currentActionIsCanceled = false;
            this.actionHasStarted = false;
            this.preventingGhost = {
                hover: undefined,
            };
            this.listeners = {
                hoverStar: undefined,
                clearHover: undefined,
            };
            this.pixiCanvasListeners = {
                mousewheel: undefined,
                contextmenu: undefined,
            };
            this.interactionManager = interactionManager;
            this.camera = camera;
            this.rectangleSelect = new RectangleSelect_1.default(selectionLayer, mainLayer);
            this.bindEventHandlers();
            this.addEventListeners();
        }
        MouseEventHandler.getButtonChanges = function (oldButtons, newButtons) {
            return oldButtons ^ newButtons;
        };
        MouseEventHandler.getActionsInButtonChanges = function (buttonChanges) {
            return ({
                pan: Boolean(buttonChanges & MouseButtons.Middle),
                select: Boolean(buttonChanges & MouseButtons.Left),
                fleetMove: Boolean(buttonChanges & MouseButtons.Right),
            });
        };
        MouseEventHandler.prototype.destroy = function () {
            for (var name_4 in this.listeners) {
                eventManager_16.default.removeEventListener(name_4, this.listeners[name_4]);
            }
            for (var name_5 in this.pixiCanvasListeners) {
                this.pixiCanvas.removeEventListener(name_5, this.pixiCanvasListeners[name_5]);
            }
            this.interactionManager.off("pointerdown", this.onPointerDown);
            this.interactionManager.off("pointerup", this.onPointerUp);
            this.interactionManager.off("pointerupoutside", this.onPointerUp);
            this.interactionManager.off("pointermove", this.onPointerChange);
            this.pixiCanvas = null;
            this.hoveredStar = null;
            this.rectangleSelect.destroy();
            this.rectangleSelect = null;
            this.interactionManager = null;
            this.camera = null;
        };
        MouseEventHandler.prototype.addEventListeners = function () {
            var _this = this;
            this.pixiCanvas = document.getElementById("pixi-canvas");
            this.pixiCanvasListeners.contextmenu = this.handleContextMenu;
            this.pixiCanvas.addEventListener("contextmenu", this.handleContextMenu);
            this.pixiCanvasListeners.mousewheel = this.handleMouseWheel;
            this.pixiCanvas.addEventListener("mousewheel", this.handleMouseWheel);
            this.listeners.hoverStar = eventManager_16.default.addEventListener("hoverStar", function (star) {
                _this.setHoveredStar(star);
            });
            this.listeners.clearHover = eventManager_16.default.addEventListener("clearHover", function () {
                _this.clearHoveredStar();
            });
            this.interactionManager.on("pointerdown", this.onPointerDown);
            this.interactionManager.on("pointerup", this.onPointerUp);
            this.interactionManager.on("pointerupoutside", this.onPointerUp);
            this.interactionManager.on("pointermove", this.onPointerChange);
        };
        MouseEventHandler.prototype.bindEventHandlers = function () {
            this.handleContextMenu = this.handleContextMenu.bind(this);
            this.handleMouseWheel = this.handleMouseWheel.bind(this);
            this.onPointerDown = this.onPointerDown.bind(this);
            this.onPointerChange = this.onPointerChange.bind(this);
            this.onPointerUp = this.onPointerUp.bind(this);
        };
        MouseEventHandler.prototype.preventGhost = function (delay, type) {
            var _this = this;
            if (this.preventingGhost[type]) {
                window.clearTimeout(this.preventingGhost[type]);
            }
            this.preventingGhost[type] = window.setTimeout(function () {
                _this.preventingGhost[type] = null;
            }, delay);
        };
        MouseEventHandler.prototype.makeUITransparent = function () {
            var ui = document.getElementsByClassName("galaxy-map-ui")[0];
            if (ui) {
                ui.classList.add("mouse-event-active-ui");
            }
        };
        MouseEventHandler.prototype.makeUIOpaque = function () {
            var ui = document.getElementsByClassName("galaxy-map-ui")[0];
            if (ui) {
                ui.classList.remove("mouse-event-active-ui");
            }
        };
        MouseEventHandler.prototype.onPointerDown = function (e) {
            this.currentActionIsCanceled = false;
            this.actionHasStarted = true;
            this.makeUITransparent();
            this.onPointerChange(e);
        };
        MouseEventHandler.prototype.onPointerChange = function (e) {
            if (!this.actionHasStarted) {
                return;
            }
            var newPressedButtons = this.currentActionIsCanceled ?
                e.data.buttons & ~MouseButtons.Left & ~MouseButtons.Right :
                e.data.buttons;
            var changedButtons = MouseEventHandler.getButtonChanges(this.pressedButtons, newPressedButtons);
            if (changedButtons) {
                this.pressedButtons = newPressedButtons;
                var changedActions = MouseEventHandler.getActionsInButtonChanges(changedButtons);
                for (var key in changedActions) {
                    if (changedActions[key]) {
                        this.handleActionChange(key, e);
                    }
                }
            }
            if (this.currentActions.pan) {
                this.handlePanMove(e);
            }
            if (this.currentActions.select) {
                this.handleSelectionMove(e);
            }
        };
        MouseEventHandler.prototype.onPointerUp = function (e) {
            this.onPointerChange(e);
            this.actionHasStarted = false;
            this.makeUIOpaque();
        };
        MouseEventHandler.prototype.handleContextMenu = function (e) {
            e.stopPropagation();
            e.preventDefault();
        };
        MouseEventHandler.prototype.handleMouseWheel = function (e) {
            this.camera.deltaZoom(e.wheelDelta / 40, 0.05);
            this.rectangleSelect.handleTargetLayerShift();
        };
        MouseEventHandler.prototype.setHoveredStar = function (star) {
            this.preventGhost(30, "hover");
            if (star !== this.hoveredStar) {
                this.hoveredStar = star;
                if (this.currentActions.fleetMove) {
                    this.setFleetMoveTarget(star);
                }
            }
        };
        MouseEventHandler.prototype.clearHoveredStar = function () {
            var _this = this;
            var timeout = window.setTimeout(function () {
                if (!_this.preventingGhost.hover) {
                    _this.hoveredStar = null;
                    if (_this.currentActions.fleetMove) {
                        _this.clearFleetMoveTarget();
                    }
                }
                window.clearTimeout(timeout);
            }, 15);
        };
        MouseEventHandler.prototype.handleActionChange = function (action, e) {
            switch (action) {
                case "pan":
                    {
                        if (!this.currentActions.pan) {
                            this.handlePanStart(e);
                        }
                        else {
                            this.handlePanEnd();
                        }
                        break;
                    }
                case "select":
                    {
                        if (this.currentActions.fleetMove) {
                            this.cancelCurrentAction();
                        }
                        else if (!this.currentActions.select) {
                            this.handleSelectionStart(e);
                        }
                        else {
                            this.completeSelection(e);
                        }
                        break;
                    }
                case "fleetMove":
                    {
                        if (this.currentActions.select) {
                            this.cancelCurrentAction();
                        }
                        else if (!this.currentActions.fleetMove) {
                            this.handleFleetMoveStart();
                        }
                        else {
                            this.completeFleetMove();
                        }
                        break;
                    }
            }
        };
        MouseEventHandler.prototype.cancelCurrentAction = function () {
            this.currentActionIsCanceled = true;
            if (this.currentActions.fleetMove) {
                this.handleFleetMoveStop();
            }
            if (this.currentActions.select) {
                this.handleSelectionStop();
            }
        };
        MouseEventHandler.prototype.handlePanStart = function (e) {
            this.camera.startScroll(e.data.global);
            this.currentActions.pan = true;
        };
        MouseEventHandler.prototype.handlePanMove = function (e) {
            this.camera.scrollMove(e.data.global);
            this.rectangleSelect.handleTargetLayerShift();
        };
        MouseEventHandler.prototype.handlePanEnd = function () {
            this.currentActions.pan = false;
        };
        MouseEventHandler.prototype.handleSelectionStart = function (e) {
            this.rectangleSelect.startSelection(e.data.global);
            this.currentActions.select = true;
        };
        MouseEventHandler.prototype.handleSelectionMove = function (e) {
            this.rectangleSelect.moveSelection(e.data.global);
        };
        MouseEventHandler.prototype.completeSelection = function (e) {
            this.rectangleSelect.endSelection();
            this.handleSelectionStop();
        };
        MouseEventHandler.prototype.handleSelectionStop = function () {
            this.rectangleSelect.clearSelection();
            this.currentActions.select = false;
        };
        MouseEventHandler.prototype.setFleetMoveTarget = function (star) {
            eventManager_16.default.dispatchEvent("setPotentialMoveTarget", star);
        };
        MouseEventHandler.prototype.clearFleetMoveTarget = function () {
            eventManager_16.default.dispatchEvent("clearPotentialMoveTarget");
        };
        MouseEventHandler.prototype.handleFleetMoveStart = function () {
            eventManager_16.default.dispatchEvent("startPotentialMove");
            if (this.hoveredStar) {
                this.setFleetMoveTarget(this.hoveredStar);
            }
            this.currentActions.fleetMove = true;
        };
        MouseEventHandler.prototype.completeFleetMove = function () {
            if (this.hoveredStar) {
                eventManager_16.default.dispatchEvent("moveFleets", this.hoveredStar);
            }
            this.handleFleetMoveStop();
        };
        MouseEventHandler.prototype.handleFleetMoveStop = function () {
            eventManager_16.default.dispatchEvent("endPotentialMove");
            this.currentActions.fleetMove = false;
        };
        return MouseEventHandler;
    }());
    exports.default = MouseEventHandler;
});
define("src/PathfindingArrow", ["require", "exports", "src/App", "src/Color", "src/eventManager"], function (require, exports, App_7, Color_3, eventManager_17) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PathfindingArrow = (function () {
        function PathfindingArrow(parentContainer) {
            this.selectedFleets = [];
            this.labelCache = {};
            this.listeners = {};
            this.curveStyles = {
                reachable: {
                    color: Color_3.default.fromHex(0xFFFFF0),
                },
                unreachable: {
                    color: Color_3.default.fromHex(0xFF0000),
                },
            };
            this.parentContainer = parentContainer;
            this.container = new PIXI.Container();
            this.parentContainer.addChild(this.container);
            this.addEventListeners();
        }
        PathfindingArrow.prototype.destroy = function () {
            this.active = false;
            this.removeEventListeners();
            this.parentContainer = null;
            this.container = null;
            this.currentTarget = null;
            window.clearTimeout(this.clearTargetTimeout);
            this.selectedFleets = null;
            this.labelCache = null;
        };
        PathfindingArrow.prototype.removeEventListener = function (name) {
            eventManager_17.default.removeEventListener(name, this.listeners[name]);
        };
        PathfindingArrow.prototype.removeEventListeners = function () {
            for (var name_6 in this.listeners) {
                this.removeEventListener(name_6);
            }
        };
        PathfindingArrow.prototype.addEventListener = function (name, handler) {
            this.listeners[name] = handler;
            eventManager_17.default.addEventListener(name, handler);
        };
        PathfindingArrow.prototype.addEventListeners = function () {
            var self = this;
            this.addEventListener("startPotentialMove", function () {
                self.startMove();
            });
            this.addEventListener("setPotentialMoveTarget", function (star) {
                self.setTarget(star);
            });
            this.addEventListener("clearPotentialMoveTarget", function () {
                self.clearTarget();
            });
            this.addEventListener("endPotentialMove", function () {
                self.endMove();
            });
        };
        PathfindingArrow.prototype.startMove = function () {
            var fleets = App_7.default.playerControl.selectedFleets;
            if (this.active || !fleets || fleets.length < 1) {
                return;
            }
            this.active = true;
            this.currentTarget = null;
            this.selectedFleets = fleets;
            this.clearArrows();
        };
        PathfindingArrow.prototype.setTarget = function (star) {
            if (!this.active) {
                return;
            }
            if (this.clearTargetTimeout) {
                window.clearTimeout(this.clearTargetTimeout);
            }
            this.currentTarget = star;
            window.setTimeout(this.drawAllCurrentCurves.bind(this), 10);
        };
        PathfindingArrow.prototype.clearTarget = function () {
            if (!this.active) {
                return;
            }
            var self = this;
            if (this.clearTargetTimeout) {
                window.clearTimeout(this.clearTargetTimeout);
            }
            this.clearTargetTimeout = window.setTimeout(function () {
                self.currentTarget = null;
                self.clearArrows();
                self.clearTargetTimeout = null;
            }, 10);
        };
        PathfindingArrow.prototype.endMove = function () {
            this.active = false;
            this.currentTarget = null;
            this.selectedFleets = [];
            this.clearArrows();
        };
        PathfindingArrow.prototype.clearArrows = function () {
            this.container.removeChildren();
        };
        PathfindingArrow.prototype.makeLabel = function (style, distance) {
            var textStyle;
            switch (style) {
                case "reachable":
                    {
                        textStyle =
                            {
                                fill: 0xFFFFF0,
                            };
                        break;
                    }
                case "unreachable":
                    {
                        textStyle =
                            {
                                fill: 0xFF0000,
                            };
                        break;
                    }
            }
            if (!this.labelCache[style]) {
                this.labelCache[style] = {};
            }
            this.labelCache[style][distance] = new PIXI.Text("" + distance, textStyle);
        };
        PathfindingArrow.prototype.getLabel = function (style, distance) {
            if (!this.labelCache[style] || !this.labelCache[style][distance]) {
                this.makeLabel(style, distance);
            }
            return this.labelCache[style][distance];
        };
        PathfindingArrow.prototype.getAllCurrentPaths = function () {
            var paths = [];
            for (var i = 0; i < this.selectedFleets.length; i++) {
                var fleet = this.selectedFleets[i];
                if (fleet.location.id === this.currentTarget.id)
                    continue;
                var path = fleet.getPathTo(this.currentTarget);
                paths.push({
                    fleet: fleet,
                    path: path,
                });
            }
            return paths;
        };
        PathfindingArrow.prototype.getAllCurrentCurves = function () {
            var paths = this.getAllCurrentPaths();
            var curves = [];
            var totalPathsPerStar = {};
            var alreadyVisitedPathsPerStar = {};
            for (var i = 0; i < paths.length; i++) {
                for (var j = 0; j < paths[i].path.length; j++) {
                    var star = paths[i].path[j].star;
                    if (!totalPathsPerStar[star.id]) {
                        totalPathsPerStar[star.id] = 0;
                        alreadyVisitedPathsPerStar[star.id] = 0;
                    }
                    totalPathsPerStar[star.id]++;
                }
            }
            for (var i = 0; i < paths.length; i++) {
                var fleet = paths[i].fleet;
                var path = paths[i].path;
                var distance = path.length - 1;
                var currentMovePoints = fleet.getMinCurrentMovePoints();
                var canReach = currentMovePoints >= distance;
                var style = canReach ? "reachable" : "unreachable";
                var curvePoints = [];
                for (var j = path.length - 1; j >= 0; j--) {
                    var star = path[j].star;
                    var sourceStar = j < path.length - 1 ? path[j + 1].star : null;
                    if (totalPathsPerStar[star.id] > 1 && star !== this.currentTarget) {
                        var visits = ++alreadyVisitedPathsPerStar[star.id];
                        curvePoints.unshift(this.getTargetOffset(star, sourceStar, visits, totalPathsPerStar[star.id], 12));
                    }
                    else {
                        curvePoints.unshift(star);
                    }
                }
                var curveData = this.getCurveData(curvePoints);
                curves.push({
                    style: style,
                    curveData: curveData,
                });
            }
            return curves;
        };
        PathfindingArrow.prototype.drawAllCurrentCurves = function () {
            this.clearArrows();
            var curves = this.getAllCurrentCurves();
            for (var i = 0; i < curves.length; i++) {
                var curve = this.drawCurve(curves[i].curveData, this.curveStyles[curves[i].style]);
                this.container.addChild(curve);
            }
        };
        PathfindingArrow.prototype.getCurveData = function (points) {
            var i6 = 1.0 / 6.0;
            var path = [];
            var abababa = [points[0]].concat(points);
            abababa.push(points[points.length - 1]);
            for (var i = 3, n = abababa.length; i < n; i++) {
                var p0 = abababa[i - 3];
                var p1 = abababa[i - 2];
                var p2 = abababa[i - 1];
                var p3 = abababa[i];
                path.push([
                    p2.x * i6 + p1.x - p0.x * i6,
                    p2.y * i6 + p1.y - p0.y * i6,
                    p3.x * -i6 + p2.x + p1.x * i6,
                    p3.y * -i6 + p2.y + p1.y * i6,
                    p2.x,
                    p2.y,
                ]);
            }
            path[0][0] = points[0].x;
            path[0][1] = points[0].y;
            return path;
        };
        PathfindingArrow.prototype.drawCurve = function (points, style) {
            var gfx = new PIXI.Graphics();
            gfx.lineStyle(12, style.color.getHex(), 0.7);
            gfx.moveTo(points[0][0], points[0][1]);
            for (var i = 0; i < points.length; i++) {
                gfx.bezierCurveTo.apply(gfx, points[i]);
            }
            var curveShape = gfx.currentPath.shape;
            curveShape.closed = false;
            this.drawArrowHead(gfx, style.color.getHex());
            return gfx;
        };
        PathfindingArrow.prototype.drawArrowHead = function (gfx, color) {
            var curveShape = gfx.currentPath.shape;
            var points = curveShape.points;
            var x1 = points[points.length - 12];
            var y1 = points[points.length - 11];
            var x2 = points[points.length - 2];
            var y2 = points[points.length - 1];
            var lineAngle = Math.atan2(y2 - y1, x2 - x1);
            var headLength = 30;
            var buttAngle = 27 * (Math.PI / 180);
            var hypotenuseLength = Math.abs(headLength / Math.cos(buttAngle));
            var angle1 = lineAngle + Math.PI + buttAngle;
            var topX = x2 + Math.cos(angle1) * hypotenuseLength;
            var topY = y2 + Math.sin(angle1) * hypotenuseLength;
            var angle2 = lineAngle + Math.PI - buttAngle;
            var botX = x2 + Math.cos(angle2) * hypotenuseLength;
            var botY = y2 + Math.sin(angle2) * hypotenuseLength;
            gfx.lineStyle(null);
            gfx.moveTo(x2, y2);
            gfx.beginFill(color, 0.7);
            gfx.lineTo(topX, topY);
            gfx.lineTo(botX, botY);
            gfx.lineTo(x2, y2);
            gfx.endFill();
            var buttMidX = x2 + Math.cos(lineAngle + Math.PI) * headLength;
            var buttMidY = y2 + Math.sin(lineAngle + Math.PI) * headLength;
            for (var i = points.length - 1; i >= 0; i -= 2) {
                var y = points[i];
                var x = points[i - 1];
                var distance = Math.sqrt(Math.pow(x2 - x, 2) + Math.pow(y2 - y, 2));
                if (distance >= headLength + 10) {
                    points.push(buttMidX);
                    points.push(buttMidY);
                    break;
                }
                else {
                    points.pop();
                    points.pop();
                }
            }
        };
        PathfindingArrow.prototype.getTargetOffset = function (target, sourcePoint, i, totalPaths, offsetPerOrbit) {
            var maxPerOrbit = 6;
            var currentOrbit = Math.ceil(i / maxPerOrbit);
            var isOuterOrbit = currentOrbit > Math.floor(totalPaths / maxPerOrbit);
            var pathsInCurrentOrbit = isOuterOrbit ? totalPaths % maxPerOrbit : maxPerOrbit;
            var positionInOrbit = (i - 1) % pathsInCurrentOrbit;
            var distance = currentOrbit * offsetPerOrbit;
            var angle = (Math.PI * 2 / pathsInCurrentOrbit) * positionInOrbit;
            if (sourcePoint) {
                var dx = sourcePoint.x - target.x;
                var dy = sourcePoint.y - target.y;
                var approachAngle = Math.atan2(dy, dx);
                angle += approachAngle;
            }
            var x = Math.sin(angle) * distance;
            var y = Math.cos(angle) * distance;
            return ({
                x: target.x + x,
                y: target.y - y,
            });
        };
        return PathfindingArrow;
    }());
    exports.default = PathfindingArrow;
});
define("src/Renderer", ["require", "exports", "src/BackgroundDrawer", "src/Camera", "src/MouseEventHandler", "src/PathfindingArrow"], function (require, exports, BackgroundDrawer_1, Camera_1, MouseEventHandler_1, PathfindingArrow_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Renderer = (function () {
        function Renderer(backgroundSeed, backgroundDrawingFunction) {
            this.activeRenderLoopId = 0;
            this.isPaused = false;
            this.forceFrame = false;
            PIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.NEAREST;
            this.stage = new PIXI.Container();
            this.backgroundDrawer = new BackgroundDrawer_1.default({
                seed: backgroundSeed,
                drawBackgroundFN: backgroundDrawingFunction,
            });
            this.setupDefaultLayers();
            this.activeRenderLoopId++;
            this.stage.renderable = true;
            this.resizeListener = this.resize.bind(this);
            window.addEventListener("resize", this.resizeListener, false);
        }
        Renderer.prototype.destroy = function () {
            this.stage.renderable = false;
            this.pause();
            this.backgroundDrawer.destroy();
            if (this.pathfindingArrow) {
                this.pathfindingArrow.destroy();
                this.pathfindingArrow = null;
            }
            if (this.mouseEventHandler) {
                this.mouseEventHandler.destroy();
                this.mouseEventHandler = null;
            }
            if (this.camera) {
                this.camera.destroy();
                this.camera = null;
            }
            if (this.renderer) {
                this.renderer.destroy(true);
                this.renderer = null;
            }
            this.stage.destroy(true);
            this.stage = null;
            this.pixiContainer = null;
            window.removeEventListener("resize", this.resizeListener);
        };
        Renderer.prototype.removeRendererView = function () {
            if (this.renderer && this.renderer.view.parentNode) {
                this.renderer.view.parentNode.removeChild(this.renderer.view);
            }
        };
        Renderer.prototype.bindRendererView = function (container) {
            this.pixiContainer = container;
            if (!this.renderer) {
                var containerStyle = window.getComputedStyle(this.pixiContainer);
                this.renderer = new PIXI.WebGLRenderer(parseInt(containerStyle.width), parseInt(containerStyle.height), {
                    autoResize: false,
                    antialias: true,
                });
                this.backgroundDrawer.setExternalRenderer(this.renderer);
            }
            this.pixiContainer.appendChild(this.renderer.view);
            this.renderer.view.setAttribute("id", "pixi-canvas");
            this.backgroundDrawer.bindRendererView(this.pixiContainer);
            this.resize();
            this.addCamera();
        };
        Renderer.prototype.pause = function () {
            this.isPaused = true;
            this.forceFrame = false;
        };
        Renderer.prototype.resume = function () {
            this.isPaused = false;
            this.forceFrame = false;
            this.activeRenderLoopId = this.activeRenderLoopId++;
            this.render(this.activeRenderLoopId);
        };
        Renderer.prototype.setupDefaultLayers = function () {
            this.layers =
                {
                    background: this.backgroundDrawer.pixiContainer,
                    main: new PIXI.Container(),
                    map: new PIXI.Container(),
                    select: new PIXI.Container(),
                };
            this.stage.removeChildren();
            this.stage.addChild(this.layers.background);
            this.layers.background.interactive = false;
            this.layers.background.interactiveChildren = false;
            this.stage.addChild(this.layers.main);
            this.layers.main.addChild(this.layers.map);
            this.stage.addChild(this.layers.select);
            this.layers.select.interactive = false;
            this.layers.select.interactiveChildren = false;
        };
        Renderer.prototype.addCamera = function () {
            if (this.mouseEventHandler) {
                this.mouseEventHandler.destroy();
            }
            if (this.camera) {
                this.camera.destroy();
            }
            this.camera = new Camera_1.default(this.layers.main);
            this.mouseEventHandler = new MouseEventHandler_1.default(this.renderer.plugins.interaction, this.camera, this.layers.select, this.layers.main);
            this.pathfindingArrow = new PathfindingArrow_1.default(this.layers.main);
        };
        Renderer.prototype.resize = function () {
            if (this.renderer && document.body.contains(this.renderer.view)) {
                var w = this.pixiContainer.offsetWidth * window.devicePixelRatio;
                var h = this.pixiContainer.offsetHeight * window.devicePixelRatio;
                this.renderer.resize(w, h);
                this.backgroundDrawer.handleResize();
                if (this.isPaused) {
                    this.renderOnce();
                }
            }
        };
        Renderer.prototype.renderOnce = function () {
            this.forceFrame = true;
            this.render();
        };
        Renderer.prototype.render = function (renderLoopId) {
            if (!document.body.contains(this.pixiContainer)) {
                this.pause();
                return;
            }
            if (this.isPaused) {
                if (this.forceFrame) {
                    this.forceFrame = false;
                }
                else {
                    return;
                }
            }
            this.renderer.render(this.stage);
            if (this.activeRenderLoopId === renderLoopId) {
                window.requestAnimationFrame(this.render.bind(this, renderLoopId));
            }
        };
        return Renderer;
    }());
    exports.default = Renderer;
});
define("src/localization/languageSupport", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var LanguageSupportLevel;
    (function (LanguageSupportLevel) {
        LanguageSupportLevel[LanguageSupportLevel["None"] = 0] = "None";
        LanguageSupportLevel[LanguageSupportLevel["Partial"] = 1] = "Partial";
        LanguageSupportLevel[LanguageSupportLevel["Full"] = 2] = "Full";
    })(LanguageSupportLevel = exports.LanguageSupportLevel || (exports.LanguageSupportLevel = {}));
    function getLanguageSupportLevelForModuleFiles() {
        var moduleFiles = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            moduleFiles[_i] = arguments[_i];
        }
        var totalModulesCount = moduleFiles.length;
        var languageSupportLevelByCode = {};
        var modulesGroupedByLanguageSupport = groupModuleFilesByLanguageSupport.apply(void 0, moduleFiles);
        for (var languageCode in modulesGroupedByLanguageSupport) {
            var supportedModulesCount = modulesGroupedByLanguageSupport[languageCode].length;
            if (supportedModulesCount < totalModulesCount) {
                languageSupportLevelByCode[languageCode] = LanguageSupportLevel.Partial;
            }
            else {
                languageSupportLevelByCode[languageCode] = LanguageSupportLevel.Full;
            }
        }
        return languageSupportLevelByCode;
    }
    exports.getLanguageSupportLevelForModuleFiles = getLanguageSupportLevelForModuleFiles;
    function getLanguagesByCode() {
        var moduleFiles = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            moduleFiles[_i] = arguments[_i];
        }
        var languagesByCode = {};
        moduleFiles.forEach(function (moduleFile) {
            if (moduleFile.supportedLanguages !== "all") {
                moduleFile.supportedLanguages.forEach(function (language) {
                    languagesByCode[language.code] = language;
                });
            }
        });
        return languagesByCode;
    }
    exports.getLanguagesByCode = getLanguagesByCode;
    function groupModuleFilesByLanguageSupport() {
        var moduleFiles = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            moduleFiles[_i] = arguments[_i];
        }
        var moduleFilesByLanguageSupport = {};
        moduleFiles.forEach(function (moduleFile) {
            if (moduleFile.supportedLanguages !== "all") {
                moduleFile.supportedLanguages.forEach(function (language) {
                    if (!moduleFilesByLanguageSupport[language.code]) {
                        moduleFilesByLanguageSupport[language.code] = [];
                    }
                    moduleFilesByLanguageSupport[language.code].push(moduleFile);
                });
            }
        });
        var universalModuleFiles = moduleFiles.filter(function (moduleFile) {
            return moduleFile.supportedLanguages === "all";
        });
        for (var code in moduleFilesByLanguageSupport) {
            (_a = moduleFilesByLanguageSupport[code]).push.apply(_a, universalModuleFiles);
        }
        return moduleFilesByLanguageSupport;
        var _a;
    }
});
define("src/localization/activeLanguage", ["require", "exports", "src/activeModuleData", "src/localization/languageSupport"], function (require, exports, activeModuleData_16, languageSupport_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var activeLanguageCode;
    function getActiveLanguage() {
        var languagesByCode = languageSupport_1.getLanguagesByCode.apply(void 0, activeModuleData_16.activeModuleData.moduleFiles);
        if (!languagesByCode[activeLanguageCode]) {
            throw new Error("Language '" + activeLanguageCode + "' is not supported by any module files. " +
                ("Supported languages: " + Object.keys(languagesByCode).join(", ")));
        }
        else {
            return languagesByCode[activeLanguageCode];
        }
    }
    exports.getActiveLanguage = getActiveLanguage;
    function setActiveLanguageCode(languageCode) {
        if (languageCode === activeLanguageCode) {
            return;
        }
        activeLanguageCode = languageCode;
    }
    exports.setActiveLanguageCode = setActiveLanguageCode;
});
define("src/BattleSceneUnit", ["require", "exports", "src/Options"], function (require, exports, Options_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BattleSceneUnit = (function () {
        function BattleSceneUnit(container, renderer) {
            this.unitState = 3;
            this.hasSFXSprite = false;
            this.container = container;
            this.renderer = renderer;
            this.spriteContainer = new PIXI.Container();
            this.container.addChild(this.spriteContainer);
        }
        BattleSceneUnit.prototype.changeActiveUnit = function (unit, afterChangedCallback) {
            if (this.hasSFXSprite) {
                if (unit) {
                    this.enterUnitSpriteWithoutAnimation(unit);
                }
                else {
                    this.exitUnitSpriteWithoutAnimation();
                }
                this.hasSFXSprite = false;
            }
            else if (!unit && this.activeUnit) {
                this.onFinishExit = afterChangedCallback;
                this.exitUnitSprite();
            }
            else if (unit && unit !== this.activeUnit) {
                this.onFinishEnter = afterChangedCallback;
                this.enterUnitSprite(unit);
            }
            else if (afterChangedCallback) {
                afterChangedCallback();
            }
        };
        BattleSceneUnit.prototype.setSFX = function (SFXTemplate, user, target) {
            if (this.activeUnit) {
                var duration = SFXTemplate.duration * Options_4.default.battleAnimationTiming.effectDuration;
                if (this.activeUnit === user && SFXTemplate.userSprite) {
                    this.setSFXSprite(SFXTemplate.userSprite, duration);
                }
                else if (this.activeUnit === target && SFXTemplate.enemySprite) {
                    this.setSFXSprite(SFXTemplate.enemySprite, duration);
                }
                else {
                }
            }
            else {
            }
        };
        BattleSceneUnit.prototype.resize = function () {
            if (this.spriteContainer.children.length > 0) {
                this.setContainerPosition();
            }
        };
        BattleSceneUnit.prototype.enterUnitSpriteWithoutAnimation = function (unit) {
            this.setUnit(unit);
            this.setUnitSprite(unit);
            this.finishUnitSpriteEnter();
        };
        BattleSceneUnit.prototype.exitUnitSpriteWithoutAnimation = function () {
            this.finishUnitSpriteExit();
        };
        BattleSceneUnit.prototype.enterUnitSprite = function (unit) {
            if (this.unitState === 1) {
                this.onFinishExit = this.startUnitSpriteEnter.bind(this, unit);
                this.exitUnitSprite();
            }
            else if (this.unitState === 2) {
                this.onFinishExit = this.startUnitSpriteEnter.bind(this, unit);
            }
            else {
                this.clearUnit();
                this.clearUnitSprite();
                this.startUnitSpriteEnter(unit);
            }
        };
        BattleSceneUnit.prototype.exitUnitSprite = function () {
            if (this.unitState === 0) {
                this.finishUnitSpriteExit();
            }
            else if (this.unitState === 1) {
                this.startUnitSpriteExit();
            }
            else if (this.unitState === 2) {
                this.onFinishExit = null;
            }
            else {
                console.warn("called exitUnitSprite with unintended animation state " + this.unitState);
            }
        };
        BattleSceneUnit.prototype.startUnitSpriteEnter = function (unit) {
            var enterAnimationDuration = Options_4.default.battleAnimationTiming.unitEnter;
            if (enterAnimationDuration <= 0) {
                this.enterUnitSpriteWithoutAnimation(unit);
                return;
            }
            this.setUnit(unit);
            this.setUnitSprite(unit);
            this.unitState = 0;
            this.tween = this.makeEnterExitTween("enter", enterAnimationDuration, this.finishUnitSpriteEnter.bind(this));
            this.tween.start();
        };
        BattleSceneUnit.prototype.finishUnitSpriteEnter = function () {
            this.unitState = 1;
            this.clearTween();
            if (this.onFinishEnter) {
                this.onFinishEnter();
                this.onFinishEnter = null;
            }
        };
        BattleSceneUnit.prototype.startUnitSpriteExit = function () {
            var exitAnimationDuration = Options_4.default.battleAnimationTiming.unitExit;
            if (exitAnimationDuration <= 0) {
                this.exitUnitSpriteWithoutAnimation();
                return;
            }
            this.unitState = 2;
            this.tween = this.makeEnterExitTween("exit", exitAnimationDuration, this.finishUnitSpriteExit.bind(this));
            this.tween.start();
        };
        BattleSceneUnit.prototype.finishUnitSpriteExit = function () {
            this.clearUnit();
            this.clearUnitSprite();
            if (this.onFinishExit) {
                this.onFinishExit();
                this.onFinishExit = null;
            }
        };
        BattleSceneUnit.prototype.getSFXParams = function (props) {
            var bounds = this.getSceneBounds();
            return ({
                user: props.unit,
                userOffset: { x: 0, y: 0 },
                width: bounds.width,
                height: bounds.height,
                duration: props.duration,
                facingRight: props.unit.battleStats.side === "side1",
                renderer: this.renderer,
                triggerStart: props.triggerStart,
                triggerEnd: props.triggerEnd,
            });
        };
        BattleSceneUnit.prototype.setContainerPosition = function () {
            var sceneBounds = this.getSceneBounds();
            var shouldReverse = this.activeUnit.battleStats.side === "side2";
            var containerBounds = this.spriteContainer.getLocalBounds();
            var xPadding = 25;
            var yPadding = 40;
            this.spriteContainer.y = Math.round(sceneBounds.height - containerBounds.height - containerBounds.y - yPadding);
            if (shouldReverse) {
                this.spriteContainer.scale.x = -1;
                this.spriteContainer.x = Math.round(sceneBounds.width - xPadding);
            }
            else {
                this.spriteContainer.x = Math.round(xPadding);
            }
        };
        BattleSceneUnit.prototype.setUnit = function (unit) {
            this.clearUnit();
            this.activeUnit = unit;
        };
        BattleSceneUnit.prototype.clearUnit = function () {
            this.unitState = 3;
            this.activeUnit = null;
            this.clearTween();
        };
        BattleSceneUnit.prototype.makeUnitSprite = function (unit, SFXParams) {
            return unit.drawBattleScene(SFXParams);
        };
        BattleSceneUnit.prototype.addUnitSprite = function (sprite) {
            this.spriteContainer.addChild(sprite);
            this.setContainerPosition();
        };
        BattleSceneUnit.prototype.clearUnitSprite = function () {
            this.spriteContainer.removeChildren();
        };
        BattleSceneUnit.prototype.setUnitSprite = function (unit) {
            this.clearUnitSprite();
            var SFXParams = this.getSFXParams({
                unit: unit,
                triggerStart: this.addUnitSprite.bind(this),
            });
            this.makeUnitSprite(unit, SFXParams);
        };
        BattleSceneUnit.prototype.clearTween = function () {
            if (this.tween) {
                this.tween.stop();
                TWEEN.remove(this.tween);
                this.tween = null;
            }
        };
        BattleSceneUnit.prototype.makeEnterExitTween = function (direction, duration, onComplete) {
            var side = this.activeUnit.battleStats.side;
            var container = this.spriteContainer;
            var bounds = container.getBounds();
            var distanceToMove = bounds.width * 1.25;
            if (side === "side2") {
                distanceToMove *= -1;
            }
            var offscreenLocation = container.x - distanceToMove;
            var stationaryLocation = container.x;
            var startX = direction === "enter" ? offscreenLocation : stationaryLocation;
            var finishX = direction === "enter" ? stationaryLocation : offscreenLocation;
            container.x = startX;
            var tweeningObject = { x: startX };
            var tween = new TWEEN.Tween(tweeningObject).to({
                x: finishX,
            }, duration).onStart(function () {
                container.x = startX;
            }).onUpdate(function () {
                container.x = tweeningObject.x;
            }).onComplete(onComplete);
            tween.start();
            return tween;
        };
        BattleSceneUnit.prototype.setSFXSprite = function (spriteDrawingFN, duration) {
            this.clearUnitSprite();
            var SFXParams = this.getSFXParams({
                unit: this.activeUnit,
                duration: duration,
                triggerStart: this.addUnitSprite.bind(this),
            });
            this.hasSFXSprite = true;
            spriteDrawingFN(SFXParams);
        };
        return BattleSceneUnit;
    }());
    exports.default = BattleSceneUnit;
});
define("src/BattleSceneUnitOverlay", ["require", "exports", "src/Options"], function (require, exports, Options_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BattleSceneUnitOverlay = (function () {
        function BattleSceneUnitOverlay(container, renderer) {
            this.animationIsActive = false;
            this.container = container;
            this.renderer = renderer;
            this.initLayers();
        }
        BattleSceneUnitOverlay.prototype.destroy = function () {
        };
        BattleSceneUnitOverlay.prototype.initLayers = function () {
            this.overlayContainer = new PIXI.Container;
            this.container.addChild(this.overlayContainer);
        };
        BattleSceneUnitOverlay.prototype.setSFX = function (SFXTemplate, user, target) {
            if (this.activeUnit) {
                var duration = SFXTemplate.duration * Options_5.default.battleAnimationTiming.effectDuration;
                if (this.activeUnit === user && SFXTemplate.userOverlay) {
                    this.setOverlay(SFXTemplate.userOverlay, user, duration);
                }
                else if (this.activeUnit === target && SFXTemplate.enemyOverlay) {
                    this.setOverlay(SFXTemplate.enemyOverlay, target, duration);
                }
                else {
                }
            }
            else {
            }
        };
        BattleSceneUnitOverlay.prototype.setOverlay = function (overlayFN, unit, duration) {
            this.clearOverlay();
            if (duration <= 0) {
                return;
            }
            if (this.animationIsActive) {
                console.warn("Triggered new unit overlay animation without clearing previous one");
            }
            this.activeUnit = unit;
            var SFXParams = this.getSFXParams(duration, this.addOverlay.bind(this), this.finishAnimation.bind(this));
            overlayFN(SFXParams);
        };
        BattleSceneUnitOverlay.prototype.clearOverlay = function () {
            this.animationIsActive = false;
            this.onAnimationFinish = null;
            this.activeUnit = null;
            this.overlayContainer.removeChildren();
        };
        BattleSceneUnitOverlay.prototype.getSFXParams = function (duration, triggerStart, triggerEnd) {
            var bounds = this.getSceneBounds();
            return ({
                user: this.activeUnit,
                userOffset: { x: 0, y: 0 },
                width: bounds.width,
                height: bounds.height,
                duration: duration,
                facingRight: this.activeUnit.battleStats.side === "side1",
                renderer: this.renderer,
                triggerStart: triggerStart,
                triggerEnd: triggerEnd,
            });
        };
        BattleSceneUnitOverlay.prototype.setContainerPosition = function () {
            var sceneBounds = this.getSceneBounds();
            var shouldLockToRight = this.activeUnit.battleStats.side === "side2";
            var containerBounds = this.overlayContainer.getLocalBounds();
            this.overlayContainer.y = sceneBounds.height - containerBounds.height;
            if (shouldLockToRight) {
                this.overlayContainer.x = sceneBounds.width - containerBounds.width;
            }
        };
        BattleSceneUnitOverlay.prototype.addOverlay = function (overlay) {
            this.animationIsActive = true;
            this.overlayContainer.addChild(overlay);
            this.setContainerPosition();
        };
        BattleSceneUnitOverlay.prototype.finishAnimation = function () {
            if (this.onAnimationFinish) {
                this.onAnimationFinish();
            }
            this.clearOverlay();
        };
        return BattleSceneUnitOverlay;
    }());
    exports.default = BattleSceneUnitOverlay;
});
define("src/BattleScene", ["require", "exports", "src/BattleSceneUnit", "src/BattleSceneUnitOverlay", "src/Options"], function (require, exports, BattleSceneUnit_1, BattleSceneUnitOverlay_1, Options_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BattleScene = (function () {
        function BattleScene(containerElement) {
            this.side1UnitHasFinishedUpdating = false;
            this.side2UnitHasFinishedUpdating = false;
            this.isPaused = false;
            this.forceFrame = false;
            this.container = new PIXI.Container();
            this.renderer = PIXI.autoDetectRenderer(2, 2, {
                autoResize: false,
                antialias: true,
                transparent: true,
            });
            this.renderer.view.setAttribute("id", "battle-scene-pixi-canvas");
            this.initLayers();
            this.resizeListener = this.handleResize.bind(this);
            window.addEventListener("resize", this.resizeListener, false);
            if (containerElement) {
                this.bindRendererView(containerElement);
            }
        }
        BattleScene.prototype.destroy = function () {
            this.container.renderable = false;
            this.pause();
            if (this.renderer) {
                this.renderer.destroy(true);
                this.renderer = null;
            }
            this.container = null;
            this.containerElement = null;
            window.removeEventListener("resize", this.resizeListener);
        };
        BattleScene.prototype.bindRendererView = function (containerElement) {
            if (this.containerElement) {
                this.containerElement.removeChild(this.renderer.view);
            }
            this.containerElement = containerElement;
            if (this.renderer) {
                this.handleResize();
            }
            this.containerElement.appendChild(this.renderer.view);
        };
        BattleScene.prototype.handleAbilityUse = function (props) {
            this.clearActiveSFX();
            this.userUnit = props.user;
            this.targetUnit = props.target;
            this.activeSFX = props.SFXTemplate;
            this.onSFXStartCallback = props.onSFXStartCallback;
            this.abilityUseHasFinishedCallback = props.afterFinishedCallback;
            this.activeSFXHasFinishedCallback = this.handleActiveSFXEnd.bind(this);
            this.triggerEffectCallback = props.triggerEffectCallback;
            this.beforeUseDelayHasFinishedCallback = this.playSFX.bind(this);
            this.prepareSFX();
        };
        BattleScene.prototype.updateUnits = function (afterFinishedUpdatingCallback) {
            var boundAfterFinishFN1 = null;
            var boundAfterFinishFN2 = null;
            if (afterFinishedUpdatingCallback) {
                this.afterUnitsHaveFinishedUpdatingCallback = afterFinishedUpdatingCallback;
                boundAfterFinishFN1 = this.finishUpdatingUnit.bind(this, "side1");
                boundAfterFinishFN2 = this.finishUpdatingUnit.bind(this, "side2");
                this.side1UnitHasFinishedUpdating = false;
                this.side2UnitHasFinishedUpdating = false;
            }
            var activeSide1Unit = this.getHighestPriorityUnitForSide("side1");
            var activeSide2Unit = this.getHighestPriorityUnitForSide("side2");
            this.side1Unit.changeActiveUnit(activeSide1Unit, boundAfterFinishFN1);
            this.side1Overlay.activeUnit = activeSide1Unit;
            this.side2Unit.changeActiveUnit(activeSide2Unit, boundAfterFinishFN2);
            this.side2Overlay.activeUnit = activeSide2Unit;
        };
        BattleScene.prototype.renderOnce = function () {
            this.forceFrame = true;
            this.render();
        };
        BattleScene.prototype.pause = function () {
            this.isPaused = true;
            this.forceFrame = false;
        };
        BattleScene.prototype.resume = function () {
            this.isPaused = false;
            this.forceFrame = false;
            this.render();
        };
        BattleScene.prototype.initLayers = function () {
            this.layers =
                {
                    battleOverlay: new PIXI.Container(),
                    side1Container: new PIXI.Container(),
                    side2Container: new PIXI.Container(),
                };
            this.side1Unit = new BattleSceneUnit_1.default(this.layers.side1Container, this.renderer);
            this.side2Unit = new BattleSceneUnit_1.default(this.layers.side2Container, this.renderer);
            this.side1Unit.getSceneBounds = this.side2Unit.getSceneBounds = this.getSceneBounds;
            this.side1Overlay = new BattleSceneUnitOverlay_1.default(this.layers.side1Container, this.renderer);
            this.side2Overlay = new BattleSceneUnitOverlay_1.default(this.layers.side2Container, this.renderer);
            this.side1Overlay.getSceneBounds = this.side2Overlay.getSceneBounds = this.getSceneBounds;
            this.container.addChild(this.layers.side1Container);
            this.container.addChild(this.layers.side2Container);
            this.container.addChild(this.layers.battleOverlay);
        };
        BattleScene.prototype.handleResize = function () {
            if (!this.containerElement) {
                return;
            }
            var w = this.containerElement.clientWidth * window.devicePixelRatio;
            var h = this.containerElement.clientHeight * window.devicePixelRatio;
            this.renderer.resize(w, h);
            this.side1Unit.resize();
            this.side2Unit.resize();
        };
        BattleScene.prototype.getSceneBounds = function () {
            return ({
                width: this.renderer.width,
                height: this.renderer.height,
            });
        };
        BattleScene.prototype.getSFXParams = function (props) {
            var bounds = this.getSceneBounds();
            var duration = this.activeSFX.duration * Options_6.default.battleAnimationTiming.effectDuration;
            return ({
                user: this.userUnit,
                target: this.targetUnit,
                userOffset: this.getBattleSceneUnit(this.userUnit).spriteContainer.position,
                targetOffset: this.getBattleSceneUnit(this.targetUnit).spriteContainer.position,
                width: bounds.width,
                height: bounds.height,
                duration: duration,
                facingRight: this.userUnit.battleStats.side === "side1",
                renderer: this.renderer,
                triggerStart: props.triggerStart,
                triggerEffect: this.executeTriggerEffectCallback.bind(this),
                triggerEnd: props.triggerEnd,
            });
        };
        BattleScene.prototype.getHighestPriorityUnitForSide = function (side) {
            var units = [];
            if (Boolean(this.activeSFX)) {
                units.push(this.targetUnit, this.userUnit);
            }
            else {
                units.push(this.activeUnit, this.hoveredUnit);
            }
            for (var i = 0; i < units.length; i++) {
                var unit = units[i];
                if (unit && unit.battleStats.side === side) {
                    return unit;
                }
            }
            return null;
        };
        BattleScene.prototype.haveBothUnitsFinishedUpdating = function () {
            return this.side1UnitHasFinishedUpdating && this.side2UnitHasFinishedUpdating;
        };
        BattleScene.prototype.executeIfBothUnitsHaveFinishedUpdating = function () {
            if (this.afterUnitsHaveFinishedUpdatingCallback && this.haveBothUnitsFinishedUpdating()) {
                var temp = this.afterUnitsHaveFinishedUpdatingCallback;
                this.afterUnitsHaveFinishedUpdatingCallback = null;
                temp();
            }
            else {
                return;
            }
        };
        BattleScene.prototype.finishUpdatingUnit = function (side) {
            if (side === "side1") {
                this.side1UnitHasFinishedUpdating = true;
            }
            else {
                this.side2UnitHasFinishedUpdating = true;
            }
            this.executeIfBothUnitsHaveFinishedUpdating();
        };
        BattleScene.prototype.executeBeforeUseDelayHasFinishedCallback = function () {
            if (!this.beforeUseDelayHasFinishedCallback) {
                throw new Error("No callback set for 'before ability use delay' finish.");
            }
            var temp = this.beforeUseDelayHasFinishedCallback;
            this.beforeUseDelayHasFinishedCallback = null;
            temp();
        };
        BattleScene.prototype.executeOnSFXStartCallback = function () {
            if (this.onSFXStartCallback) {
                var temp = this.onSFXStartCallback;
                this.onSFXStartCallback = null;
                temp();
            }
        };
        BattleScene.prototype.executeTriggerEffectCallback = function () {
            if (this.triggerEffectCallback) {
                var temp = this.triggerEffectCallback;
                this.triggerEffectCallback = null;
                temp();
            }
        };
        BattleScene.prototype.executeAfterUseDelayHasFinishedCallback = function () {
            if (!this.afterUseDelayHasFinishedCallback) {
                throw new Error("No callback set for 'after ability use delay' finish.");
            }
            var temp = this.afterUseDelayHasFinishedCallback;
            this.afterUseDelayHasFinishedCallback = null;
            temp();
        };
        BattleScene.prototype.executeAbilityUseHasFinishedCallback = function () {
            if (!this.abilityUseHasFinishedCallback) {
                throw new Error("No callback set for ability use finish.");
            }
            var temp = this.abilityUseHasFinishedCallback;
            this.abilityUseHasFinishedCallback = null;
            temp();
        };
        BattleScene.prototype.prepareSFX = function () {
            var _this = this;
            var beforeUseDelay = Options_6.default.battleAnimationTiming.before;
            var afterUnitsHaveFinishedUpdatingCallback = function () {
                if (beforeUseDelay >= 0) {
                    window.setTimeout(_this.executeBeforeUseDelayHasFinishedCallback.bind(_this), beforeUseDelay);
                }
                else {
                    _this.executeBeforeUseDelayHasFinishedCallback();
                }
            };
            this.updateUnits(afterUnitsHaveFinishedUpdatingCallback);
        };
        BattleScene.prototype.playSFX = function () {
            var SFXDuration = Options_6.default.battleAnimationTiming.effectDuration *
                this.activeSFX.duration;
            this.executeOnSFXStartCallback();
            if (!this.activeSFX.SFXWillTriggerEffect || SFXDuration <= 0) {
                this.executeTriggerEffectCallback();
            }
            if (SFXDuration <= 0) {
                this.handleActiveSFXEnd();
            }
            else {
                this.triggerSFXStart(this.activeSFX, this.userUnit, this.targetUnit, this.handleActiveSFXEnd.bind(this));
            }
        };
        BattleScene.prototype.clearActiveSFX = function () {
            this.activeSFX = null;
            this.userUnit = null;
            this.targetUnit = null;
            this.clearBattleOverlay();
            this.clearUnitOverlays();
        };
        BattleScene.prototype.handleActiveSFXEnd = function () {
            var _this = this;
            var afterUseDelay = Options_6.default.battleAnimationTiming.after;
            this.afterUseDelayHasFinishedCallback = function () {
                _this.clearActiveSFX();
                _this.updateUnits(_this.executeAbilityUseHasFinishedCallback.bind(_this));
            };
            if (afterUseDelay >= 0) {
                window.setTimeout(this.executeAfterUseDelayHasFinishedCallback.bind(this), afterUseDelay);
            }
            else {
                this.executeAfterUseDelayHasFinishedCallback();
            }
        };
        BattleScene.prototype.triggerSFXStart = function (SFXTemplate, user, target, afterFinishedCallback) {
            this.activeSFX = SFXTemplate;
            this.side1Unit.setSFX(SFXTemplate, user, target);
            this.side2Unit.setSFX(SFXTemplate, user, target);
            this.side1Overlay.setSFX(SFXTemplate, user, target);
            this.side2Overlay.setSFX(SFXTemplate, user, target);
            this.makeBattleOverlay(afterFinishedCallback);
        };
        BattleScene.prototype.makeBattleOverlay = function (afterFinishedCallback) {
            if (!this.activeSFX.battleOverlay) {
                afterFinishedCallback();
            }
            else {
                var SFXParams = this.getSFXParams({
                    triggerStart: this.addBattleOverlay.bind(this),
                    triggerEnd: afterFinishedCallback,
                });
                this.activeSFX.battleOverlay(SFXParams);
            }
        };
        BattleScene.prototype.addBattleOverlay = function (overlay) {
            this.layers.battleOverlay.addChild(overlay);
        };
        BattleScene.prototype.clearBattleOverlay = function () {
            this.layers.battleOverlay.removeChildren();
        };
        BattleScene.prototype.clearUnitOverlays = function () {
            this.side1Overlay.clearOverlay();
            this.side2Overlay.clearOverlay();
        };
        BattleScene.prototype.getBattleSceneUnit = function (unit) {
            switch (unit.battleStats.side) {
                case "side1":
                    {
                        return this.side1Unit;
                    }
                case "side2":
                    {
                        return this.side2Unit;
                    }
            }
        };
        BattleScene.prototype.render = function (timeStamp) {
            if (this.isPaused) {
                if (this.forceFrame) {
                    this.forceFrame = false;
                }
                else {
                    return;
                }
            }
            this.renderer.render(this.container);
            TWEEN.update();
            window.requestAnimationFrame(this.render.bind(this));
        };
        return BattleScene;
    }());
    exports.default = BattleScene;
});
define("src/uicomponents/BattleSceneTester", ["require", "exports", "react", "react-dom", "src/Battle", "src/BattleScene", "src/Player", "src/Unit", "src/utility", "src/activeModuleData"], function (require, exports, React, ReactDOM, Battle_2, BattleScene_1, Player_2, Unit_3, utility_18, activeModuleData_17) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BattleSceneTesterComponent = (function (_super) {
        __extends(BattleSceneTesterComponent, _super);
        function BattleSceneTesterComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "BattleSceneTester";
            _this.battle = null;
            _this.battleScene = null;
            _this.state = _this.getInitialStateTODO();
            _this.bindMethods();
            return _this;
        }
        BattleSceneTesterComponent.prototype.bindMethods = function () {
            this.useSelectedAbility = this.useSelectedAbility.bind(this);
            this.makeBattle = this.makeBattle.bind(this);
            this.selectUnit = this.selectUnit.bind(this);
            this.makeUnitElements = this.makeUnitElements.bind(this);
            this.makeFormation = this.makeFormation.bind(this);
            this.makeUnit = this.makeUnit.bind(this);
            this.handleUnitHover = this.handleUnitHover.bind(this);
            this.handleClearHover = this.handleClearHover.bind(this);
            this.handleChangeDuration = this.handleChangeDuration.bind(this);
            this.handleSelectSFXTemplate = this.handleSelectSFXTemplate.bind(this);
        };
        BattleSceneTesterComponent.prototype.getInitialStateTODO = function () {
            var side1Units = [];
            var side2Units = [];
            for (var i = 0; i < 5; i++) {
                side1Units.push(this.makeUnit());
                side2Units.push(this.makeUnit());
            }
            var side1Player = Player_2.default.createDummyPlayer();
            var side2Player = Player_2.default.createDummyPlayer();
            var battle = this.battle = this.makeBattle({
                side1Units: side1Units,
                side2Units: side2Units,
                side1Player: side1Player,
                side2Player: side2Player,
            });
            battle.init();
            var initialSFXTemplateKey = "rocketAttack";
            var initialSFXTemplate = activeModuleData_17.activeModuleData.Templates.BattleSFX[initialSFXTemplateKey];
            return ({
                activeUnit: side1Units[0],
                selectedSide1Unit: side1Units[0],
                selectedSide2Unit: side2Units[0],
                selectedSFXTemplateKey: initialSFXTemplateKey,
                duration: initialSFXTemplate.duration,
            });
        };
        BattleSceneTesterComponent.prototype.componentDidMount = function () {
            var battleScene = this.battleScene = new BattleScene_1.default(ReactDOM.findDOMNode(this.battleSceneContainer));
            battleScene.resume();
            battleScene.activeUnit = this.state.selectedSide1Unit;
            battleScene.updateUnits();
        };
        BattleSceneTesterComponent.prototype.makeUnit = function () {
            var template = utility_18.getRandomProperty(activeModuleData_17.activeModuleData.Templates.Units);
            return Unit_3.default.fromTemplate({
                template: template,
                race: utility_18.getRandomProperty(activeModuleData_17.activeModuleData.Templates.Races),
            });
        };
        BattleSceneTesterComponent.prototype.makeFormation = function (units) {
            var formation = [];
            var unitsIndex = 0;
            for (var i = 0; i < 2; i++) {
                formation.push([]);
                for (var j = 0; j < 3; j++) {
                    var unitToAdd = units[unitsIndex] ? units[unitsIndex] : null;
                    formation[i].push(unitToAdd);
                    unitsIndex++;
                }
            }
            return formation;
        };
        BattleSceneTesterComponent.prototype.makeBattle = function (props) {
            return new Battle_2.default({
                battleData: {
                    location: null,
                    building: null,
                    attacker: {
                        player: props.side1Player,
                        units: props.side1Units,
                    },
                    defender: {
                        player: props.side2Player,
                        units: props.side2Units,
                    },
                },
                side1: this.makeFormation(props.side1Units),
                side2: this.makeFormation(props.side2Units),
                side1Player: props.side1Player,
                side2Player: props.side2Player,
            });
        };
        BattleSceneTesterComponent.prototype.handleUnitHover = function (unit) {
            this.battleScene.hoveredUnit = unit;
            this.battleScene.updateUnits();
        };
        BattleSceneTesterComponent.prototype.handleClearHover = function () {
            this.battleScene.hoveredUnit = null;
            this.battleScene.updateUnits();
        };
        BattleSceneTesterComponent.prototype.selectUnit = function (unit) {
            var statePropForSide = unit.battleStats.side === "side1" ? "selectedSide1Unit" : "selectedSide2Unit";
            var statePropForOtherSide = unit.battleStats.side === "side1" ? "selectedSide2Unit" : "selectedSide1Unit";
            var previousSelectedUnit = this.state[statePropForSide];
            var newSelectedUnit = (previousSelectedUnit === unit) ? null : unit;
            var newStateObj = {};
            newStateObj[statePropForSide] = newSelectedUnit;
            var newActiveUnit = newSelectedUnit || this.state[statePropForOtherSide] || null;
            newStateObj.activeUnit = newActiveUnit;
            this.setState(newStateObj);
            this.battleScene.activeUnit = newActiveUnit;
            this.battleScene.updateUnits();
        };
        BattleSceneTesterComponent.prototype.handleSelectSFXTemplate = function (e) {
            var target = e.currentTarget;
            var SFXTemplate = activeModuleData_17.activeModuleData.Templates.BattleSFX[target.value];
            this.setState({
                selectedSFXTemplateKey: target.value,
                duration: SFXTemplate.duration,
            });
        };
        BattleSceneTesterComponent.prototype.handleChangeDuration = function (e) {
            var target = e.currentTarget;
            this.setState({
                duration: parseInt(target.value),
            });
        };
        BattleSceneTesterComponent.prototype.useSelectedAbility = function () {
            var user = this.state.activeUnit;
            var target = user === this.state.selectedSide1Unit ? this.state.selectedSide2Unit : this.state.selectedSide1Unit;
            var bs = this.battleScene;
            var SFXTemplate = utility_18.extendObject(activeModuleData_17.activeModuleData.Templates.BattleSFX[this.state.selectedSFXTemplateKey]);
            if (this.state.duration) {
                SFXTemplate.duration = this.state.duration;
            }
            bs.handleAbilityUse({
                user: user,
                target: target,
                SFXTemplate: SFXTemplate,
                triggerEffectCallback: function () { console.log("triggerEffect"); },
                onSFXStartCallback: function () { console.log("onSFXStart"); },
                afterFinishedCallback: function () { console.log("afterFinishedCallback"); },
            });
        };
        BattleSceneTesterComponent.prototype.makeUnitElements = function (units) {
            var unitElements = [];
            for (var i = 0; i < units.length; i++) {
                var unit = units[i];
                var style = {};
                if (unit === this.state.activeUnit) {
                    style.border = "1px solid red";
                }
                if (unit === this.state.selectedSide1Unit || unit === this.state.selectedSide2Unit) {
                    style.backgroundColor = "yellow";
                }
                unitElements.push(React.DOM.div({
                    className: "battle-scene-test-controls-units-unit",
                    onMouseEnter: this.handleUnitHover.bind(this, unit),
                    onMouseLeave: this.handleClearHover.bind(this, unit),
                    onClick: this.selectUnit.bind(this, unit),
                    key: "" + unit.id,
                    style: style,
                }, unit.name));
            }
            return unitElements;
        };
        BattleSceneTesterComponent.prototype.render = function () {
            var _this = this;
            var battle = this.battle;
            var side1UnitElements = this.makeUnitElements(battle.getUnitsForSide("side1"));
            var side2UnitElements = this.makeUnitElements(battle.getUnitsForSide("side2"));
            var SFXTemplateSelectOptions = [];
            for (var key in activeModuleData_17.activeModuleData.Templates.BattleSFX) {
                SFXTemplateSelectOptions.push(React.DOM.option({
                    value: key,
                    key: key,
                }, key));
            }
            return (React.DOM.div({
                className: "battle-scene-test",
            }, React.DOM.div({
                className: "battle-scene-test-pixi-container",
                ref: function (component) {
                    _this.battleSceneContainer = component;
                },
            }, null), React.DOM.div({
                className: "battle-scene-test-controls",
            }, React.DOM.div({
                className: "battle-scene-test-controls-units",
            }, React.DOM.div({
                className: "battle-scene-test-controls-units-side1",
            }, side1UnitElements), React.DOM.div({
                className: "battle-scene-test-controls-units-side2",
            }, side2UnitElements)), React.DOM.select({
                value: this.state.selectedSFXTemplateKey,
                onChange: this.handleSelectSFXTemplate,
            }, SFXTemplateSelectOptions), React.DOM.button({
                className: "battle-scene-test-ability2",
                onClick: this.useSelectedAbility,
                disabled: !this.state.selectedSFXTemplateKey || !(this.state.selectedSide1Unit && this.state.selectedSide2Unit),
            }, "use ability"), React.DOM.input({
                type: "number",
                step: 100,
                min: 100,
                max: 20000,
                value: "" + this.state.duration,
                onChange: this.handleChangeDuration,
                placeholder: "duration",
            }, null))));
        };
        return BattleSceneTesterComponent;
    }(React.Component));
    exports.BattleSceneTesterComponent = BattleSceneTesterComponent;
    var Factory = React.createFactory(BattleSceneTesterComponent);
    exports.default = Factory;
});
define("src/uicomponents/PlayerFlag", ["require", "exports", "react", "react-dom", "src/utility"], function (require, exports, React, ReactDOM, utility_19) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PlayerFlagComponent = (function (_super) {
        __extends(PlayerFlagComponent, _super);
        function PlayerFlagComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "PlayerFlag";
            return _this;
        }
        PlayerFlagComponent.prototype.renderFlagCanvas = function () {
            var containerNode = ReactDOM.findDOMNode(this.ref_TODO_container);
            if (containerNode.firstChild) {
                containerNode.removeChild(containerNode.firstChild);
            }
            var containerRect = containerNode.getBoundingClientRect();
            var canvas = this.props.flag.getCanvas(containerRect.width, containerRect.height, this.props.stretch, !this.props.isMutable);
            canvas.style.maxWidth = "100%";
            canvas.style.maxHeight = "100%";
            containerNode.appendChild(canvas);
        };
        PlayerFlagComponent.prototype.componentDidMount = function () {
            this.renderFlagCanvas();
        };
        PlayerFlagComponent.prototype.componentDidUpdate = function () {
            this.renderFlagCanvas();
        };
        PlayerFlagComponent.prototype.render = function () {
            var _this = this;
            var props = utility_19.shallowExtend(this.props.props, {
                ref: function (component) {
                    _this.ref_TODO_container = component;
                },
            });
            return (React.DOM.div(props, null));
        };
        return PlayerFlagComponent;
    }(React.PureComponent));
    exports.PlayerFlagComponent = PlayerFlagComponent;
    var Factory = React.createFactory(PlayerFlagComponent);
    exports.default = Factory;
});
define("src/uicomponents/FlagMaker", ["require", "exports", "react", "src/Flag", "src/colorGeneration", "src/uicomponents/PlayerFlag"], function (require, exports, React, Flag_3, colorGeneration_4, PlayerFlag_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var FlagMakerComponent = (function (_super) {
        __extends(FlagMakerComponent, _super);
        function FlagMakerComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.setStateTimeoutHandle = undefined;
            _this.sizeValue = 46;
            _this.state = _this.getInitialStateTODO();
            _this.bindMethods();
            return _this;
        }
        FlagMakerComponent.prototype.bindMethods = function () {
            this.handleSizeChange = this.handleSizeChange.bind(this);
            this.makeFlags = this.makeFlags.bind(this);
        };
        FlagMakerComponent.prototype.getInitialStateTODO = function () {
            return ({
                size: 46,
            });
        };
        FlagMakerComponent.prototype.handleSizeChange = function (e) {
            if (this.setStateTimeoutHandle) {
                window.clearTimeout(this.setStateTimeoutHandle);
            }
            var target = e.currentTarget;
            var value = parseInt(target.value);
            if (isFinite(value)) {
                this.sizeValue = value;
                this.setStateTimeoutHandle = window.setTimeout(this.setState.bind(this, { size: value }), 500);
            }
        };
        FlagMakerComponent.prototype.makeFlags = function () {
            this.forceUpdate();
        };
        FlagMakerComponent.prototype.render = function () {
            var _this = this;
            var flagElements = [];
            for (var i = 0; i < 100; i++) {
                var colorScheme = colorGeneration_4.generateColorScheme();
                var flag = new Flag_3.Flag(colorScheme.main);
                flag.addRandomEmblem(colorScheme.secondary);
                flagElements.push(PlayerFlag_1.default({
                    key: i,
                    flag: flag,
                    props: {
                        width: this.state.size,
                        height: this.state.size,
                        style: {
                            width: this.state.size,
                            height: this.state.size,
                        },
                    },
                }));
            }
            return (React.DOM.div(null, React.DOM.div({
                className: "flags",
                ref: function (component) {
                    _this.ref_TODO_flags = component;
                },
            }, flagElements), React.DOM.button({
                onClick: this.makeFlags,
            }, "make flags"), React.DOM.input({
                onChange: this.handleSizeChange,
                defaultValue: "" + this.sizeValue,
                type: "number",
            })));
        };
        return FlagMakerComponent;
    }(React.Component));
    exports.FlagMakerComponent = FlagMakerComponent;
    var Factory = React.createFactory(FlagMakerComponent);
    exports.default = Factory;
});
define("src/AbilityUseEffectQueue", ["require", "exports", "src/utility"], function (require, exports, utility_20) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbilityUseEffectQueue = (function () {
        function AbilityUseEffectQueue(battleScene, callbacks) {
            this.queue = [];
            this.battleScene = battleScene;
            for (var key in callbacks) {
                this[key] = callbacks[key];
            }
            this.triggerEffect = this.triggerEffect.bind(this);
            this.finishEffect = this.finishEffect.bind(this);
        }
        AbilityUseEffectQueue.squashEffects = function (parent, toSquash, parentIsMostRecent) {
            if (parentIsMostRecent === void 0) { parentIsMostRecent = false; }
            var squashedChangedUnitDisplayDataById = utility_20.shallowExtend.apply(void 0, [{},
                parent.changedUnitDisplayDataById].concat(toSquash.map(function (effect) { return effect.changedUnitDisplayDataById; })));
            if (parentIsMostRecent) {
                var squashedEffect = utility_20.shallowExtend({}, { changedUnitDisplayDataById: squashedChangedUnitDisplayDataById }, parent);
                return squashedEffect;
            }
            else {
                var squashedEffect = utility_20.shallowExtend({}, parent, { changedUnitDisplayDataById: squashedChangedUnitDisplayDataById });
                return squashedEffect;
            }
        };
        AbilityUseEffectQueue.squashEffectsWithoutSFX = function (sourceEffects) {
            var squashed = [];
            var effectsToSquash = [];
            for (var i = sourceEffects.length - 1; i >= 0; i--) {
                var effect = sourceEffects[i];
                if (effect.sfx) {
                    if (effectsToSquash.length > 0) {
                        var squashedEffect = AbilityUseEffectQueue.squashEffects(effect, effectsToSquash);
                        effectsToSquash = [];
                        squashed.push(squashedEffect);
                    }
                    else {
                        squashed.push(effect);
                    }
                }
                else {
                    effectsToSquash.unshift(effect);
                }
            }
            if (effectsToSquash.length > 0) {
                var lastEffectWithSFX = squashed.pop();
                squashed.push(AbilityUseEffectQueue.squashEffects(lastEffectWithSFX, effectsToSquash, true));
            }
            squashed.reverse();
            return squashed;
        };
        AbilityUseEffectQueue.prototype.addEffects = function (effects) {
            (_a = this.queue).push.apply(_a, AbilityUseEffectQueue.squashEffectsWithoutSFX(effects));
            var _a;
        };
        AbilityUseEffectQueue.prototype.playOnce = function () {
            this.currentEffect = this.queue.shift();
            if (!this.currentEffect) {
                this.handleEndOfQueue();
                return;
            }
            if (this.onEffectStart) {
                this.onEffectStart(this.currentEffect);
            }
            this.battleScene.handleAbilityUse({
                SFXTemplate: this.currentEffect.sfx,
                user: this.currentEffect.sfxUser,
                target: this.currentEffect.sfxTarget,
                triggerEffectCallback: this.triggerEffect,
                onSFXStartCallback: this.onSFXStart,
                afterFinishedCallback: this.finishEffect,
            });
        };
        AbilityUseEffectQueue.prototype.triggerEffect = function () {
            if (this.onEffectTrigger) {
                this.onEffectTrigger(this.currentEffect);
            }
        };
        AbilityUseEffectQueue.prototype.finishEffect = function () {
            this.currentEffect = null;
            if (this.onCurrentFinished) {
                this.onCurrentFinished();
            }
        };
        AbilityUseEffectQueue.prototype.handleEndOfQueue = function () {
            if (this.onAllFinished) {
                this.onAllFinished();
            }
        };
        return AbilityUseEffectQueue;
    }());
    exports.AbilityUseEffectQueue = AbilityUseEffectQueue;
});
define("src/battleAbilityUI", ["require", "exports", "src/battleAbilityProcessing", "src/battleAbilityTargeting"], function (require, exports, battleAbilityProcessing_2, battleAbilityTargeting_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function getUnitsInAbilityArea(battle, ability, user, target) {
        var includedUnitsById = {};
        var abilityEffects = [ability.mainEffect];
        if (ability.secondaryEffects) {
            abilityEffects.push.apply(abilityEffects, ability.secondaryEffects);
        }
        abilityEffects.forEach(function (abilityEffect) {
            battleAbilityProcessing_2.getUnitsInEffectArea(abilityEffect, battle, user, target).forEach(function (unit) {
                includedUnitsById[unit.id] = unit;
            });
        });
        var units = [];
        for (var id in includedUnitsById) {
            units.push(includedUnitsById[id]);
        }
        return units;
    }
    exports.getUnitsInAbilityArea = getUnitsInAbilityArea;
    exports.getTargetsForAllAbilities = battleAbilityTargeting_2.getTargetsForAllAbilities;
});
define("src/uicomponents/battle/AbilityTooltip", ["require", "exports", "react"], function (require, exports, React) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbilityTooltipComponent = (function (_super) {
        __extends(AbilityTooltipComponent, _super);
        function AbilityTooltipComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "AbilityTooltip";
            return _this;
        }
        AbilityTooltipComponent.prototype.shouldComponentUpdate = function (newProps) {
            for (var prop in newProps) {
                if (prop !== "activeTargets") {
                    if (this.props[prop] !== newProps[prop]) {
                        return true;
                    }
                }
            }
            return false;
        };
        AbilityTooltipComponent.prototype.render = function () {
            var abilities = this.props.activeTargets[this.props.targetUnit.id];
            var abilityElements = [];
            var containerProps = {
                className: "ability-tooltip",
                onMouseLeave: this.props.handleMouseLeave,
            };
            var parentRect = this.props.parentElement.getBoundingClientRect();
            containerProps.style =
                {
                    position: "fixed",
                    top: parentRect.top,
                };
            if (this.props.facesLeft) {
                containerProps.className += " ability-tooltip-faces-left";
                containerProps.style.left = parentRect.left;
            }
            else {
                containerProps.className += " ability-tooltip-faces-right";
                containerProps.style.left = parentRect.right - 128;
            }
            for (var i = 0; i < abilities.length; i++) {
                var ability = abilities[i];
                var data = {};
                data.className = "ability-tooltip-ability";
                data.key = i;
                data.onClick = this.props.handleAbilityUse.bind(null, ability, this.props.targetUnit);
                data.onMouseEnter = this.props.handleMouseEnterAbility.bind(null, ability);
                data.onMouseLeave = this.props.handleMouseLeaveAbility;
                if (ability.description) {
                    data.title = ability.description;
                }
                abilityElements.push(React.DOM.div(data, ability.displayName));
            }
            return (React.DOM.div(containerProps, abilityElements));
        };
        return AbilityTooltipComponent;
    }(React.Component));
    exports.AbilityTooltipComponent = AbilityTooltipComponent;
    var Factory = React.createFactory(AbilityTooltipComponent);
    exports.default = Factory;
});
define("src/uicomponents/battle/BattleBackground", ["require", "exports", "react", "react-dom", "src/BackgroundDrawer", "src/pixiWrapperFunctions"], function (require, exports, React, ReactDOM, BackgroundDrawer_2, pixiWrapperFunctions_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BattleBackgroundComponent = (function (_super) {
        __extends(BattleBackgroundComponent, _super);
        function BattleBackgroundComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "BattleBackground";
            _this.bindMethods();
            _this.backgroundDrawer = new BackgroundDrawer_2.default({
                seed: _this.props.backgroundSeed,
                drawBackgroundFN: _this.props.backgroundDrawingFunction,
            });
            return _this;
        }
        BattleBackgroundComponent.prototype.bindMethods = function () {
            this.handleResize = this.handleResize.bind(this);
        };
        BattleBackgroundComponent.prototype.componentWillReceiveProps = function (newProps) {
            var propsToCheck = ["getBlurArea", "backgroundSeed", "backgroundDrawingFunction"];
            for (var _i = 0, propsToCheck_1 = propsToCheck; _i < propsToCheck_1.length; _i++) {
                var prop = propsToCheck_1[_i];
                if (this.props[prop] !== newProps[prop]) {
                    this.handleResize();
                    break;
                }
            }
        };
        BattleBackgroundComponent.prototype.handleResize = function () {
            var blurarea = this.props.getBlurArea();
            this.backgroundDrawer.blurArea = pixiWrapperFunctions_2.convertClientRectToPixiRect(blurarea);
            this.backgroundDrawer.handleResize();
        };
        BattleBackgroundComponent.prototype.componentDidMount = function () {
            var containerElement = ReactDOM.findDOMNode(this.pixiContainer);
            this.backgroundDrawer.bindRendererView(containerElement);
            window.addEventListener("resize", this.handleResize, false);
        };
        BattleBackgroundComponent.prototype.componentWillUnmount = function () {
            window.removeEventListener("resize", this.handleResize);
            this.backgroundDrawer.destroy();
        };
        BattleBackgroundComponent.prototype.render = function () {
            var _this = this;
            return (React.DOM.div({
                className: "battle-pixi-container",
                ref: function (component) {
                    _this.pixiContainer = component;
                },
            }, this.props.children));
        };
        return BattleBackgroundComponent;
    }(React.Component));
    exports.BattleBackgroundComponent = BattleBackgroundComponent;
    var Factory = React.createFactory(BattleBackgroundComponent);
    exports.default = Factory;
});
define("src/uicomponents/battle/BattleDisplayStrength", ["require", "exports", "react"], function (require, exports, React) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BattleDisplayStrengthComponent = (function (_super) {
        __extends(BattleDisplayStrengthComponent, _super);
        function BattleDisplayStrengthComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "BattleDisplayStrength";
            _this.state = _this.getInitialStateTODO();
            _this.bindMethods();
            return _this;
        }
        BattleDisplayStrengthComponent.prototype.bindMethods = function () {
            this.updateDisplayStrength = this.updateDisplayStrength.bind(this);
            this.animateDisplayedStrength = this.animateDisplayedStrength.bind(this);
        };
        BattleDisplayStrengthComponent.prototype.getInitialStateTODO = function () {
            return ({
                displayedStrength: this.props.from,
            });
        };
        BattleDisplayStrengthComponent.prototype.componentDidMount = function () {
            this.animateDisplayedStrengthIfNeeded(this.props);
        };
        BattleDisplayStrengthComponent.prototype.componentWillReceiveProps = function (newProps) {
            this.animateDisplayedStrengthIfNeeded(newProps);
        };
        BattleDisplayStrengthComponent.prototype.componentWillUnmount = function () {
            if (this.activeTween) {
                this.activeTween.stop();
            }
        };
        BattleDisplayStrengthComponent.prototype.animateDisplayedStrengthIfNeeded = function (props) {
            if (isFinite(props.animationDuration) && props.to !== props.from) {
                this.animateDisplayedStrength(props.from, props.to, props.animationDuration);
            }
        };
        BattleDisplayStrengthComponent.prototype.updateDisplayStrength = function (newAmount) {
            this.setState({
                displayedStrength: newAmount,
            });
        };
        BattleDisplayStrengthComponent.prototype.animateDisplayedStrength = function (strengthBefore, strengthAfter, duration) {
            var _this = this;
            var stopped = false;
            if (this.activeTween) {
                this.activeTween.stop();
            }
            if (strengthBefore === strengthAfter) {
                return;
            }
            var animateTween = function () {
                if (stopped) {
                    cancelAnimationFrame(_this.animationFrameHandle);
                    return;
                }
                TWEEN.update();
                _this.animationFrameHandle = window.requestAnimationFrame(animateTween);
            };
            var tweeningHealthObject = {
                health: strengthBefore,
            };
            var tween = new TWEEN.Tween(tweeningHealthObject).to({
                health: strengthAfter,
            }, duration);
            tween.onUpdate(function () {
                _this.setState({
                    displayedStrength: tweeningHealthObject.health,
                });
            }).easing(TWEEN.Easing.Sinusoidal.Out);
            tween.onStop(function () {
                cancelAnimationFrame(_this.animationFrameHandle);
                stopped = true;
                TWEEN.remove(tween);
            });
            this.activeTween = tween;
            tween.start();
            animateTween();
        };
        BattleDisplayStrengthComponent.prototype.render = function () {
            return (React.DOM.div({ className: "unit-strength-battle-display" }, Math.ceil(this.state.displayedStrength)));
        };
        return BattleDisplayStrengthComponent;
    }(React.Component));
    exports.BattleDisplayStrengthComponent = BattleDisplayStrengthComponent;
    var Factory = React.createFactory(BattleDisplayStrengthComponent);
    exports.default = Factory;
});
define("localization/defaultLanguages", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.en = {
        code: "en",
        displayName: "English",
    };
});
define("src/localization/transformers", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.transformers = {
        capitalize: function (s) { return s.charAt(0).toUpperCase() + s.slice(1); },
    };
});
define("src/localization/IntermediateLocalizedString", ["require", "exports", "src/localization/transformers"], function (require, exports, transformers_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var format = formatString.create(transformers_1.transformers);
    var IntermediateLocalizedString = (function () {
        function IntermediateLocalizedString(value) {
            this.value = value;
        }
        IntermediateLocalizedString.prototype.format = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return format.apply(void 0, [this.value].concat(args));
        };
        IntermediateLocalizedString.prototype.capitalize = function () {
            return transformers_1.transformers.capitalize(this.value);
        };
        return IntermediateLocalizedString;
    }());
    exports.IntermediateLocalizedString = IntermediateLocalizedString;
});
define("src/localization/LocalizedText", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("src/localization/Localizer", ["require", "exports", "src/localization/IntermediateLocalizedString", "src/localization/activeLanguage", "src/localization/transformers", "src/rangeOperations", "src/utility"], function (require, exports, IntermediateLocalizedString_1, activeLanguage_1, transformers_2, rangeOperations_2, utility_21) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Localizer = (function () {
        function Localizer(key) {
            this.textsByLanguageCode = {};
            this.key = key;
        }
        Localizer.parseRangeString = function (rangeString) {
            var rangeRegex = /^(-?(?:0|[1-9]\d*)(?:\.\d+)?)?\.\.(-?(?:0|[1-9]\d*)(?:\.\d+)?)?$/;
            var match = rangeString.match(rangeRegex);
            if (!match) {
                return null;
            }
            var min = match[1] ? Number(match[1]) : -Infinity;
            var max = match[2] ? Number(match[2]) : Infinity;
            return { min: min, max: max };
        };
        Localizer.localizedTextIsValid = function (text) {
            if (typeof text === "string") {
                return true;
            }
            else {
                var textByQuantity = text;
                var allRanges = [];
                for (var quantityKey in textByQuantity) {
                    if (quantityKey === "other") {
                        continue;
                    }
                    else if (!isNaN(Number(quantityKey))) {
                        continue;
                    }
                    else {
                        var range = Localizer.parseRangeString(quantityKey);
                        if (!range) {
                            console.warn("Couldn't parse range string '" + quantityKey + "' " + text);
                            return false;
                        }
                        else if (!isFinite(range.min) && !isFinite(range.max)) {
                            console.warn("Infinite range string '" + quantityKey + "' " + text + ". Please use 'other' as the key instead.");
                            return false;
                        }
                        else {
                            allRanges.push(range);
                            continue;
                        }
                    }
                }
                if (rangeOperations_2.rangesHaveOverlap.apply(void 0, allRanges)) {
                    console.warn("Ambiguous quantity-dependant localization. Overlapping ranges in " + text + ".");
                    return false;
                }
                return true;
            }
        };
        Localizer.getStringFromLocalizedTextByQuantity = function (text, quantity) {
            for (var quantityString in text) {
                if (quantityString === "other") {
                    continue;
                }
                else if (!isNaN(Number(quantityString))) {
                    var quantityStringValue = Number(quantityString);
                    var delta = Math.abs(quantity - quantityStringValue);
                    var epsilon = 0.00001;
                    if (delta < epsilon) {
                        return text[quantityString];
                    }
                }
                else {
                    var range = Localizer.parseRangeString(quantityString);
                    if (quantity >= range.min && quantity <= range.max) {
                        return text[quantityString];
                    }
                }
            }
            return text.other;
        };
        Localizer.prototype.registerTexts = function (texts, language) {
            this.textsByLanguageCode[language.code] = {};
            this.appendTexts(texts, language);
        };
        Localizer.prototype.appendTexts = function (texts, language) {
            var _this = this;
            if (!this.textsByLanguageCode[language.code]) {
                throw new Error("No texts registered for language code " + language.code + ".\n        Call Localizer.registerTexts first.");
            }
            var _loop_6 = function (textKey) {
                if (!this_3.textsByLanguageCode[language.code][textKey]) {
                    this_3.textsByLanguageCode[language.code][textKey] = [];
                }
                var localizedTexts = (Array.isArray(texts[textKey]) ?
                    texts[textKey] :
                    [texts[textKey]]);
                localizedTexts.forEach(function (text) {
                    var isValid = Localizer.localizedTextIsValid(text);
                    if (isValid) {
                        _this.textsByLanguageCode[language.code][textKey].push(text);
                    }
                    else {
                        console.warn("Invalid localization " + language.code + "." + textKey);
                    }
                });
            };
            var this_3 = this;
            for (var textKey in texts) {
                _loop_6(textKey);
            }
        };
        Localizer.prototype.localize = function (key, quantity) {
            if (quantity === void 0) { quantity = 1; }
            return new IntermediateLocalizedString_1.IntermediateLocalizedString(this.localizeRaw(key, quantity));
        };
        Localizer.prototype.processNestedLocalizations = function (s, quantity) {
            var _this = this;
            return s.replace(/([\[\]])\1|[\[](.*?)(?:!(.+?))?[\]]/g, function (match, literal, key, transformerKey) {
                if (literal) {
                    return literal;
                }
                if (!key) {
                    throw new Error("Invalid nested localization text " + s);
                }
                var localized = _this.localizeRaw(key, quantity);
                if (transformerKey) {
                    if (transformers_2.transformers[transformerKey]) {
                        return transformers_2.transformers[transformerKey](localized);
                    }
                    else {
                        throw new Error("Invalid transformer " + transformerKey + " in text " + s + ".\n" +
                            ("Valid transformers: " + Object.keys(transformers_2.transformers).join(", ")));
                    }
                }
                else {
                    return localized;
                }
            });
        };
        Localizer.prototype.localizeRaw = function (key, quantity) {
            var activeLanguage = activeLanguage_1.getActiveLanguage();
            var missingLocalizationString = activeLanguage.code + "." + this.key + "." + key;
            var textsForActiveLanguage = this.textsByLanguageCode[activeLanguage.code];
            if (textsForActiveLanguage) {
                var localizedTexts = this.textsByLanguageCode[activeLanguage.code][key];
                if (localizedTexts && localizedTexts.length > 0) {
                    var localizedText = utility_21.getRandomArrayItem(localizedTexts);
                    var stringForQuantity = (typeof localizedText === "string") ?
                        localizedText :
                        Localizer.getStringFromLocalizedTextByQuantity(localizedText, quantity);
                    var processedText = this.processNestedLocalizations(stringForQuantity, quantity);
                    return processedText;
                }
            }
            console.warn("Missing localization '" + missingLocalizationString + "'");
            return missingLocalizationString;
        };
        return Localizer;
    }());
    exports.Localizer = Localizer;
});
define("localization/en/battle", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.battle = {
        preparing: "Preparing",
        unitIsPreparingToUseAbility: "Unit is preparing to use ability",
        guard: "Guard",
        chanceToProtect: "{guardChance}% chance to protect",
        allUnits: "all units",
        sameRowUnits: "units in same row",
        takesReducedDamage: "This unit takes {damageReduction}% reduced damage from physical attacks.",
        destroyed: "Destroyed",
        captured: "Captured",
        unitAnnihilated: "Unit annihilated",
        delay_turnOrder: "delay",
        turnsLeft: "Turns left",
        clickAnywhereToContinue: "Click anywhere to continue",
        simulateBattle: "Simulate battle",
        startBattle: "Start battle",
        autoFormation: "Auto formation",
        enemy: "Enemy",
        cantInspectEnemyFormationAsStarIsNotInDetectionRadius: "Can't inspect enemy formation as star is not in detection radius",
        own_adjective: "Own",
        attacking: "Attacking",
        defending: "Defending",
    };
});
define("localization/en/diplomacy", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.diplomacy = {
        opinion: "Opinion",
        diplomaticStatus: "Status",
        makePeace: "Make peace",
        declareWar: "Declare war",
        endsOn: "Ends on",
        attitudeModifierEffect: "Effect",
        aiPersonality: "AI Personality",
    };
});
define("localization/en/fleet", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fleet = {
        unidentifiedShip: "Unidentified ship",
        merge: "merge",
        reorganize: "reorganize",
        reorganizeFleets: "Reorganize fleets",
        movesRemaining: "Moves",
        select_imperative: "select",
        deselect_imperative: "deselect",
        split_imperative: "split",
    };
});
define("localization/en/galaxyMapUI", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.galaxyMapUI = {
        technology: "Technology",
        diplomacy: "Diplomacy",
        economy: "Economy",
        equip: "Equip",
        turnCounter: "Turn",
        income: "Income",
        endTurn: "End turn",
        mapMode: "Map mode",
        constructBuilding: "construct",
        upgradeBuilding: "upgrade",
        buildingCost: "Cost",
        buildingTypeName: "Name",
        attackTarget_imperative: "attack",
        attackTargetTooltip: "Attack {enemyName} {targetType}",
    };
});
define("localization/en/gameOver", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.gameOver = {
        newGame: "New game",
        gameOver: "Game over",
        areYouSureYouWantToStartANewGame: "Are you sure you want to start a new game?",
    };
});
define("localization/en/general", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.general = {
        ok: "Ok",
        cancel: "Cancel",
        dontShowAgain: "Don't show again",
        reset: "Reset",
        perTurn: " per turn",
        randomize: "Randomize",
        remove: "Remove",
        clear: "Clear",
        auto: "Auto",
        date: "Date",
        del: "Del",
        delete: "Delete",
        confirmDeletion: "Confirm deletion",
        close: "Close",
        show: "Show",
        id: "Id",
        displayName: "Name",
    };
});
define("localization/en/helpers/helpers", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function sPlural(stem) {
        return ({
            1: stem,
            "2..": stem + "s",
        });
    }
    exports.sPlural = sPlural;
});
define("localization/en/items", ["require", "exports", "localization/en/helpers/helpers"], function (require, exports, helpers) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.items = {
        item: helpers.sPlural("item"),
        itemSlot: "Item slot",
        ability: "Ability",
        slot: "Slot",
        type: "Type",
    };
});
define("localization/en/notifications", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.notifications = {
        notificationFilterButton: "Filter",
        markAsRead: "Mark as read",
        messageSettings: "Message settings",
        alwaysShow_short: "Always",
        showIfInvolved_short: "Involved",
        neverShow_short: "Never",
        notificationToolTip: "Left click to show details. Right click to mark as read.",
    };
});
define("localization/en/options", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.options = {
        options: "Options",
        resetAllOptions: "Reset all options",
        language: "Language",
        fullLanguageSupport: "Full language support",
        partialLanguageSupport: "Partial language support",
        battleAnimationTiming: "Battle animation timing",
        beforeAbility: "Before ability",
        abilityEffectDuration: "Ability effect duration",
        afterAbility: "After ability",
        unitEnter: "Unit enter",
        unitExit: "Unit exit",
        turnTransition: "Turn transition",
        debug: "Debug",
        debugMode: "Debug mode",
        aiVsAiBattleSimulationDepth: "AI vs. AI Battle simulation depth",
        ui: "UI",
        alwaysExpandTopRightMenuOnLowResolution: "Always expand top right menu on low resolution",
        messageSettings: "Message settings",
        resetTutorials: "Reset tutorials",
        display: "Display",
        borderWidth: "Border width",
        areYouSureYouWantToResetAllOptions: "Are you sure you want to reset all options?",
    };
});
define("localization/en/player", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.player = {
        money: "Money",
        technologyLevel: "Level",
        researchSpeed: "Research speed",
        flag: "Flag",
        color_1: "Color 1",
        color_2: "Color 2",
        race: "Race",
        player: {
            1: "player",
            "2..": "players",
        },
        playerName: "Name",
        deadPlayer: "Dead",
    };
});
define("localization/en/production", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.production = {
        increaseBaseStatsOfUnitsBuiltHere: "Increase base stats of units built here",
        upgradeStats: "Upgrade stats",
        increaseBaseHealthOfUnitsBuiltHere: "Increase base health of units built here",
        upgradeHealth: "Upgrade health",
        upgradeItems: "Upgrade items",
        constructManufactory: "Construct manufactory",
        upgradeManufactoryCapacity: "Upgrade capacity",
        upgradeManufactoryCapacityTooltip: "Increase amount of things this manufactory can build per turn",
        production: "Production",
    };
});
define("localization/en/saves", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.saves = {
        saveName: "Name",
        save_imperative: "Save",
        promptOverwrite: "Are you sure you want to overwrite '{toOverWrite}'?",
        confirmOverwrite: "Confirm overwrite",
        load_imperative: "Load",
        save_noun: {
            1: "save",
            "2..": "saves",
        },
        confirmSaveDeletion: "Are you sure you want to delete the following [save_noun]?",
        loadGame: "Load game",
    };
});
define("localization/en/setupGame", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupGame = {
        addNewPlayer: "Add new player",
        startGame: "Start game",
        defaultOptions: "Default Options",
        basicOptions: "Basic Options",
        advancedOptions: "Advanced Options",
        confirmUseLargeImage: "Are you sure you want to use an image that is {fileSize} MB in size?\n" +
            "(The image won't be uploaded anywhere, but processing it might take a while)",
        editFlag: "Edit flag",
        hotLinkedImageLoadingFailed: "Linked image failed to load. Try saving it and using a local copy.",
        noValidImageFile: "The attached file wasn't recognized as an image.",
        addNewEmblem: "Add new emblem",
        emblemSetterTooltip: "Left click to edit. Right click to remove",
        emblems: "Emblems",
        emblemColor: "Emblem color",
    };
});
define("localization/en/trade", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.trade = {
        propose: "Propose",
        accept: "Accept",
        reject: "Reject",
        tradeableItems: "tradeable items",
        trade_noun: "Trade",
        trade_imperative: "Trade",
    };
});
define("localization/en/unit", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unit = {
        unit: {
            1: "unit",
            "2..": "units",
        },
        maxActionPoints: "Max action points",
        attack: "Attack",
        defence: "Defence",
        intelligence: "Intelligence",
        speed: "Speed",
        type: "Type",
        strength: "Strength",
        act: "Act",
        atk: "Atk",
        def: "Def",
        int: "Int",
        spd: "Spd",
    };
});
define("localization/en/unitUpgrade", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unitUpgrade = {
        unitUpgradeHeader: "{unitName} level {currentLevel} -> {nextLevel}",
        upgradeAttribute: "{attribute}: {currentLevel} -> {nextLevel}",
        newAbility: "** New ability **",
        learnAbility: "Learn ability",
        upgradeAbility: "Upgrade ability",
        upgradeStats: "Upgrade stats",
        upgradeUnit: "Upgrade unit",
        clickToLevelUp: "Click to level up",
        EXPReadOut: "{currentEXP} / {EXPToNextLevel} EXP",
    };
});
define("localization/localize", ["require", "exports", "localization/defaultLanguages", "src/localization/Localizer", "localization/en/battle", "localization/en/diplomacy", "localization/en/fleet", "localization/en/galaxyMapUI", "localization/en/gameOver", "localization/en/general", "localization/en/items", "localization/en/notifications", "localization/en/options", "localization/en/player", "localization/en/production", "localization/en/saves", "localization/en/setupGame", "localization/en/trade", "localization/en/unit", "localization/en/unitUpgrade", "src/utility"], function (require, exports, Languages, Localizer_1, battle_1, diplomacy_1, fleet_1, galaxyMapUI_1, gameOver_1, general_1, items_1, notifications_1, options_1, player_1, production_1, saves_1, setupGame_1, trade_1, unit_1, unitUpgrade_1, utility_22) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.localizer = new Localizer_1.Localizer("ui");
    var mergedTexts = utility_22.shallowExtend(battle_1.battle, diplomacy_1.diplomacy, fleet_1.fleet, galaxyMapUI_1.galaxyMapUI, gameOver_1.gameOver, general_1.general, items_1.items, notifications_1.notifications, options_1.options, player_1.player, production_1.production, saves_1.saves, setupGame_1.setupGame, trade_1.trade, unit_1.unit, unitUpgrade_1.unitUpgrade);
    exports.localizer.registerTexts(mergedTexts, Languages.en);
    var boundLocalize = exports.localizer.localize.bind(exports.localizer);
    function localizeF(key, quantity) {
        if (quantity === void 0) { quantity = 1; }
        var realQuantity = quantity === "plural" ? 2 : quantity;
        return boundLocalize(key, realQuantity);
    }
    exports.localizeF = localizeF;
    function localize(key, quantity) {
        if (quantity === void 0) { quantity = 1; }
        var realQuantity = quantity === "plural" ? 2 : quantity;
        return boundLocalize(key, realQuantity).format();
    }
    exports.localize = localize;
});
define("src/uicomponents/battle/BattleFinish", ["require", "exports", "react", "localization/localize"], function (require, exports, React, localize_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BattleFinishComponent = (function (_super) {
        __extends(BattleFinishComponent, _super);
        function BattleFinishComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "BattleFinish";
            return _this;
        }
        BattleFinishComponent.prototype.render = function () {
            return (React.DOM.div({
                className: "battle-scene-finish-container",
            }, React.DOM.h1({
                className: "battle-scene-finish-header",
            }, this.props.humanPlayerWonBattle ? "You win" : "You lose"), React.DOM.h3({
                className: "battle-scene-finish-subheader",
            }, localize_1.localize("clickAnywhereToContinue"))));
        };
        return BattleFinishComponent;
    }(React.PureComponent));
    exports.BattleFinishComponent = BattleFinishComponent;
    var Factory = React.createFactory(BattleFinishComponent);
    exports.default = Factory;
});
define("src/uicomponents/battle/BattleSceneFlag", ["require", "exports", "react", "react-dom"], function (require, exports, React, ReactDOM) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BattleSceneFlagComponent = (function (_super) {
        __extends(BattleSceneFlagComponent, _super);
        function BattleSceneFlagComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "BattleSceneFlag";
            _this.flagCanvas = null;
            _this.bindMethods();
            return _this;
        }
        BattleSceneFlagComponent.prototype.bindMethods = function () {
            this.handleResize = this.handleResize.bind(this);
            this.setFlag = this.setFlag.bind(this);
            this.drawFlag = this.drawFlag.bind(this);
        };
        BattleSceneFlagComponent.prototype.componentDidMount = function () {
            this.setFlag();
            window.addEventListener("resize", this.handleResize, false);
        };
        BattleSceneFlagComponent.prototype.componentWillUnmount = function () {
            window.removeEventListener("resize", this.handleResize);
        };
        BattleSceneFlagComponent.prototype.handleResize = function () {
            this.setFlag();
        };
        BattleSceneFlagComponent.prototype.setFlag = function () {
            var DOMNode = ReactDOM.findDOMNode(this);
            if (this.flagCanvas) {
                DOMNode.removeChild(this.flagCanvas);
            }
            this.flagCanvas = this.drawFlag();
            ReactDOM.findDOMNode(this).appendChild(this.flagCanvas);
        };
        BattleSceneFlagComponent.prototype.drawFlag = function () {
            var bounds = ReactDOM.findDOMNode(this).getBoundingClientRect();
            var width = bounds.width;
            var canvas = this.props.flag.getCanvas(width, bounds.height, true, false);
            var context = canvas.getContext("2d");
            context.globalCompositeOperation = "destination-out";
            var gradient;
            if (this.props.facingRight) {
                gradient = context.createLinearGradient(0, 0, width, 0);
            }
            else {
                gradient = context.createLinearGradient(width, 0, 0, 0);
            }
            gradient.addColorStop(0.0, "rgba(255, 255, 255, 0.3)");
            gradient.addColorStop(0.6, "rgba(255, 255, 255, 0.5)");
            gradient.addColorStop(0.8, "rgba(255, 255, 255, 0.8)");
            gradient.addColorStop(1.0, "rgba(255, 255, 255, 1.0)");
            context.fillStyle = gradient;
            context.fillRect(0, 0, width, bounds.height);
            canvas.classList.add("battle-scene-start-player-flag");
            return canvas;
        };
        BattleSceneFlagComponent.prototype.render = function () {
            return (React.DOM.div({
                className: "battle-scene-flag-container",
            }, null));
        };
        return BattleSceneFlagComponent;
    }(React.Component));
    exports.BattleSceneFlagComponent = BattleSceneFlagComponent;
    var Factory = React.createFactory(BattleSceneFlagComponent);
    exports.default = Factory;
});
define("src/uicomponents/battle/BattleScene", ["require", "exports", "react", "react-dom", "src/uicomponents/battle/BattleFinish", "src/uicomponents/battle/BattleSceneFlag"], function (require, exports, React, ReactDOM, BattleFinish_1, BattleSceneFlag_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BattleSceneComponent = (function (_super) {
        __extends(BattleSceneComponent, _super);
        function BattleSceneComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "BattleScene";
            return _this;
        }
        BattleSceneComponent.prototype.shouldComponentUpdate = function (newProps) {
            var propsThatShouldTriggerUpdate = {
                battleState: true,
            };
            for (var key in newProps) {
                if (propsThatShouldTriggerUpdate[key] && newProps[key] !== this.props[key]) {
                    return true;
                }
            }
            return false;
        };
        BattleSceneComponent.prototype.componentWillReceiveProps = function (newProps) {
            if (this.props.battleState === "start" && newProps.battleState === "active") {
                this.props.battleScene.bindRendererView(ReactDOM.findDOMNode(this));
                this.props.battleScene.resume();
            }
            else if (this.props.battleState === "active" && newProps.battleState === "finish") {
                this.props.battleScene.destroy();
            }
        };
        BattleSceneComponent.prototype.render = function () {
            var componentToRender;
            switch (this.props.battleState) {
                case "start":
                    {
                        componentToRender = React.DOM.div({
                            className: "battle-scene-flags-container",
                        }, BattleSceneFlag_1.default({
                            flag: this.props.flag1,
                            facingRight: true,
                        }), BattleSceneFlag_1.default({
                            flag: this.props.flag2,
                            facingRight: false,
                        }));
                        break;
                    }
                case "active":
                    {
                        componentToRender = null;
                        break;
                    }
                case "finish":
                    {
                        componentToRender = BattleFinish_1.default({
                            humanPlayerWonBattle: this.props.humanPlayerWonBattle,
                        });
                        break;
                    }
            }
            return (React.DOM.div({
                className: "battle-scene",
            }, componentToRender));
        };
        return BattleSceneComponent;
    }(React.Component));
    exports.BattleSceneComponent = BattleSceneComponent;
    var Factory = React.createFactory(BattleSceneComponent);
    exports.default = Factory;
});
define("src/uicomponents/battle/BattleScore", ["require", "exports", "react", "src/uicomponents/PlayerFlag"], function (require, exports, React, PlayerFlag_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BattleScoreComponent = (function (_super) {
        __extends(BattleScoreComponent, _super);
        function BattleScoreComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "BattleScore";
            return _this;
        }
        BattleScoreComponent.prototype.render = function () {
            var evaluationPercentage = 50 + this.props.evaluation * 50;
            var transitionDurationString = "" + this.props.animationDuration + "ms";
            return (React.DOM.div({
                className: "battle-score-wrapper",
            }, React.DOM.div({
                className: "battle-score-container",
            }, React.DOM.img({
                className: "battle-score-mid-point",
                src: "img/icons/battleScoreMidPoint.png",
            }, null), PlayerFlag_2.default({
                props: {
                    className: "battle-score-flag",
                },
                flag: this.props.player1.flag,
            }), React.DOM.div({
                className: "battle-score-bar-container",
            }, React.DOM.div({
                className: "battle-score-bar-value battle-score-bar-side1",
                style: {
                    width: "" + evaluationPercentage + "%",
                    backgroundColor: "#" + this.props.player1.color.getHexString(),
                    borderColor: "#" + this.props.player1.secondaryColor.getHexString(),
                    transitionDuration: transitionDurationString,
                },
            }), React.DOM.div({
                className: "battle-score-bar-value battle-score-bar-side2",
                style: {
                    width: "" + (100 - evaluationPercentage) + "%",
                    backgroundColor: "#" + this.props.player2.color.getHexString(),
                    borderColor: "#" + this.props.player2.secondaryColor.getHexString(),
                    transitionDuration: transitionDurationString,
                },
            })), PlayerFlag_2.default({
                props: {
                    className: "battle-score-flag",
                },
                flag: this.props.player2.flag,
            }))));
        };
        return BattleScoreComponent;
    }(React.PureComponent));
    exports.BattleScoreComponent = BattleScoreComponent;
    var Factory = React.createFactory(BattleScoreComponent);
    exports.default = Factory;
});
define("src/uicomponents/battle/BattleUIState", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BattleUIState;
    (function (BattleUIState) {
        BattleUIState[BattleUIState["Starting"] = 0] = "Starting";
        BattleUIState[BattleUIState["Idle"] = 1] = "Idle";
        BattleUIState[BattleUIState["FocusingUnit"] = 2] = "FocusingUnit";
        BattleUIState[BattleUIState["PlayingSFX"] = 3] = "PlayingSFX";
        BattleUIState[BattleUIState["TransitioningTurn"] = 4] = "TransitioningTurn";
        BattleUIState[BattleUIState["Ending"] = 5] = "Ending";
    })(BattleUIState || (BattleUIState = {}));
    exports.default = BattleUIState;
});
define("src/uicomponents/unit/UnitIconContainer", ["require", "exports", "react"], function (require, exports, React) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var UnitIconContainerComponent = (function (_super) {
        __extends(UnitIconContainerComponent, _super);
        function UnitIconContainerComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "UnitIconContainer";
            return _this;
        }
        UnitIconContainerComponent.prototype.render = function () {
            var containerProps = {
                className: "unit-icon-container",
            };
            var fillerProps = {
                className: "unit-icon-filler",
            };
            if (this.props.facesLeft) {
                fillerProps.className += " unit-border-right";
                containerProps.className += " unit-border-no-right";
            }
            else {
                fillerProps.className += " unit-border-left";
                containerProps.className += " unit-border-no-left";
            }
            var iconElement = React.Children.count(this.props.children) === 1 ?
                React.Children.only(this.props.children) :
                React.DOM.img({ src: this.props.iconSrc });
            return (React.DOM.div({ className: "unit-icon-wrapper" }, React.DOM.div(fillerProps), React.DOM.div(containerProps, iconElement), React.DOM.div(fillerProps)));
        };
        return UnitIconContainerComponent;
    }(React.PureComponent));
    exports.UnitIconContainerComponent = UnitIconContainerComponent;
    var Factory = React.createFactory(UnitIconContainerComponent);
    exports.default = Factory;
});
define("src/uicomponents/unit/EmptyUnit", ["require", "exports", "react", "src/uicomponents/unit/UnitIconContainer"], function (require, exports, React, UnitIconContainer_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var EmptyUnitComponent = (function (_super) {
        __extends(EmptyUnitComponent, _super);
        function EmptyUnitComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "EmptyUnit";
            return _this;
        }
        EmptyUnitComponent.prototype.render = function () {
            var innerElements = [
                React.DOM.div({
                    className: "unit-body",
                    key: "body",
                }, null),
                UnitIconContainer_1.default({
                    iconSrc: null,
                    facesLeft: this.props.facesLeft,
                    key: "icon",
                }),
            ];
            if (this.props.facesLeft) {
                innerElements.reverse();
            }
            return (React.DOM.div({
                className: "unit empty-unit" + (this.props.facesLeft ? " enemy-unit" : " friendly-unit"),
                onMouseUp: this.props.onMouseUp,
            }, innerElements));
        };
        return EmptyUnitComponent;
    }(React.PureComponent));
    exports.EmptyUnitComponent = EmptyUnitComponent;
    var Factory = React.createFactory(EmptyUnitComponent);
    exports.default = Factory;
});
define("src/uicomponents/unit/UnitAttributeChanges", ["require", "exports", "react"], function (require, exports, React) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var UnitAttributeChangesComponent = (function (_super) {
        __extends(UnitAttributeChangesComponent, _super);
        function UnitAttributeChangesComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "UnitAttributeChanges";
            return _this;
        }
        UnitAttributeChangesComponent.prototype.render = function () {
            var attributeElements = [];
            if (this.props.attributeChanges) {
                for (var attributeType in this.props.attributeChanges) {
                    if (attributeType === "maxActionPoints") {
                        continue;
                    }
                    var amountChanged = this.props.attributeChanges[attributeType];
                    if (!amountChanged) {
                        continue;
                    }
                    var changeIsPositive = amountChanged > 0;
                    var polarityString = changeIsPositive ? "positive" : "negative";
                    var polaritySign = changeIsPositive ? " +" : " ";
                    var imageSrc = "img/icons/statusEffect_" + polarityString + "_" + attributeType + ".png";
                    var titleString = "" + attributeType + polaritySign + amountChanged;
                    attributeElements.push(React.DOM.img({
                        className: "attribute-change-icon" + " attribute-change-icon-" + attributeType,
                        src: imageSrc,
                        key: attributeType,
                        title: titleString,
                    }));
                }
            }
            return (React.DOM.div({
                className: "unit-attribute-changes",
            }, attributeElements));
        };
        return UnitAttributeChangesComponent;
    }(React.PureComponent));
    exports.UnitAttributeChangesComponent = UnitAttributeChangesComponent;
    var Factory = React.createFactory(UnitAttributeChangesComponent);
    exports.default = Factory;
});
define("src/uicomponents/unit/UnitActions", ["require", "exports", "react"], function (require, exports, React) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var UnitActionsComponent = (function (_super) {
        __extends(UnitActionsComponent, _super);
        function UnitActionsComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "UnitActions";
            return _this;
        }
        UnitActionsComponent.prototype.render = function () {
            var availableSrc = "img/icons/availableAction.png";
            var hoveredSrc = "img/icons/hoveredAction.png";
            var spentSrc = "img/icons/spentAction.png";
            var icons = [];
            var availableCount = this.props.currentActionPoints - (this.props.hoveredActionPointExpenditure || 0);
            for (var i = 0; i < availableCount; i++) {
                icons.push(React.DOM.img({
                    src: availableSrc,
                    className: "unit-action-point available-action-point",
                    key: "available" + i,
                }));
            }
            var hoveredCount = Math.min(this.props.hoveredActionPointExpenditure, this.props.currentActionPoints);
            for (var i = 0; i < hoveredCount; i++) {
                icons.push(React.DOM.img({
                    src: hoveredSrc,
                    className: "unit-action-point hovered-action-point",
                    key: "hovered" + i,
                }));
            }
            var spentCount = this.props.maxActionPoints - this.props.currentActionPoints;
            for (var i = 0; i < spentCount; i++) {
                icons.push(React.DOM.img({
                    src: spentSrc,
                    className: "unit-action-point spent-action-point",
                    key: "spent" + i,
                }));
            }
            return (React.DOM.div({ className: "unit-action-points" }, icons));
        };
        return UnitActionsComponent;
    }(React.PureComponent));
    exports.UnitActionsComponent = UnitActionsComponent;
    var Factory = React.createFactory(UnitActionsComponent);
    exports.default = Factory;
});
define("src/uicomponents/unit/UnitStatus", ["require", "exports", "react", "src/utility", "localization/localize"], function (require, exports, React, utility_23, localize_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var UnitStatusComponent = (function (_super) {
        __extends(UnitStatusComponent, _super);
        function UnitStatusComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "UnitStatus";
            return _this;
        }
        UnitStatusComponent.prototype.render = function () {
            var statusElement = null;
            if (this.props.guardAmount > 0) {
                var guard = this.props.guardAmount;
                var damageReduction = Math.min(50, guard / 2);
                var chanceToProtectString = localize_2.localizeF("chanceToProtect").format({ guardChance: guard });
                var protectedUnitsString = this.props.guardCoverage === 1 ?
                    localize_2.localize("allUnits") :
                    localize_2.localize("sameRowUnits");
                var damageReductionString = localize_2.localizeF("takesReducedDamage").format({ damageReduction: damageReduction });
                var guardText = chanceToProtectString + " " + protectedUnitsString + "." +
                    ("\n" + damageReductionString);
                statusElement = React.DOM.div({
                    className: "status-container guard-meter-container",
                }, React.DOM.div({
                    className: "guard-meter-value",
                    style: {
                        width: "" + utility_23.clamp(guard, 0, 100) + "%",
                    },
                }), React.DOM.div({
                    className: "status-inner-wrapper",
                }, React.DOM.div({
                    className: "guard-text-container status-inner",
                    title: guardText,
                }, React.DOM.div({
                    className: "guard-text status-text",
                }, localize_2.localize("guard")), React.DOM.div({
                    className: "guard-text-value status-text",
                }, "" + guard + "%"))));
            }
            else if (this.props.isPreparing) {
                statusElement = React.DOM.div({
                    className: "status-container preparation-container",
                }, React.DOM.div({
                    className: "status-inner-wrapper",
                }, React.DOM.div({
                    className: "preparation-text-container status-inner",
                    title: localize_2.localize("unitIsPreparingToUseAbility"),
                }, localize_2.localize("preparing"))));
            }
            return (React.DOM.div({ className: "unit-status" }, statusElement));
        };
        return UnitStatusComponent;
    }(React.Component));
    exports.UnitStatusComponent = UnitStatusComponent;
    var Factory = React.createFactory(UnitStatusComponent);
    exports.default = Factory;
});
define("src/uicomponents/unit/UnitStrength", ["require", "exports", "react"], function (require, exports, React) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var UnitStrengthComponent = (function (_super) {
        __extends(UnitStrengthComponent, _super);
        function UnitStrengthComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "UnitStrength";
            _this.state = _this.getInitialStateTODO();
            _this.bindMethods();
            return _this;
        }
        UnitStrengthComponent.prototype.bindMethods = function () {
            this.updateDisplayStrength = this.updateDisplayStrength.bind(this);
            this.makeSquadronInfo = this.makeSquadronInfo.bind(this);
            this.animateDisplayedStrength = this.animateDisplayedStrength.bind(this);
            this.makeStrengthText = this.makeStrengthText.bind(this);
            this.makeCapitalInfo = this.makeCapitalInfo.bind(this);
        };
        UnitStrengthComponent.prototype.getInitialStateTODO = function () {
            return ({
                displayedStrength: this.props.currentHealth,
            });
        };
        UnitStrengthComponent.prototype.componentWillReceiveProps = function (newProps) {
            if (newProps.animateStrength &&
                newProps.currentHealth !== this.props.currentHealth &&
                (!newProps.maxHealth || newProps.maxHealth === this.props.maxHealth)) {
                var animateDuration = Math.max(newProps.animateDuration || 0, 0);
                this.animateDisplayedStrength(newProps.currentHealth, animateDuration);
            }
            else {
                this.updateDisplayStrength(newProps.currentHealth);
            }
        };
        UnitStrengthComponent.prototype.componentWillUnmount = function () {
            if (this.activeTween) {
                this.activeTween.stop();
            }
        };
        UnitStrengthComponent.prototype.updateDisplayStrength = function (newAmount) {
            this.setState({
                displayedStrength: newAmount,
            });
        };
        UnitStrengthComponent.prototype.animateDisplayedStrength = function (newAmount, time) {
            var _this = this;
            var stopped = false;
            var animateTween = function () {
                if (stopped) {
                    cancelAnimationFrame(_this.animationFrameHandle);
                    return;
                }
                TWEEN.update();
                _this.animationFrameHandle = window.requestAnimationFrame(animateTween);
            };
            var tweeningHealthObject = {
                health: this.state.displayedStrength,
            };
            var tween = new TWEEN.Tween(tweeningHealthObject).to({
                health: newAmount,
            }, time);
            tween.onUpdate(function () {
                _this.setState({
                    displayedStrength: tweeningHealthObject.health,
                });
            }).easing(TWEEN.Easing.Sinusoidal.Out);
            tween.onStop(function () {
                stopped = true;
                TWEEN.remove(tween);
            });
            this.activeTween = tween;
            tween.start();
            animateTween();
        };
        UnitStrengthComponent.prototype.makeSquadronInfo = function () {
            return (React.DOM.div({ className: "unit-strength-container" }, this.makeStrengthText()));
        };
        UnitStrengthComponent.prototype.makeCapitalInfo = function () {
            var text = this.makeStrengthText();
            var relativeHealth = this.state.displayedStrength / this.props.maxHealth;
            var bar = React.DOM.div({
                className: "unit-strength-bar",
            }, React.DOM.div({
                className: "unit-strength-bar-value",
                style: {
                    width: "" + relativeHealth * 100 + "%",
                },
            }));
            return (React.DOM.div({ className: "unit-strength-container" }, text, bar));
        };
        UnitStrengthComponent.prototype.makeStrengthText = function () {
            var critThreshhold = 0.3;
            var currentStyle = {
                className: "unit-strength-current",
            };
            var healthRatio = this.state.displayedStrength / this.props.maxHealth;
            if (!this.props.isNotDetected && healthRatio <= critThreshhold) {
                currentStyle.className += " critical";
            }
            else if (!this.props.isNotDetected && this.state.displayedStrength < this.props.maxHealth) {
                currentStyle.className += " wounded";
            }
            var containerProps = {
                className: (this.props.isSquadron ? "unit-strength-amount" :
                    "unit-strength-amount-capital"),
            };
            var displayed = this.props.isNotDetected ? "???" : "" + Math.ceil(this.state.displayedStrength);
            var max = this.props.isNotDetected ? "???" : "" + this.props.maxHealth;
            return (React.DOM.div(containerProps, React.DOM.span(currentStyle, displayed), React.DOM.span({ className: "unit-strength-max" }, "/" + max)));
        };
        UnitStrengthComponent.prototype.render = function () {
            if (this.props.isSquadron) {
                return this.makeSquadronInfo();
            }
            else {
                return this.makeCapitalInfo();
            }
        };
        return UnitStrengthComponent;
    }(React.Component));
    exports.UnitStrengthComponent = UnitStrengthComponent;
    var Factory = React.createFactory(UnitStrengthComponent);
    exports.default = Factory;
});
define("src/uicomponents/unit/UnitInfo", ["require", "exports", "react", "src/uicomponents/unit/UnitActions", "src/uicomponents/unit/UnitStatus", "src/uicomponents/unit/UnitStrength", "localization/localize"], function (require, exports, React, UnitActions_1, UnitStatus_1, UnitStrength_1, localize_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var UnitInfoComponent = (function (_super) {
        __extends(UnitInfoComponent, _super);
        function UnitInfoComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "UnitInfo";
            return _this;
        }
        UnitInfoComponent.prototype.render = function () {
            var battleEndStatus = null;
            if (this.props.wasDestroyed) {
                battleEndStatus = React.DOM.div({
                    className: "unit-battle-end-status-container",
                }, React.DOM.div({
                    className: "unit-battle-end-status unit-battle-end-status-dead",
                }, localize_3.localize("destroyed")));
            }
            else if (this.props.wasCaptured) {
                battleEndStatus = React.DOM.div({
                    className: "unit-battle-end-status-container",
                }, React.DOM.div({
                    className: "unit-battle-end-status unit-battle-end-status-captured",
                }, localize_3.localize("captured")));
            }
            return (React.DOM.div({ className: "unit-info" }, React.DOM.div({ className: "unit-info-name" }, this.props.name), React.DOM.div({ className: "unit-info-inner" }, UnitStatus_1.default({
                guardAmount: this.props.guardAmount,
                isPreparing: this.props.isPreparing,
            }), UnitStrength_1.default({
                maxHealth: this.props.maxHealth,
                currentHealth: this.props.currentHealth,
                isSquadron: this.props.isSquadron,
                animateStrength: true,
                animateDuration: this.props.animateDuration,
            }), UnitActions_1.default({
                maxActionPoints: this.props.maxActionPoints,
                currentActionPoints: this.props.currentActionPoints,
                hoveredActionPointExpenditure: this.props.hoveredActionPointExpenditure,
            }), battleEndStatus)));
        };
        return UnitInfoComponent;
    }(React.PureComponent));
    exports.UnitInfoComponent = UnitInfoComponent;
    var Factory = React.createFactory(UnitInfoComponent);
    exports.default = Factory;
});
define("src/uicomponents/unit/UnitPassiveEffects", ["require", "exports", "react"], function (require, exports, React) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var UnitPassiveEffectsComponent = (function (_super) {
        __extends(UnitPassiveEffectsComponent, _super);
        function UnitPassiveEffectsComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "UnitPassiveEffects";
            return _this;
        }
        UnitPassiveEffectsComponent.prototype.render = function () {
            return ((this.props.passiveEffects && this.props.passiveEffects.length > 0) ?
                React.DOM.img({
                    className: "unit-passive-effects-icon",
                    src: "img/icons/availableAction.png",
                    title: this.props.passiveEffects.reduce(function (t, e) {
                        return t + e.displayName + ": " + e.description + "\n";
                    }, ""),
                }) :
                null);
        };
        return UnitPassiveEffectsComponent;
    }(React.PureComponent));
    exports.UnitPassiveEffectsComponent = UnitPassiveEffectsComponent;
    var Factory = React.createFactory(UnitPassiveEffectsComponent);
    exports.default = Factory;
});
define("src/uicomponents/unit/UnitPortrait", ["require", "exports", "react"], function (require, exports, React) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var UnitPortraitComponent = (function (_super) {
        __extends(UnitPortraitComponent, _super);
        function UnitPortraitComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "UnitPortrait";
            return _this;
        }
        UnitPortraitComponent.prototype.render = function () {
            var props = {};
            props.className = "unit-portrait " + (this.props.className || "");
            if (this.props.imageSrc) {
                props.style =
                    {
                        backgroundImage: 'url("' + this.props.imageSrc + '")',
                    };
            }
            return (React.DOM.div(props, null));
        };
        return UnitPortraitComponent;
    }(React.Component));
    exports.UnitPortraitComponent = UnitPortraitComponent;
    var Factory = React.createFactory(UnitPortraitComponent);
    exports.default = Factory;
});
define("src/Rect", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("src/uicomponents/mixins/normalizeEvent", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function normalizeMouseEvent(nativeEvent, reactEvent) {
        return ({
            wasTouchEvent: false,
            clientX: nativeEvent.clientX,
            clientY: nativeEvent.clientY,
            pageX: nativeEvent.pageX,
            pageY: nativeEvent.pageY,
            target: nativeEvent.target,
            button: nativeEvent.button,
            preventDefault: (reactEvent ?
                reactEvent.preventDefault.bind(reactEvent) :
                nativeEvent.preventDefault.bind(nativeEvent)),
            stopPropagation: (reactEvent ?
                reactEvent.stopPropagation.bind(reactEvent) :
                nativeEvent.stopPropagation.bind(nativeEvent)),
        });
    }
    function normalizeTouchEvent(nativeEvent, reactEvent) {
        var touch = nativeEvent.touches[0];
        return ({
            wasTouchEvent: true,
            clientX: touch.clientX,
            clientY: touch.clientY,
            pageX: touch.pageX,
            pageY: touch.pageY,
            target: touch.target,
            button: -1,
            preventDefault: (reactEvent ?
                reactEvent.preventDefault.bind(reactEvent) :
                nativeEvent.preventDefault.bind(nativeEvent)),
            stopPropagation: (reactEvent ?
                reactEvent.stopPropagation.bind(reactEvent) :
                nativeEvent.stopPropagation.bind(nativeEvent)),
        });
    }
    function normalizeEvent(sourceEvent) {
        var castedEvent = sourceEvent;
        var isReactEvent = Boolean(castedEvent.nativeEvent);
        var isTouchEvent = Boolean(castedEvent.touches);
        if (isTouchEvent) {
            if (isReactEvent) {
                return normalizeTouchEvent(castedEvent.nativeEvent, castedEvent);
            }
            else {
                return normalizeTouchEvent(sourceEvent);
            }
        }
        else {
            if (isReactEvent) {
                return normalizeMouseEvent(castedEvent.nativeEvent, castedEvent);
            }
            else {
                return normalizeMouseEvent(sourceEvent);
            }
        }
    }
    exports.default = normalizeEvent;
});
define("src/uicomponents/mixins/DragPositioner", ["require", "exports", "react", "react-dom", "src/utility", "src/uicomponents/mixins/normalizeEvent"], function (require, exports, React, ReactDOM, utility_24, normalizeEvent_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DragPositioner = (function () {
        function DragPositioner(owner, props) {
            this.isDragging = false;
            this.startOnHandleElementOnly = false;
            this.dragThreshhold = 5;
            this.preventAutoResize = false;
            this.shouldMakeClone = false;
            this.position = {
                left: undefined,
                top: undefined,
                width: undefined,
                height: undefined,
            };
            this.originPosition = { x: 0, y: 0 };
            this.mouseIsDown = false;
            this.dragOffset = { x: 0, y: 0 };
            this.mouseDownPosition = { x: 0, y: 0 };
            this.cloneElement = null;
            this.ownerIsMounted = false;
            this.owner = owner;
            if (props) {
                var propKeysMap = {
                    containerElement: "containerElementDescriptor",
                };
                for (var key in props) {
                    if (propKeysMap[key]) {
                        this[propKeysMap[key]] = props[key];
                    }
                    else {
                        this[key] = props[key];
                    }
                }
            }
            this.setContainerRect = this.setContainerRect.bind(this);
            this.handleNativeMoveEvent = this.handleNativeMoveEvent.bind(this);
            this.handleNativeUpEvent = this.handleNativeUpEvent.bind(this);
            this.handleReactDownEvent = this.handleReactDownEvent.bind(this);
        }
        DragPositioner.prototype.componentDidMount = function () {
            this.ownerIsMounted = true;
            this.ownerDOMNode = ReactDOM.findDOMNode(this.owner);
            if (this.containerElementDescriptor) {
                if (this.containerElementDescriptor instanceof React.Component) {
                    this.containerElement = ReactDOM.findDOMNode(this.containerElementDescriptor);
                }
                else {
                    this.containerElement = this.containerElementDescriptor;
                }
            }
            else {
                this.containerElement = document.body;
            }
            this.setContainerRect();
            window.addEventListener("resize", this.setContainerRect, false);
        };
        DragPositioner.prototype.componentWillUnmount = function () {
            this.ownerIsMounted = false;
            this.removeEventListeners();
            window.removeEventListener("resize", this.setContainerRect);
        };
        DragPositioner.prototype.getStyleAttributes = function () {
            return utility_24.shallowCopy(this.position);
        };
        DragPositioner.prototype.handleReactDownEvent = function (e) {
            this.handleMouseDown(normalizeEvent_1.default(e));
        };
        DragPositioner.prototype.updateDOMNodeStyle = function () {
            var s;
            if (this.cloneElement) {
                s = this.cloneElement.style;
            }
            else {
                s = this.ownerDOMNode.style;
                s.width = "" + this.position.width + "px";
                s.height = "" + this.position.height + "px";
            }
            s.left = "" + this.position.left + "px";
            s.top = "" + this.position.top + "px";
        };
        DragPositioner.prototype.handleMouseDown = function (e) {
            if (e.button) {
                return;
            }
            if (this.startOnHandleElementOnly) {
                if (!e.target.classList.contains("draggable")) {
                    e.stopPropagation();
                    return;
                }
            }
            e.preventDefault();
            e.stopPropagation();
            if (this.isDragging) {
                return;
            }
            var clientRect = this.ownerDOMNode.getBoundingClientRect();
            if (e.wasTouchEvent) {
                this.needsFirstTouchUpdate = true;
                this.touchEventTarget = e.target;
            }
            this.addEventListeners();
            this.dragOffset = this.forcedDragOffset ||
                {
                    x: e.clientX - clientRect.left,
                    y: e.clientY - clientRect.top,
                };
            this.mouseIsDown = true;
            this.mouseDownPosition =
                {
                    x: e.pageX,
                    y: e.pageY,
                };
            this.originPosition =
                {
                    x: clientRect.left + document.body.scrollLeft,
                    y: clientRect.top + document.body.scrollTop,
                };
            if (this.dragThreshhold <= 0) {
                this.handleMouseMove(e);
            }
        };
        DragPositioner.prototype.handleMouseMove = function (e) {
            e.preventDefault();
            if (e.clientX === 0 && e.clientY === 0) {
                return;
            }
            if (!this.isDragging) {
                var deltaX = Math.abs(e.pageX - this.mouseDownPosition.x);
                var deltaY = Math.abs(e.pageY - this.mouseDownPosition.y);
                var delta = deltaX + deltaY;
                if (delta >= this.dragThreshhold) {
                    this.isDragging = true;
                    if (!this.preventAutoResize) {
                        this.position.width = this.ownerDOMNode.offsetWidth;
                        this.position.height = this.ownerDOMNode.offsetHeight;
                    }
                    if (this.shouldMakeClone || this.makeDragClone) {
                        if (!this.makeDragClone) {
                            var nextSibling = this.ownerDOMNode.nextSibling;
                            var clone = this.ownerDOMNode.cloneNode(true);
                            utility_24.recursiveRemoveAttribute(clone, "data-reactid");
                            this.ownerDOMNode.parentNode.insertBefore(clone, nextSibling);
                            this.cloneElement = clone;
                        }
                        else {
                            var clone = this.makeDragClone();
                            utility_24.recursiveRemoveAttribute(clone, "data-reactid");
                            document.body.appendChild(clone);
                            this.cloneElement = clone;
                        }
                    }
                    var x = e.pageX - this.dragOffset.x;
                    var y = e.pageY - this.dragOffset.y;
                    this.owner.forceUpdate();
                    if (this.onDragStart) {
                        this.onDragStart(x, y);
                    }
                }
            }
            if (this.isDragging) {
                this.handleDrag(e);
            }
        };
        DragPositioner.prototype.handleDrag = function (e) {
            var domWidth;
            var domHeight;
            if (this.makeDragClone) {
                domWidth = this.cloneElement.offsetWidth;
                domHeight = this.cloneElement.offsetHeight;
            }
            else {
                domWidth = this.ownerDOMNode.offsetWidth;
                domHeight = this.ownerDOMNode.offsetHeight;
            }
            var minX = this.containerRect.left;
            var maxX = this.containerRect.right;
            var minY = this.containerRect.top;
            var maxY = this.containerRect.bottom;
            var x = e.pageX - this.dragOffset.x;
            var y = e.pageY - this.dragOffset.y;
            var x2 = x + domWidth;
            var y2 = y + domHeight;
            if (x < minX) {
                x = minX;
            }
            else if (x2 > maxX) {
                x = maxX - domWidth;
            }
            if (y < minY) {
                y = minY;
            }
            else if (y2 > maxY) {
                y = maxY - domHeight;
            }
            if (this.onDragMove) {
                this.onDragMove(x, y);
            }
            else {
                this.position.left = x;
                this.position.top = y;
                this.updateDOMNodeStyle();
            }
        };
        DragPositioner.prototype.handleMouseUp = function (e) {
            e.stopPropagation();
            e.preventDefault();
            this.mouseIsDown = false;
            this.mouseDownPosition =
                {
                    x: 0,
                    y: 0,
                };
            if (this.isDragging) {
                this.handleDragEnd(e);
            }
            this.removeEventListeners();
        };
        DragPositioner.prototype.handleDragEnd = function (e) {
            if (this.cloneElement) {
                this.cloneElement.parentNode.removeChild(this.cloneElement);
                this.cloneElement = null;
            }
            this.isDragging = false;
            this.dragOffset = { x: 0, y: 0 };
            this.originPosition = { x: 0, y: 0 };
            if (this.onDragEnd) {
                this.onDragEnd();
            }
            if (this.ownerIsMounted) {
                this.owner.forceUpdate();
            }
        };
        DragPositioner.prototype.setContainerRect = function () {
            this.containerRect = this.containerElement.getBoundingClientRect();
        };
        DragPositioner.prototype.handleNativeMoveEvent = function (e) {
            this.handleMouseMove(normalizeEvent_1.default(e));
        };
        DragPositioner.prototype.handleNativeUpEvent = function (e) {
            this.handleMouseUp(normalizeEvent_1.default(e));
        };
        DragPositioner.prototype.addEventListeners = function () {
            this.containerElement.addEventListener("mousemove", this.handleNativeMoveEvent);
            document.addEventListener("mouseup", this.handleNativeUpEvent);
            if (this.touchEventTarget) {
                this.touchEventTarget.addEventListener("touchmove", this.handleNativeMoveEvent);
                this.touchEventTarget.addEventListener("touchend", this.handleNativeUpEvent);
            }
        };
        DragPositioner.prototype.removeEventListeners = function () {
            this.containerElement.removeEventListener("mousemove", this.handleNativeMoveEvent);
            document.removeEventListener("mouseup", this.handleNativeUpEvent);
            if (this.touchEventTarget) {
                this.touchEventTarget.removeEventListener("touchmove", this.handleNativeMoveEvent);
                this.touchEventTarget.removeEventListener("touchend", this.handleNativeUpEvent);
                this.touchEventTarget = null;
            }
        };
        return DragPositioner;
    }());
    exports.default = DragPositioner;
});
define("src/uicomponents/mixins/applyMixins", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var lifeCycleFunctions = [
        "componentWillMount", "componentDidMount",
        "componentWillReceiveProps", "componentWillUpdate",
        "componentDidUpdate", "componentWillUnmount",
    ];
    function wrapLifeCycleFunction(base, functionName, mixins) {
        var originalFunction = base[functionName];
        var mixinsWithFunction = mixins.filter(function (mixin) { return Boolean(mixin[functionName]); });
        base[functionName] = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            mixinsWithFunction.forEach(function (mixin) {
                mixin[functionName].apply(mixin, args);
            });
            if (originalFunction) {
                originalFunction.apply(base, args);
            }
        };
    }
    function wrapRenderFunction(base, mixins) {
        var originalFunction = base.render;
        var mixinsWithFunction = mixins.filter(function (mixin) { return Boolean(mixin.onRender); });
        base.render = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            mixinsWithFunction.forEach(function (mixin) {
                mixin.onRender.call(mixin);
            });
            return originalFunction.apply(base, args);
        };
    }
    function applyMixins(base) {
        var mixins = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            mixins[_i - 1] = arguments[_i];
        }
        lifeCycleFunctions.forEach(function (functionName) {
            wrapLifeCycleFunction(base, functionName, mixins);
        });
        wrapRenderFunction(base, mixins);
    }
    exports.default = applyMixins;
});
define("src/uicomponents/unit/Unit", ["require", "exports", "react", "src/uicomponents/unit/UnitAttributeChanges", "src/uicomponents/unit/UnitIconContainer", "src/uicomponents/unit/UnitInfo", "src/uicomponents/unit/UnitPassiveEffects", "src/uicomponents/unit/UnitPortrait", "src/uicomponents/mixins/DragPositioner", "src/uicomponents/mixins/applyMixins", "localization/localize"], function (require, exports, React, UnitAttributeChanges_1, UnitIconContainer_2, UnitInfo_1, UnitPassiveEffects_1, UnitPortrait_1, DragPositioner_1, applyMixins_1, localize_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var UnitComponent = (function (_super) {
        __extends(UnitComponent, _super);
        function UnitComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "Unit";
            _this.state = _this.getInitialStateTODO();
            _this.bindMethods();
            if (_this.props.isDraggable) {
                _this.dragPositioner = new DragPositioner_1.default(_this, _this.props.dragPositionerProps);
                _this.dragPositioner.onDragStart = _this.onDragStart;
                _this.dragPositioner.onDragEnd = _this.onDragEnd;
                applyMixins_1.default(_this, _this.dragPositioner);
            }
            return _this;
        }
        UnitComponent.prototype.bindMethods = function () {
            this.handleClick = this.handleClick.bind(this);
            this.onDragEnd = this.onDragEnd.bind(this);
            this.handleMouseEnter = this.handleMouseEnter.bind(this);
            this.onDragStart = this.onDragStart.bind(this);
            this.handleMouseLeave = this.handleMouseLeave.bind(this);
        };
        UnitComponent.prototype.getInitialStateTODO = function () {
            return ({});
        };
        UnitComponent.prototype.onDragStart = function () {
            this.props.onDragStart();
        };
        UnitComponent.prototype.onDragEnd = function () {
            this.props.onDragEnd();
        };
        UnitComponent.prototype.handleClick = function () {
            this.props.onUnitClick();
        };
        UnitComponent.prototype.handleMouseEnter = function () {
            this.props.handleMouseEnterUnit();
        };
        UnitComponent.prototype.handleMouseLeave = function (e) {
            this.props.handleMouseLeaveUnit(e);
        };
        UnitComponent.prototype.render = function () {
            var wrapperProps = {
                className: "unit",
                onMouseEnter: this.props.handleMouseEnterUnit ? this.handleMouseEnter : null,
                onMouseLeave: this.props.handleMouseLeaveUnit ? this.handleMouseLeave : null,
                onClick: this.props.onUnitClick ? this.handleClick : null,
                onMouseUp: this.props.onMouseUp,
            };
            if (this.props.isDraggable) {
                wrapperProps.className += " draggable";
                wrapperProps.onMouseDown = wrapperProps.onTouchStart = this.dragPositioner.handleReactDownEvent;
                if (this.dragPositioner.isDragging) {
                    wrapperProps.style = this.dragPositioner.getStyleAttributes();
                    wrapperProps.className += " dragging";
                }
            }
            if (this.props.facesLeft) {
                wrapperProps.className += " enemy-unit";
            }
            else {
                wrapperProps.className += " friendly-unit";
            }
            if (this.props.isActiveUnit) {
                wrapperProps.className += " active-unit";
            }
            if (this.props.isInPotentialTargetArea) {
                wrapperProps.className += " target-unit";
            }
            if (this.props.isHovered) {
                wrapperProps.className += " hovered-unit";
            }
            if (this.props.isTargetOfActiveEffect) {
                wrapperProps.className += " active-effect-unit";
            }
            var bodyElements = [
                React.DOM.div({
                    className: "unit-portrait-container",
                    key: "portraitContainer",
                }, UnitPortrait_1.default({
                    imageSrc: (this.props.portraitSrc || ""),
                }), UnitPassiveEffects_1.default({
                    passiveEffects: this.props.passiveEffects,
                }), UnitAttributeChanges_1.default({
                    attributeChanges: this.props.attributeChanges,
                })),
                UnitInfo_1.default({
                    key: "info",
                    name: this.props.name,
                    guardAmount: this.props.guardAmount,
                    guardType: this.props.guardType,
                    isPreparing: this.props.isPreparing,
                    maxHealth: this.props.maxHealth,
                    currentHealth: this.props.currentHealth,
                    currentActionPoints: this.props.currentActionPoints,
                    maxActionPoints: this.props.maxActionPoints,
                    hoveredActionPointExpenditure: this.props.hoveredActionPointExpenditure,
                    isSquadron: this.props.isSquadron,
                    wasDestroyed: this.props.wasDestroyed,
                    wasCaptured: this.props.wasCaptured,
                    animateDuration: this.props.animateDuration,
                }),
            ];
            if (this.props.facesLeft) {
                bodyElements.reverse();
            }
            if (this.props.isAnnihilated) {
                bodyElements.push(React.DOM.div({ key: "overlay", className: "unit-annihilated-overlay" }, localize_4.localize("unitAnnihilated")));
            }
            var innerElements = [
                React.DOM.div({
                    className: "unit-body",
                    id: "unit-id_" + this.props.id,
                    key: "body",
                }, bodyElements),
                UnitIconContainer_2.default({
                    key: "icon",
                    facesLeft: this.props.facesLeft,
                    iconSrc: this.props.iconSrc,
                }),
            ];
            return (React.DOM.div(wrapperProps, this.props.facesLeft ? innerElements.reverse() : innerElements));
        };
        return UnitComponent;
    }(React.PureComponent));
    exports.UnitComponent = UnitComponent;
    var Factory = React.createFactory(UnitComponent);
    exports.default = Factory;
});
define("src/uicomponents/unit/UnitWrapper", ["require", "exports", "react"], function (require, exports, React) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var UnitWrapperComponent = (function (_super) {
        __extends(UnitWrapperComponent, _super);
        function UnitWrapperComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "UnitWrapper";
            return _this;
        }
        UnitWrapperComponent.prototype.render = function () {
            return (React.DOM.div({
                className: "unit-wrapper",
            }, this.props.children));
        };
        return UnitWrapperComponent;
    }(React.Component));
    exports.UnitWrapperComponent = UnitWrapperComponent;
    var Factory = React.createFactory(UnitWrapperComponent);
    exports.default = Factory;
});
define("src/uicomponents/battle/Formation", ["require", "exports", "react", "src/activeModuleData", "src/utility", "src/uicomponents/unit/EmptyUnit", "src/uicomponents/unit/Unit", "src/uicomponents/unit/UnitWrapper"], function (require, exports, React, activeModuleData_18, utility_25, EmptyUnit_1, Unit_4, UnitWrapper_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var FormationComponent = (function (_super) {
        __extends(FormationComponent, _super);
        function FormationComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "Formation";
            return _this;
        }
        FormationComponent.prototype.makeBoundFunction = function (functionToBind, valueToBind) {
            if (!functionToBind) {
                return null;
            }
            else {
                return (function () { functionToBind(valueToBind); });
            }
        };
        FormationComponent.prototype.unitInArray = function (unitToCheck, arr) {
            if (!arr) {
                return false;
            }
            else {
                return arr.some(function (unit) { return unit === unitToCheck; });
            }
        };
        FormationComponent.prototype.render = function () {
            var formationRowElements = [];
            for (var i = 0; i < this.props.formation.length; i++) {
                var absoluteRowIndex = this.props.facesLeft ?
                    i + activeModuleData_18.activeModuleData.ruleSet.battle.rowsPerFormation :
                    i;
                var unitElements = [];
                for (var j = 0; j < this.props.formation[i].length; j++) {
                    var unit = this.props.formation[i][j];
                    var absolutePosition = [absoluteRowIndex, j];
                    var onMouseUp = this.props.onMouseUp ?
                        this.props.onMouseUp.bind(null, absolutePosition) :
                        null;
                    var unitProps = void 0;
                    if (unit) {
                        var unitDisplayData = this.props.unitDisplayDataById[unit.id];
                        var componentProps = {
                            id: unit.id,
                            onUnitClick: this.makeBoundFunction(this.props.onUnitClick, unit),
                            handleMouseEnterUnit: this.makeBoundFunction(this.props.handleMouseEnterUnit, unit),
                            handleMouseLeaveUnit: this.props.handleMouseLeaveUnit,
                            isDraggable: this.props.isDraggable,
                            onDragStart: this.makeBoundFunction(this.props.onDragStart, unit),
                            onDragEnd: this.props.onDragEnd,
                            onMouseUp: onMouseUp,
                            animateDuration: this.props.unitStrengthAnimateDuration,
                        };
                        var displayProps = {
                            wasDestroyed: this.unitInArray(unit, this.props.destroyedUnits),
                            wasCaptured: this.unitInArray(unit, this.props.capturedUnits),
                            isInBattlePrep: this.props.isInBattlePrep,
                            isActiveUnit: this.props.activeUnit === unit,
                            isHovered: this.props.hoveredUnit === unit,
                            isInPotentialTargetArea: this.unitInArray(unit, this.props.targetsInPotentialArea),
                            isTargetOfActiveEffect: this.unitInArray(unit, this.props.activeEffectUnits),
                            hoveredActionPointExpenditure: this.props.hoveredAbility &&
                                this.props.activeUnit === unit ? this.props.hoveredAbility.actionsUse : null,
                        };
                        unitProps = utility_25.shallowExtend(unitDisplayData, componentProps, displayProps);
                        if (this.props.facesLeft && this.props.isInBattlePrep) {
                            unitProps.facesLeft = true;
                        }
                    }
                    unitElements.push(UnitWrapper_1.default({ key: ("unit_wrapper_" + i) + j }, EmptyUnit_1.default({
                        facesLeft: this.props.facesLeft,
                        onMouseUp: onMouseUp,
                    }), !unit ? null : Unit_4.default(unitProps)));
                }
                formationRowElements.push(React.DOM.div({
                    className: "battle-formation-row",
                    key: "row_" + i,
                }, unitElements));
            }
            return (React.DOM.div({ className: "battle-formation" }, formationRowElements));
        };
        return FormationComponent;
    }(React.Component));
    exports.FormationComponent = FormationComponent;
    var Factory = React.createFactory(FormationComponent);
    exports.default = Factory;
});
define("src/uicomponents/battle/TurnCounter", ["require", "exports", "react", "react-transition-group"], function (require, exports, React, ReactTransitionGroup) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ReactCSSTransitionGroup = React.createFactory(ReactTransitionGroup.CSSTransitionGroup);
    var FirstChild = React.createClass({
        render: function () {
            var child = React.Children.toArray(this.props.children)[0];
            return child || null;
        },
    });
    var TurnCounterComponent = (function (_super) {
        __extends(TurnCounterComponent, _super);
        function TurnCounterComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "TurnCounter";
            return _this;
        }
        TurnCounterComponent.prototype.componentDidMount = function () {
            if (this.inner) {
                this.inner.style.animationDuration = "" + this.props.animationDuration + "ms";
            }
        };
        TurnCounterComponent.prototype.render = function () {
            var _this = this;
            return (React.DOM.div({
                className: "turn-counter" +
                    (!this.props.isEmpty ? " turn-counter-available-border" : ""),
            }, ReactCSSTransitionGroup({
                transitionName: "available-turn",
                transitionAppear: false,
                transitionEnter: false,
                transitionLeave: true,
                transitionLeaveTimeout: this.props.animationDuration,
                component: FirstChild,
            }, this.props.isEmpty ? null : React.DOM.div({
                key: "inner",
                className: "available-turn",
                ref: function (element) {
                    _this.inner = element;
                },
            }))));
        };
        return TurnCounterComponent;
    }(React.PureComponent));
    exports.TurnCounterComponent = TurnCounterComponent;
    var Factory = React.createFactory(TurnCounterComponent);
    exports.default = Factory;
});
define("src/uicomponents/battle/TurnCounterList", ["require", "exports", "react", "src/uicomponents/battle/TurnCounter", "localization/localize"], function (require, exports, React, TurnCounter_1, localize_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TurnCounterListComponent = (function (_super) {
        __extends(TurnCounterListComponent, _super);
        function TurnCounterListComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "TurnCounterList";
            return _this;
        }
        TurnCounterListComponent.prototype.render = function () {
            var turnElements = [];
            var usedTurns = this.props.maxTurns - this.props.turnsLeft;
            for (var i = 0; i < this.props.maxTurns; i++) {
                turnElements.push(TurnCounter_1.default({
                    key: i,
                    isEmpty: i < usedTurns,
                    animationDuration: this.props.animationDuration,
                }));
            }
            return (React.DOM.div({
                className: "turns-container",
                title: localize_5.localize("turnsLeft") + ": " + this.props.turnsLeft,
            }, turnElements));
        };
        return TurnCounterListComponent;
    }(React.PureComponent));
    exports.TurnCounterListComponent = TurnCounterListComponent;
    var Factory = React.createFactory(TurnCounterListComponent);
    exports.default = Factory;
});
define("src/uicomponents/battle/TurnOrderUnit", ["require", "exports", "react", "localization/localize"], function (require, exports, React, localize_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AnimationState;
    (function (AnimationState) {
        AnimationState[AnimationState["RemoveDeadUnit"] = 0] = "RemoveDeadUnit";
        AnimationState[AnimationState["FillSpaceLeftByDeadUnits"] = 1] = "FillSpaceLeftByDeadUnits";
        AnimationState[AnimationState["RemoveUnit"] = 2] = "RemoveUnit";
        AnimationState[AnimationState["ClearSpaceForUnit"] = 3] = "ClearSpaceForUnit";
        AnimationState[AnimationState["InsertUnit"] = 4] = "InsertUnit";
        AnimationState[AnimationState["PushUnit"] = 5] = "PushUnit";
        AnimationState[AnimationState["Idle"] = 6] = "Idle";
    })(AnimationState = exports.AnimationState || (exports.AnimationState = {}));
    var TurnOrderUnitComponent = (function (_super) {
        __extends(TurnOrderUnitComponent, _super);
        function TurnOrderUnitComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "TurnOrderUnit";
            _this.containerClassForAnimationState = (_a = {},
                _a[AnimationState.RemoveDeadUnit] = "remove-dead-unit",
                _a[AnimationState.FillSpaceLeftByDeadUnits] = "fill-space-left-by-dead-unit",
                _a[AnimationState.RemoveUnit] = "remove-unit",
                _a[AnimationState.ClearSpaceForUnit] = "clear-space-for-unit",
                _a[AnimationState.InsertUnit] = "insert-unit",
                _a[AnimationState.PushUnit] = "push-unit",
                _a[AnimationState.Idle] = "",
                _a);
            return _this;
            var _a;
        }
        TurnOrderUnitComponent.prototype.render = function () {
            var additionalUnitClasses = "";
            if (this.props.isFriendly) {
                additionalUnitClasses += " turn-order-unit-friendly";
            }
            else {
                additionalUnitClasses += " turn-order-unit-enemy";
            }
            if (this.props.isHovered) {
                additionalUnitClasses += " turn-order-unit-hover";
            }
            return (React.DOM.div({
                className: "turn-order-unit-container" + " " +
                    this.containerClassForAnimationState[this.props.animationState],
                style: {
                    animationDuration: "" + this.props.transitionDuration + "ms",
                },
            }, React.DOM.div({
                className: "turn-order-unit" + additionalUnitClasses,
                style: {
                    animationDuration: "" + this.props.transitionDuration + "ms",
                },
                title: localize_6.localize("delay_turnOrder") + ": " + this.props.delay,
                onMouseEnter: this.props.onMouseEnter,
                onMouseLeave: this.props.onMouseLeave,
            }, this.props.unitName)));
        };
        return TurnOrderUnitComponent;
    }(React.PureComponent));
    exports.TurnOrderUnitComponent = TurnOrderUnitComponent;
    var Factory = React.createFactory(TurnOrderUnitComponent);
    exports.default = Factory;
});
define("src/uicomponents/battle/TurnOrder", ["require", "exports", "react", "react-dom", "src/uicomponents/battle/TurnOrderUnit"], function (require, exports, React, ReactDOM, TurnOrderUnit_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TurnOrderComponent = (function (_super) {
        __extends(TurnOrderComponent, _super);
        function TurnOrderComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "TurnOrder";
            _this.state = _this.getInitialStateTODO();
            _this.bindMethods();
            return _this;
        }
        TurnOrderComponent.prototype.bindMethods = function () {
            this.setMaxUnits = this.setMaxUnits.bind(this);
        };
        TurnOrderComponent.prototype.getInitialStateTODO = function () {
            return ({
                maxUnits: 7,
                currentDisplayData: this.props.turnOrderDisplayData,
                pendingDisplayData: undefined,
                pendingDeadUnitsById: {},
                pendingDeadUnitIndices: {},
                insertIndex: undefined,
                animationState: TurnOrderUnit_1.AnimationState.Idle,
            });
        };
        TurnOrderComponent.prototype.componentDidMount = function () {
            this.setMaxUnits();
            window.addEventListener("resize", this.setMaxUnits);
        };
        TurnOrderComponent.prototype.componentWillUnmount = function () {
            window.removeEventListener("resize", this.setMaxUnits);
            if (isFinite(this.timeoutHandle)) {
                window.clearTimeout(this.timeoutHandle);
            }
        };
        TurnOrderComponent.prototype.componentWillReceiveProps = function (newProps) {
            var _this = this;
            if (newProps.turnIsTransitioning && !this.props.turnIsTransitioning) {
                var removedUnit = this.state.currentDisplayData[0].unit;
                var newRemovedUnitIndex = void 0;
                for (var i = 0; i < newProps.turnOrderDisplayData.length; i++) {
                    if (newProps.turnOrderDisplayData[i].unit === removedUnit) {
                        newRemovedUnitIndex = i;
                        break;
                    }
                }
                var pendingDeadUnitsById_1 = {};
                this.props.turnOrderDisplayData.forEach(function (currentDisplayData) {
                    var unit = currentDisplayData.unit;
                    if (!newProps.turnOrderDisplayData.some(function (newDisplayData) {
                        return newDisplayData.unit === unit;
                    })) {
                        pendingDeadUnitsById_1[unit.id] = true;
                    }
                });
                var unitsToRender = Math.min(newProps.turnOrderDisplayData.length, this.state.maxUnits);
                var shouldInsertRemovedUnit = newRemovedUnitIndex < unitsToRender - 1;
                this.setState({
                    pendingDisplayData: newProps.turnOrderDisplayData,
                    pendingDeadUnitsById: pendingDeadUnitsById_1,
                    insertIndex: shouldInsertRemovedUnit ? newRemovedUnitIndex : undefined,
                }, function () {
                    _this.removeDeadUnits();
                });
            }
        };
        TurnOrderComponent.prototype.getTransitionDuration = function () {
            return this.props.turnTransitionDuration / 4;
        };
        TurnOrderComponent.prototype.setFinishAnimatingTimeout = function () {
            var _this = this;
            this.timeoutHandle = window.setTimeout(function () {
                _this.setState({
                    animationState: TurnOrderUnit_1.AnimationState.Idle,
                });
            }, this.getTransitionDuration());
        };
        TurnOrderComponent.prototype.removeDeadUnits = function () {
            var _this = this;
            if (Object.keys(this.state.pendingDeadUnitsById).length > 0) {
                var deadUnitIndices_1 = {};
                this.state.currentDisplayData.forEach(function (displayData, i) {
                    if (_this.state.pendingDeadUnitsById[displayData.unit.id]) {
                        deadUnitIndices_1[i] = true;
                    }
                });
                this.setState({
                    animationState: TurnOrderUnit_1.AnimationState.RemoveDeadUnit,
                    pendingDeadUnitIndices: deadUnitIndices_1,
                }, function () {
                    _this.timeoutHandle = window.setTimeout(function () {
                        _this.fillSpaceLeftByDeadUnits();
                    }, _this.getTransitionDuration());
                });
            }
            else {
                this.removeUnit();
            }
        };
        TurnOrderComponent.prototype.fillSpaceLeftByDeadUnits = function () {
            var _this = this;
            this.setState({
                animationState: TurnOrderUnit_1.AnimationState.FillSpaceLeftByDeadUnits,
            }, function () {
                _this.timeoutHandle = window.setTimeout(function () {
                    _this.setState({
                        currentDisplayData: _this.state.currentDisplayData.filter(function (d) {
                            return !_this.state.pendingDeadUnitsById[d.unit.id];
                        }),
                    }, function () {
                        _this.removeUnit();
                    });
                }, _this.getTransitionDuration());
            });
        };
        TurnOrderComponent.prototype.removeUnit = function () {
            var _this = this;
            this.setState({
                animationState: TurnOrderUnit_1.AnimationState.RemoveUnit,
            }, function () {
                _this.timeoutHandle = window.setTimeout(function () {
                    _this.setState({
                        currentDisplayData: _this.state.currentDisplayData.slice(1),
                    });
                    if (isFinite(_this.state.insertIndex)) {
                        _this.clearSpaceForUnit();
                    }
                    else {
                        _this.pushUnit();
                    }
                }, _this.getTransitionDuration());
            });
        };
        TurnOrderComponent.prototype.clearSpaceForUnit = function () {
            var _this = this;
            this.setState({
                animationState: TurnOrderUnit_1.AnimationState.ClearSpaceForUnit,
            }, function () {
                _this.timeoutHandle = window.setTimeout(function () {
                    _this.insertUnit();
                }, _this.getTransitionDuration());
            });
        };
        TurnOrderComponent.prototype.insertUnit = function () {
            var _this = this;
            this.setState({
                currentDisplayData: this.state.pendingDisplayData,
                pendingDisplayData: undefined,
                animationState: TurnOrderUnit_1.AnimationState.InsertUnit,
            }, function () {
                _this.setFinishAnimatingTimeout();
            });
        };
        TurnOrderComponent.prototype.pushUnit = function () {
            var _this = this;
            this.setState({
                currentDisplayData: this.state.pendingDisplayData,
                pendingDisplayData: undefined,
                animationState: TurnOrderUnit_1.AnimationState.PushUnit,
            }, function () {
                _this.setFinishAnimatingTimeout();
            });
        };
        TurnOrderComponent.prototype.setMaxUnits = function () {
            var minUnits = 7;
            var containerElement = ReactDOM.findDOMNode(this);
            var containerWidth = containerElement.getBoundingClientRect().width - 30;
            var unitElementWidth = 160;
            var ceil = Math.ceil(containerWidth / unitElementWidth);
            this.setState({
                maxUnits: Math.max(ceil, minUnits),
            });
        };
        TurnOrderComponent.prototype.render = function () {
            var toRender = [];
            var unitsToRender = Math.min(this.state.currentDisplayData.length, this.state.maxUnits);
            var transitionDuration = this.getTransitionDuration();
            for (var i = 0; i < unitsToRender; i++) {
                var displayData = this.state.currentDisplayData[i];
                var unitAnimationState = TurnOrderUnit_1.AnimationState.Idle;
                switch (this.state.animationState) {
                    case TurnOrderUnit_1.AnimationState.RemoveDeadUnit:
                        {
                            if (this.state.pendingDeadUnitsById[displayData.unit.id]) {
                                unitAnimationState = TurnOrderUnit_1.AnimationState.RemoveDeadUnit;
                            }
                            break;
                        }
                    case TurnOrderUnit_1.AnimationState.FillSpaceLeftByDeadUnits:
                        {
                            if (this.state.pendingDeadUnitIndices[i]) {
                                unitAnimationState = TurnOrderUnit_1.AnimationState.FillSpaceLeftByDeadUnits;
                            }
                            break;
                        }
                    case TurnOrderUnit_1.AnimationState.RemoveUnit:
                        {
                            if (i === 0) {
                                unitAnimationState = TurnOrderUnit_1.AnimationState.RemoveUnit;
                            }
                            break;
                        }
                    case TurnOrderUnit_1.AnimationState.ClearSpaceForUnit:
                        {
                            if (i === this.state.insertIndex) {
                                unitAnimationState = TurnOrderUnit_1.AnimationState.ClearSpaceForUnit;
                            }
                            break;
                        }
                    case TurnOrderUnit_1.AnimationState.InsertUnit:
                        {
                            if (i === this.state.insertIndex) {
                                unitAnimationState = TurnOrderUnit_1.AnimationState.InsertUnit;
                            }
                            break;
                        }
                    case TurnOrderUnit_1.AnimationState.PushUnit:
                        {
                            if (i === unitsToRender - 1) {
                                unitAnimationState = TurnOrderUnit_1.AnimationState.PushUnit;
                            }
                            break;
                        }
                }
                toRender.push(TurnOrderUnit_1.default({
                    key: displayData.unit.id,
                    unitName: displayData.unit.name,
                    delay: displayData.moveDelay,
                    isFriendly: this.props.unitsBySide.side1.indexOf(displayData.unit) > -1,
                    isHovered: this.props.hoveredUnit && displayData.unit === this.props.hoveredUnit,
                    animationState: unitAnimationState,
                    transitionDuration: transitionDuration,
                    onMouseEnter: this.props.onMouseEnterUnit.bind(null, displayData.unit),
                    onMouseLeave: this.props.onMouseLeaveUnit,
                }));
            }
            if (isFinite(this.props.hoveredGhostIndex)) {
                toRender.splice(this.props.hoveredGhostIndex, 0, React.DOM.div({
                    className: "turn-order-arrow",
                    key: "ghost",
                }));
            }
            return (React.DOM.div({ className: "turn-order-container" }, toRender));
        };
        return TurnOrderComponent;
    }(React.Component));
    exports.TurnOrderComponent = TurnOrderComponent;
    var Factory = React.createFactory(TurnOrderComponent);
    exports.default = Factory;
});
define("src/uicomponents/battle/Battle", ["require", "exports", "react", "react-dom", "src/AbilityUseEffectQueue", "src/activeModuleData", "src/BattleScene", "src/MCTree", "src/Options", "src/battleAbilityUI", "src/battleAbilityUsage", "src/utility", "src/uicomponents/battle/AbilityTooltip", "src/uicomponents/battle/BattleBackground", "src/uicomponents/battle/BattleDisplayStrength", "src/uicomponents/battle/BattleScene", "src/uicomponents/battle/BattleScore", "src/uicomponents/battle/BattleUIState", "src/uicomponents/battle/Formation", "src/uicomponents/battle/TurnCounterList", "src/uicomponents/battle/TurnOrder"], function (require, exports, React, ReactDOM, AbilityUseEffectQueue_1, activeModuleData_19, BattleScene_2, MCTree_2, Options_7, battleAbilityUI_1, battleAbilityUsage_3, utility_26, AbilityTooltip_1, BattleBackground_1, BattleDisplayStrength_1, BattleScene_3, BattleScore_1, BattleUIState_1, Formation_1, TurnCounterList_1, TurnOrder_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BattleComponent = (function (_super) {
        __extends(BattleComponent, _super);
        function BattleComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "Battle";
            _this.tempHoveredUnit = null;
            _this.MCTree = null;
            _this.state = _this.getInitialStateTODO();
            _this.bindMethods();
            _this.battleScene = new BattleScene_2.default();
            _this.abilityUseEffectQueue = new AbilityUseEffectQueue_1.AbilityUseEffectQueue(_this.battleScene, {
                onEffectStart: _this.setStateForBattleEffect,
                onSFXStart: function () {
                    _this.SFXStartTime = Date.now();
                },
                onEffectTrigger: _this.onBattleEffectTrigger,
                onCurrentFinished: _this.playQueuedBattleEffects,
                onAllFinished: _this.finishPlayingQueuedBattleEffects,
            });
            return _this;
        }
        BattleComponent.prototype.bindMethods = function () {
            this.clearHoveredUnit = this.clearHoveredUnit.bind(this);
            this.getBlurArea = this.getBlurArea.bind(this);
            this.handleMouseEnterUnit = this.handleMouseEnterUnit.bind(this);
            this.handleMouseEnterAbility = this.handleMouseEnterAbility.bind(this);
            this.usePreparedAbility = this.usePreparedAbility.bind(this);
            this.useAIAbility = this.useAIAbility.bind(this);
            this.handleMouseLeaveAbility = this.handleMouseLeaveAbility.bind(this);
            this.startTurnTransition = this.startTurnTransition.bind(this);
            this.handleTurnEnd = this.handleTurnEnd.bind(this);
            this.handleMouseLeaveUnit = this.handleMouseLeaveUnit.bind(this);
            this.usePlayerAbility = this.usePlayerAbility.bind(this);
            this.endBattleStart = this.endBattleStart.bind(this);
            this.getUnitElement = this.getUnitElement.bind(this);
            this.handleAbilityUse = this.handleAbilityUse.bind(this);
            this.finishBattle = this.finishBattle.bind(this);
            this.setStateForBattleEffect = this.setStateForBattleEffect.bind(this);
            this.playQueuedBattleEffects = this.playQueuedBattleEffects.bind(this);
            this.finishPlayingQueuedBattleEffects = this.finishPlayingQueuedBattleEffects.bind(this);
            this.onBattleEffectTrigger = this.onBattleEffectTrigger.bind(this);
        };
        BattleComponent.prototype.getInitialStateTODO = function () {
            var initialDisplayData = {};
            this.props.battle.forEachUnit(function (unit) {
                initialDisplayData[unit.id] = unit.getDisplayData("battle");
            });
            return ({
                UIState: BattleUIState_1.default.Starting,
                highlightedUnit: null,
                hoveredUnit: null,
                hoveredAbility: null,
                targetsInPotentialArea: [],
                potentialDelayId: undefined,
                potentialDelayAmount: undefined,
                abilityTooltip: {
                    parentElement: null,
                    facesLeft: null,
                },
                battleSceneUnit1: null,
                battleSceneUnit2: null,
                playingBattleEffect: false,
                battleEffectDuration: null,
                battleEffectDurationAfterTrigger: undefined,
                battleEvaluation: this.props.battle.getEvaluation(),
                unitDisplayDataById: initialDisplayData,
                previousUnitDisplayDataById: initialDisplayData,
            });
        };
        BattleComponent.prototype.componentDidMount = function () {
            this.battleStartStartTime = Date.now();
            this.ref_TODO_background.handleResize();
        };
        BattleComponent.prototype.endBattleStart = function () {
            var _this = this;
            if (Date.now() < this.battleStartStartTime + 1000) {
                return;
            }
            else if (this.props.battle.ended) {
                this.setState({
                    UIState: BattleUIState_1.default.Ending,
                });
            }
            else {
                this.setState({
                    UIState: BattleUIState_1.default.Idle,
                }, function () {
                    _this.battleScene.activeUnit = _this.props.battle.activeUnit;
                    _this.battleScene.updateUnits();
                    if (_this.tempHoveredUnit) {
                        _this.handleMouseEnterUnit(_this.tempHoveredUnit);
                    }
                    if (_this.props.battle.getActivePlayer() !== _this.props.humanPlayer) {
                        _this.useAIAbility();
                    }
                });
            }
        };
        BattleComponent.prototype.getBlurArea = function () {
            return ReactDOM.findDOMNode(this.ref_TODO_formationsContainer).getBoundingClientRect();
        };
        BattleComponent.prototype.clearHoveredUnit = function () {
            this.tempHoveredUnit = null;
            this.setState({
                hoveredUnit: null,
                highlightedUnit: null,
                abilityTooltip: {
                    parentElement: null,
                },
                hoveredAbility: null,
                potentialDelayId: undefined,
                potentialDelayAmount: undefined,
                targetsInPotentialArea: [],
            });
            this.battleScene.hoveredUnit = null;
            if (this.state.UIState === BattleUIState_1.default.Idle) {
                this.battleScene.updateUnits();
            }
        };
        BattleComponent.prototype.handleMouseLeaveUnit = function (e) {
            if (!this.state.hoveredUnit || this.state.playingBattleEffect) {
                this.tempHoveredUnit = null;
                return;
            }
            var nativeEvent = e.nativeEvent;
            var toElement = nativeEvent.toElement || nativeEvent.relatedTarget;
            if (!toElement) {
                this.clearHoveredUnit();
                return;
            }
            if (!this.ref_TODO_abilityTooltip) {
                this.clearHoveredUnit();
                return;
            }
            var tooltipElement = ReactDOM.findDOMNode(this.ref_TODO_abilityTooltip);
            if (toElement !== this.state.abilityTooltip.parentElement &&
                (this.ref_TODO_abilityTooltip && toElement !== tooltipElement) &&
                toElement.parentElement !== tooltipElement) {
                this.clearHoveredUnit();
            }
        };
        BattleComponent.prototype.handleMouseEnterUnit = function (unit) {
            this.tempHoveredUnit = unit;
            if (this.state.UIState !== BattleUIState_1.default.Idle) {
                return;
            }
            var facesLeft = unit.battleStats.side === "side2";
            var parentElement = this.getUnitElement(unit);
            this.setState({
                abilityTooltip: {
                    parentElement: parentElement,
                    facesLeft: facesLeft,
                },
                hoveredUnit: unit,
                highlightedUnit: unit,
            });
            this.battleScene.hoveredUnit = unit;
            this.battleScene.updateUnits();
        };
        BattleComponent.prototype.handleMouseEnterAbility = function (ability) {
            var targetsInPotentialArea = battleAbilityUI_1.getUnitsInAbilityArea(this.props.battle, ability, this.props.battle.activeUnit, this.state.hoveredUnit);
            var abilityUseDelay = ability.preparation ?
                ability.preparation.prepDelay * ability.preparation.turnsToPrep :
                ability.moveDelay;
            this.setState({
                hoveredAbility: ability,
                potentialDelayId: this.props.battle.activeUnit.id,
                potentialDelayAmount: this.props.battle.activeUnit.battleStats.moveDelay + abilityUseDelay,
                targetsInPotentialArea: targetsInPotentialArea,
            });
        };
        BattleComponent.prototype.handleMouseLeaveAbility = function () {
            this.setState({
                hoveredAbility: null,
                potentialDelayId: undefined,
                potentialDelayAmount: undefined,
                targetsInPotentialArea: [],
            });
        };
        BattleComponent.prototype.getUnitElement = function (unit) {
            return document.getElementById("unit-id_" + unit.id);
        };
        BattleComponent.prototype.handleAbilityUse = function (ability, target, wasByPlayer) {
            var abilityUseEffects = battleAbilityUsage_3.useAbilityAndGetUseEffects(this.props.battle, ability, this.props.battle.activeUnit, target);
            this.abilityUseEffectQueue.addEffects(abilityUseEffects);
            this.playQueuedBattleEffects();
        };
        BattleComponent.getUnitsBySideFromEffect = function (effect) {
            var userSide = effect.sfxUser.battleStats.side;
            var targetSide = effect.sfxTarget.battleStats.side;
            return ({
                battleSceneUnit1: (targetSide === "side1" ? effect.sfxTarget :
                    (userSide === "side1" ? effect.sfxUser : null)),
                battleSceneUnit2: (targetSide === "side2" ? effect.sfxTarget :
                    (userSide === "side2" ? effect.sfxUser : null)),
            });
        };
        BattleComponent.prototype.setStateForBattleEffect = function (effect) {
            var stateObj = BattleComponent.getUnitsBySideFromEffect(effect);
            stateObj.playingBattleEffect = true;
            stateObj.UIState = BattleUIState_1.default.PlayingSFX;
            stateObj.battleEffectDuration = effect.sfx.duration * Options_7.default.battleAnimationTiming.effectDuration;
            this.setState(stateObj, this.clearHoveredUnit);
        };
        BattleComponent.prototype.playQueuedBattleEffects = function () {
            this.abilityUseEffectQueue.playOnce();
        };
        BattleComponent.prototype.onBattleEffectTrigger = function (effect) {
            this.setState({
                previousUnitDisplayDataById: utility_26.shallowCopy(this.state.unitDisplayDataById),
                unitDisplayDataById: utility_26.shallowExtend(this.state.unitDisplayDataById, effect.changedUnitDisplayDataById),
                battleEvaluation: effect.newEvaluation,
                battleEffectDurationAfterTrigger: this.state.battleEffectDuration -
                    (Date.now() - this.SFXStartTime),
            });
        };
        BattleComponent.prototype.finishPlayingQueuedBattleEffects = function () {
            this.setState({
                battleSceneUnit1: null,
                battleSceneUnit2: null,
                playingBattleEffect: false,
                battleEffectDuration: undefined,
                battleEffectDurationAfterTrigger: undefined,
            }, this.startTurnTransition);
        };
        BattleComponent.prototype.startTurnTransition = function () {
            var _this = this;
            if (!this.state.hoveredUnit || !this.state.hoveredUnit.isTargetable()) {
                this.clearHoveredUnit();
            }
            this.props.battle.endTurn();
            this.setState({
                UIState: BattleUIState_1.default.TransitioningTurn,
            }, function () {
                window.setTimeout(_this.handleTurnEnd, Options_7.default.battleAnimationTiming.turnTransition);
            });
        };
        BattleComponent.prototype.handleTurnEnd = function () {
            if (this.props.battle.ended) {
                this.setState({
                    UIState: BattleUIState_1.default.Ending,
                });
            }
            else if (this.props.battle.activeUnit && this.props.battle.activeUnit.battleStats.queuedAction) {
                this.usePreparedAbility();
            }
            else if (this.props.battle.getActivePlayer() !== this.props.humanPlayer) {
                this.useAIAbility();
            }
            else {
                this.battleScene.activeUnit = this.props.battle.activeUnit;
                this.battleScene.updateUnits();
                this.setState({
                    UIState: BattleUIState_1.default.Idle,
                });
            }
        };
        BattleComponent.prototype.usePreparedAbility = function () {
            var unit = this.props.battle.activeUnit;
            var action = unit.battleStats.queuedAction;
            var target = this.props.battle.unitsById[action.targetId];
            var userIsHuman = this.props.battle.getActivePlayer() === this.props.humanPlayer;
            this.handleAbilityUse(action.ability, target, userIsHuman);
        };
        BattleComponent.prototype.usePlayerAbility = function (ability, target) {
            this.handleAbilityUse(ability, target, true);
        };
        BattleComponent.prototype.useAIAbility = function () {
            if (!this.props.battle.activeUnit || this.props.battle.ended) {
                return;
            }
            if (!this.MCTree)
                this.MCTree = new MCTree_2.default(this.props.battle, this.props.battle.activeUnit.battleStats.side, false);
            var move = this.MCTree.getBestMoveAndAdvance(1000);
            var target = this.props.battle.unitsById[move.targetId];
            this.handleAbilityUse(move.ability, target, false);
        };
        BattleComponent.prototype.finishBattle = function () {
            if (Date.now() < this.battleEndStartTime + 1000) {
                return;
            }
            this.props.battle.finishBattle();
        };
        BattleComponent.prototype.render = function () {
            var _this = this;
            var battle = this.props.battle;
            var playerCanAct = this.state.UIState === BattleUIState_1.default.Idle;
            var activeTargets = playerCanAct ? battleAbilityUI_1.getTargetsForAllAbilities(battle, battle.activeUnit) : undefined;
            var abilityTooltip = null;
            if (playerCanAct &&
                this.state.hoveredUnit &&
                activeTargets[this.state.hoveredUnit.id]) {
                abilityTooltip = AbilityTooltip_1.default({
                    handleAbilityUse: this.usePlayerAbility,
                    handleMouseLeave: this.handleMouseLeaveUnit,
                    handleMouseEnterAbility: this.handleMouseEnterAbility,
                    handleMouseLeaveAbility: this.handleMouseLeaveAbility,
                    targetUnit: this.state.hoveredUnit,
                    parentElement: this.state.abilityTooltip.parentElement,
                    facesLeft: this.state.abilityTooltip.facesLeft,
                    activeTargets: activeTargets,
                    ref: function (component) {
                        _this.ref_TODO_abilityTooltip = component;
                    },
                    key: this.state.hoveredUnit.id,
                });
            }
            ;
            var activeEffectUnits = [];
            if (this.state.playingBattleEffect) {
                activeEffectUnits = [this.state.battleSceneUnit1, this.state.battleSceneUnit2];
            }
            var upperFooterElement;
            if (this.state.UIState === BattleUIState_1.default.Starting) {
                upperFooterElement = null;
            }
            else if (!this.state.playingBattleEffect) {
                upperFooterElement = TurnOrder_1.default({
                    key: "turnOrder",
                    unitsBySide: battle.unitsBySide,
                    turnOrderDisplayData: battle.turnOrder.getDisplayData(),
                    hoveredUnit: this.state.highlightedUnit,
                    hoveredGhostIndex: isFinite(this.state.potentialDelayAmount) ?
                        battle.turnOrder.getGhostIndex(this.state.potentialDelayAmount, this.state.potentialDelayId) :
                        undefined,
                    onMouseEnterUnit: this.handleMouseEnterUnit,
                    onMouseLeaveUnit: this.handleMouseLeaveUnit,
                    turnIsTransitioning: this.state.UIState === BattleUIState_1.default.TransitioningTurn,
                    turnTransitionDuration: Options_7.default.battleAnimationTiming.turnTransition,
                });
            }
            else {
                upperFooterElement = React.DOM.div({
                    key: "battleDisplayStrength",
                    className: "battle-display-strength-container",
                }, React.DOM.div({
                    className: "battle-display-strength battle-display-strength-side1",
                }, this.state.battleSceneUnit1 ? BattleDisplayStrength_1.default({
                    key: "battleDisplayStrength" + this.state.battleSceneUnit1.id,
                    animationDuration: this.state.battleEffectDurationAfterTrigger,
                    from: this.state.previousUnitDisplayDataById[this.state.battleSceneUnit1.id].currentHealth,
                    to: this.state.unitDisplayDataById[this.state.battleSceneUnit1.id].currentHealth,
                }) : null), React.DOM.div({
                    className: "battle-display-strength battle-display-strength-side2",
                }, this.state.battleSceneUnit2 ? BattleDisplayStrength_1.default({
                    key: "battleDisplayStrength" + this.state.battleSceneUnit2.id,
                    animationDuration: this.state.battleEffectDurationAfterTrigger,
                    from: this.state.previousUnitDisplayDataById[this.state.battleSceneUnit2.id].currentHealth,
                    to: this.state.unitDisplayDataById[this.state.battleSceneUnit2.id].currentHealth,
                }) : null));
            }
            var upperFooter = upperFooterElement;
            var containerProps = {
                className: "battle-container",
            };
            var playerWonBattle = null;
            if (this.state.UIState === BattleUIState_1.default.Starting) {
                containerProps.className += " battle-start-overlay";
                containerProps.onClick = this.endBattleStart;
            }
            else if (battle.ended) {
                if (!this.battleEndStartTime) {
                    this.battleEndStartTime = Date.now();
                }
                containerProps.className += " battle-start-overlay";
                containerProps.onClick = this.finishBattle;
                playerWonBattle = this.props.humanPlayer === battle.getVictor();
            }
            var battleState;
            if (this.state.UIState === BattleUIState_1.default.Starting) {
                battleState = "start";
            }
            else if (this.state.UIState === BattleUIState_1.default.Ending) {
                battleState = "finish";
            }
            else {
                battleState = "active";
            }
            return (BattleBackground_1.default({
                backgroundSeed: this.props.battle.battleData.location.getSeed(),
                backgroundDrawingFunction: activeModuleData_19.activeModuleData.starBackgroundDrawingFunction,
                getBlurArea: this.getBlurArea,
                ref: function (component) {
                    _this.ref_TODO_background = component;
                },
            }, React.DOM.div(containerProps, React.DOM.div({
                className: "battle-upper",
            }, BattleScore_1.default({
                evaluation: this.state.battleEvaluation,
                player1: battle.side1Player,
                player2: battle.side2Player,
                animationDuration: this.state.battleEffectDurationAfterTrigger,
            }), upperFooter, BattleScene_3.default({
                battleState: battleState,
                battleScene: this.battleScene,
                humanPlayerWonBattle: playerWonBattle,
                flag1: battle.side1Player.flag,
                flag2: battle.side2Player.flag,
            })), React.DOM.div({
                className: "formations-container",
                ref: function (container) {
                    _this.ref_TODO_formationsContainer = container;
                },
            }, Formation_1.default({
                unitDisplayDataById: this.state.unitDisplayDataById,
                formation: battle.side1,
                facesLeft: false,
                handleMouseEnterUnit: this.handleMouseEnterUnit,
                handleMouseLeaveUnit: this.handleMouseLeaveUnit,
                isInBattlePrep: false,
                hoveredUnit: this.state.highlightedUnit,
                activeUnit: battle.activeUnit,
                targetsInPotentialArea: this.state.targetsInPotentialArea,
                activeEffectUnits: activeEffectUnits,
                hoveredAbility: this.state.hoveredAbility,
                capturedUnits: this.props.battle.capturedUnits,
                destroyedUnits: this.props.battle.deadUnits,
                unitStrengthAnimateDuration: this.state.battleEffectDurationAfterTrigger,
            }), TurnCounterList_1.default({
                turnsLeft: battle.turnsLeft,
                maxTurns: battle.maxTurns,
                animationDuration: 100,
            }), Formation_1.default({
                unitDisplayDataById: this.state.unitDisplayDataById,
                formation: battle.side2,
                facesLeft: true,
                handleMouseEnterUnit: this.handleMouseEnterUnit,
                handleMouseLeaveUnit: this.handleMouseLeaveUnit,
                isInBattlePrep: false,
                hoveredUnit: this.state.highlightedUnit,
                activeUnit: battle.activeUnit,
                targetsInPotentialArea: this.state.targetsInPotentialArea,
                activeEffectUnits: activeEffectUnits,
                hoveredAbility: this.state.hoveredAbility,
                capturedUnits: this.props.battle.capturedUnits,
                destroyedUnits: this.props.battle.deadUnits,
                unitStrengthAnimateDuration: this.state.battleEffectDurationAfterTrigger,
            }), abilityTooltip, this.state.playingBattleEffect ?
                React.DOM.div({ className: "battle-formations-darken" }, null) :
                null))));
        };
        return BattleComponent;
    }(React.Component));
    exports.BattleComponent = BattleComponent;
    var Factory = React.createFactory(BattleComponent);
    exports.default = Factory;
});
define("src/uicomponents/list/List", ["require", "exports", "react", "react-dom", "src/eventManager", "src/utility"], function (require, exports, React, ReactDOM, eventManager_18, utility_27) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ListComponent = (function (_super) {
        __extends(ListComponent, _super);
        function ListComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.state = _this.getInitialStateTODO();
            _this.bindMethods();
            return _this;
        }
        ListComponent.prototype.bindMethods = function () {
            this.getNewSortingOrder = this.getNewSortingOrder.bind(this);
            this.handleScroll = this.handleScroll.bind(this);
            this.makeInitialSortingOrder = this.makeInitialSortingOrder.bind(this);
            this.shiftSelection = this.shiftSelection.bind(this);
            this.handleSelectRow = this.handleSelectRow.bind(this);
            this.setDesiredHeight = this.setDesiredHeight.bind(this);
            this.handleSelectColumn = this.handleSelectColumn.bind(this);
            this.getSortedItems = this.getSortedItems.bind(this);
        };
        ListComponent.prototype.getInitialStateTODO = function () {
            var initialColumn = this.props.initialSortOrder ?
                this.props.initialSortOrder[0] :
                this.props.initialColumns[0];
            var sortingOrderForColumnKey = {};
            this.props.initialColumns.forEach(function (column) {
                sortingOrderForColumnKey[column.key] = column.defaultOrder;
            });
            return ({
                columns: this.props.initialColumns,
                selected: null,
                selectedColumn: initialColumn,
                columnSortingOrder: this.makeInitialSortingOrder(this.props.initialColumns, initialColumn),
                sortingOrderForColumnKey: sortingOrderForColumnKey,
            });
        };
        ListComponent.prototype.componentDidMount = function () {
            var self = this;
            window.addEventListener("resize", this.setDesiredHeight, false);
            eventManager_18.default.addEventListener("popupResized", this.setDesiredHeight);
            if (this.props.keyboardSelect) {
                ReactDOM.findDOMNode(this).addEventListener("keydown", function (event) {
                    switch (event.keyCode) {
                        case 40:
                            {
                                self.shiftSelection(1);
                                break;
                            }
                        case 38:
                            {
                                self.shiftSelection(-1);
                                break;
                            }
                        default:
                            {
                                return;
                            }
                    }
                });
            }
            if (this.props.initialSelected) {
                this.handleSelectRow(this.props.initialSelected);
            }
            else if (this.props.autoSelect) {
                this.handleSelectRow(this.sortedItems[0]);
                ReactDOM.findDOMNode(this).focus();
            }
            else {
                this.setState({ selected: this.sortedItems[0] });
            }
        };
        ListComponent.prototype.componentWillUnmount = function () {
            window.removeEventListener("resize", this.setDesiredHeight);
            eventManager_18.default.removeEventListener("popupResized", this.setDesiredHeight);
        };
        ListComponent.prototype.componentDidUpdate = function () {
            this.setDesiredHeight();
        };
        ListComponent.prototype.setDesiredHeight = function () {
            var ownNode = ReactDOM.findDOMNode(this);
            var innerNode = ReactDOM.findDOMNode(this.ref_TODO_inner);
            ownNode.style.height = "auto";
            innerNode.style.height = "auto";
            var parentHeight = ownNode.parentElement.getBoundingClientRect().height;
            var ownRect = ownNode.getBoundingClientRect();
            var ownHeight = ownRect.height;
            var strippedOwnHeight = parseInt(getComputedStyle(ownNode).height);
            var extraHeight = ownHeight - strippedOwnHeight;
            var desiredHeight = parentHeight - extraHeight;
            var maxHeight = window.innerHeight - ownRect.top - extraHeight;
            desiredHeight = Math.min(desiredHeight, maxHeight);
            ownNode.style.height = "" + desiredHeight + "px";
            innerNode.style.height = "" + desiredHeight + "px";
        };
        ListComponent.prototype.handleScroll = function (e) {
            var target = e.currentTarget;
            var header = ReactDOM.findDOMNode(this.ref_TODO_header);
            var titles = header.getElementsByClassName("fixed-table-th-inner");
            var marginString = "-" + target.scrollLeft + "px";
            for (var i = 0; i < titles.length; i++) {
                titles[i].style.marginLeft = marginString;
            }
        };
        ListComponent.prototype.makeInitialSortingOrder = function (columns, initialColumn) {
            var initialSortOrder = this.props.initialSortOrder;
            if (!initialSortOrder || initialSortOrder.length < 1) {
                initialSortOrder = [initialColumn];
            }
            var order = initialSortOrder;
            for (var i = 0; i < columns.length; i++) {
                if (initialSortOrder.indexOf(columns[i]) < 0) {
                    order.push(columns[i]);
                }
            }
            return order;
        };
        ListComponent.prototype.getNewSortingOrder = function (newColumn) {
            var order = this.state.columnSortingOrder.slice(0);
            var current = order.indexOf(newColumn);
            if (current >= 0) {
                order.splice(current);
            }
            order.unshift(newColumn);
            return order;
        };
        ListComponent.reverseListOrder = function (order) {
            if (order === "asc") {
                return "desc";
            }
            else if (order === "desc") {
                return "asc";
            }
            else {
                throw new Error("Invalid list order: " + order);
            }
        };
        ListComponent.prototype.getSortingOrderForColumnKeyWithColumnReversed = function (columnToReverse) {
            var copied = utility_27.shallowCopy(this.state.sortingOrderForColumnKey);
            copied[columnToReverse.key] = ListComponent.reverseListOrder(copied[columnToReverse.key]);
            return copied;
        };
        ListComponent.prototype.handleSelectColumn = function (column) {
            if (column.notSortable) {
                return;
            }
            var stateObj = {
                selectedColumn: column,
                columnSortingOrder: this.getNewSortingOrder(column),
            };
            if (this.state.selectedColumn.key === column.key) {
                stateObj.sortingOrderForColumnKey = this.getSortingOrderForColumnKeyWithColumnReversed(column);
            }
            this.setState(stateObj);
        };
        ListComponent.prototype.handleSelectRow = function (row) {
            if (this.props.onRowChange && row) {
                this.props.onRowChange.call(null, row);
            }
            this.setState({
                selected: row,
            });
        };
        ListComponent.prototype.getSortedItems = function () {
            var _this = this;
            var sortingFunctions = {};
            function makeSortingFunction(column) {
                if (column.sortingFunction) {
                    return column.sortingFunction;
                }
                else {
                    return (function (a, b) {
                        var a1;
                        var b1;
                        if (column.propToSortBy) {
                            a1 = a.content.props[column.propToSortBy];
                            b1 = b.content.props[column.propToSortBy];
                        }
                        else {
                            a1 = a.key;
                            b1 = b.key;
                        }
                        if (a1 > b1)
                            return 1;
                        else if (a1 < b1)
                            return -1;
                        else
                            return 0;
                    });
                }
            }
            function getSortingFunction(column) {
                if (!sortingFunctions[column.key]) {
                    sortingFunctions[column.key] = makeSortingFunction(column);
                }
                return sortingFunctions[column.key];
            }
            var sortedItems = this.props.listItems.slice(0).sort(function (a, b) {
                for (var i = 0; i < _this.state.columnSortingOrder.length; i++) {
                    var columnToSortBy = _this.state.columnSortingOrder[i];
                    var sortingFunction = getSortingFunction(columnToSortBy);
                    var sortingResult = sortingFunction(a, b);
                    if (sortingResult) {
                        if (_this.state.sortingOrderForColumnKey[columnToSortBy.key] === "desc") {
                            return -1 * sortingResult;
                        }
                        else {
                            return sortingResult;
                        }
                    }
                }
                var keySortingResult = a.key > b.key ? 1 : -1;
                if (_this.state.sortingOrderForColumnKey[_this.state.selectedColumn.key] === "desc") {
                    return -1 * keySortingResult;
                }
                else {
                    return keySortingResult;
                }
            });
            return sortedItems;
        };
        ListComponent.prototype.shiftSelection = function (amountToShift) {
            var reverseIndexes = {};
            for (var i = 0; i < this.sortedItems.length; i++) {
                reverseIndexes[this.sortedItems[i].key] = i;
            }
            ;
            var currSelectedIndex = reverseIndexes[this.state.selected.key];
            var nextIndex = (currSelectedIndex + amountToShift) % this.sortedItems.length;
            if (nextIndex < 0) {
                nextIndex += this.sortedItems.length;
            }
            this.handleSelectRow(this.sortedItems[nextIndex]);
        };
        ListComponent.prototype.render = function () {
            var _this = this;
            var columns = [];
            var headerLabels = [];
            this.state.columns.forEach(function (column) {
                var colProps = {
                    key: column.key,
                };
                if (_this.props.colStylingFN) {
                    colProps = _this.props.colStylingFN(column, colProps);
                }
                columns.push(React.DOM.col(colProps));
                var sortStatus = "";
                if (!column.notSortable) {
                    sortStatus = " sortable";
                }
                if (_this.state.selectedColumn.key === column.key) {
                    sortStatus += " sorted-" + _this.state.sortingOrderForColumnKey[column.key];
                }
                else if (!column.notSortable) {
                    sortStatus += " unsorted";
                }
                headerLabels.push(React.DOM.th({
                    key: column.key,
                }, React.DOM.div({
                    className: "fixed-table-th-inner",
                }, React.DOM.div({
                    className: "fixed-table-th-content" + sortStatus,
                    title: column.title || colProps.title || null,
                    onMouseDown: _this.handleSelectColumn.bind(null, column),
                    onTouchStart: _this.handleSelectColumn.bind(null, column),
                }, column.label))));
            });
            this.sortedItems = this.getSortedItems();
            var rows = [];
            this.sortedItems.forEach(function (item, i) {
                rows.push(React.cloneElement(item.content, {
                    key: item.key,
                    activeColumns: _this.state.columns,
                    handleClick: _this.handleSelectRow.bind(null, item),
                }));
                if (_this.props.addSpacer && i < _this.sortedItems.length - 1) {
                    rows.push(React.DOM.tr({
                        className: "list-spacer",
                        key: "spacer" + i,
                    }, React.DOM.td({
                        colSpan: 20,
                    }, null)));
                }
            });
            return (React.DOM.div({
                className: "fixed-table-container" + (this.props.noHeader ? " no-header" : ""),
                tabIndex: isFinite(this.props.tabIndex) ? this.props.tabIndex : 1,
            }, React.DOM.div({ className: "fixed-table-header-background" }), React.DOM.div({
                className: "fixed-table-container-inner",
                ref: function (component) {
                    _this.ref_TODO_inner = component;
                },
                onScroll: this.handleScroll,
            }, React.DOM.table({
                className: "react-list",
            }, React.DOM.colgroup(null, columns), React.DOM.thead({ className: "fixed-table-actual-header", ref: function (component) {
                    _this.ref_TODO_header = component;
                } }, React.DOM.tr(null, headerLabels)), React.DOM.thead({ className: "fixed-table-hidden-header" }, React.DOM.tr(null, headerLabels)), React.DOM.tbody(null, rows)))));
        };
        return ListComponent;
    }(React.Component));
    exports.ListComponent = ListComponent;
    var Factory = React.createFactory(ListComponent);
    exports.default = Factory;
});
define("src/uicomponents/unitlist/ItemListItem", ["require", "exports", "react", "src/uicomponents/mixins/DragPositioner", "src/uicomponents/mixins/applyMixins"], function (require, exports, React, DragPositioner_2, applyMixins_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ItemListItemComponent = (function (_super) {
        __extends(ItemListItemComponent, _super);
        function ItemListItemComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "ItemListItem";
            _this.bindMethods();
            if (_this.props.isDraggable) {
                _this.dragPositioner = new DragPositioner_2.default(_this, _this.props.dragPositionerProps);
                _this.dragPositioner.onDragStart = _this.onDragStart;
                _this.dragPositioner.onDragEnd = _this.onDragEnd;
                _this.dragPositioner.makeDragClone = _this.makeDragClone;
                applyMixins_2.default(_this, _this.dragPositioner);
            }
            return _this;
        }
        ItemListItemComponent.prototype.bindMethods = function () {
            this.makeCell = this.makeCell.bind(this);
            this.onDragEnd = this.onDragEnd.bind(this);
            this.onDragStart = this.onDragStart.bind(this);
            this.makeDragClone = this.makeDragClone.bind(this);
        };
        ItemListItemComponent.prototype.onDragStart = function () {
            console.log("onDragStart", this.props.item.template.displayName);
            this.props.onDragStart(this.props.item);
        };
        ItemListItemComponent.prototype.onDragEnd = function () {
            this.props.onDragEnd();
        };
        ItemListItemComponent.prototype.makeCell = function (type) {
            var cellProps = {};
            cellProps.key = type;
            cellProps.className = "item-list-item-cell" + " item-list-" + type;
            var cellContent;
            switch (type) {
                case "ability":
                    {
                        if (this.props.ability) {
                            cellProps.title = this.props.ability.description;
                            if (this.props.abilityIsPassive) {
                                cellProps.className += " passive-skill";
                            }
                            cellContent = this.props.ability.displayName;
                        }
                        break;
                    }
                default:
                    {
                        cellContent = this.props[type];
                        if (isFinite(cellContent)) {
                            cellProps.className += " center-text";
                        }
                        break;
                    }
            }
            return (React.DOM.td(cellProps, cellContent));
        };
        ItemListItemComponent.prototype.makeDragClone = function () {
            var clone = new Image();
            clone.src = this.props.item.template.icon;
            clone.className = "item-icon-base draggable dragging";
            return clone;
        };
        ItemListItemComponent.prototype.render = function () {
            var columns = this.props.activeColumns;
            var cells = [];
            for (var i = 0; i < columns.length; i++) {
                var cell = this.makeCell(columns[i].key);
                cells.push(cell);
            }
            var rowProps = {
                className: "item-list-item",
                onClick: this.props.handleClick,
                key: this.props.keyTODO,
            };
            if (this.dragPositioner) {
                rowProps.className += " draggable";
                rowProps.onTouchStart = rowProps.onMouseDown =
                    this.dragPositioner.handleReactDownEvent;
            }
            if (this.props.isReserved) {
                rowProps.className += " reserved-item";
            }
            return (React.DOM.tr(rowProps, cells));
        };
        return ItemListItemComponent;
    }(React.Component));
    exports.ItemListItemComponent = ItemListItemComponent;
    var Factory = React.createFactory(ItemListItemComponent);
    exports.default = Factory;
});
define("src/uicomponents/unitlist/ItemList", ["require", "exports", "react", "src/uicomponents/list/List", "src/uicomponents/unitlist/ItemListItem", "localization/localize"], function (require, exports, React, List_1, ItemListItem_1, localize_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ItemListComponent = (function (_super) {
        __extends(ItemListComponent, _super);
        function ItemListComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "ItemList";
            _this.bindMethods();
            return _this;
        }
        ItemListComponent.prototype.getSlotIndex = function (slot) {
            if (slot === "high") {
                return 2;
            }
            else if (slot === "mid") {
                return 1;
            }
            else
                return 0;
        };
        ItemListComponent.prototype.bindMethods = function () {
            this.getSlotIndex = this.getSlotIndex.bind(this);
        };
        ItemListComponent.prototype.render = function () {
            var rows = [];
            var items = this.props.items;
            for (var i = 0; i < items.length; i++) {
                var item = items[i];
                var ability = null;
                var abilityIsPassive = false;
                if (item.template.ability) {
                    ability = item.template.ability;
                }
                else if (item.template.passiveSkill) {
                    ability = item.template.passiveSkill;
                    abilityIsPassive = true;
                }
                var props = {
                    typeName: item.template.displayName,
                    slot: item.template.slot,
                    unitName: item.unit ? item.unit.name : "",
                    item: item,
                    key: item.id,
                    keyTODO: item.id,
                    id: item.id,
                    slotIndex: this.getSlotIndex(item.template.slot),
                    unit: item.unit ? item.unit : null,
                    techLevel: item.template.techLevel,
                    cost: item.template.buildCost,
                    ability: ability,
                    abilityIsPassive: abilityIsPassive,
                    isReserved: Boolean(item.unit),
                    dragPositionerProps: {
                        shouldMakeClone: true,
                        forcedDragOffset: { x: 32, y: 32 },
                    },
                    isDraggable: this.props.isDraggable,
                    onDragStart: this.props.onDragStart,
                    onDragEnd: this.props.onDragEnd,
                };
                rows.push({
                    key: "" + item.id,
                    content: ItemListItem_1.default(props),
                });
            }
            var columns = [
                {
                    label: localize_7.localize("type"),
                    key: "typeName",
                    defaultOrder: "asc",
                },
                {
                    label: localize_7.localize("slot"),
                    key: "slot",
                    propToSortBy: "slotIndex",
                    defaultOrder: "desc",
                },
                {
                    label: localize_7.localize("unit"),
                    key: "unitName",
                    defaultOrder: "desc",
                },
                {
                    label: localize_7.localize("ability"),
                    key: "ability",
                    defaultOrder: "desc",
                },
            ];
            return (React.DOM.div({ className: "item-list fixed-table-parent" }, List_1.default({
                listItems: rows,
                initialColumns: columns,
                initialSortOrder: [columns[1], columns[2]],
                onRowChange: this.props.onRowChange,
                tabIndex: 2,
                keyboardSelect: true,
            })));
        };
        return ItemListComponent;
    }(React.Component));
    exports.ItemListComponent = ItemListComponent;
    var Factory = React.createFactory(ItemListComponent);
    exports.default = Factory;
});
define("src/uicomponents/unitlist/AbilityList", ["require", "exports", "react"], function (require, exports, React) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbilityListComponent = (function (_super) {
        __extends(AbilityListComponent, _super);
        function AbilityListComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "AbilityList";
            return _this;
        }
        AbilityListComponent.prototype.render = function () {
            var abilities = this.props.abilities;
            if (abilities.length < 1) {
                return null;
            }
            var abilityElements = [];
            var addedAbilityTypes = {};
            abilities.sort(function (_a, _b) {
                if (_a.mainEffect && !_b.mainEffect)
                    return -1;
                else if (_b.mainEffect && !_a.mainEffect)
                    return 1;
                if (_a.type === "learnable")
                    return 1;
                else if (_b.type === "learnable")
                    return -1;
                var a = _a.displayName.toLowerCase();
                var b = _b.displayName.toLowerCase();
                if (a > b)
                    return 1;
                else if (a < b)
                    return -1;
                else
                    return 0;
            });
            for (var i = 0; i < abilities.length; i++) {
                var ability = abilities[i];
                if (ability.isHidden) {
                    continue;
                }
                if (!addedAbilityTypes[ability.type]) {
                    addedAbilityTypes[ability.type] = 0;
                }
                var className = "unit-info-ability";
                var isLearnable = ability.type === "learnable";
                if (isLearnable) {
                    className += " learnable-ability";
                }
                else {
                    var isPassiveSkill = !ability.mainEffect;
                    if (isPassiveSkill) {
                        className += " passive-skill";
                    }
                    else {
                        className += " active-skill";
                    }
                    if (addedAbilityTypes[ability.type] >= 1) {
                        className += " redundant-ability";
                    }
                }
                abilityElements.push(React.DOM.li({
                    className: className,
                    title: ability.description,
                    key: ability.type + addedAbilityTypes[ability.type],
                    onClick: (this.props.handleClick ? this.props.handleClick.bind(null, ability) : undefined),
                }, "[" + ability.displayName + "]"));
                addedAbilityTypes[ability.type]++;
            }
            return (React.DOM.ul({
                className: "ability-list",
            }, abilityElements));
        };
        return AbilityListComponent;
    }(React.Component));
    exports.AbilityListComponent = AbilityListComponent;
    var Factory = React.createFactory(AbilityListComponent);
    exports.default = Factory;
});
define("src/Direction", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("src/uicomponents/windows/WindowResizeHandle", ["require", "exports", "react", "src/uicomponents/mixins/DragPositioner", "src/uicomponents/mixins/applyMixins"], function (require, exports, React, DragPositioner_3, applyMixins_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var WindowResizeHandleComponent = (function (_super) {
        __extends(WindowResizeHandleComponent, _super);
        function WindowResizeHandleComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "WindowResizeHandle";
            _this.bindMethods();
            switch (_this.props.direction) {
                case "n":
                case "s":
                    {
                        _this.directionRestriction = "vertical";
                        break;
                    }
                case "e":
                case "w":
                    {
                        _this.directionRestriction = "horizontal";
                        break;
                    }
                case "ne":
                case "se":
                case "sw":
                case "nw":
                    {
                        _this.directionRestriction = "free";
                        break;
                    }
                default:
                    {
                        throw new Error("Invalid window resize handle direction '" + _this.props.direction + "'");
                    }
            }
            _this.dragPositioner = new DragPositioner_3.default(_this);
            _this.dragPositioner.onDragMove = _this.onDragMove;
            _this.dragPositioner.onDragStart = _this.onDragStart;
            _this.dragPositioner.forcedDragOffset = { x: 0, y: 0 };
            applyMixins_3.default(_this, _this.dragPositioner);
            return _this;
        }
        WindowResizeHandleComponent.prototype.render = function () {
            return (React.DOM.div({
                className: "window-resize-handle" + (" window-resize-handle-" + this.props.direction),
                onTouchStart: this.dragPositioner.handleReactDownEvent,
                onMouseDown: this.dragPositioner.handleReactDownEvent,
            }));
        };
        WindowResizeHandleComponent.prototype.onDragStart = function (x, y) {
            this.props.handleResizeStart(x, y);
        };
        WindowResizeHandleComponent.prototype.onDragMove = function (x, y) {
            var deltaX = x - this.dragPositioner.originPosition.x;
            var deltaY = y - this.dragPositioner.originPosition.y;
            this.props.handleResizeMove(this.directionRestriction === "vertical" ? 0 : deltaX, this.directionRestriction === "horizontal" ? 0 : deltaY);
        };
        WindowResizeHandleComponent.prototype.bindMethods = function () {
            this.onDragStart = this.onDragStart.bind(this);
            this.onDragMove = this.onDragMove.bind(this);
        };
        return WindowResizeHandleComponent;
    }(React.Component));
    exports.WindowResizeHandleComponent = WindowResizeHandleComponent;
    var Factory = React.createFactory(WindowResizeHandleComponent);
    exports.default = Factory;
});
define("src/uicomponents/windows/windowManager", ["require", "exports", "src/IdDictionary"], function (require, exports, IdDictionary_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var baseZIndex = 10000;
    var windowCascadeMargin = 20;
    var zIndex = baseZIndex;
    function getNewZIndex(component) {
        if (component.state && component.state.zIndex && component.state.zIndex === zIndex) {
            return zIndex;
        }
        else {
            return zIndex++;
        }
    }
    exports.getNewZIndex = getNewZIndex;
    var byId = new IdDictionary_3.IdDictionary();
    function getDefaultInitialPosition(rect, container) {
        var windowsByZIndex = byId.sort(function (a, b) {
            return b.state.zIndex - a.state.zIndex;
        });
        if (windowsByZIndex.length === 0) {
            return ({
                left: container.offsetWidth / 2.5 - rect.width / 2,
                top: container.offsetHeight / 2.5 - rect.height / 2,
                width: rect.width,
                height: rect.height,
            });
        }
        else {
            var topMostWindowPosition = windowsByZIndex[0].dragPositioner.position;
            return ({
                left: topMostWindowPosition.left + windowCascadeMargin,
                top: topMostWindowPosition.top + windowCascadeMargin,
                width: rect.width,
                height: rect.height,
            });
        }
    }
    exports.getDefaultInitialPosition = getDefaultInitialPosition;
    function handleMount(component) {
        if (byId.has(component)) {
            throw new Error("Duplicate window id " + component.id + " in window " + component);
        }
        byId.set(component, component);
    }
    exports.handleMount = handleMount;
    function handleUnount(component) {
        byId.delete(component);
    }
    exports.handleUnount = handleUnount;
});
define("src/uicomponents/windows/WindowContainer", ["require", "exports", "react", "react-dom", "src/uicomponents/windows/WindowResizeHandle", "src/uicomponents/windows/windowManager", "src/utility", "src/uicomponents/mixins/DragPositioner", "src/uicomponents/mixins/applyMixins"], function (require, exports, React, ReactDOM, WindowResizeHandle_1, windowManager, utility_28, DragPositioner_4, applyMixins_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var id = 0;
    var WindowContainerComponent = (function (_super) {
        __extends(WindowContainerComponent, _super);
        function WindowContainerComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "WindowContainer";
            _this.resizeStartPosition = {
                top: undefined,
                left: undefined,
                width: undefined,
                height: undefined,
            };
            _this.id = id++;
            _this.bindMethods();
            _this.state =
                {
                    zIndex: windowManager.getNewZIndex(_this),
                };
            _this.dragPositioner = new DragPositioner_4.default(_this, {
                preventAutoResize: true,
                startOnHandleElementOnly: true,
            });
            applyMixins_4.default(_this, _this.dragPositioner);
            return _this;
        }
        WindowContainerComponent.prototype.componentDidMount = function () {
            this.setInitialPosition();
            windowManager.handleMount(this);
        };
        WindowContainerComponent.prototype.componentWillUnmount = function () {
            windowManager.handleUnount(this);
        };
        WindowContainerComponent.prototype.render = function () {
            var customAttributes = {};
            var defaultAttributes = {
                className: "window-container",
                style: {
                    top: this.dragPositioner.position.top,
                    left: this.dragPositioner.position.left,
                    width: this.dragPositioner.position.width,
                    height: this.dragPositioner.position.height,
                    zIndex: this.state.zIndex,
                    minWidth: this.props.minWidth,
                    minHeight: this.props.minHeight,
                    maxWidth: this.props.maxWidth,
                    maxHeight: this.props.maxHeight,
                },
            };
            var attributes = utility_28.shallowExtend(customAttributes, defaultAttributes);
            return (React.DOM.div(attributes, this.props.children, !this.props.isResizable ? null : this.makeResizeHandles()));
        };
        WindowContainerComponent.prototype.getPosition = function () {
            return utility_28.shallowCopy(this.dragPositioner.position);
        };
        WindowContainerComponent.prototype.onMouseDown = function (e) {
            this.dragPositioner.handleReactDownEvent(e);
            this.setState({
                zIndex: windowManager.getNewZIndex(this),
            });
        };
        WindowContainerComponent.prototype.bindMethods = function () {
            this.onMouseDown = this.onMouseDown.bind(this);
            this.handleResizeMove = this.handleResizeMove.bind(this);
            this.handleResizeStart = this.handleResizeStart.bind(this);
            this.setInitialPosition = this.setInitialPosition.bind(this);
            this.makeResizeHandles = this.makeResizeHandles.bind(this);
        };
        WindowContainerComponent.prototype.setInitialPosition = function () {
            var initialRect = ReactDOM.findDOMNode(this).getBoundingClientRect();
            var position = {
                top: initialRect.top,
                left: initialRect.left,
                width: initialRect.width,
                height: initialRect.height,
            };
            var container = this.props.containerElement;
            var requestedPosition = this.props.getInitialPosition ?
                this.props.getInitialPosition(position, container) :
                windowManager.getDefaultInitialPosition(position, container);
            var maxWidth = Math.min(this.props.maxWidth, container.offsetWidth);
            var maxHeight = Math.min(this.props.maxHeight, container.offsetHeight);
            position.width = utility_28.clamp(requestedPosition.width, this.props.minWidth, maxWidth);
            position.height = utility_28.clamp(requestedPosition.height, this.props.minHeight, maxHeight);
            position.left = utility_28.clamp(requestedPosition.left, 0, container.offsetWidth - position.width);
            position.top = utility_28.clamp(requestedPosition.top, 0, container.offsetHeight - position.height);
            this.dragPositioner.position = position;
            this.dragPositioner.updateDOMNodeStyle();
        };
        WindowContainerComponent.prototype.handleResizeMove = function (rawDeltaX, rawDeltaY) {
            var minWidth = this.props.minWidth || 0;
            var maxWidth = this.props.maxWidth || window.innerWidth;
            var minHeight = this.props.minHeight || 0;
            var maxHeight = this.props.maxHeight || window.innerHeight;
            if (this.resizeStartQuadrant.left) {
                var deltaX = utility_28.clamp(rawDeltaX, this.resizeStartPosition.width - maxWidth, this.resizeStartPosition.width - minWidth);
                this.dragPositioner.position.width = this.resizeStartPosition.width - deltaX;
                this.dragPositioner.position.left = this.resizeStartPosition.left + deltaX;
            }
            else {
                var deltaX = rawDeltaX;
                this.dragPositioner.position.width = this.resizeStartPosition.width + deltaX;
                this.dragPositioner.position.width = utility_28.clamp(this.dragPositioner.position.width, minWidth, maxWidth);
            }
            if (this.resizeStartQuadrant.top) {
                var deltaY = utility_28.clamp(rawDeltaY, this.resizeStartPosition.height - maxHeight, this.resizeStartPosition.height - minHeight);
                this.dragPositioner.position.top = this.resizeStartPosition.top + deltaY;
                this.dragPositioner.position.height = this.resizeStartPosition.height - deltaY;
            }
            else {
                var deltaY = rawDeltaY;
                this.dragPositioner.position.height = this.resizeStartPosition.height + deltaY;
                this.dragPositioner.position.height = utility_28.clamp(this.dragPositioner.position.height, minHeight, maxHeight);
            }
            this.dragPositioner.updateDOMNodeStyle();
        };
        WindowContainerComponent.prototype.handleResizeStart = function (x, y) {
            var rect = ReactDOM.findDOMNode(this).getBoundingClientRect();
            var midX = rect.left + rect.width / 2;
            var midY = rect.top + rect.height / 2;
            this.resizeStartPosition = utility_28.shallowCopy(this.dragPositioner.position);
            this.resizeStartQuadrant =
                {
                    left: x < midX,
                    top: y < midY,
                };
        };
        WindowContainerComponent.prototype.makeResizeHandles = function (directions) {
            var _this = this;
            if (directions === void 0) { directions = "all"; }
            var directionsToCreate = directions === "all" ?
                ["n", "e", "w", "s", "ne", "se", "sw", "nw"] :
                directions.slice(0);
            return directionsToCreate.map(function (direction) {
                return WindowResizeHandle_1.default({
                    handleResizeMove: _this.handleResizeMove,
                    handleResizeStart: _this.handleResizeStart,
                    direction: direction,
                    key: direction,
                });
            });
        };
        return WindowContainerComponent;
    }(React.Component));
    exports.WindowContainerComponent = WindowContainerComponent;
    var Factory = React.createFactory(WindowContainerComponent);
    exports.default = Factory;
});
define("src/uicomponents/windows/DefaultWindow", ["require", "exports", "react", "src/uicomponents/windows/WindowContainer"], function (require, exports, React, WindowContainer_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DefaultWindowComponent = (function (_super) {
        __extends(DefaultWindowComponent, _super);
        function DefaultWindowComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "DefaultWindow";
            _this.handleTitleBarMouseDown = _this.handleTitleBarMouseDown.bind(_this);
            return _this;
        }
        DefaultWindowComponent.prototype.render = function () {
            var _this = this;
            return (WindowContainer_1.default({
                isResizable: this.props.isResizable === false ? false : true,
                containerElement: document.body,
                minWidth: this.props.minWidth,
                minHeight: this.props.minHeight,
                maxWidth: this.props.maxWidth || Infinity,
                maxHeight: this.props.maxHeight || Infinity,
                ref: function (component) {
                    _this.windowContainerComponent = component;
                },
            }, React.DOM.div({
                className: "window",
            }, React.DOM.div({
                className: "window-title-bar draggable",
                onMouseDown: this.handleTitleBarMouseDown,
                onTouchStart: this.handleTitleBarMouseDown,
            }, React.DOM.div({
                className: "window-title",
            }, this.props.title), React.DOM.button({
                className: "window-close-button",
                onClick: this.props.handleClose,
            })), React.DOM.div({
                className: "window-content",
            }, this.props.children))));
        };
        DefaultWindowComponent.prototype.handleTitleBarMouseDown = function (e) {
            this.windowContainerComponent.onMouseDown(e);
        };
        return DefaultWindowComponent;
    }(React.Component));
    exports.DefaultWindowComponent = DefaultWindowComponent;
    var Factory = React.createFactory(DefaultWindowComponent);
    exports.default = Factory;
});
define("src/uicomponents/unitlist/UpgradeAbilities", ["require", "exports", "react", "src/uicomponents/unitlist/AbilityList", "localization/localize"], function (require, exports, React, AbilityList_1, localize_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var UpgradeAbilitiesComponent = (function (_super) {
        __extends(UpgradeAbilitiesComponent, _super);
        function UpgradeAbilitiesComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "UpgradeAbilities";
            return _this;
        }
        UpgradeAbilitiesComponent.prototype.render = function () {
            if (this.props.abilities.length === 0) {
                return null;
            }
            var headerText;
            if (this.props.learningNewability) {
                headerText = localize_8.localize("learnAbility");
            }
            else {
                headerText = localize_8.localize("upgradeAbility");
                if (this.props.sourceAbility) {
                    headerText += " " + this.props.sourceAbility.displayName;
                }
            }
            return (React.DOM.div({
                className: "upgrade-abilities",
            }, React.DOM.div({
                className: "upgrade-abilities-header",
            }, headerText), AbilityList_1.default({
                abilities: this.props.abilities,
                handleClick: this.props.handleClick,
            })));
        };
        return UpgradeAbilitiesComponent;
    }(React.Component));
    exports.UpgradeAbilitiesComponent = UpgradeAbilitiesComponent;
    var Factory = React.createFactory(UpgradeAbilitiesComponent);
    exports.default = Factory;
});
define("src/uicomponents/unitlist/UpgradeAttributes", ["require", "exports", "react", "localization/localize"], function (require, exports, React, localize_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var UpgradeAttributesComponent = (function (_super) {
        __extends(UpgradeAttributesComponent, _super);
        function UpgradeAttributesComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "UpgradeAttributes";
            _this.bindMethods();
            return _this;
        }
        UpgradeAttributesComponent.prototype.upgradeAttribute = function (attribute, e) {
            if (e.button)
                return;
            this.props.handleClick(attribute);
        };
        UpgradeAttributesComponent.prototype.bindMethods = function () {
            this.upgradeAttribute = this.upgradeAttribute.bind(this);
        };
        UpgradeAttributesComponent.prototype.render = function () {
            var _this = this;
            var unit = this.props.unit;
            var rows = [];
            var attributes = unit.baseAttributes.getAttributesTypesSortedForDisplay();
            attributes.forEach(function (attribute) {
                var maxAttribute = attribute === "maxActionPoints" ? 6 : 9;
                if (unit.baseAttributes[attribute] < maxAttribute) {
                    rows.push(React.DOM.li({
                        className: "upgrade-attributes-attribute",
                        onClick: _this.upgradeAttribute.bind(_this, attribute),
                        key: attribute,
                    }, localize_9.localizeF("upgradeAttribute").format({
                        attribute: localize_9.localize(attribute),
                        currentLevel: unit.baseAttributes[attribute],
                        nextLevel: unit.baseAttributes[attribute] + 1,
                    })));
                }
            });
            if (rows.length === 0) {
                return null;
            }
            return (React.DOM.div({
                className: "upgrade-attributes",
            }, React.DOM.div({
                className: "upgrade-attributes-header",
            }, localize_9.localize("upgradeStats")), React.DOM.ol({
                className: "upgrade-attributes-list",
            }, rows)));
        };
        return UpgradeAttributesComponent;
    }(React.Component));
    exports.UpgradeAttributesComponent = UpgradeAttributesComponent;
    var Factory = React.createFactory(UpgradeAttributesComponent);
    exports.default = Factory;
});
define("src/uicomponents/unitlist/UpgradeUnit", ["require", "exports", "react", "src/uicomponents/windows/DefaultWindow", "src/uicomponents/unitlist/UpgradeAbilities", "src/uicomponents/unitlist/UpgradeAttributes", "localization/localize"], function (require, exports, React, DefaultWindow_1, UpgradeAbilities_1, UpgradeAttributes_1, localize_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var UpgradeUnitComponent = (function (_super) {
        __extends(UpgradeUnitComponent, _super);
        function UpgradeUnitComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "UpgradeUnit";
            _this.state =
                {
                    currentlyUpgradingAbility: null,
                    upgradeData: _this.props.unit.getAbilityUpgradeData(),
                };
            _this.bindMethods();
            return _this;
        }
        UpgradeUnitComponent.prototype.render = function () {
            var unit = this.props.unit;
            var upgradableAbilities = [];
            for (var source in this.state.upgradeData) {
                if (this.state.upgradeData[source].base) {
                    upgradableAbilities.push(this.state.upgradeData[source].base);
                }
                else {
                    upgradableAbilities.push({
                        type: source,
                        displayName: localize_10.localize("newAbility"),
                        description: "",
                    });
                }
            }
            var activeUpgradeData = !this.state.currentlyUpgradingAbility ?
                null :
                this.state.upgradeData[this.state.currentlyUpgradingAbility.type];
            return (React.DOM.div({
                className: "upgrade-unit",
            }, !this.state.currentlyUpgradingAbility ? null :
                DefaultWindow_1.default({
                    title: localize_10.localize("upgradeAbility"),
                    handleClose: this.closeAbilityUpgradePopup,
                    isResizable: false,
                    minWidth: 150,
                    minHeight: 150,
                }, UpgradeAbilities_1.default({
                    abilities: activeUpgradeData.possibleUpgrades,
                    handleClick: this.upgradeAbility.bind(this, activeUpgradeData.base),
                    sourceAbility: activeUpgradeData.base,
                    learningNewability: !Boolean(activeUpgradeData.base),
                })), React.DOM.div({
                className: "upgrade-unit-header",
            }, localize_10.localizeF("unitUpgradeHeader").format({
                unitName: unit.name,
                currentLevel: unit.level,
                nextLevel: unit.level + 1,
            })), UpgradeAbilities_1.default({
                abilities: upgradableAbilities,
                handleClick: this.makeAbilityLearnPopup,
            }), UpgradeAttributes_1.default({
                unit: unit,
                handleClick: this.upgradeAttribute,
            })));
        };
        UpgradeUnitComponent.prototype.bindMethods = function () {
            this.upgradeAttribute = this.upgradeAttribute.bind(this);
            this.upgradeAbility = this.upgradeAbility.bind(this);
            this.makeAbilityLearnPopup = this.makeAbilityLearnPopup.bind(this);
            this.closeAbilityUpgradePopup = this.closeAbilityUpgradePopup.bind(this);
        };
        UpgradeUnitComponent.prototype.upgradeAbility = function (source, newAbility) {
            var unit = this.props.unit;
            unit.upgradeAbility(source, newAbility);
            unit.handleLevelUp();
            this.setState({
                upgradeData: unit.getAbilityUpgradeData(),
            });
            this.closeAbilityUpgradePopup();
            this.props.onUnitUpgrade();
        };
        UpgradeUnitComponent.prototype.upgradeAttribute = function (attribute) {
            var unit = this.props.unit;
            unit.baseAttributes[attribute] += 1;
            unit.attributesAreDirty = true;
            unit.handleLevelUp();
            this.props.onUnitUpgrade();
        };
        UpgradeUnitComponent.prototype.makeAbilityLearnPopup = function (ability) {
            this.setState({ currentlyUpgradingAbility: ability });
        };
        UpgradeUnitComponent.prototype.closeAbilityUpgradePopup = function () {
            this.setState({ currentlyUpgradingAbility: null });
        };
        return UpgradeUnitComponent;
    }(React.Component));
    exports.UpgradeUnitComponent = UpgradeUnitComponent;
    var Factory = React.createFactory(UpgradeUnitComponent);
    exports.default = Factory;
});
define("src/uicomponents/unitlist/UnitExperience", ["require", "exports", "react", "src/uicomponents/windows/DefaultWindow", "src/uicomponents/unitlist/UpgradeUnit", "localization/localize"], function (require, exports, React, DefaultWindow_2, UpgradeUnit_1, localize_11) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var UnitExperienceComponent = (function (_super) {
        __extends(UnitExperienceComponent, _super);
        function UnitExperienceComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "UnitExperience";
            _this.state =
                {
                    hasUpgradePopup: false,
                };
            _this.bindMethods();
            return _this;
        }
        UnitExperienceComponent.prototype.render = function () {
            var rows = [];
            var totalBars = Math.ceil(this.props.experienceToNextLevel) / 10;
            var filledBars = Math.ceil(this.props.experienceForCurrentLevel / 10);
            var lastBarWidth = (10 * (this.props.experienceForCurrentLevel % 10));
            for (var i = 0; i < totalBars; i++) {
                var bgProps = {
                    className: "unit-experience-bar-point-background",
                };
                if (i < filledBars) {
                    bgProps.className += " filled";
                    if (i === filledBars - 1 && lastBarWidth !== 0) {
                        bgProps.style =
                            {
                                width: "" + lastBarWidth + "%",
                            };
                    }
                }
                else {
                    bgProps.className += " empty";
                }
                rows.push(React.DOM.div({
                    className: "unit-experience-bar-point",
                    key: "" + i,
                }, React.DOM.div(bgProps, null)));
            }
            var isReadyToLevelUp = this.props.experienceForCurrentLevel >= this.props.experienceToNextLevel;
            var containerProps = {
                className: "unit-experience-bar-container",
            };
            var barProps = {
                className: "unit-experience-bar",
                title: localize_11.localizeF("EXPReadOut").format({
                    currentEXP: this.props.experienceForCurrentLevel,
                    EXPToNextLevel: this.props.experienceToNextLevel,
                }),
            };
            if (isReadyToLevelUp) {
                containerProps.onClick = this.openPopup;
                containerProps.className += " ready-to-level-up";
            }
            return (React.DOM.div({
                className: "unit-experience-wrapper",
            }, !this.state.hasUpgradePopup ? null :
                DefaultWindow_2.default({
                    title: localize_11.localize("upgradeUnit"),
                    handleClose: this.closePopup,
                    isResizable: false,
                    minWidth: 150,
                    minHeight: 150,
                }, UpgradeUnit_1.default({
                    unit: this.props.unit,
                    onUnitUpgrade: this.handleUnitUpgrade,
                })), React.DOM.div(containerProps, React.DOM.div(barProps, rows), !isReadyToLevelUp ? null : React.DOM.span({
                className: "ready-to-level-up-message",
            }, localize_11.localize("clickToLevelUp")))));
        };
        UnitExperienceComponent.prototype.bindMethods = function () {
            this.openPopup = this.openPopup.bind(this);
            this.closePopup = this.closePopup.bind(this);
            this.handleUnitUpgrade = this.handleUnitUpgrade.bind(this);
        };
        UnitExperienceComponent.prototype.openPopup = function () {
            this.setState({ hasUpgradePopup: true });
        };
        UnitExperienceComponent.prototype.closePopup = function () {
            this.setState({ hasUpgradePopup: false });
        };
        UnitExperienceComponent.prototype.handleUnitUpgrade = function () {
            if (this.props.unit.canLevelUp()) {
                this.props.onUnitUpgrade();
            }
            else {
                this.closePopup();
            }
        };
        return UnitExperienceComponent;
    }(React.Component));
    exports.UnitExperienceComponent = UnitExperienceComponent;
    var Factory = React.createFactory(UnitExperienceComponent);
    exports.default = Factory;
});
define("src/uicomponents/unitlist/UnitItem", ["require", "exports", "react", "src/uicomponents/mixins/DragPositioner", "src/uicomponents/mixins/applyMixins", "localization/localize"], function (require, exports, React, DragPositioner_5, applyMixins_5, localize_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var UnitItemComponent = (function (_super) {
        __extends(UnitItemComponent, _super);
        function UnitItemComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "UnitItem";
            _this.bindMethods();
            _this.dragPositioner = new DragPositioner_5.default(_this, _this.props.dragPositionerProps);
            _this.dragPositioner.onDragStart = _this.onDragStart;
            _this.dragPositioner.onDragEnd = _this.onDragEnd;
            applyMixins_5.default(_this, _this.dragPositioner);
            return _this;
        }
        UnitItemComponent.prototype.bindMethods = function () {
            this.onDragEnd = this.onDragEnd.bind(this);
            this.getTechIcon = this.getTechIcon.bind(this);
            this.onDragStart = this.onDragStart.bind(this);
        };
        UnitItemComponent.prototype.onDragStart = function () {
            this.props.onDragStart(this.props.item);
        };
        UnitItemComponent.prototype.onDragEnd = function () {
            this.props.onDragEnd();
        };
        UnitItemComponent.prototype.getTechIcon = function (techLevel) {
            switch (techLevel) {
                case 2:
                    {
                        return "img/icons/t2icon.png";
                    }
                case 3:
                    {
                        return "img/icons/t3icon.png";
                    }
                default:
                    {
                        throw new Error("Couldn't find icon for item tech level " + techLevel);
                    }
            }
        };
        UnitItemComponent.prototype.render = function () {
            if (!this.props.item) {
                return (React.DOM.div({ className: "empty-unit-item",
                    title: localize_12.localize("itemSlot") + ": " + this.props.slot
                }));
            }
            var item = this.props.item;
            var divProps = {
                className: "unit-item",
                title: item.template.displayName,
            };
            if (this.props.isDraggable) {
                divProps.className += " draggable";
                divProps.onMouseDown = divProps.onTouchStart =
                    this.dragPositioner.handleReactDownEvent;
                if (this.dragPositioner.isDragging) {
                    divProps.style = this.dragPositioner.getStyleAttributes();
                    divProps.className += " dragging";
                }
            }
            return (React.DOM.div(divProps, React.DOM.div({
                className: "item-icon-container",
            }, React.DOM.img({
                className: "item-icon-base",
                src: item.template.icon,
            }), item.template.techLevel > 1 ? React.DOM.img({
                className: "item-icon-tech-level",
                src: this.getTechIcon(item.template.techLevel),
            }) : null)));
        };
        return UnitItemComponent;
    }(React.Component));
    exports.UnitItemComponent = UnitItemComponent;
    var Factory = React.createFactory(UnitItemComponent);
    exports.default = Factory;
});
define("src/uicomponents/unitlist/UnitItemWrapper", ["require", "exports", "react", "src/uicomponents/unitlist/UnitItem"], function (require, exports, React, UnitItem_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var UnitItemWrapperComponent = (function (_super) {
        __extends(UnitItemWrapperComponent, _super);
        function UnitItemWrapperComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "UnitItemWrapper";
            _this.bindMethods();
            return _this;
        }
        UnitItemWrapperComponent.prototype.bindMethods = function () {
            this.handleMouseUp = this.handleMouseUp.bind(this);
        };
        UnitItemWrapperComponent.prototype.handleMouseUp = function () {
            this.props.onMouseUp(this.props.index);
        };
        UnitItemWrapperComponent.prototype.render = function () {
            var wrapperProps = {
                className: "unit-item-wrapper",
            };
            if (this.props.onMouseUp) {
                wrapperProps.onMouseUp = this.handleMouseUp;
            }
            ;
            if (this.props.currentDragItem) {
                var dragItem = this.props.currentDragItem;
                if (dragItem.template.slot === this.props.slot) {
                    wrapperProps.className += " drop-target";
                }
                else {
                    wrapperProps.onMouseUp = null;
                    wrapperProps.className += " invalid-drop-target";
                }
            }
            return (React.DOM.div(wrapperProps, UnitItem_1.default({
                item: this.props.item,
                slot: this.props.slot,
                key: "item",
                isDraggable: this.props.isDraggable,
                onDragStart: this.props.onDragStart,
                onDragEnd: this.props.onDragEnd,
            })));
        };
        return UnitItemWrapperComponent;
    }(React.Component));
    exports.UnitItemWrapperComponent = UnitItemWrapperComponent;
    var Factory = React.createFactory(UnitItemWrapperComponent);
    exports.default = Factory;
});
define("src/uicomponents/unitlist/UnitItemGroup", ["require", "exports", "react", "src/uicomponents/unitlist/UnitItemWrapper"], function (require, exports, React, UnitItemWrapper_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var UnitItemGroupComponent = (function (_super) {
        __extends(UnitItemGroupComponent, _super);
        function UnitItemGroupComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "UnitItemGroup";
            return _this;
        }
        UnitItemGroupComponent.prototype.render = function () {
            var itemWrappers = [];
            var itemsByPosition = {};
            this.props.items.forEach(function (item) {
                itemsByPosition[item.positionInUnit] = item;
            });
            for (var i = 0; i < this.props.maxItems; i++) {
                itemWrappers.push(UnitItemWrapper_1.default({
                    key: i,
                    slot: this.props.slotName,
                    item: itemsByPosition[i],
                    index: i,
                    onMouseUp: this.props.onMouseUp,
                    isDraggable: this.props.isDraggable,
                    onDragStart: this.props.onDragStart,
                    onDragEnd: this.props.onDragEnd,
                    currentDragItem: this.props.currentDragItem,
                }));
            }
            return (React.DOM.div({
                className: "unit-item-group unit-item-group-" + this.props.slotName,
            }, itemWrappers));
        };
        return UnitItemGroupComponent;
    }(React.Component));
    exports.UnitItemGroupComponent = UnitItemGroupComponent;
    var Factory = React.createFactory(UnitItemGroupComponent);
    exports.default = Factory;
});
define("src/uicomponents/unitlist/MenuUnitInfo", ["require", "exports", "react", "src/uicomponents/unitlist/AbilityList", "src/uicomponents/unitlist/UnitExperience", "src/uicomponents/unitlist/UnitItemGroup"], function (require, exports, React, AbilityList_2, UnitExperience_1, UnitItemGroup_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MenuUnitInfoComponent = (function (_super) {
        __extends(MenuUnitInfoComponent, _super);
        function MenuUnitInfoComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "MenuUnitInfo";
            _this.bindMethods();
            return _this;
        }
        MenuUnitInfoComponent.prototype.bindMethods = function () {
            this.handleUnitUpgrade = this.handleUnitUpgrade.bind(this);
        };
        MenuUnitInfoComponent.prototype.handleUnitUpgrade = function () {
            this.forceUpdate();
        };
        MenuUnitInfoComponent.prototype.render = function () {
            var unit = this.props.unit;
            if (!unit)
                return (React.DOM.div({ className: "menu-unit-info" }));
            var itemGroups = [];
            var itemsBySlot = unit.items.getItemsBySlot();
            for (var slot in unit.items.itemSlots) {
                itemGroups.push(UnitItemGroup_1.default({
                    key: slot,
                    slotName: slot,
                    maxItems: unit.items.itemSlots[slot],
                    items: itemsBySlot[slot],
                    onMouseUp: this.props.onMouseUp,
                    isDraggable: this.props.isDraggable,
                    onDragStart: this.props.onDragStart,
                    onDragEnd: this.props.onDragEnd,
                    currentDragItem: this.props.currentDragItem,
                }));
            }
            var unitAbilities = unit.getAllAbilities();
            unitAbilities = unitAbilities.concat(unit.getAllPassiveSkills());
            return (React.DOM.div({
                className: "menu-unit-info",
            }, React.DOM.div({
                className: "menu-unit-info-left",
            }, React.DOM.div({
                className: "menu-unit-info-name",
            }, unit.name), React.DOM.div({
                className: "menu-unit-info-abilities",
            }, AbilityList_2.default({
                abilities: unitAbilities,
            })), UnitExperience_1.default({
                experienceForCurrentLevel: unit.experienceForCurrentLevel,
                experienceToNextLevel: unit.getExperienceToNextLevel(),
                unit: unit,
                onUnitUpgrade: this.handleUnitUpgrade,
            })), React.DOM.div({
                className: "menu-unit-info-items-wrapper",
            }, itemGroups)));
        };
        return MenuUnitInfoComponent;
    }(React.Component));
    exports.MenuUnitInfoComponent = MenuUnitInfoComponent;
    var Factory = React.createFactory(MenuUnitInfoComponent);
    exports.default = Factory;
});
define("src/uicomponents/unitlist/UnitListItem", ["require", "exports", "react", "react-dom", "src/utility", "src/uicomponents/unit/Unit", "src/uicomponents/unit/UnitStrength", "src/uicomponents/mixins/DragPositioner", "src/uicomponents/mixins/applyMixins"], function (require, exports, React, ReactDOM, utility_29, Unit_5, UnitStrength_2, DragPositioner_6, applyMixins_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var UnitListItemComponent = (function (_super) {
        __extends(UnitListItemComponent, _super);
        function UnitListItemComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "UnitListItem";
            _this.bindMethods();
            if (_this.props.isDraggable) {
                _this.dragPositioner = new DragPositioner_6.default(_this, _this.props.dragPositionerProps);
                _this.dragPositioner.onDragStart = _this.onDragStart;
                _this.dragPositioner.makeDragClone = _this.makeDragClone;
                _this.dragPositioner.onDragEnd = _this.onDragEnd;
                applyMixins_6.default(_this, _this.dragPositioner);
            }
            return _this;
        }
        UnitListItemComponent.prototype.bindMethods = function () {
            this.handleMouseEnter = this.handleMouseEnter.bind(this);
            this.handleMouseLeave = this.handleMouseLeave.bind(this);
            this.makeCell = this.makeCell.bind(this);
            this.onDragEnd = this.onDragEnd.bind(this);
            this.onDragStart = this.onDragStart.bind(this);
            this.makeDragClone = this.makeDragClone.bind(this);
        };
        UnitListItemComponent.prototype.componentDidMount = function () {
            if (!this.props.isDraggable)
                return;
            var container = document.getElementsByClassName("unit-wrapper")[0];
            this.dragPositioner.forcedDragOffset =
                {
                    x: container.offsetWidth / 2,
                    y: container.offsetHeight / 2,
                };
        };
        UnitListItemComponent.prototype.onDragStart = function () {
            this.props.onDragStart(this.props.unit);
        };
        UnitListItemComponent.prototype.makeDragClone = function () {
            var container = document.createElement("div");
            ReactDOM.render(Unit_5.default(utility_29.shallowExtend(this.props.unit.getDisplayData("battlePrep"), { id: this.props.unit.id })), container);
            var renderedElement = container.firstChild;
            var wrapperElement = document.getElementsByClassName("unit-wrapper")[0];
            renderedElement.classList.add("draggable", "dragging");
            renderedElement.style.width = "" + wrapperElement.offsetWidth + "px";
            renderedElement.style.height = "" + wrapperElement.offsetHeight + "px";
            this.dragPositioner.forcedDragOffset =
                {
                    x: wrapperElement.offsetWidth / 2,
                    y: wrapperElement.offsetHeight / 2,
                };
            return renderedElement;
        };
        UnitListItemComponent.prototype.onDragEnd = function () {
            this.props.onDragEnd();
        };
        UnitListItemComponent.prototype.handleMouseEnter = function () {
            this.props.onMouseEnter(this.props.unit);
        };
        UnitListItemComponent.prototype.handleMouseLeave = function () {
            this.props.onMouseLeave();
        };
        UnitListItemComponent.prototype.makeCell = function (type) {
            var unit = this.props.unit;
            var cellProps = {};
            cellProps.key = type;
            cellProps.className = "unit-list-item-cell" + " unit-list-" + type;
            var cellContent;
            switch (type) {
                case "strength":
                    {
                        cellContent = UnitStrength_2.default({
                            maxHealth: this.props.maxHealth,
                            currentHealth: this.props.currentHealth,
                            isSquadron: true,
                        });
                        break;
                    }
                case "attack":
                case "defence":
                case "intelligence":
                case "speed":
                    {
                        cellContent = this.props[type];
                        if (unit.attributes[type] < unit.baseAttributes[type]) {
                            cellProps.className += " lowered-stat";
                        }
                        else if (unit.attributes[type] > unit.baseAttributes[type]) {
                            cellProps.className += " raised-stat";
                        }
                        break;
                    }
                default:
                    {
                        cellContent = this.props[type];
                        break;
                    }
            }
            return (React.DOM.td(cellProps, cellContent));
        };
        UnitListItemComponent.prototype.render = function () {
            var columns = this.props.activeColumns;
            var cells = [];
            for (var i = 0; i < columns.length; i++) {
                var cell = this.makeCell(columns[i].key);
                cells.push(cell);
            }
            var rowProps = {
                className: "unit-list-item",
                onClick: this.props.handleClick,
            };
            if (this.props.isDraggable && !this.props.isUnavailable) {
                rowProps.className += " draggable";
                rowProps.onTouchStart = rowProps.onMouseDown =
                    this.dragPositioner.handleReactDownEvent;
            }
            if (this.props.isSelected) {
                rowProps.className += " selected-unit";
            }
            ;
            if (this.props.isReserved) {
                rowProps.className += " reserved-unit";
            }
            if (this.props.isUnavailable) {
                rowProps.className += " unavailable-unit";
            }
            if (this.props.isHovered) {
                rowProps.className += " unit-list-item-hovered";
            }
            else if (this.props.onMouseEnter) {
                rowProps.onMouseEnter = this.handleMouseEnter;
                rowProps.onMouseLeave = this.handleMouseLeave;
            }
            return (React.DOM.tr(rowProps, cells));
        };
        return UnitListItemComponent;
    }(React.Component));
    exports.UnitListItemComponent = UnitListItemComponent;
    var Factory = React.createFactory(UnitListItemComponent);
    exports.default = Factory;
});
define("src/uicomponents/unitlist/UnitList", ["require", "exports", "react", "src/uicomponents/list/List", "src/uicomponents/unitlist/UnitListItem", "localization/localize"], function (require, exports, React, List_2, UnitListItem_1, localize_13) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var UnitListComponent = (function (_super) {
        __extends(UnitListComponent, _super);
        function UnitListComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "UnitList";
            return _this;
        }
        UnitListComponent.prototype.render = function () {
            var _this = this;
            var rows = this.props.units.map(function (unit) {
                return ({
                    key: "" + unit.id,
                    content: UnitListItem_1.default({
                        unit: unit,
                        id: unit.id,
                        name: unit.name,
                        typeName: unit.template.displayName,
                        strength: "" + unit.currentHealth + " / " + unit.maxHealth,
                        currentHealth: unit.currentHealth,
                        maxHealth: unit.maxHealth,
                        maxActionPoints: unit.attributes.maxActionPoints,
                        attack: unit.attributes.attack,
                        defence: unit.attributes.defence,
                        intelligence: unit.attributes.intelligence,
                        speed: unit.attributes.speed,
                        isReserved: _this.props.reservedUnits.indexOf(unit) !== -1,
                        isUnavailable: _this.props.unavailableUnits.indexOf(unit) !== -1,
                        isSelected: (_this.props.selectedUnit && _this.props.selectedUnit.id === unit.id),
                        isHovered: (_this.props.hoveredUnit && _this.props.hoveredUnit.id === unit.id),
                        onMouseEnter: _this.props.onMouseEnterUnit,
                        onMouseLeave: _this.props.onMouseLeave,
                        isDraggable: _this.props.isDraggable,
                        onDragStart: _this.props.onDragStart,
                        onDragEnd: _this.props.onDragEnd,
                        dragPositionerProps: {
                            shouldMakeClone: true,
                        },
                    }),
                });
            });
            var columns = [
                {
                    label: localize_13.localize("id"),
                    key: "id",
                    defaultOrder: "asc",
                },
                {
                    label: localize_13.localize("type"),
                    key: "typeName",
                    defaultOrder: "asc",
                },
                {
                    label: localize_13.localize("strength"),
                    key: "strength",
                    defaultOrder: "desc",
                    sortingFunction: function (a, b) {
                        return a.content.props.currentHealth - b.content.props.currentHealth;
                    },
                },
                {
                    label: localize_13.localize("act"),
                    key: "maxActionPoints",
                    defaultOrder: "desc",
                },
                {
                    label: localize_13.localize("atk"),
                    key: "attack",
                    defaultOrder: "desc",
                },
                {
                    label: localize_13.localize("def"),
                    key: "defence",
                    defaultOrder: "desc",
                },
                {
                    label: localize_13.localize("int"),
                    key: "intelligence",
                    defaultOrder: "desc",
                },
                {
                    label: localize_13.localize("spd"),
                    key: "speed",
                    defaultOrder: "desc",
                },
            ];
            return (React.DOM.div({ className: "unit-list fixed-table-parent" }, List_2.default({
                listItems: rows,
                initialColumns: columns,
                onRowChange: this.props.onRowChange,
                autoSelect: this.props.autoSelect,
                keyboardSelect: true,
            })));
        };
        return UnitListComponent;
    }(React.Component));
    exports.UnitListComponent = UnitListComponent;
    var Factory = React.createFactory(UnitListComponent);
    exports.default = Factory;
});
define("src/uicomponents/galaxymap/DefenceBuilding", ["require", "exports", "react", "src/App", "src/utility", "src/uicomponents/PlayerFlag"], function (require, exports, React, App_8, utility_30, PlayerFlag_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DefenceBuildingComponent = (function (_super) {
        __extends(DefenceBuildingComponent, _super);
        function DefenceBuildingComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "DefenceBuilding";
            return _this;
        }
        DefenceBuildingComponent.prototype.shouldComponentUpdate = function (newProps) {
            return newProps.building !== this.props.building;
        };
        DefenceBuildingComponent.prototype.render = function () {
            var building = this.props.building;
            var image = App_8.default.images[building.template.iconSrc];
            return (React.DOM.div({
                className: "defence-building",
            }, React.DOM.img({
                className: "defence-building-icon",
                src: utility_30.colorImageInPlayerColor(image, building.controller),
                title: building.template.displayName,
            }), PlayerFlag_3.default({
                props: {
                    className: "defence-building-controller",
                    title: building.controller.name.fullName,
                },
                key: "flag",
                flag: building.controller.flag,
            })));
        };
        return DefenceBuildingComponent;
    }(React.Component));
    exports.DefenceBuildingComponent = DefenceBuildingComponent;
    var Factory = React.createFactory(DefenceBuildingComponent);
    exports.default = Factory;
});
define("src/uicomponents/galaxymap/DefenceBuildingList", ["require", "exports", "react", "src/uicomponents/galaxymap/DefenceBuilding"], function (require, exports, React, DefenceBuilding_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DefenceBuildingListComponent = (function (_super) {
        __extends(DefenceBuildingListComponent, _super);
        function DefenceBuildingListComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "DefenceBuildingList";
            return _this;
        }
        DefenceBuildingListComponent.prototype.shouldComponentUpdate = function (newProps) {
            var newBuildings = newProps.buildings;
            var oldBuildings = this.props.buildings;
            if (newBuildings.length !== oldBuildings.length)
                return true;
            else {
                for (var i = 0; i < newBuildings.length; i++) {
                    if (oldBuildings.indexOf(newBuildings[i]) === -1)
                        return true;
                }
            }
            return false;
        };
        DefenceBuildingListComponent.prototype.render = function () {
            if (!this.props.buildings)
                return null;
            var buildings = [];
            for (var i = 0; i < this.props.buildings.length; i++) {
                buildings.push(DefenceBuilding_1.default({
                    key: this.props.buildings[i].id,
                    building: this.props.buildings[i],
                }));
            }
            if (this.props.reverse) {
                buildings.reverse();
            }
            return (React.DOM.div({
                className: "defence-building-list",
            }, buildings));
        };
        return DefenceBuildingListComponent;
    }(React.Component));
    exports.DefenceBuildingListComponent = DefenceBuildingListComponent;
    var Factory = React.createFactory(DefenceBuildingListComponent);
    exports.default = Factory;
});
define("src/uicomponents/battleprep/BattleInfo", ["require", "exports", "react", "src/uicomponents/PlayerFlag", "src/uicomponents/galaxymap/DefenceBuildingList", "localization/localize"], function (require, exports, React, PlayerFlag_4, DefenceBuildingList_1, localize_14) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BattleInfoComponent = (function (_super) {
        __extends(BattleInfoComponent, _super);
        function BattleInfoComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "BattleInfo";
            return _this;
        }
        BattleInfoComponent.prototype.render = function () {
            var battlePrep = this.props.battlePrep;
            var star = battlePrep.battleData.location;
            var isAttacker = battlePrep.humanPlayer === battlePrep.attacker;
            return (React.DOM.div({
                className: "battle-info",
            }, React.DOM.div({
                className: "battle-info-opponent",
            }, PlayerFlag_4.default({
                flag: battlePrep.enemyPlayer.flag,
                props: {
                    className: "battle-info-opponent-icon",
                },
            }), React.DOM.div({
                className: "battle-info-opponent-name",
            }, battlePrep.enemyPlayer.name.fullName)), React.DOM.div({
                className: "battle-info-summary",
            }, star.name + ": " + (isAttacker ? localize_14.localize("attacking") : localize_14.localize("defending"))), DefenceBuildingList_1.default({
                buildings: star.buildings["defence"],
                reverse: isAttacker,
            })));
        };
        return BattleInfoComponent;
    }(React.Component));
    exports.BattleInfoComponent = BattleInfoComponent;
    var Factory = React.createFactory(BattleInfoComponent);
    exports.default = Factory;
});
define("src/uicomponents/battleprep/BattlePrep", ["require", "exports", "react", "react-dom", "src/App", "src/activeModuleData", "src/BattleSimulator", "src/Options", "src/uicomponents/battle/BattleBackground", "src/uicomponents/battle/Formation", "src/uicomponents/unitlist/ItemList", "src/uicomponents/unitlist/MenuUnitInfo", "src/uicomponents/unitlist/UnitList", "src/uicomponents/battleprep/BattleInfo", "localization/localize"], function (require, exports, React, ReactDOM, App_9, activeModuleData_20, BattleSimulator_2, Options_8, BattleBackground_2, Formation_2, ItemList_1, MenuUnitInfo_1, UnitList_1, BattleInfo_1, localize_15) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BattlePrepComponent = (function (_super) {
        __extends(BattlePrepComponent, _super);
        function BattlePrepComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "BattlePrep";
            _this.state = _this.getInitialStateTODO();
            _this.bindMethods();
            return _this;
        }
        BattlePrepComponent.prototype.bindMethods = function () {
            this.handleMouseEnterUnit = this.handleMouseEnterUnit.bind(this);
            this.handleDragEnd = this.handleDragEnd.bind(this);
            this.handleItemDragStart = this.handleItemDragStart.bind(this);
            this.setLeftLowerElement = this.setLeftLowerElement.bind(this);
            this.handleItemDragEnd = this.handleItemDragEnd.bind(this);
            this.handleItemDrop = this.handleItemDrop.bind(this);
            this.setSelectedUnit = this.setSelectedUnit.bind(this);
            this.handleMouseLeaveUnit = this.handleMouseLeaveUnit.bind(this);
            this.clearSelectedUnit = this.clearSelectedUnit.bind(this);
            this.autoMakeFormation = this.autoMakeFormation.bind(this);
            this.handleSelectRow = this.handleSelectRow.bind(this);
            this.handleDragStart = this.handleDragStart.bind(this);
            this.handleDrop = this.handleDrop.bind(this);
            this.getBackgroundBlurArea = this.getBackgroundBlurArea.bind(this);
        };
        BattlePrepComponent.prototype.getInitialStateTODO = function () {
            return ({
                currentDragUnit: null,
                hoveredUnit: null,
                selectedUnit: null,
                currentDragItem: null,
                leftLowerElement: "playerFormation",
            });
        };
        BattlePrepComponent.prototype.componentDidMount = function () {
            this.ref_TODO_background.handleResize();
        };
        BattlePrepComponent.prototype.autoMakeFormation = function () {
            this.props.battlePrep.humanFormation.clearFormation();
            this.props.battlePrep.humanFormation.setAutoFormation(this.props.battlePrep.enemyUnits, this.props.battlePrep.enemyFormation.formation);
            this.setLeftLowerElement("playerFormation");
            this.forceUpdate();
        };
        BattlePrepComponent.prototype.handleSelectRow = function (row) {
            if (!row.content.props.unit) {
                return;
            }
            this.setSelectedUnit(row.content.props.unit);
        };
        BattlePrepComponent.prototype.clearSelectedUnit = function () {
            this.setState({
                selectedUnit: null,
            });
        };
        BattlePrepComponent.prototype.setSelectedUnit = function (unit) {
            if (unit === this.state.selectedUnit) {
                this.clearSelectedUnit();
                return;
            }
            this.setState({
                selectedUnit: unit,
                hoveredUnit: null,
            });
        };
        BattlePrepComponent.prototype.handleMouseEnterUnit = function (unit) {
            this.setState({
                hoveredUnit: unit,
            });
        };
        BattlePrepComponent.prototype.handleMouseLeaveUnit = function () {
            this.setState({
                hoveredUnit: null,
            });
        };
        BattlePrepComponent.prototype.handleDragStart = function (unit) {
            this.setState({
                currentDragUnit: unit,
            });
        };
        BattlePrepComponent.prototype.handleDragEnd = function (dropSuccesful) {
            if (dropSuccesful === void 0) { dropSuccesful = false; }
            if (!dropSuccesful && this.state.currentDragUnit) {
                this.props.battlePrep.humanFormation.removeUnit(this.state.currentDragUnit);
            }
            this.setState({
                currentDragUnit: null,
                hoveredUnit: null,
            });
            return dropSuccesful;
        };
        BattlePrepComponent.prototype.handleDrop = function (position) {
            var battlePrep = this.props.battlePrep;
            if (this.state.currentDragUnit) {
                battlePrep.humanFormation.setUnit(this.state.currentDragUnit, position);
            }
            this.handleDragEnd(true);
        };
        BattlePrepComponent.prototype.handleItemDragStart = function (item) {
            this.setState({
                currentDragItem: item,
            });
        };
        BattlePrepComponent.prototype.setLeftLowerElement = function (newElement) {
            var oldElement = this.state.leftLowerElement;
            var newState = {
                leftLowerElement: newElement,
            };
            if (oldElement === "enemyFormation" || newElement === "enemyFormation") {
                newState.selectedUnit = null;
            }
            this.setState(newState);
        };
        BattlePrepComponent.prototype.handleItemDragEnd = function (dropSuccesful) {
            if (dropSuccesful === void 0) { dropSuccesful = false; }
            if (!dropSuccesful && this.state.currentDragItem && this.state.selectedUnit) {
                var item = this.state.currentDragItem;
                if (this.state.selectedUnit.items.hasItem(item)) {
                    this.state.selectedUnit.items.removeItem(item);
                }
            }
            this.setState({
                currentDragItem: null,
            });
        };
        BattlePrepComponent.prototype.handleItemDrop = function (index) {
            var item = this.state.currentDragItem;
            var unit = this.state.selectedUnit;
            if (unit && item) {
                unit.items.addItemAtPosition(item, index);
            }
            this.handleItemDragEnd(true);
        };
        BattlePrepComponent.prototype.getBackgroundBlurArea = function () {
            return ReactDOM.findDOMNode(this.ref_TODO_upper).getBoundingClientRect();
        };
        BattlePrepComponent.prototype.render = function () {
            var _this = this;
            var battlePrep = this.props.battlePrep;
            var player = battlePrep.humanPlayer;
            var leftUpperElement;
            var hoveredUnit = this.state.currentDragUnit || this.state.hoveredUnit;
            if (hoveredUnit) {
                leftUpperElement = MenuUnitInfo_1.default({
                    unit: hoveredUnit,
                });
            }
            else if (this.state.selectedUnit) {
                var selectedUnitIsFriendly = battlePrep.humanUnits.some(function (unit) { return unit === _this.state.selectedUnit; });
                leftUpperElement = MenuUnitInfo_1.default({
                    unit: this.state.selectedUnit,
                    onMouseUp: this.handleItemDrop,
                    isDraggable: selectedUnitIsFriendly,
                    onDragStart: this.handleItemDragStart,
                    onDragEnd: this.handleItemDragEnd,
                    currentDragItem: this.state.currentDragItem,
                });
            }
            else {
                leftUpperElement = BattleInfo_1.default({
                    battlePrep: battlePrep,
                });
            }
            var leftLowerElement;
            switch (this.state.leftLowerElement) {
                case "playerFormation":
                    {
                        leftLowerElement = Formation_2.default({
                            key: "playerFormation",
                            formation: battlePrep.humanFormation.formation,
                            facesLeft: false,
                            unitDisplayDataById: battlePrep.humanFormation.getDisplayData(),
                            isInBattlePrep: true,
                            hoveredUnit: this.state.hoveredUnit,
                            activeUnit: this.state.selectedUnit,
                            onMouseUp: this.handleDrop,
                            onUnitClick: this.setSelectedUnit,
                            handleMouseEnterUnit: this.handleMouseEnterUnit,
                            handleMouseLeaveUnit: this.handleMouseLeaveUnit,
                            unitStrengthAnimateDuration: undefined,
                            isDraggable: true,
                            onDragStart: this.handleDragStart,
                            onDragEnd: this.handleDragEnd,
                        });
                        break;
                    }
                case "enemyFormation":
                    {
                        leftLowerElement = Formation_2.default({
                            key: "enemyFormation",
                            formation: battlePrep.enemyFormation.formation,
                            facesLeft: true,
                            unitDisplayDataById: battlePrep.enemyFormation.getDisplayData(),
                            isInBattlePrep: true,
                            hoveredUnit: this.state.hoveredUnit,
                            activeUnit: this.state.selectedUnit,
                            onUnitClick: this.setSelectedUnit,
                            handleMouseEnterUnit: this.handleMouseEnterUnit,
                            handleMouseLeaveUnit: this.handleMouseLeaveUnit,
                            unitStrengthAnimateDuration: undefined,
                            isDraggable: false,
                        });
                        break;
                    }
                case "itemEquip":
                    {
                        leftLowerElement = ItemList_1.default({
                            key: "itemEquip",
                            items: player.items,
                            isDraggable: true,
                            onDragStart: this.handleItemDragStart,
                            onDragEnd: this.handleItemDragEnd,
                            onRowChange: this.handleSelectRow,
                        });
                        break;
                    }
            }
            ;
            var playerIsDefending = player === battlePrep.defender;
            var humanFormationValidity = battlePrep.humanFormation.getFormationValidity();
            var canScout = player.starIsDetected(battlePrep.battleData.location);
            return (React.DOM.div({ className: "battle-prep" }, React.DOM.div({ className: "battle-prep-left" }, React.DOM.div({ className: "battle-prep-left-upper-wrapper", ref: function (component) {
                    _this.ref_TODO_upper = component;
                } }, BattleBackground_2.default({
                getBlurArea: this.getBackgroundBlurArea,
                backgroundSeed: battlePrep.battleData.location.getSeed(),
                backgroundDrawingFunction: activeModuleData_20.activeModuleData.starBackgroundDrawingFunction,
                ref: function (component) {
                    _this.ref_TODO_background = component;
                },
            }, React.DOM.div({ className: "battle-prep-left-upper-inner" }, leftUpperElement))), React.DOM.div({ className: "battle-prep-left-controls" }, React.DOM.button({
                className: "battle-prep-controls-button",
                onClick: this.setLeftLowerElement.bind(this, "itemEquip"),
                disabled: this.state.leftLowerElement === "itemEquip",
            }, localize_15.localize("equip")), React.DOM.button({
                className: "battle-prep-controls-button",
                onClick: this.setLeftLowerElement.bind(this, "playerFormation"),
                disabled: this.state.leftLowerElement === "playerFormation",
            }, localize_15.localize("own_adjective")), React.DOM.button({
                className: "battle-prep-controls-button",
                onClick: this.setLeftLowerElement.bind(this, "enemyFormation"),
                disabled: this.state.leftLowerElement === "enemyFormation" || !canScout,
                title: canScout ?
                    null :
                    localize_15.localize("cantInspectEnemyFormationAsStarIsNotInDetectionRadius"),
            }, localize_15.localize("enemy")), React.DOM.button({
                onClick: this.autoMakeFormation,
            }, localize_15.localize("autoFormation")), React.DOM.button({
                onClick: function () {
                    App_9.default.reactUI.switchScene("galaxyMap");
                },
                disabled: playerIsDefending,
            }, localize_15.localize("cancel")), React.DOM.button({
                className: "battle-prep-controls-button",
                disabled: !humanFormationValidity.isValid,
                title: humanFormationValidity.description,
                onClick: function () {
                    var battle = battlePrep.makeBattle();
                    App_9.default.reactUI.battle = battle;
                    App_9.default.reactUI.switchScene("battle");
                }.bind(this),
            }, localize_15.localize("startBattle")), !Options_8.default.debug.enabled ? null : React.DOM.button({
                className: "battle-prep-controls-button",
                onClick: function () {
                    var battle = battlePrep.makeBattle();
                    var simulator = new BattleSimulator_2.default(battle);
                    simulator.simulateBattle();
                    battle.isSimulated = false;
                    simulator.finishBattle();
                }.bind(this),
            }, localize_15.localize("simulateBattle"))), React.DOM.div({ className: "battle-prep-left-lower" }, leftLowerElement)), UnitList_1.default({
                units: battlePrep.humanFormation.units,
                selectedUnit: this.state.selectedUnit,
                reservedUnits: battlePrep.humanFormation.getPlacedUnits(),
                unavailableUnits: battlePrep.humanPlayer === battlePrep.attacker ?
                    battlePrep.humanUnits.filter(function (unit) { return !unit.canFightOffensiveBattle(); }) :
                    [],
                hoveredUnit: this.state.hoveredUnit,
                isDraggable: this.state.leftLowerElement === "playerFormation",
                onDragStart: this.handleDragStart,
                onDragEnd: this.handleDragEnd,
                onRowChange: this.handleSelectRow,
                onMouseEnterUnit: this.handleMouseEnterUnit,
                onMouseLeave: this.handleMouseLeaveUnit,
            })));
        };
        return BattlePrepComponent;
    }(React.Component));
    exports.BattlePrepComponent = BattlePrepComponent;
    var Factory = React.createFactory(BattlePrepComponent);
    exports.default = Factory;
});
define("src/uicomponents/mapmodes/MapModeSelector", ["require", "exports", "react"], function (require, exports, React) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MapModeSelectorComponent = (function (_super) {
        __extends(MapModeSelectorComponent, _super);
        function MapModeSelectorComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "MapModeSelector";
            _this.bindMethods();
            return _this;
        }
        MapModeSelectorComponent.prototype.handleChange = function (e) {
            var target = e.currentTarget;
            var value = target.value;
            this.props.mapRenderer.setMapModeByKey(value);
            if (this.props.onUpdate) {
                this.props.onUpdate();
            }
        };
        MapModeSelectorComponent.prototype.bindMethods = function () {
            this.makeOptions = this.makeOptions.bind(this);
            this.handleChange = this.handleChange.bind(this);
        };
        MapModeSelectorComponent.prototype.makeOptions = function () {
            var mapRenderer = this.props.mapRenderer;
            var options = [];
            for (var key in mapRenderer.mapModes) {
                var mapMode = mapRenderer.mapModes[key];
                options.push(React.DOM.option({
                    value: key,
                    key: key,
                }, mapMode.displayName));
            }
            return options;
        };
        MapModeSelectorComponent.prototype.render = function () {
            var mapRenderer = this.props.mapRenderer;
            return (React.DOM.select({
                className: "map-mode-selector",
                value: mapRenderer.currentMapMode.template.key,
                onChange: this.handleChange,
            }, this.makeOptions()));
        };
        return MapModeSelectorComponent;
    }(React.Component));
    exports.MapModeSelectorComponent = MapModeSelectorComponent;
    var Factory = React.createFactory(MapModeSelectorComponent);
    exports.default = Factory;
});
define("src/uicomponents/mapmodes/MapRendererLayersListItem", ["require", "exports", "react", "react-dom", "src/uicomponents/mixins/DragPositioner", "src/uicomponents/mixins/applyMixins"], function (require, exports, React, ReactDOM, DragPositioner_7, applyMixins_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MapRendererLayersListItemComponent = (function (_super) {
        __extends(MapRendererLayersListItemComponent, _super);
        function MapRendererLayersListItemComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "MapRendererLayersListItem";
            _this.onDragEnd = _this.onDragEnd.bind(_this);
            _this.handleHover = _this.handleHover.bind(_this);
            _this.onDragStart = _this.onDragStart.bind(_this);
            _this.onDragMove = _this.onDragMove.bind(_this);
            _this.clearHover = _this.clearHover.bind(_this);
            _this.setLayerAlpha = _this.setLayerAlpha.bind(_this);
            _this.dragPositioner = new DragPositioner_7.default(_this, _this.props.dragPositionerProps);
            _this.dragPositioner.onDragStart = _this.onDragStart;
            _this.dragPositioner.onDragMove = _this.onDragMove;
            _this.dragPositioner.onDragEnd = _this.onDragEnd;
            applyMixins_7.default(_this, _this.dragPositioner);
            return _this;
        }
        MapRendererLayersListItemComponent.prototype.componentWillReceiveProps = function (newProps) {
            if (newProps.listItemIsDragging !== this.props.listItemIsDragging) {
                this.clearHover();
            }
        };
        MapRendererLayersListItemComponent.prototype.render = function () {
            var divProps = {
                className: "map-renderer-layers-list-item draggable",
                onMouseDown: this.dragPositioner.handleReactDownEvent,
                onTouchStart: this.dragPositioner.handleReactDownEvent,
            };
            if (this.dragPositioner.isDragging) {
                divProps.style = this.dragPositioner.getStyleAttributes();
                divProps.className += " dragging";
            }
            if (this.props.listItemIsDragging) {
                divProps.onMouseMove = this.handleHover;
                divProps.onMouseLeave = this.clearHover;
                if (this.props.hoverSide) {
                    divProps.className += " insert-" + this.props.hoverSide;
                }
            }
            return (React.DOM.li(divProps, React.DOM.input({
                type: "checkbox",
                className: "map-renderer-layers-list-item-checkbox",
                checked: this.props.isActive,
                onChange: this.props.toggleActive,
            }), React.DOM.span({
                className: "map-renderer-layers-list-item-name draggable",
            }, this.props.layerName), React.DOM.input({
                className: "map-renderer-layers-list-item-alpha",
                type: "number",
                min: 0,
                max: 1,
                step: 0.05,
                value: "" + this.props.layer.alpha,
                onChange: this.setLayerAlpha,
            })));
        };
        MapRendererLayersListItemComponent.prototype.onDragStart = function () {
            this.props.onDragStart(this.props.layer);
        };
        MapRendererLayersListItemComponent.prototype.onDragMove = function (x, y) {
            this.dragPositioner.position.top = y;
            this.dragPositioner.updateDOMNodeStyle();
        };
        MapRendererLayersListItemComponent.prototype.onDragEnd = function () {
            this.props.onDragEnd();
        };
        MapRendererLayersListItemComponent.prototype.handleHover = function (e) {
            var rect = ReactDOM.findDOMNode(this).getBoundingClientRect();
            var midPoint = rect.top + rect.height / 2;
            var isAbove = e.clientY < midPoint;
            var hoverSide = isAbove ? "top" : "bottom";
            this.setState({
                hoverSide: hoverSide,
            });
            this.props.setHoverPosition(this.props.layer, hoverSide);
        };
        MapRendererLayersListItemComponent.prototype.clearHover = function () {
            this.setState({
                hoverSide: null,
            });
        };
        MapRendererLayersListItemComponent.prototype.setLayerAlpha = function (e) {
            var target = e.currentTarget;
            var value = parseFloat(target.value);
            if (isFinite(value)) {
                this.props.updateLayer(this.props.layer);
                this.props.layer.alpha = value;
            }
            this.forceUpdate();
        };
        return MapRendererLayersListItemComponent;
    }(React.PureComponent));
    exports.MapRendererLayersListItemComponent = MapRendererLayersListItemComponent;
    var Factory = React.createFactory(MapRendererLayersListItemComponent);
    exports.default = Factory;
});
define("src/uicomponents/mapmodes/MapRendererLayersList", ["require", "exports", "react", "src/uicomponents/mapmodes/MapRendererLayersListItem"], function (require, exports, React, MapRendererLayersListItem_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MapRendererLayersListComponent = (function (_super) {
        __extends(MapRendererLayersListComponent, _super);
        function MapRendererLayersListComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "MapRendererLayersList";
            _this.state =
                {
                    currentDraggingLayer: null,
                    layerToInsertNextTo: null,
                    insertPosition: null,
                };
            _this.handleDragEnd = _this.handleDragEnd.bind(_this);
            _this.handleToggleActive = _this.handleToggleActive.bind(_this);
            _this.updateLayer = _this.updateLayer.bind(_this);
            _this.handleSetHoverPosition = _this.handleSetHoverPosition.bind(_this);
            _this.handleDragStart = _this.handleDragStart.bind(_this);
            return _this;
        }
        MapRendererLayersListComponent.prototype.handleDragStart = function (layer) {
            this.setState({
                currentDraggingLayer: layer,
            });
        };
        MapRendererLayersListComponent.prototype.handleDragEnd = function () {
            this.props.mapRenderer.currentMapMode.moveLayer(this.state.currentDraggingLayer, this.state.layerToInsertNextTo, this.state.insertPosition);
            this.props.mapRenderer.resetMapModeLayersPosition();
            this.setState({
                currentDraggingLayer: null,
                layerToInsertNextTo: null,
                insertPosition: null,
            });
        };
        MapRendererLayersListComponent.prototype.render = function () {
            var mapMode = this.props.currentMapMode;
            if (!mapMode) {
                return null;
            }
            var layersData = mapMode.layers;
            var listItems = [];
            for (var i = 0; i < layersData.length; i++) {
                var layer = layersData[i];
                var layerKey = layer.template.key;
                listItems.push(MapRendererLayersListItem_1.default({
                    layer: layer,
                    layerName: layer.template.displayName,
                    isActive: mapMode.activeLayers[layerKey],
                    key: layerKey,
                    toggleActive: this.handleToggleActive.bind(this, layer),
                    listItemIsDragging: Boolean(this.state.currentDraggingLayer),
                    onDragStart: this.handleDragStart,
                    onDragEnd: this.handleDragEnd,
                    setHoverPosition: this.handleSetHoverPosition,
                    hoverSide: (layer === this.state.layerToInsertNextTo ? this.state.insertPosition : null),
                    updateLayer: this.updateLayer,
                    dragPositionerProps: {
                        containerElement: this,
                        startOnHandleElementOnly: true,
                    },
                }));
            }
            return (React.DOM.ol({
                className: "map-renderer-layers-list",
            }, listItems));
        };
        MapRendererLayersListComponent.prototype.handleToggleActive = function (layer) {
            var mapRenderer = this.props.mapRenderer;
            mapRenderer.currentMapMode.toggleLayer(layer);
            mapRenderer.updateMapModeLayers([layer]);
            this.forceUpdate();
        };
        MapRendererLayersListComponent.prototype.handleSetHoverPosition = function (layer, position) {
            this.setState({
                layerToInsertNextTo: layer,
                insertPosition: position,
            });
        };
        MapRendererLayersListComponent.prototype.updateLayer = function (layer) {
            var mapRenderer = this.props.mapRenderer;
            mapRenderer.setLayerAsDirty(layer.template.key);
        };
        return MapRendererLayersListComponent;
    }(React.PureComponent));
    exports.MapRendererLayersListComponent = MapRendererLayersListComponent;
    var Factory = React.createFactory(MapRendererLayersListComponent);
    exports.default = Factory;
});
define("src/uicomponents/mapmodes/MapModeSettings", ["require", "exports", "react", "src/uicomponents/mapmodes/MapModeSelector", "src/uicomponents/mapmodes/MapRendererLayersList", "localization/localize"], function (require, exports, React, MapModeSelector_1, MapRendererLayersList_1, localize_16) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MapModeSettingsComponent = (function (_super) {
        __extends(MapModeSettingsComponent, _super);
        function MapModeSettingsComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "MapModeSettings";
            _this.bindMethods();
            return _this;
        }
        MapModeSettingsComponent.prototype.bindMethods = function () {
            this.handleReset = this.handleReset.bind(this);
        };
        MapModeSettingsComponent.prototype.handleReset = function () {
            var mapRenderer = this.props.mapRenderer;
            mapRenderer.currentMapMode.resetLayers();
            mapRenderer.resetMapModeLayersPosition();
            mapRenderer.setAllLayersAsDirty();
            this.ref_TODO_layersList.forceUpdate();
        };
        MapModeSettingsComponent.prototype.render = function () {
            var _this = this;
            return (React.DOM.div({
                className: "map-mode-settings",
            }, MapModeSelector_1.default({
                mapRenderer: this.props.mapRenderer,
                onUpdate: this.forceUpdate.bind(this),
            }), React.DOM.button({
                className: "reset-map-mode-button",
                onClick: this.handleReset,
            }, localize_16.localize("reset")), MapRendererLayersList_1.default({
                mapRenderer: this.props.mapRenderer,
                currentMapMode: this.props.mapRenderer.currentMapMode,
                ref: function (component) {
                    _this.ref_TODO_layersList = component;
                },
            })));
        };
        return MapModeSettingsComponent;
    }(React.Component));
    exports.MapModeSettingsComponent = MapModeSettingsComponent;
    var Factory = React.createFactory(MapModeSettingsComponent);
    exports.default = Factory;
});
define("src/uicomponents/windows/DialogBox", ["require", "exports", "react", "react-dom", "src/uicomponents/windows/DefaultWindow", "localization/localize"], function (require, exports, React, ReactDOM, DefaultWindow_3, localize_17) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DialogBoxComponent = (function (_super) {
        __extends(DialogBoxComponent, _super);
        function DialogBoxComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "DialogBox";
            return _this;
        }
        DialogBoxComponent.prototype.componentDidMount = function () {
            ReactDOM.findDOMNode(this.okButtonElement).focus();
        };
        DialogBoxComponent.prototype.render = function () {
            var _this = this;
            return (DefaultWindow_3.default({
                title: this.props.title,
                handleClose: this.props.handleCancel,
                isResizable: false,
                minWidth: this.props.minWidth || 50,
                minHeight: this.props.minHeight || 50,
                maxWidth: this.props.maxWidth || Infinity,
                maxHeight: this.props.maxHeight || Infinity,
            }, React.DOM.div({
                className: "dialog-box",
            }, React.DOM.div({
                className: "dialog-box-content",
            }, this.props.children), React.DOM.div({
                className: "dialog-box-buttons",
            }, React.DOM.button({
                className: "dialog-box-button ok-button",
                onClick: this.props.handleOk,
                ref: function (component) {
                    _this.okButtonElement = component;
                },
            }, this.props.okText || localize_17.localize("ok")), this.props.extraButtons, React.DOM.button({
                className: "dialog-box-button cancel-button",
                onClick: this.props.handleCancel,
            }, this.props.cancelText || localize_17.localize("cancel"))))));
        };
        return DialogBoxComponent;
    }(React.Component));
    exports.DialogBoxComponent = DialogBoxComponent;
    var Factory = React.createFactory(DialogBoxComponent);
    exports.default = Factory;
});
define("src/uicomponents/notifications/Notification", ["require", "exports", "react", "localization/localize"], function (require, exports, React, localize_18) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var NotificationComponent = (function (_super) {
        __extends(NotificationComponent, _super);
        function NotificationComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "Notification";
            _this.bindMethods();
            return _this;
        }
        NotificationComponent.prototype.bindMethods = function () {
            this.handleClick = this.handleClick.bind(this);
            this.handleClose = this.handleClose.bind(this);
            this.handleRightClick = this.handleRightClick.bind(this);
        };
        NotificationComponent.prototype.handleClose = function () {
            this.props.markAsRead(this.props.notification);
        };
        NotificationComponent.prototype.handleClick = function () {
            this.props.togglePopup(this.props.notification);
        };
        NotificationComponent.prototype.handleRightClick = function (e) {
            e.preventDefault();
            e.stopPropagation();
            this.handleClose();
        };
        NotificationComponent.prototype.render = function () {
            var notification = this.props.notification;
            return (React.DOM.li({
                className: "notification",
                onClick: this.handleClick,
                onContextMenu: this.handleRightClick,
                title: localize_18.localize("notificationToolTip"),
            }, React.DOM.img({
                className: "notification-image",
                src: notification.template.iconSrc,
            }), React.DOM.span({
                className: "notification-message",
            }, notification.makeMessage())));
        };
        return NotificationComponent;
    }(React.Component));
    exports.NotificationComponent = NotificationComponent;
    var Factory = React.createFactory(NotificationComponent);
    exports.default = Factory;
});
define("src/uicomponents/galaxymap/OptionsGroup", ["require", "exports", "react", "localization/localize"], function (require, exports, React, localize_19) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var OptionsGroupComponent = (function (_super) {
        __extends(OptionsGroupComponent, _super);
        function OptionsGroupComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "OptionsGroup";
            _this.state = _this.getInitialStateTODO();
            _this.bindMethods();
            return _this;
        }
        OptionsGroupComponent.prototype.render = function () {
            var rows = [];
            if (!this.state.isCollapsed) {
                for (var i = 0; i < this.props.options.length; i++) {
                    var option = this.props.options[i];
                    rows.push(React.DOM.div({
                        className: "option-container",
                        key: option.key,
                    }, option.content));
                }
            }
            var resetButton = null;
            if (this.props.resetFN) {
                resetButton = React.DOM.button({
                    className: "reset-options-button",
                    onClick: this.props.resetFN,
                }, localize_19.localize("reset"));
            }
            var header = this.props.header || resetButton ?
                React.DOM.div({
                    className: "option-group-header",
                }, React.DOM.div({
                    className: "option-group-header-title" + (this.state.isCollapsed ? " collapsed" : " collapsible"),
                    onClick: this.toggleCollapse,
                }, this.props.header), resetButton) :
                null;
            return (React.DOM.div({ className: "option-group" }, header, rows));
        };
        OptionsGroupComponent.prototype.bindMethods = function () {
            this.toggleCollapse = this.toggleCollapse.bind(this);
        };
        OptionsGroupComponent.prototype.getInitialStateTODO = function () {
            return ({
                isCollapsed: this.props.isCollapsedInitially || false,
            });
        };
        OptionsGroupComponent.prototype.toggleCollapse = function () {
            this.setState({
                isCollapsed: !this.state.isCollapsed,
            });
        };
        return OptionsGroupComponent;
    }(React.Component));
    exports.OptionsGroupComponent = OptionsGroupComponent;
    var Factory = React.createFactory(OptionsGroupComponent);
    exports.default = Factory;
});
define("src/uicomponents/notifications/NotificationFilterListItem", ["require", "exports", "react", "src/NotificationFilterState", "src/eventManager"], function (require, exports, React, NotificationFilterState_2, eventManager_19) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var NotificationFilterListItemComponent = (function (_super) {
        __extends(NotificationFilterListItemComponent, _super);
        function NotificationFilterListItemComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "NotificationFilterListItem";
            _this.state = _this.getInitialStateTODO();
            _this.bindMethods();
            return _this;
        }
        NotificationFilterListItemComponent.prototype.bindMethods = function () {
            this.handleChangeState = this.handleChangeState.bind(this);
        };
        NotificationFilterListItemComponent.prototype.getInitialStateTODO = function () {
            return ({
                filterState: this.props.filterState,
            });
        };
        NotificationFilterListItemComponent.prototype.componentWillReceiveProps = function (newProps) {
            this.setState({
                filterState: newProps.filterState,
            });
        };
        NotificationFilterListItemComponent.prototype.handleChangeState = function (state) {
            var filter = this.props.filter;
            filter.handleFilterStateChange(this.props.keyTODO, state);
            filter.save();
            this.setState({
                filterState: filter.filters[this.props.keyTODO],
            });
            eventManager_19.default.dispatchEvent("updateNotificationLog");
        };
        NotificationFilterListItemComponent.prototype.render = function () {
            var inputElements = [];
            var filterState = this.state.filterState;
            for (var state in NotificationFilterState_2.default) {
                var numericState = parseInt(state);
                if (!isFinite(numericState))
                    continue;
                var stateIsActive = filterState.indexOf(numericState) !== -1;
                inputElements.push(React.DOM.input({
                    className: "notification-filter-list-item-filter",
                    type: "checkbox",
                    id: this.props.keyTODO,
                    key: state,
                    checked: stateIsActive,
                    onChange: this.handleChangeState.bind(this, numericState),
                    title: NotificationFilterState_2.default[numericState],
                }));
            }
            return (React.DOM.div({
                className: "notification-filter-list-item" + (this.props.isHighlighted ? " highlighted" : ""),
            }, React.DOM.label({
                className: "notification-filter-list-item-label",
                htmlFor: this.props.keyTODO,
            }, this.props.displayName), React.DOM.div({
                className: "notification-filter-list-item-filters",
            }, inputElements)));
        };
        return NotificationFilterListItemComponent;
    }(React.Component));
    exports.NotificationFilterListItemComponent = NotificationFilterListItemComponent;
    var Factory = React.createFactory(NotificationFilterListItemComponent);
    exports.default = Factory;
});
define("src/uicomponents/notifications/NotificationFilterList", ["require", "exports", "react", "react-dom", "src/eventManager", "src/uicomponents/galaxymap/OptionsGroup", "src/uicomponents/notifications/NotificationFilterListItem", "localization/localize"], function (require, exports, React, ReactDOM, eventManager_20, OptionsGroup_1, NotificationFilterListItem_1, localize_20) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var NotificationFilterListComponent = (function (_super) {
        __extends(NotificationFilterListComponent, _super);
        function NotificationFilterListComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "NotificationFilterList";
            _this.bindMethods();
            return _this;
        }
        NotificationFilterListComponent.prototype.bindMethods = function () {
            this.scrollToHighlighted = this.scrollToHighlighted.bind(this);
            this.handleResetCategory = this.handleResetCategory.bind(this);
        };
        NotificationFilterListComponent.prototype.handleResetCategory = function (category) {
            var filter = this.props.filter;
            filter.setDefaultFilterStatesForCategory(category);
            filter.save();
            this.forceUpdate();
            eventManager_20.default.dispatchEvent("updateNotificationLog");
        };
        NotificationFilterListComponent.prototype.scrollToHighlighted = function () {
            if (this.props.highlightedOptionKey) {
                var bodyNode = ReactDOM.findDOMNode(this.ref_TODO_body);
                var highlightedNode = bodyNode.getElementsByClassName("highlighted")[0];
                bodyNode.scrollTop = highlightedNode.offsetTop - bodyNode.offsetHeight / 3;
            }
        };
        NotificationFilterListComponent.prototype.parentPopupDidMount = function () {
            this.scrollToHighlighted();
        };
        NotificationFilterListComponent.prototype.render = function () {
            var _this = this;
            var filter = this.props.filter;
            var filtersByCategory = filter.getFiltersByCategory();
            var filterGroupElements = [];
            for (var category in filtersByCategory) {
                var filtersForCategory = filtersByCategory[category];
                var filterElementsForCategory = [];
                for (var i = 0; i < filtersForCategory.length; i++) {
                    var notificationTemplate = filtersForCategory[i].notificationTemplate;
                    var isHighlighted = Boolean(this.props.highlightedOptionKey &&
                        this.props.highlightedOptionKey === notificationTemplate.key);
                    filterElementsForCategory.push({
                        key: notificationTemplate.key,
                        content: NotificationFilterListItem_1.default({
                            displayName: notificationTemplate.displayName,
                            filter: filter,
                            filterState: filtersForCategory[i].filterState,
                            keyTODO: notificationTemplate.key,
                            isHighlighted: isHighlighted,
                        }),
                    });
                }
                filterGroupElements.push(OptionsGroup_1.default({
                    header: category,
                    options: filterElementsForCategory,
                    key: category,
                    resetFN: this.handleResetCategory.bind(this, category),
                }));
            }
            return (React.DOM.div({
                className: "notification-filter-list",
            }, React.DOM.div({
                className: "notification-filter-list-header",
            }, React.DOM.div({
                className: "notification-filter-list-item-label",
            }, localize_20.localize("show")), React.DOM.div({
                className: "notification-filter-list-item-filters",
            }, localize_20.localize("alwaysShow_short"), localize_20.localize("showIfInvolved_short"), localize_20.localize("neverShow_short"))), React.DOM.div({
                className: "notification-filter-list-body",
                ref: function (component) {
                    _this.ref_TODO_body = component;
                },
            }, filterGroupElements)));
        };
        return NotificationFilterListComponent;
    }(React.Component));
    exports.NotificationFilterListComponent = NotificationFilterListComponent;
    var Factory = React.createFactory(NotificationFilterListComponent);
    exports.default = Factory;
});
define("src/uicomponents/notifications/NotificationFilterButton", ["require", "exports", "react", "src/uicomponents/windows/DefaultWindow", "src/uicomponents/notifications/NotificationFilterList", "localization/localize"], function (require, exports, React, DefaultWindow_4, NotificationFilterList_1, localize_21) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var NotificationFilterButtonComponent = (function (_super) {
        __extends(NotificationFilterButtonComponent, _super);
        function NotificationFilterButtonComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "NotificationFilterButton";
            _this.state =
                {
                    hasNotificationFilterPopup: false,
                };
            _this.bindMethods();
            return _this;
        }
        NotificationFilterButtonComponent.prototype.render = function () {
            return (React.DOM.div({
                className: "notification-filter-button-container",
            }, React.DOM.button({
                className: "notification-filter-button",
                onClick: this.togglePopup,
            }, this.props.text), !this.state.hasNotificationFilterPopup ? null :
                DefaultWindow_4.default({
                    title: localize_21.localize("messageSettings"),
                    handleClose: this.closePopup,
                    minWidth: 440,
                    minHeight: 150,
                }, NotificationFilterList_1.default({
                    filter: this.props.filter,
                    highlightedOptionKey: this.props.highlightedOptionKey,
                }))));
        };
        NotificationFilterButtonComponent.prototype.bindMethods = function () {
            this.openPopup = this.openPopup.bind(this);
            this.closePopup = this.closePopup.bind(this);
            this.togglePopup = this.togglePopup.bind(this);
        };
        NotificationFilterButtonComponent.prototype.openPopup = function () {
            this.setState({
                hasNotificationFilterPopup: true,
            });
        };
        NotificationFilterButtonComponent.prototype.closePopup = function () {
            this.setState({
                hasNotificationFilterPopup: false,
            });
        };
        NotificationFilterButtonComponent.prototype.togglePopup = function () {
            if (this.state.hasNotificationFilterPopup) {
                this.closePopup();
            }
            else {
                this.openPopup();
            }
        };
        return NotificationFilterButtonComponent;
    }(React.Component));
    exports.NotificationFilterButtonComponent = NotificationFilterButtonComponent;
    var Factory = React.createFactory(NotificationFilterButtonComponent);
    exports.default = Factory;
});
define("src/uicomponents/notifications/NotificationLog", ["require", "exports", "react", "react-dom", "src/eventManager", "src/uicomponents/windows/DialogBox", "src/uicomponents/notifications/Notification", "src/uicomponents/notifications/NotificationFilterButton", "localization/localize"], function (require, exports, React, ReactDOM, eventManager_21, DialogBox_1, Notification_3, NotificationFilterButton_1, localize_22) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var NotificationLogComponent = (function (_super) {
        __extends(NotificationLogComponent, _super);
        function NotificationLogComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "NotificationLog";
            _this.updateListener = undefined;
            _this.state = _this.getInitialStateTODO();
            _this.bindMethods();
            return _this;
        }
        NotificationLogComponent.prototype.componentDidMount = function () {
            this.updateListener = eventManager_21.default.addEventListener("updateNotificationLog", this.forceUpdate.bind(this));
        };
        NotificationLogComponent.prototype.componentWillUnmount = function () {
            eventManager_21.default.removeEventListener("updateNotificationLog", this.updateListener);
        };
        NotificationLogComponent.prototype.componentDidUpdate = function () {
            var domNode = ReactDOM.findDOMNode(this);
            domNode.scrollTop = domNode.scrollHeight;
        };
        NotificationLogComponent.prototype.render = function () {
            var _this = this;
            var log = this.props.log;
            var notifications = log.filterNotifications(log.notifications.filter(function (notification) {
                return !notification.hasBeenRead;
            }));
            var items = [];
            for (var i = 0; i < notifications.length; i++) {
                items.push(Notification_3.default({
                    notification: notifications[i],
                    key: this.getNotificationKey(notifications[i]),
                    markAsRead: this.handleMarkAsRead,
                    togglePopup: this.togglePopup,
                }));
            }
            return (React.DOM.div({
                className: "notification-log-container",
            }, React.DOM.ol({
                className: "notification-log",
            }, items.reverse()), this.state.notificationsWithActivePopup.map(function (notification) {
                return DialogBox_1.default({
                    key: _this.getNotificationKey(notification),
                    title: notification.getTitle(),
                    handleOk: function () {
                        _this.handleMarkAsRead(notification);
                        _this.closePopup(notification);
                    },
                    handleCancel: function () {
                        _this.closePopup(notification);
                    },
                    okText: localize_22.localize("markAsRead"),
                    cancelText: localize_22.localize("close"),
                    extraButtons: [
                        NotificationFilterButton_1.default({
                            key: "notificationFilter",
                            filter: log.notificationFilter,
                            text: localize_22.localize("notificationFilterButton"),
                            highlightedOptionKey: notification.template.key,
                        }),
                    ],
                }, notification.template.contentConstructor({
                    notification: notification,
                }));
            })));
        };
        NotificationLogComponent.prototype.bindMethods = function () {
            this.closePopup = this.closePopup.bind(this);
            this.getNotificationKey = this.getNotificationKey.bind(this);
            this.handleMarkAsRead = this.handleMarkAsRead.bind(this);
            this.togglePopup = this.togglePopup.bind(this);
        };
        NotificationLogComponent.prototype.getInitialStateTODO = function () {
            return ({
                notificationsWithActivePopup: [],
            });
        };
        NotificationLogComponent.prototype.getNotificationKey = function (notification) {
            return notification.turn + "_" + this.props.log.notifications.indexOf(notification);
        };
        NotificationLogComponent.prototype.handleMarkAsRead = function (notification) {
            notification.hasBeenRead = true;
            if (this.hasPopup(notification)) {
                this.closePopup(notification);
            }
            else {
                this.forceUpdate();
            }
        };
        NotificationLogComponent.prototype.openPopup = function (notification) {
            this.setState({
                notificationsWithActivePopup: this.state.notificationsWithActivePopup.concat(notification),
            });
        };
        NotificationLogComponent.prototype.closePopup = function (notificationToRemove) {
            this.setState({
                notificationsWithActivePopup: this.state.notificationsWithActivePopup.filter(function (notification) {
                    return notification !== notificationToRemove;
                }),
            });
        };
        NotificationLogComponent.prototype.hasPopup = function (notification) {
            return this.state.notificationsWithActivePopup.indexOf(notification) >= 0;
        };
        NotificationLogComponent.prototype.togglePopup = function (notification) {
            if (this.hasPopup(notification)) {
                this.closePopup(notification);
            }
            else {
                this.openPopup(notification);
            }
        };
        return NotificationLogComponent;
    }(React.PureComponent));
    exports.NotificationLogComponent = NotificationLogComponent;
    var Factory = React.createFactory(NotificationLogComponent);
    exports.default = Factory;
});
define("src/uicomponents/notifications/Notifications", ["require", "exports", "react", "src/uicomponents/notifications/NotificationLog"], function (require, exports, React, NotificationLog_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var NotificationsComponent = (function (_super) {
        __extends(NotificationsComponent, _super);
        function NotificationsComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "Notifications";
            return _this;
        }
        NotificationsComponent.prototype.render = function () {
            return (React.DOM.div({
                className: "notifications-container",
            }, NotificationLog_2.default({
                log: this.props.log,
                currentTurn: this.props.currentTurn,
                key: "log",
            })));
        };
        return NotificationsComponent;
    }(React.Component));
    exports.NotificationsComponent = NotificationsComponent;
    var Factory = React.createFactory(NotificationsComponent);
    exports.default = Factory;
});
define("src/uicomponents/possibleactions/AttackTarget", ["require", "exports", "react", "src/eventManager", "src/uicomponents/PlayerFlag", "localization/localize"], function (require, exports, React, eventManager_22, PlayerFlag_5, localize_23) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AttackTargetComponent = (function (_super) {
        __extends(AttackTargetComponent, _super);
        function AttackTargetComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "AttackTarget";
            _this.bindMethods();
            return _this;
        }
        AttackTargetComponent.prototype.bindMethods = function () {
            this.handleAttack = this.handleAttack.bind(this);
        };
        AttackTargetComponent.prototype.handleAttack = function () {
            eventManager_22.default.dispatchEvent("attackTarget", this.props.attackTarget);
        };
        AttackTargetComponent.prototype.render = function () {
            var target = this.props.attackTarget;
            return (React.DOM.button({
                className: "attack-target-button possible-action",
                onClick: this.handleAttack,
                title: localize_23.localizeF("attackTargetTooltip").format({
                    enemyName: target.enemy.name.getPossessive(),
                    targetType: target.type,
                }),
            }, React.DOM.span({
                className: "possible-action-title",
            }, localize_23.localize("attackTarget_imperative")), PlayerFlag_5.default({
                flag: target.enemy.flag,
                props: {
                    className: "attack-target-player-flag",
                },
            })));
        };
        return AttackTargetComponent;
    }(React.Component));
    exports.AttackTargetComponent = AttackTargetComponent;
    var Factory = React.createFactory(AttackTargetComponent);
    exports.default = Factory;
});
define("src/uicomponents/mixins/UpdateWhenMoneyChanges", ["require", "exports", "src/eventManager"], function (require, exports, eventManager_23) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var UpdateWhenMoneyChanges = (function () {
        function UpdateWhenMoneyChanges(owner, onMoneyChange) {
            this.owner = owner;
            this.onMoneyChange = onMoneyChange;
            this.handleMoneyChange = this.handleMoneyChange.bind(this);
        }
        UpdateWhenMoneyChanges.prototype.componentDidMount = function () {
            eventManager_23.default.addEventListener("playerMoneyUpdated", this.handleMoneyChange);
        };
        UpdateWhenMoneyChanges.prototype.componentWillUnmount = function () {
            eventManager_23.default.removeEventListener("playerMoneyUpdated", this.handleMoneyChange);
        };
        UpdateWhenMoneyChanges.prototype.handleMoneyChange = function () {
            if (this.onMoneyChange) {
                this.onMoneyChange();
            }
            else {
                this.owner.setState({ money: this.owner.props.player.money });
            }
        };
        return UpdateWhenMoneyChanges;
    }());
    exports.default = UpdateWhenMoneyChanges;
});
define("src/uicomponents/possibleactions/BuildableBuilding", ["require", "exports", "react", "src/uicomponents/mixins/UpdateWhenMoneyChanges", "src/uicomponents/mixins/applyMixins"], function (require, exports, React, UpdateWhenMoneyChanges_1, applyMixins_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BuildableBuildingComponent = (function (_super) {
        __extends(BuildableBuildingComponent, _super);
        function BuildableBuildingComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "BuildableBuilding";
            _this.state = _this.getInitialStateTODO();
            _this.bindMethods();
            applyMixins_8.default(_this, new UpdateWhenMoneyChanges_1.default(_this, _this.overrideHandleMoneyChange));
            return _this;
        }
        BuildableBuildingComponent.prototype.bindMethods = function () {
            this.overrideHandleMoneyChange = this.overrideHandleMoneyChange.bind(this);
            this.makeCell = this.makeCell.bind(this);
        };
        BuildableBuildingComponent.prototype.getInitialStateTODO = function () {
            return ({
                canAfford: this.props.player.money >= this.props.buildCost,
            });
        };
        BuildableBuildingComponent.prototype.overrideHandleMoneyChange = function () {
            this.setState({
                canAfford: this.props.player.money >= this.props.buildCost,
            });
        };
        BuildableBuildingComponent.prototype.makeCell = function (type) {
            var cellProps = {};
            cellProps.key = type;
            cellProps.className = "buildable-building-list-item-cell " + type;
            var cellContent;
            switch (type) {
                case "buildCost":
                    {
                        cellContent = this.props.buildCost;
                        if (!this.state.canAfford) {
                            cellProps.className += " negative";
                        }
                        break;
                    }
                case "typeName":
                    {
                        cellContent = this.props.typeName;
                        break;
                    }
            }
            return (React.DOM.td(cellProps, cellContent));
        };
        BuildableBuildingComponent.prototype.render = function () {
            var template = this.props.template;
            var cells = [];
            var columns = this.props.activeColumns;
            for (var i = 0; i < columns.length; i++) {
                cells.push(this.makeCell(columns[i].key));
            }
            var props = {
                className: "buildable-item buildable-building",
                onClick: this.props.handleClick,
                title: template.description,
            };
            if (!this.state.canAfford) {
                props.onClick = null;
                props.className += " disabled";
            }
            return (React.DOM.tr(props, cells));
        };
        return BuildableBuildingComponent;
    }(React.Component));
    exports.BuildableBuildingComponent = BuildableBuildingComponent;
    var Factory = React.createFactory(BuildableBuildingComponent);
    exports.default = Factory;
});
define("src/uicomponents/possibleactions/BuildableBuildingList", ["require", "exports", "react", "src/Building", "src/uicomponents/list/List", "src/uicomponents/possibleactions/BuildableBuilding", "localization/localize"], function (require, exports, React, Building_2, List_3, BuildableBuilding_1, localize_24) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BuildableBuildingListComponent = (function (_super) {
        __extends(BuildableBuildingListComponent, _super);
        function BuildableBuildingListComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "BuildableBuildingList";
            _this.state = _this.getInitialStateTODO();
            _this.bindMethods();
            return _this;
        }
        BuildableBuildingListComponent.prototype.bindMethods = function () {
            this.buildBuilding = this.buildBuilding.bind(this);
            this.updateBuildings = this.updateBuildings.bind(this);
        };
        BuildableBuildingListComponent.prototype.getInitialStateTODO = function () {
            return ({
                buildingTemplates: this.props.star.getBuildableBuildings(),
            });
        };
        BuildableBuildingListComponent.prototype.updateBuildings = function () {
            var buildingTemplates = this.props.star.getBuildableBuildings();
            this.setState({
                buildingTemplates: buildingTemplates,
            });
            if (buildingTemplates.length < 1) {
                this.props.clearExpandedAction();
            }
        };
        BuildableBuildingListComponent.prototype.buildBuilding = function (rowItem) {
            var template = rowItem.content.props.template;
            var building = new Building_2.default({
                template: template,
                location: this.props.star,
            });
            if (!building.controller) {
                building.controller = this.props.player;
            }
            this.props.star.addBuilding(building);
            building.controller.money -= template.buildCost;
            this.updateBuildings();
        };
        BuildableBuildingListComponent.prototype.render = function () {
            if (this.state.buildingTemplates.length < 1)
                return null;
            var rows = [];
            for (var i = 0; i < this.state.buildingTemplates.length; i++) {
                var template = this.state.buildingTemplates[i];
                rows.push({
                    key: template.type,
                    content: BuildableBuilding_1.default({
                        template: template,
                        typeName: template.displayName,
                        buildCost: template.buildCost,
                        player: this.props.player,
                    }),
                });
            }
            var columns = [
                {
                    label: localize_24.localize("buildingTypeName"),
                    key: "typeName",
                    defaultOrder: "asc",
                },
                {
                    label: localize_24.localize("buildingCost"),
                    key: "buildCost",
                    defaultOrder: "desc",
                },
            ];
            return (React.DOM.div({ className: "buildable-item-list buildable-building-list fixed-table-parent" }, List_3.default({
                listItems: rows,
                initialColumns: columns,
                onRowChange: this.buildBuilding,
                addSpacer: true,
            })));
        };
        return BuildableBuildingListComponent;
    }(React.Component));
    exports.BuildableBuildingListComponent = BuildableBuildingListComponent;
    var Factory = React.createFactory(BuildableBuildingListComponent);
    exports.default = Factory;
});
define("src/uicomponents/possibleactions/BuildingUpgradeListItem", ["require", "exports", "react", "src/uicomponents/mixins/UpdateWhenMoneyChanges", "src/uicomponents/mixins/applyMixins"], function (require, exports, React, UpdateWhenMoneyChanges_2, applyMixins_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BuildingUpgradeListItemComponent = (function (_super) {
        __extends(BuildingUpgradeListItemComponent, _super);
        function BuildingUpgradeListItemComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "BuildingUpgradeListItem";
            _this.state = _this.getInitialStateTODO();
            _this.bindMethods();
            applyMixins_9.default(_this, new UpdateWhenMoneyChanges_2.default(_this, _this.overrideHandleMoneyChange));
            return _this;
        }
        BuildingUpgradeListItemComponent.prototype.bindMethods = function () {
            this.handleClick = this.handleClick.bind(this);
            this.overrideHandleMoneyChange = this.overrideHandleMoneyChange.bind(this);
        };
        BuildingUpgradeListItemComponent.prototype.getInitialStateTODO = function () {
            return ({
                canAfford: this.props.player.money >= this.props.upgradeData.cost,
            });
        };
        BuildingUpgradeListItemComponent.prototype.overrideHandleMoneyChange = function () {
            this.setState({
                canAfford: this.props.player.money >= this.props.upgradeData.cost,
            });
        };
        BuildingUpgradeListItemComponent.prototype.handleClick = function () {
            this.props.handleUpgrade(this.props.upgradeData);
        };
        BuildingUpgradeListItemComponent.prototype.render = function () {
            var upgradeData = this.props.upgradeData;
            var rowProps = {
                key: upgradeData.template.type,
                className: "building-upgrade-list-item",
                onClick: this.handleClick,
                title: upgradeData.template.description,
            };
            var costProps = {
                key: "cost",
                className: "building-upgrade-list-item-cost",
            };
            if (!this.state.canAfford) {
                rowProps.onClick = null;
                rowProps.disabled = true;
                rowProps.className += " disabled";
                costProps.className += " negative";
            }
            return (React.DOM.tr(rowProps, React.DOM.td({
                key: "name",
                className: "building-upgrade-list-item-name",
            }, upgradeData.template.displayName + " " + (upgradeData.level > 1 ? upgradeData.level : "")), React.DOM.td(costProps, upgradeData.cost)));
        };
        return BuildingUpgradeListItemComponent;
    }(React.Component));
    exports.BuildingUpgradeListItemComponent = BuildingUpgradeListItemComponent;
    var Factory = React.createFactory(BuildingUpgradeListItemComponent);
    exports.default = Factory;
});
define("src/uicomponents/possibleactions/BuildingUpgradeList", ["require", "exports", "react", "src/Building", "src/uicomponents/possibleactions/BuildingUpgradeListItem"], function (require, exports, React, Building_3, BuildingUpgradeListItem_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BuildingUpgradeListComponent = (function (_super) {
        __extends(BuildingUpgradeListComponent, _super);
        function BuildingUpgradeListComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "BuildingUpgradeList";
            _this.bindMethods();
            return _this;
        }
        BuildingUpgradeListComponent.prototype.bindMethods = function () {
            this.hasAvailableUpgrades = this.hasAvailableUpgrades.bind(this);
            this.upgradeBuilding = this.upgradeBuilding.bind(this);
        };
        BuildingUpgradeListComponent.prototype.hasAvailableUpgrades = function () {
            var possibleUpgrades = this.props.star.getBuildingUpgrades();
            return Object.keys(possibleUpgrades).length > 0;
        };
        BuildingUpgradeListComponent.prototype.upgradeBuilding = function (upgradeData) {
            var star = upgradeData.parentBuilding.location;
            var newBuilding = new Building_3.default({
                template: upgradeData.template,
                location: star,
                controller: upgradeData.parentBuilding.controller,
                upgradeLevel: upgradeData.level,
                totalCost: upgradeData.parentBuilding.totalCost + upgradeData.cost,
            });
            star.removeBuilding(upgradeData.parentBuilding);
            star.addBuilding(newBuilding);
            upgradeData.parentBuilding.controller.money -= upgradeData.cost;
            if (!this.hasAvailableUpgrades()) {
                this.props.clearExpandedAction();
            }
            else {
                this.forceUpdate();
            }
        };
        BuildingUpgradeListComponent.prototype.render = function () {
            if (!this.hasAvailableUpgrades())
                return null;
            var upgradeGroups = [];
            var possibleUpgrades = this.props.star.getBuildingUpgrades();
            var sortedParentBuildings = Object.keys(possibleUpgrades).sort(function (aId, bId) {
                var a = possibleUpgrades[aId][0].parentBuilding.template.displayName;
                var b = possibleUpgrades[bId][0].parentBuilding.template.displayName;
                if (a < b)
                    return -1;
                else if (a > b)
                    return 1;
                else
                    return 0;
            });
            for (var i = 0; i < sortedParentBuildings.length; i++) {
                var parentBuildingId = sortedParentBuildings[i];
                var upgrades = possibleUpgrades[parentBuildingId];
                var parentBuilding = upgrades[0].parentBuilding;
                var upgradeElements = [];
                for (var j = 0; j < upgrades.length; j++) {
                    if (j > 0) {
                        upgradeElements.push(React.DOM.tr({
                            className: "list-spacer",
                            key: "spacer" + i + j,
                        }, React.DOM.td({
                            colSpan: 20,
                        }, null)));
                    }
                    ;
                    upgradeElements.push(BuildingUpgradeListItem_1.default({
                        key: upgrades[j].template.type,
                        player: this.props.player,
                        handleUpgrade: this.upgradeBuilding,
                        upgradeData: upgrades[j],
                    }));
                }
                var parentElement = React.DOM.div({
                    key: "" + parentBuilding.id,
                    className: "building-upgrade-group",
                }, React.DOM.div({
                    className: "building-upgrade-group-header",
                }, parentBuilding.template.displayName), React.DOM.table({
                    className: "buildable-item-list",
                }, React.DOM.tbody({}, upgradeElements)));
                upgradeGroups.push(parentElement);
            }
            return (React.DOM.ul({
                className: "building-upgrade-list",
            }, upgradeGroups));
        };
        return BuildingUpgradeListComponent;
    }(React.Component));
    exports.BuildingUpgradeListComponent = BuildingUpgradeListComponent;
    var Factory = React.createFactory(BuildingUpgradeListComponent);
    exports.default = Factory;
});
define("src/uicomponents/possibleactions/PossibleActions", ["require", "exports", "react", "src/eventManager", "src/uicomponents/possibleactions/AttackTarget", "src/uicomponents/possibleactions/BuildableBuildingList", "src/uicomponents/possibleactions/BuildingUpgradeList", "localization/localize"], function (require, exports, React, eventManager_24, AttackTarget_1, BuildableBuildingList_1, BuildingUpgradeList_1, localize_25) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PossibleActionsComponent = (function (_super) {
        __extends(PossibleActionsComponent, _super);
        function PossibleActionsComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "PossibleActions";
            _this.state = _this.getInitialStateTODO();
            _this.bindMethods();
            return _this;
        }
        PossibleActionsComponent.prototype.bindMethods = function () {
            this.buildBuildings = this.buildBuildings.bind(this);
            this.canUpgradeBuildings = this.canUpgradeBuildings.bind(this);
            this.clearExpandedAction = this.clearExpandedAction.bind(this);
            this.handlePlayerBuiltBuilding = this.handlePlayerBuiltBuilding.bind(this);
            this.updateActions = this.updateActions.bind(this);
            this.upgradeBuildings = this.upgradeBuildings.bind(this);
        };
        PossibleActionsComponent.prototype.getInitialStateTODO = function () {
            return ({
                expandedAction: null,
                expandedActionElement: null,
                canUpgradeBuildings: this.canUpgradeBuildings(this.props.selectedStar),
            });
        };
        PossibleActionsComponent.prototype.componentWillReceiveProps = function (newProps) {
            if (this.props.selectedStar !== newProps.selectedStar) {
                var newState = {};
                var afterStateSetCallback = void 0;
                newState.canUpgradeBuildings = this.canUpgradeBuildings(newProps.selectedStar);
                if (this.state.expandedActionElement) {
                    newState.expandedAction = null;
                    newState.expandedActionElement = null;
                    afterStateSetCallback = this.updateActions;
                }
                this.setState(newState, afterStateSetCallback);
            }
        };
        PossibleActionsComponent.prototype.componentDidMount = function () {
            eventManager_24.default.addEventListener("clearPossibleActions", this.clearExpandedAction);
            eventManager_24.default.addEventListener("humanPlayerBuiltBuilding", this.handlePlayerBuiltBuilding);
        };
        PossibleActionsComponent.prototype.componentWillUnmount = function () {
            eventManager_24.default.removeAllListeners("clearPossibleActions");
            eventManager_24.default.removeEventListener("humanPlayerBuiltBuilding", this.handlePlayerBuiltBuilding);
        };
        PossibleActionsComponent.prototype.canUpgradeBuildings = function (star) {
            return star && Object.keys(star.getBuildingUpgrades()).length > 0;
        };
        PossibleActionsComponent.prototype.handlePlayerBuiltBuilding = function () {
            this.setState({
                canUpgradeBuildings: this.canUpgradeBuildings(this.props.selectedStar),
            });
        };
        PossibleActionsComponent.prototype.updateActions = function () {
            this.props.setExpandedActionElementOnParent(this.state.expandedActionElement);
            eventManager_24.default.dispatchEvent("possibleActionsUpdated");
        };
        PossibleActionsComponent.prototype.clearExpandedAction = function () {
            this.setState({
                expandedAction: null,
                expandedActionElement: null,
            }, this.updateActions);
        };
        PossibleActionsComponent.prototype.buildBuildings = function () {
            if (!this.props.selectedStar ||
                this.state.expandedAction === "buildBuildings") {
                this.clearExpandedAction();
            }
            else {
                var element = React.DOM.div({
                    className: "expanded-action",
                }, BuildableBuildingList_1.default({
                    player: this.props.player,
                    star: this.props.selectedStar,
                    clearExpandedAction: this.clearExpandedAction,
                }));
                this.setState({
                    expandedAction: "buildBuildings",
                    expandedActionElement: element,
                }, this.updateActions);
            }
        };
        PossibleActionsComponent.prototype.upgradeBuildings = function () {
            if (!this.props.selectedStar ||
                this.state.expandedAction === "upgradeBuildings") {
                this.clearExpandedAction();
            }
            else {
                var element = React.DOM.div({
                    className: "expanded-action",
                }, BuildingUpgradeList_1.default({
                    player: this.props.player,
                    star: this.props.selectedStar,
                    clearExpandedAction: this.clearExpandedAction,
                }));
                this.setState({
                    expandedAction: "upgradeBuildings",
                    expandedActionElement: element,
                }, this.updateActions);
            }
        };
        PossibleActionsComponent.prototype.render = function () {
            var allActions = [];
            if (this.props.attackTargets) {
                allActions.push.apply(allActions, this.props.attackTargets.map(function (attackTarget) {
                    return AttackTarget_1.default({
                        key: attackTarget.enemy.id,
                        attackTarget: attackTarget,
                    });
                }));
            }
            var star = this.props.selectedStar;
            if (star) {
                if (star.owner === this.props.player) {
                    if (star.getBuildableBuildings().length > 0) {
                        allActions.push(React.DOM.button({
                            className: "possible-action",
                            onClick: this.buildBuildings,
                            key: "buildActions",
                        }, localize_25.localize("constructBuilding")));
                    }
                    if (this.state.canUpgradeBuildings) {
                        allActions.push(React.DOM.button({
                            className: "possible-action",
                            onClick: this.upgradeBuildings,
                            key: "upgradeActions",
                        }, localize_25.localize("upgradeBuilding")));
                    }
                }
            }
            if (allActions.length < 1) {
                return null;
            }
            var possibleActions = React.DOM.div({
                className: "possible-actions",
            }, allActions);
            return (React.DOM.div({
                className: "possible-actions-wrapper",
            }, React.DOM.div({
                className: "possible-actions-container" +
                    (this.state.expandedAction ? " has-expanded-action" : ""),
            }, possibleActions)));
        };
        return PossibleActionsComponent;
    }(React.Component));
    exports.PossibleActionsComponent = PossibleActionsComponent;
    var Factory = React.createFactory(PossibleActionsComponent);
    exports.default = Factory;
});
define("src/tutorials/IntroTutorial", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var IntroTutorial = {
        pages: [
            {
                content: [
                    "Thanks for checking out spacegame!",
                    "",
                    "This game is still heavily in development. Many things are unfinished or unimplemented, including a proper tutorial.",
                ],
            },
            {
                content: [
                    "To get started, click on \"Production\" in the top menu. ",
                    "",
                    "Click on a ship type on the right of the production window to add it to your build queue. ",
                    "Units in the queue are built at the end of each turn. ",
                    "",
                    "You can end your turn by clicking the \"End turn\" button at the bottom right of the main window.",
                ],
            },
            {
                content: [
                    "Built units are assigned to fleets on the map. ",
                    "",
                    "To select fleets, drag a rectangle over them on the map or click on the fleet icon. ",
                    "Selected fleets can be moved by right-clicking.",
                    "",
                    "To move the camera, drag the map while holding down middle mouse button or while holding down ctrl/cmd + right click.",
                    "Touchscreen devices aren't supported yet, sorry.",
                ],
            },
            {
                content: [
                    "To start a battle, move your fleet to a star containing hostile fleets and click on \"attack\" button in the bottom left of the main window.",
                    "",
                    "In the battle setup screen, drag units from the unit list on the right into the formation on the bottom left or click the \"Auto formation\" button.",
                    "",
                    "To use abilities in battle, hover over the unit you want to target and select the ability to use.",
                ],
            },
        ],
    };
    exports.default = IntroTutorial;
});
define("src/tutorials/TutorialState", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TutorialState;
    (function (TutorialState) {
        TutorialState[TutorialState["NeverShow"] = -1] = "NeverShow";
        TutorialState[TutorialState["DontShowThisSession"] = 0] = "DontShowThisSession";
        TutorialState[TutorialState["Show"] = 1] = "Show";
    })(TutorialState || (TutorialState = {}));
    exports.default = TutorialState;
});
define("src/tutorials/TutorialStatus", ["require", "exports", "src/tutorials/TutorialState"], function (require, exports, TutorialState_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var defaultTutorialStatus = {
        introTutorial: TutorialState_1.default.Show,
    };
    var TutorialStatus = (function () {
        function TutorialStatus() {
            this.setDefaultValues();
        }
        TutorialStatus.prototype.setDefaultValues = function () {
            this.introTutorial = defaultTutorialStatus.introTutorial;
        };
        TutorialStatus.prototype.setDefaultValuesForUndefined = function () {
            this.introTutorial = isFinite(this.introTutorial) ? this.introTutorial : defaultTutorialStatus.introTutorial;
        };
        TutorialStatus.prototype.save = function () {
            localStorage.setItem("Rance.TutorialStatus", JSON.stringify(this.serialize()));
        };
        TutorialStatus.prototype.load = function () {
            this.setDefaultValues();
            if (!localStorage["Rance.TutorialStatus"]) {
                return;
            }
            var parsedData = JSON.parse(localStorage.getItem("Rance.TutorialStatus"));
            this.deSerialize(parsedData);
        };
        TutorialStatus.prototype.reset = function () {
            localStorage.removeItem("Rance.TutorialStatus");
            this.setDefaultValues();
        };
        TutorialStatus.prototype.serialize = function () {
            return ({
                introTutorial: this.introTutorial,
            });
        };
        TutorialStatus.getDeSerializedState = function (state) {
            return state === TutorialState_1.default.DontShowThisSession ? TutorialState_1.default.Show : state;
        };
        TutorialStatus.prototype.deSerialize = function (data) {
            this.introTutorial = TutorialStatus.getDeSerializedState(data.introTutorial);
            this.setDefaultValuesForUndefined();
        };
        return TutorialStatus;
    }());
    var tutorialStatus = new TutorialStatus();
    exports.default = tutorialStatus;
});
define("src/uicomponents/tutorials/DontShowAgain", ["require", "exports", "react", "src/tutorials/TutorialState", "src/tutorials/TutorialStatus", "localization/localize"], function (require, exports, React, TutorialState_2, TutorialStatus_1, localize_26) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DontShowAgainComponent = (function (_super) {
        __extends(DontShowAgainComponent, _super);
        function DontShowAgainComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "DontShowAgain";
            _this.state = _this.getInitialStateTODO();
            _this.bindMethods();
            return _this;
        }
        DontShowAgainComponent.prototype.bindMethods = function () {
            this.toggleState = this.toggleState.bind(this);
            this.getTutorialState = this.getTutorialState.bind(this);
        };
        DontShowAgainComponent.prototype.getInitialStateTODO = function () {
            return ({
                isChecked: this.getTutorialState() === TutorialState_2.default.NeverShow,
            });
        };
        DontShowAgainComponent.prototype.getTutorialState = function () {
            return TutorialStatus_1.default[this.props.tutorialId];
        };
        DontShowAgainComponent.prototype.toggleState = function () {
            if (this.state.isChecked) {
                TutorialStatus_1.default[this.props.tutorialId] = TutorialState_2.default.Show;
            }
            else {
                TutorialStatus_1.default[this.props.tutorialId] = TutorialState_2.default.NeverShow;
            }
            TutorialStatus_1.default.save();
            this.setState({
                isChecked: !this.state.isChecked,
            });
        };
        DontShowAgainComponent.prototype.render = function () {
            return (React.DOM.div({
                className: "dont-show-again-wrapper",
            }, React.DOM.label(null, React.DOM.input({
                type: "checkBox",
                className: "dont-show-again",
                checked: this.state.isChecked,
                onChange: this.toggleState,
            }), localize_26.localize("dontShowAgain"))));
        };
        return DontShowAgainComponent;
    }(React.Component));
    exports.DontShowAgainComponent = DontShowAgainComponent;
    var Factory = React.createFactory(DontShowAgainComponent);
    exports.default = Factory;
});
define("src/uicomponents/tutorials/Tutorial", ["require", "exports", "react", "src/tutorials/TutorialState", "src/tutorials/TutorialStatus", "src/utility", "src/utility", "src/uicomponents/tutorials/DontShowAgain"], function (require, exports, React, TutorialState_3, TutorialStatus_2, utility_31, utility_32, DontShowAgain_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TutorialComponent = (function (_super) {
        __extends(TutorialComponent, _super);
        function TutorialComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "Tutorial";
            _this.state = _this.getInitialStateTODO();
            _this.bindMethods();
            return _this;
        }
        TutorialComponent.prototype.bindMethods = function () {
            this.handleEnterPage = this.handleEnterPage.bind(this);
            this.flipPage = this.flipPage.bind(this);
            this.handleLeavePage = this.handleLeavePage.bind(this);
            this.handleClose = this.handleClose.bind(this);
        };
        TutorialComponent.prototype.getInitialStateTODO = function () {
            return ({
                currentPageIndex: 0,
            });
        };
        TutorialComponent.prototype.componentDidMount = function () {
            this.handleEnterPage(this.props.pages[this.state.currentPageIndex]);
        };
        TutorialComponent.prototype.componentWillUnmount = function () {
            this.handleLeavePage(this.props.pages[this.state.currentPageIndex]);
            this.handleClose();
        };
        TutorialComponent.prototype.handleEnterPage = function (page) {
            if (page.onOpen) {
                page.onOpen();
            }
            if (page.desiredSize) {
            }
        };
        TutorialComponent.prototype.handleLeavePage = function (page) {
            if (page.onClose) {
                page.onClose();
            }
            if (page.desiredSize) {
            }
        };
        TutorialComponent.prototype.flipPage = function (amount) {
            var lastPage = this.props.pages.length - 1;
            var newPage = this.state.currentPageIndex + amount;
            newPage = utility_31.clamp(newPage, 0, lastPage);
            this.handleLeavePage(this.props.pages[this.state.currentPageIndex]);
            this.setState({
                currentPageIndex: newPage,
            }, this.handleEnterPage.bind(this, this.props.pages[newPage]));
        };
        TutorialComponent.prototype.handleClose = function () {
            if (TutorialStatus_2.default[this.props.tutorialId] === TutorialState_3.default.Show) {
                TutorialStatus_2.default[this.props.tutorialId] = TutorialState_3.default.DontShowThisSession;
            }
        };
        TutorialComponent.prototype.render = function () {
            var hasBackArrow = this.state.currentPageIndex > 0;
            var backElement;
            if (hasBackArrow) {
                backElement = React.DOM.div({
                    className: "tutorial-flip-page tutorial-flip-page-back",
                    onClick: this.flipPage.bind(this, -1),
                });
            }
            else {
                backElement = React.DOM.div({
                    className: "tutorial-flip-page disabled",
                });
            }
            var hasForwardArrow = this.state.currentPageIndex < this.props.pages.length - 1;
            var forwardElement;
            if (hasForwardArrow) {
                forwardElement = React.DOM.div({
                    className: "tutorial-flip-page tutorial-flip-page-forward",
                    onClick: this.flipPage.bind(this, 1),
                });
            }
            else {
                forwardElement = React.DOM.div({
                    className: "tutorial-flip-page disabled",
                });
            }
            return (React.DOM.div({
                className: "tutorial",
            }, React.DOM.div({
                className: "tutorial-inner",
            }, backElement, React.DOM.div({
                className: "tutorial-content",
            }, utility_32.splitMultilineText(this.props.pages[this.state.currentPageIndex].content)), forwardElement), DontShowAgain_1.default({
                tutorialId: this.props.tutorialId,
            })));
        };
        return TutorialComponent;
    }(React.Component));
    exports.TutorialComponent = TutorialComponent;
    var Factory = React.createFactory(TutorialComponent);
    exports.default = Factory;
});
define("src/uicomponents/tutorials/IntroTutorial", ["require", "exports", "react", "src/tutorials/IntroTutorial", "src/tutorials/TutorialState", "src/tutorials/TutorialStatus", "src/uicomponents/windows/DefaultWindow", "src/uicomponents/tutorials/Tutorial"], function (require, exports, React, IntroTutorial_1, TutorialState_4, TutorialStatus_3, DefaultWindow_5, Tutorial_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var IntroTutorialComponent = (function (_super) {
        __extends(IntroTutorialComponent, _super);
        function IntroTutorialComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "IntroTutorial";
            _this.popupId = null;
            _this.state =
                {
                    shouldShow: TutorialStatus_3.default.introTutorial === TutorialState_4.default.Show,
                };
            return _this;
        }
        IntroTutorialComponent.prototype.render = function () {
            var _this = this;
            if (!this.state.shouldShow) {
                return null;
            }
            return (DefaultWindow_5.default({
                title: "Tutorial",
                handleClose: function () {
                    _this.setState({ shouldShow: false });
                },
                minWidth: 300,
                minHeight: 250,
            }, Tutorial_1.default({
                pages: IntroTutorial_1.default.pages,
                tutorialId: "introTutorial",
            })));
        };
        return IntroTutorialComponent;
    }(React.Component));
    exports.IntroTutorialComponent = IntroTutorialComponent;
    var Factory = React.createFactory(IntroTutorialComponent);
    exports.default = Factory;
});
define("src/uicomponents/galaxymap/FleetUnitInfoName", ["require", "exports", "react", "localization/localize"], function (require, exports, React, localize_27) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var FleetUnitInfoNameComponent = (function (_super) {
        __extends(FleetUnitInfoNameComponent, _super);
        function FleetUnitInfoNameComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "FleetUnitInfoName";
            _this.state = _this.getInitialStateTODO();
            _this.bindMethods();
            return _this;
        }
        FleetUnitInfoNameComponent.prototype.bindMethods = function () {
            this.onChange = this.onChange.bind(this);
        };
        FleetUnitInfoNameComponent.prototype.getInitialStateTODO = function () {
            return ({
                inputElementValue: this.props.unit.name,
            });
        };
        FleetUnitInfoNameComponent.prototype.onChange = function (e) {
            var target = e.currentTarget;
            this.setState({ inputElementValue: target.value });
            this.props.unit.name = target.value;
        };
        FleetUnitInfoNameComponent.prototype.render = function () {
            return (React.DOM.input({
                className: "fleet-unit-info-name",
                value: this.props.isNotDetected ? localize_27.localize("unidentifiedShip") : this.state.inputElementValue,
                onChange: this.props.isNotDetected ? null : this.onChange,
                readOnly: this.props.isNotDetected,
            }));
        };
        return FleetUnitInfoNameComponent;
    }(React.Component));
    exports.FleetUnitInfoNameComponent = FleetUnitInfoNameComponent;
    var Factory = React.createFactory(FleetUnitInfoNameComponent);
    exports.default = Factory;
});
define("src/uicomponents/galaxymap/FleetUnitInfo", ["require", "exports", "react", "src/uicomponents/unit/UnitStrength", "src/uicomponents/galaxymap/FleetUnitInfoName", "src/uicomponents/mixins/DragPositioner", "src/uicomponents/mixins/applyMixins"], function (require, exports, React, UnitStrength_3, FleetUnitInfoName_1, DragPositioner_8, applyMixins_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var FleetUnitInfoComponent = (function (_super) {
        __extends(FleetUnitInfoComponent, _super);
        function FleetUnitInfoComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "FleetUnitInfo";
            _this.bindMethods();
            if (_this.props.isDraggable) {
                _this.dragPositioner = new DragPositioner_8.default(_this);
                _this.dragPositioner.onDragStart = _this.onDragStart;
                _this.dragPositioner.onDragEnd = _this.onDragEnd;
                applyMixins_10.default(_this, _this.dragPositioner);
            }
            return _this;
        }
        FleetUnitInfoComponent.prototype.bindMethods = function () {
            this.onDragEnd = this.onDragEnd.bind(this);
            this.onDragStart = this.onDragStart.bind(this);
        };
        FleetUnitInfoComponent.prototype.onDragStart = function () {
            this.props.onDragStart(this.props.unit);
        };
        FleetUnitInfoComponent.prototype.onDragEnd = function () {
            this.props.onDragEnd();
        };
        FleetUnitInfoComponent.prototype.render = function () {
            var unit = this.props.unit;
            var isNotDetected = !this.props.isIdentified;
            var divProps = {
                className: "fleet-unit-info",
            };
            if (this.props.isDraggable) {
                divProps.className += " draggable";
                divProps.onTouchStart = divProps.onMouseDown =
                    this.dragPositioner.handleReactDownEvent;
                if (this.dragPositioner.isDragging) {
                    divProps.style = this.dragPositioner.getStyleAttributes();
                    divProps.className += " dragging";
                }
            }
            return (React.DOM.div(divProps, React.DOM.div({
                className: "fleet-unit-info-icon-container",
            }, React.DOM.img({
                className: "fleet-unit-info-icon",
                src: isNotDetected ? "img/icons/unDetected.png" : unit.template.icon,
            })), React.DOM.div({
                className: "fleet-unit-info-info",
            }, FleetUnitInfoName_1.default({
                unit: unit,
                isNotDetected: isNotDetected,
            }), React.DOM.div({
                className: "fleet-unit-info-type",
            }, isNotDetected ? "???" : unit.template.displayName)), UnitStrength_3.default({
                maxHealth: unit.maxHealth,
                currentHealth: unit.currentHealth,
                isSquadron: true,
                isNotDetected: isNotDetected,
            })));
        };
        return FleetUnitInfoComponent;
    }(React.Component));
    exports.FleetUnitInfoComponent = FleetUnitInfoComponent;
    var Factory = React.createFactory(FleetUnitInfoComponent);
    exports.default = Factory;
});
define("src/uicomponents/galaxymap/FleetContents", ["require", "exports", "react", "src/uicomponents/galaxymap/FleetUnitInfo"], function (require, exports, React, FleetUnitInfo_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var FleetContentsComponent = (function (_super) {
        __extends(FleetContentsComponent, _super);
        function FleetContentsComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "FleetContents";
            _this.bindMethods();
            return _this;
        }
        FleetContentsComponent.prototype.bindMethods = function () {
            this.handleMouseUp = this.handleMouseUp.bind(this);
        };
        FleetContentsComponent.prototype.handleMouseUp = function () {
            if (!this.props.onMouseUp)
                return;
            this.props.onMouseUp(this.props.fleet);
        };
        FleetContentsComponent.prototype.render = function () {
            var fleetUnitInfos = [];
            var fleet = this.props.fleet;
            var hasDraggableContent = Boolean(this.props.onDragStart ||
                this.props.onDragEnd);
            for (var i = 0; i < fleet.units.length; i++) {
                var unit = fleet.units[i];
                fleetUnitInfos.push(FleetUnitInfo_1.default({
                    key: unit.id,
                    unit: unit,
                    isDraggable: hasDraggableContent,
                    onDragStart: this.props.onDragStart,
                    onDragEnd: this.props.onDragEnd,
                    isIdentified: this.props.player.unitIsIdentified(unit),
                }));
            }
            if (hasDraggableContent) {
                fleetUnitInfos.push(React.DOM.div({
                    className: "fleet-contents-dummy-unit",
                    key: "dummy",
                }));
            }
            return (React.DOM.div({
                className: "fleet-contents",
                onMouseUp: this.handleMouseUp,
            }, fleetUnitInfos));
        };
        return FleetContentsComponent;
    }(React.Component));
    exports.FleetContentsComponent = FleetContentsComponent;
    var Factory = React.createFactory(FleetContentsComponent);
    exports.default = Factory;
});
define("src/uicomponents/galaxymap/FleetControls", ["require", "exports", "react", "src/eventManager", "localization/localize"], function (require, exports, React, eventManager_25, localize_28) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var FleetControlsComponent = (function (_super) {
        __extends(FleetControlsComponent, _super);
        function FleetControlsComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "FleetControls";
            _this.bindMethods();
            return _this;
        }
        FleetControlsComponent.prototype.bindMethods = function () {
            this.deselectFleet = this.deselectFleet.bind(this);
            this.selectFleet = this.selectFleet.bind(this);
            this.splitFleet = this.splitFleet.bind(this);
        };
        FleetControlsComponent.prototype.deselectFleet = function () {
            eventManager_25.default.dispatchEvent("deselectFleet", this.props.fleet);
        };
        FleetControlsComponent.prototype.selectFleet = function () {
            eventManager_25.default.dispatchEvent("selectFleets", [this.props.fleet]);
        };
        FleetControlsComponent.prototype.splitFleet = function () {
            eventManager_25.default.dispatchEvent("splitFleet", this.props.fleet);
        };
        FleetControlsComponent.prototype.render = function () {
            var fleet = this.props.fleet;
            var splitButtonProps = {
                className: "fleet-controls-split",
            };
            if (fleet.units.length > 1 && !this.props.isInspecting) {
                splitButtonProps.onClick = this.splitFleet;
            }
            else {
                splitButtonProps.className += " disabled";
                splitButtonProps.disabled = true;
            }
            return (React.DOM.div({
                className: "fleet-controls",
            }, React.DOM.button(splitButtonProps, localize_28.localize("split_imperative")), React.DOM.button({
                className: "fleet-controls-deselect",
                onClick: this.deselectFleet,
            }, localize_28.localize("deselect_imperative")), !this.props.hasMultipleSelected ? null : React.DOM.button({
                className: "fleet-controls-select",
                onClick: this.selectFleet,
            }, localize_28.localize("select_imperative"))));
        };
        return FleetControlsComponent;
    }(React.Component));
    exports.FleetControlsComponent = FleetControlsComponent;
    var Factory = React.createFactory(FleetControlsComponent);
    exports.default = Factory;
});
define("src/uicomponents/galaxymap/FleetInfo", ["require", "exports", "react", "src/uicomponents/galaxymap/FleetControls", "localization/localize"], function (require, exports, React, FleetControls_1, localize_29) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var FleetInfoComponent = (function (_super) {
        __extends(FleetInfoComponent, _super);
        function FleetInfoComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "FleetInfo";
            _this.bindMethods();
            return _this;
        }
        FleetInfoComponent.prototype.setFleetName = function (e) {
            var target = e.currentTarget;
            this.props.fleet.name.customizeName(target.value);
            this.forceUpdate();
        };
        FleetInfoComponent.prototype.bindMethods = function () {
            this.setFleetName = this.setFleetName.bind(this);
        };
        FleetInfoComponent.prototype.render = function () {
            var fleet = this.props.fleet;
            var isNotDetected = this.props.isNotDetected;
            if (!fleet) {
                return null;
            }
            var totalCurrentHealth = fleet.getTotalCurrentHealth();
            var totalMaxHealth = fleet.getTotalMaxHealth();
            var healthRatio = totalCurrentHealth / totalMaxHealth;
            var critThreshhold = 0.3;
            var healthStatus = "";
            if (!isNotDetected && healthRatio <= critThreshhold) {
                healthStatus += " critical";
            }
            else if (!isNotDetected && totalCurrentHealth < totalMaxHealth) {
                healthStatus += " wounded";
            }
            return (React.DOM.div({
                className: "fleet-info" + (fleet.isStealthy ? " stealthy" : ""),
            }, React.DOM.div({
                className: "fleet-info-header",
            }, React.DOM.input({
                className: "fleet-info-name",
                value: isNotDetected ? "Unidentified fleet" : fleet.name.fullName,
                onChange: isNotDetected ? null : this.setFleetName,
                readOnly: isNotDetected,
            }), React.DOM.div({
                className: "fleet-info-strength",
            }, React.DOM.span({
                className: "fleet-info-strength-current" + healthStatus,
            }, isNotDetected ? "???" : totalCurrentHealth), React.DOM.span({
                className: "fleet-info-strength-max",
            }, isNotDetected ? "/???" : "/" + totalMaxHealth)), FleetControls_1.default({
                fleet: fleet,
                hasMultipleSelected: this.props.hasMultipleSelected,
                isInspecting: this.props.isInspecting,
            })), React.DOM.div({
                className: "fleet-info-move-points",
            }, isNotDetected ?
                localize_29.localize("movesRemaining") + ": ?/?" :
                localize_29.localize("movesRemaining") + ": " + fleet.getMinCurrentMovePoints() + "/" + fleet.getMinMaxMovePoints())));
        };
        return FleetInfoComponent;
    }(React.Component));
    exports.FleetInfoComponent = FleetInfoComponent;
    var Factory = React.createFactory(FleetInfoComponent);
    exports.default = Factory;
});
define("src/uicomponents/galaxymap/FleetReorganization", ["require", "exports", "react", "src/eventManager", "src/uicomponents/galaxymap/FleetContents", "localization/localize"], function (require, exports, React, eventManager_26, FleetContents_1, localize_30) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var FleetReorganizationComponent = (function (_super) {
        __extends(FleetReorganizationComponent, _super);
        function FleetReorganizationComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "FleetReorganization";
            _this.hasClosed = false;
            _this.state = _this.getInitialStateTODO();
            _this.bindMethods();
            return _this;
        }
        FleetReorganizationComponent.prototype.bindMethods = function () {
            this.handleDrop = this.handleDrop.bind(this);
            this.handleDragEnd = this.handleDragEnd.bind(this);
            this.handleClose = this.handleClose.bind(this);
            this.handleDragStart = this.handleDragStart.bind(this);
        };
        FleetReorganizationComponent.prototype.getInitialStateTODO = function () {
            return ({
                currentDragUnit: null,
            });
        };
        FleetReorganizationComponent.prototype.handleDragStart = function (unit) {
            this.setState({
                currentDragUnit: unit,
            });
        };
        FleetReorganizationComponent.prototype.handleDragEnd = function () {
            this.setState({
                currentDragUnit: null,
            });
        };
        FleetReorganizationComponent.prototype.handleDrop = function (fleet) {
            var draggingUnit = this.state.currentDragUnit;
            if (draggingUnit) {
                var oldFleet = draggingUnit.fleet;
                if (oldFleet !== fleet) {
                    oldFleet.transferUnit(fleet, draggingUnit);
                    eventManager_26.default.dispatchEvent("playerControlUpdated", null);
                }
            }
            this.handleDragEnd();
        };
        FleetReorganizationComponent.prototype.handleClose = function () {
            this.hasClosed = true;
            this.props.closeReorganization();
        };
        FleetReorganizationComponent.prototype.componentWillUnmount = function () {
            if (this.hasClosed)
                return;
            eventManager_26.default.dispatchEvent("endReorganizingFleets");
        };
        FleetReorganizationComponent.prototype.render = function () {
            var selectedFleets = this.props.fleets;
            if (!selectedFleets || selectedFleets.length < 1) {
                return null;
            }
            return (React.DOM.div({
                className: "fleet-reorganization",
            }, React.DOM.div({
                className: "fleet-reorganization-header",
            }, localize_30.localize("reorganizeFleets")), React.DOM.div({
                className: "fleet-reorganization-subheader",
            }, React.DOM.div({
                className: "fleet-reorganization-subheader-fleet-name" +
                    " fleet-reorganization-subheader-fleet-name-left",
            }, selectedFleets[0].name.fullName), React.DOM.div({
                className: "fleet-reorganization-subheader-center",
            }, null), React.DOM.div({
                className: "fleet-reorganization-subheader-fleet-name" +
                    " fleet-reorganization-subheader-fleet-name-right",
            }, selectedFleets[1].name.fullName)), React.DOM.div({
                className: "fleet-reorganization-contents",
            }, FleetContents_1.default({
                fleet: selectedFleets[0],
                onMouseUp: this.handleDrop,
                onDragStart: this.handleDragStart,
                onDragEnd: this.handleDragEnd,
                player: selectedFleets[0].player,
            }), React.DOM.div({
                className: "fleet-reorganization-contents-divider",
            }, null), FleetContents_1.default({
                fleet: selectedFleets[1],
                onMouseUp: this.handleDrop,
                onDragStart: this.handleDragStart,
                onDragEnd: this.handleDragEnd,
                player: selectedFleets[0].player,
            })), React.DOM.div({
                className: "fleet-reorganization-footer",
            }, React.DOM.button({
                className: "close-reorganization",
                onClick: this.handleClose,
            }, localize_30.localize("close")))));
        };
        return FleetReorganizationComponent;
    }(React.Component));
    exports.FleetReorganizationComponent = FleetReorganizationComponent;
    var Factory = React.createFactory(FleetReorganizationComponent);
    exports.default = Factory;
});
define("src/uicomponents/galaxymap/FleetSelection", ["require", "exports", "react", "react-dom", "src/eventManager", "src/uicomponents/galaxymap/FleetContents", "src/uicomponents/galaxymap/FleetInfo", "src/uicomponents/galaxymap/FleetReorganization", "localization/localize"], function (require, exports, React, ReactDOM, eventManager_27, FleetContents_2, FleetInfo_1, FleetReorganization_1, localize_31) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var FleetSelectionComponent = (function (_super) {
        __extends(FleetSelectionComponent, _super);
        function FleetSelectionComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "FleetSelection";
            _this.bindMethods();
            return _this;
        }
        FleetSelectionComponent.prototype.bindMethods = function () {
            this.reorganizeFleets = this.reorganizeFleets.bind(this);
            this.mergeFleets = this.mergeFleets.bind(this);
            this.setElementPosition = this.setElementPosition.bind(this);
        };
        FleetSelectionComponent.prototype.mergeFleets = function () {
            eventManager_27.default.dispatchEvent("mergeFleets", null);
        };
        FleetSelectionComponent.prototype.reorganizeFleets = function () {
            eventManager_27.default.dispatchEvent("startReorganizingFleets", this.props.selectedFleets);
        };
        FleetSelectionComponent.prototype.setElementPosition = function () {
            if (!this.ref_TODO_selected)
                return;
            var domNode = ReactDOM.findDOMNode(this.ref_TODO_selected);
            if (!this.props.selectedStar) {
                domNode.style.left = "0";
            }
            else {
                var containerNode = document.getElementsByClassName("galaxy-map-ui-bottom-left")[0];
                var actionsNode = containerNode.firstChild.firstChild;
                var actionsRect = actionsNode.getBoundingClientRect();
                var rightMostNode = (containerNode.childElementCount > 1 ?
                    containerNode.lastChild.lastChild :
                    containerNode.lastChild);
                var rightMostRect = rightMostNode.getBoundingClientRect();
                var ownBottom = domNode.getBoundingClientRect().bottom;
                var first = ReactDOM.findDOMNode(this.ref_TODO_main).firstChild;
                if (ownBottom > actionsRect.top) {
                    var styleString = "" + (rightMostRect.right) + "px";
                    domNode.style.left = styleString;
                    first.style.left = styleString;
                    first.classList.add("fleet-selection-displaced");
                }
                else {
                    domNode.style.left = "0";
                    first.style.left = "0";
                    first.classList.remove("fleet-selection-displaced");
                }
            }
        };
        FleetSelectionComponent.prototype.componentDidMount = function () {
            this.setElementPosition();
            eventManager_27.default.addEventListener("possibleActionsUpdated", this.setElementPosition);
            window.addEventListener("resize", this.setElementPosition, false);
        };
        FleetSelectionComponent.prototype.componentDidUpdate = function () {
            this.setElementPosition();
        };
        FleetSelectionComponent.prototype.componentWillUnmount = function () {
            eventManager_27.default.removeEventListener("possibleActionsUpdated", this.setElementPosition);
            window.removeEventListener("resize", this.setElementPosition);
        };
        FleetSelectionComponent.prototype.render = function () {
            var _this = this;
            var selectedFleets = this.props.selectedFleets;
            if (!selectedFleets || selectedFleets.length <= 0) {
                return null;
            }
            var allFleetsInSameLocation = true;
            var hasMultipleSelected = selectedFleets.length >= 2;
            for (var i = 1; i < selectedFleets.length; i++) {
                if (selectedFleets[i].location !== selectedFleets[i - 1].location) {
                    allFleetsInSameLocation = false;
                    break;
                }
            }
            var fleetInfos = [];
            for (var i = 0; i < selectedFleets.length; i++) {
                var fleet = selectedFleets[i];
                fleetInfos.push(FleetInfo_1.default({
                    key: fleet.id,
                    fleet: fleet,
                    hasMultipleSelected: hasMultipleSelected,
                    isInspecting: this.props.isInspecting,
                    isNotDetected: this.props.isInspecting && !this.props.player.fleetIsFullyIdentified(fleet),
                }));
            }
            var fleetSelectionControls = null;
            if (hasMultipleSelected) {
                var fleetStealthsAreClashing = selectedFleets.length === 2 && selectedFleets[0].isStealthy !== selectedFleets[1].isStealthy;
                var mergeProps = {
                    className: "fleet-selection-controls-merge",
                };
                if (allFleetsInSameLocation && !this.props.isInspecting && !fleetStealthsAreClashing) {
                    mergeProps.onClick = this.mergeFleets;
                }
                else {
                    mergeProps.disabled = true;
                    mergeProps.className += " disabled";
                }
                var reorganizeProps = {
                    className: "fleet-selection-controls-reorganize",
                };
                if (allFleetsInSameLocation && selectedFleets.length === 2 && !this.props.isInspecting &&
                    !fleetStealthsAreClashing) {
                    reorganizeProps.onClick = this.reorganizeFleets;
                }
                else {
                    reorganizeProps.disabled = true;
                    reorganizeProps.className += " disabled";
                }
                fleetSelectionControls = React.DOM.div({
                    className: "fleet-selection-controls",
                }, React.DOM.button(reorganizeProps, localize_31.localize("reorganize")), React.DOM.button(mergeProps, localize_31.localize("merge")));
            }
            var fleetContents = null;
            if (!hasMultipleSelected) {
                fleetContents = FleetContents_2.default({
                    fleet: selectedFleets[0],
                    player: this.props.player,
                });
            }
            var isReorganizing = this.props.currentlyReorganizing.length > 0;
            var reorganizeElement = null;
            if (isReorganizing) {
                reorganizeElement = FleetReorganization_1.default({
                    fleets: this.props.currentlyReorganizing,
                    closeReorganization: this.props.closeReorganization,
                });
            }
            return (React.DOM.div({
                className: "fleet-selection",
                ref: function (component) {
                    _this.ref_TODO_main = component;
                },
            }, fleetSelectionControls, hasMultipleSelected ? null : fleetInfos, React.DOM.div({
                className: "fleet-selection-selected-wrapper",
            }, React.DOM.div({
                className: "fleet-selection-selected" + (isReorganizing ? " reorganizing" : ""),
                ref: function (component) {
                    _this.ref_TODO_selected = component;
                },
            }, hasMultipleSelected ? fleetInfos : null, fleetContents), reorganizeElement)));
        };
        return FleetSelectionComponent;
    }(React.Component));
    exports.FleetSelectionComponent = FleetSelectionComponent;
    var Factory = React.createFactory(FleetSelectionComponent);
    exports.default = Factory;
});
define("src/uicomponents/galaxymap/StarInfo", ["require", "exports", "react", "src/uicomponents/galaxymap/DefenceBuildingList", "localization/localize"], function (require, exports, React, DefenceBuildingList_2, localize_32) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var StarInfoComponent = (function (_super) {
        __extends(StarInfoComponent, _super);
        function StarInfoComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "StarInfo";
            return _this;
        }
        StarInfoComponent.prototype.shouldComponentUpdate = function (newProps) {
            return this.props.selectedStar !== newProps.selectedStar;
        };
        StarInfoComponent.prototype.render = function () {
            var star = this.props.selectedStar;
            if (!star)
                return null;
            return (React.DOM.div({
                className: "star-info",
            }, React.DOM.div({
                className: "star-info-name",
            }, star.name), React.DOM.div({
                className: "star-info-owner",
            }, star.owner ? star.owner.name.fullName : null), React.DOM.div({
                className: "star-info-location",
            }, "x:" + star.x.toFixed() + " y:" + star.y.toFixed()), React.DOM.div({
                className: "star-info-income",
            }, localize_32.localize("income") + ": " + star.getIncome()), DefenceBuildingList_2.default({
                buildings: star.buildings["defence"],
            })));
        };
        return StarInfoComponent;
    }(React.Component));
    exports.StarInfoComponent = StarInfoComponent;
    var Factory = React.createFactory(StarInfoComponent);
    exports.default = Factory;
});
define("src/uicomponents/galaxymap/PlayerMoney", ["require", "exports", "react", "src/eventManager", "localization/localize"], function (require, exports, React, eventManager_28, localize_33) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PlayerMoneyComponent = (function (_super) {
        __extends(PlayerMoneyComponent, _super);
        function PlayerMoneyComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "PlayerMoney";
            _this.lastAmountRendered = undefined;
            _this.bindMethods();
            return _this;
        }
        PlayerMoneyComponent.prototype.bindMethods = function () {
            this.handlePlayerMoneyUpdated = this.handlePlayerMoneyUpdated.bind(this);
        };
        PlayerMoneyComponent.prototype.componentDidMount = function () {
            eventManager_28.default.addEventListener("playerMoneyUpdated", this.handlePlayerMoneyUpdated);
        };
        PlayerMoneyComponent.prototype.componentWillUnmount = function () {
            eventManager_28.default.removeEventListener("playerMoneyUpdated", this.handlePlayerMoneyUpdated);
        };
        PlayerMoneyComponent.prototype.handlePlayerMoneyUpdated = function () {
            if (this.props.player.money !== this.lastAmountRendered) {
                this.forceUpdate();
            }
        };
        PlayerMoneyComponent.prototype.render = function () {
            this.lastAmountRendered = this.props.player.money;
            return (React.DOM.div({
                className: "player-money",
            }, localize_33.localize("money") + " " + this.props.player.money));
        };
        return PlayerMoneyComponent;
    }(React.Component));
    exports.PlayerMoneyComponent = PlayerMoneyComponent;
    var Factory = React.createFactory(PlayerMoneyComponent);
    exports.default = Factory;
});
define("src/uicomponents/galaxymap/Resource", ["require", "exports", "react"], function (require, exports, React) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ResourceComponent = (function (_super) {
        __extends(ResourceComponent, _super);
        function ResourceComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "Resource";
            return _this;
        }
        ResourceComponent.prototype.render = function () {
            var sign = this.props.income < 0 ? "-" : "+";
            return (React.DOM.div({
                className: "resource",
                title: this.props.resource.displayName + "",
            }, React.DOM.img({
                className: "resource-icon",
                src: this.props.resource.icon,
            }, null), React.DOM.div({
                className: "resource-amount",
            }, "" + this.props.amount + " (" + sign + this.props.income + ")")));
        };
        return ResourceComponent;
    }(React.Component));
    exports.ResourceComponent = ResourceComponent;
    var Factory = React.createFactory(ResourceComponent);
    exports.default = Factory;
});
define("src/uicomponents/galaxymap/TopBarResources", ["require", "exports", "react", "src/activeModuleData", "src/eventManager", "src/uicomponents/galaxymap/Resource"], function (require, exports, React, activeModuleData_21, eventManager_29, Resource_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TopBarResourcesComponent = (function (_super) {
        __extends(TopBarResourcesComponent, _super);
        function TopBarResourcesComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "TopBarResources";
            _this.updateListener = undefined;
            return _this;
        }
        TopBarResourcesComponent.prototype.componentDidMount = function () {
            this.updateListener = eventManager_29.default.addEventListener("builtBuildingWithEffect_resourceIncome", this.forceUpdate.bind(this));
        };
        TopBarResourcesComponent.prototype.componentWillUnmount = function () {
            eventManager_29.default.removeEventListener("builtBuildingWithEffect_resourceIncome", this.updateListener);
        };
        TopBarResourcesComponent.prototype.render = function () {
            var player = this.props.player;
            var resourceElements = [];
            var resourceIncome = player.getResourceIncome();
            var resourceTypes = Object.keys(player.resources);
            for (var resourceType in resourceIncome) {
                if (resourceTypes.indexOf(resourceType) === -1) {
                    resourceTypes.push(resourceType);
                }
            }
            for (var i = 0; i < resourceTypes.length; i++) {
                var resourceType = resourceTypes[i];
                var amount = player.resources[resourceType] || 0;
                var income = resourceIncome[resourceType].amount || 0;
                if (amount === 0 && income === 0)
                    continue;
                var resourceData = {
                    resource: activeModuleData_21.activeModuleData.Templates.Resources[resourceType],
                    amount: amount,
                    income: income,
                    key: resourceType,
                };
                resourceElements.push(Resource_1.default(resourceData));
            }
            return (React.DOM.div({
                className: "top-bar-resources",
            }, resourceElements));
        };
        return TopBarResourcesComponent;
    }(React.Component));
    exports.TopBarResourcesComponent = TopBarResourcesComponent;
    var Factory = React.createFactory(TopBarResourcesComponent);
    exports.default = Factory;
});
define("src/uicomponents/galaxymap/TopBar", ["require", "exports", "react", "src/eventManager", "src/uicomponents/PlayerFlag", "src/uicomponents/galaxymap/PlayerMoney", "src/uicomponents/galaxymap/TopBarResources", "localization/localize"], function (require, exports, React, eventManager_30, PlayerFlag_6, PlayerMoney_1, TopBarResources_1, localize_34) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TopBarComponent = (function (_super) {
        __extends(TopBarComponent, _super);
        function TopBarComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "TopBar";
            _this.updateListener = undefined;
            return _this;
        }
        TopBarComponent.prototype.componentDidMount = function () {
            this.updateListener = eventManager_30.default.addEventListener("builtBuildingWithEffect_income", this.forceUpdate.bind(this));
        };
        TopBarComponent.prototype.componentWillUnmount = function () {
            eventManager_30.default.removeEventListener("builtBuildingWithEffect_income", this.updateListener);
        };
        TopBarComponent.prototype.render = function () {
            var player = this.props.player;
            var income = player.getIncome();
            var incomeClass = "top-bar-money-income";
            if (income < 0)
                incomeClass += " negative";
            return (React.DOM.div({
                className: "top-bar",
            }, React.DOM.div({
                className: "top-bar-info",
            }, React.DOM.div({
                className: "top-bar-player",
            }, PlayerFlag_6.default({
                props: {
                    className: "top-bar-player-icon",
                },
                flag: player.flag,
            }), React.DOM.div({
                className: "top-bar-turn-number",
            }, localize_34.localize("turnCounter") + " " + this.props.game.turnNumber)), React.DOM.div({
                className: "top-bar-money",
            }, PlayerMoney_1.default({
                player: player,
            }), React.DOM.div({
                className: incomeClass,
            }, "(+" + player.getIncome() + ")")), TopBarResources_1.default({
                player: player,
            }))));
        };
        return TopBarComponent;
    }(React.Component));
    exports.TopBarComponent = TopBarComponent;
    var Factory = React.createFactory(TopBarComponent);
    exports.default = Factory;
});
define("src/uicomponents/trade/TradeMoney", ["require", "exports", "react", "src/uicomponents/mixins/DragPositioner", "src/uicomponents/mixins/applyMixins"], function (require, exports, React, DragPositioner_9, applyMixins_11) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TradeMoneyComponent = (function (_super) {
        __extends(TradeMoneyComponent, _super);
        function TradeMoneyComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "TradeMoney";
            _this.bindMethods();
            _this.dragPositioner = new DragPositioner_9.default(_this, _this.props.dragPositionerProps);
            _this.dragPositioner.onDragStart = _this.onDragStart;
            _this.dragPositioner.onDragEnd = _this.onDragEnd;
            applyMixins_11.default(_this, _this.dragPositioner);
            return _this;
        }
        TradeMoneyComponent.prototype.bindMethods = function () {
            this.handleClick = this.handleClick.bind(this);
            this.onDragEnd = this.onDragEnd.bind(this);
            this.captureEvent = this.captureEvent.bind(this);
            this.onDragStart = this.onDragStart.bind(this);
            this.handleMoneyAmountChange = this.handleMoneyAmountChange.bind(this);
        };
        TradeMoneyComponent.prototype.onDragStart = function () {
            this.props.onDragStart(this.props.keyTODO);
        };
        TradeMoneyComponent.prototype.onDragEnd = function () {
            this.props.onDragEnd();
        };
        TradeMoneyComponent.prototype.handleClick = function () {
            this.props.onClick(this.props.keyTODO);
        };
        TradeMoneyComponent.prototype.handleMoneyAmountChange = function (e) {
            var target = e.currentTarget;
            var value = parseInt(target.value);
            this.props.adjustItemAmount(this.props.keyTODO, value);
        };
        TradeMoneyComponent.prototype.captureEvent = function (e) {
            e.stopPropagation();
        };
        TradeMoneyComponent.prototype.render = function () {
            var rowProps = {
                className: "tradeable-items-list-item",
            };
            if (this.props.onDragStart) {
                rowProps.className += " draggable";
                rowProps.onMouseDown = rowProps.onTouchStart = this.dragPositioner.handleReactDownEvent;
                if (this.dragPositioner.isDragging) {
                    rowProps.style = this.dragPositioner.getStyleAttributes();
                    rowProps.className += " dragging";
                }
            }
            if (this.props.onClick) {
                rowProps.onClick = this.handleClick;
            }
            var moneyElement;
            if (this.props.adjustItemAmount) {
                var moneyProps = {
                    className: "trade-money-money-available trade-item-adjust",
                    type: "number",
                    min: 0,
                    max: this.props.maxMoneyAvailable,
                    step: 1,
                    value: "" + this.props.moneyAmount,
                    onChange: this.handleMoneyAmountChange,
                    onClick: this.captureEvent,
                    onMouseDown: this.captureEvent,
                    onTouchStart: this.captureEvent,
                };
                moneyElement = React.DOM.input(moneyProps);
            }
            else {
                moneyElement = React.DOM.span({
                    className: "trade-money-money-available",
                }, this.props.moneyAmount);
            }
            return (React.DOM.tr(rowProps, React.DOM.td(null, React.DOM.span({
                className: "trade-money-title",
            }, this.props.title), moneyElement)));
        };
        return TradeMoneyComponent;
    }(React.Component));
    exports.TradeMoneyComponent = TradeMoneyComponent;
    var Factory = React.createFactory(TradeMoneyComponent);
    exports.default = Factory;
});
define("src/uicomponents/trade/TradeableItemsList", ["require", "exports", "react", "src/uicomponents/trade/TradeMoney", "src/uicomponents/list/List", "localization/localize"], function (require, exports, React, TradeMoney_1, List_4, localize_35) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TradeableItemsListComponent = (function (_super) {
        __extends(TradeableItemsListComponent, _super);
        function TradeableItemsListComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "TradeableItemsList";
            _this.bindMethods();
            return _this;
        }
        TradeableItemsListComponent.prototype.bindMethods = function () {
            this.makeRowForTradeableItem = this.makeRowForTradeableItem.bind(this);
        };
        TradeableItemsListComponent.prototype.makeRowForTradeableItem = function (item) {
            switch (item.key) {
                case "money":
                    {
                        return ({
                            key: "money",
                            content: TradeMoney_1.default({
                                keyTODO: "money",
                                title: localize_35.localize("money"),
                                moneyAmount: item.amount,
                                onDragStart: this.props.onDragStart,
                                onDragEnd: this.props.onDragEnd,
                                onClick: this.props.onItemClick,
                                adjustItemAmount: this.props.adjustItemAmount,
                                maxMoneyAvailable: (this.props.availableItems && this.props.availableItems["money"]) ?
                                    this.props.availableItems["money"].amount : undefined,
                            }),
                        });
                    }
                default:
                    {
                        throw new Error("Unrecognized tradeable item key " + item.key);
                    }
            }
        };
        TradeableItemsListComponent.prototype.render = function () {
            var tradeableItems = this.props.tradeableItems;
            var rows = [];
            for (var key in tradeableItems) {
                rows.push(this.makeRowForTradeableItem(tradeableItems[key]));
            }
            var columns = [
                {
                    label: "Item",
                    key: "item",
                    defaultOrder: "asc",
                    sortingFunction: function (a, b) {
                        return (TradeableItemsListComponent.listItemSortOrder[a.content.props.keyTODO] -
                            TradeableItemsListComponent.listItemSortOrder[b.content.props.keyTODO]);
                    },
                },
            ];
            return (React.DOM.div({
                className: "tradeable-items-list fixed-table-parent",
            }, List_4.default({
                listItems: rows,
                initialColumns: columns,
                initialSortOrder: [columns[0]],
                noHeader: this.props.noListHeader,
            })));
        };
        TradeableItemsListComponent.listItemSortOrder = {
            money: 0,
        };
        return TradeableItemsListComponent;
    }(React.Component));
    exports.TradeableItemsListComponent = TradeableItemsListComponent;
    var Factory = React.createFactory(TradeableItemsListComponent);
    exports.default = Factory;
});
define("src/uicomponents/trade/TradeableItems", ["require", "exports", "react", "src/uicomponents/trade/TradeableItemsList"], function (require, exports, React, TradeableItemsList_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TradeableItemsComponent = (function (_super) {
        __extends(TradeableItemsComponent, _super);
        function TradeableItemsComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "TradeableItems";
            _this.bindMethods();
            return _this;
        }
        TradeableItemsComponent.prototype.bindMethods = function () {
            this.handleMouseUp = this.handleMouseUp.bind(this);
        };
        TradeableItemsComponent.prototype.handleMouseUp = function () {
            this.props.onMouseUp();
        };
        TradeableItemsComponent.prototype.render = function () {
            var divProps = {
                className: "tradeable-items",
            };
            if (this.props.onMouseUp) {
                divProps.onMouseUp = this.handleMouseUp;
            }
            if (this.props.isInvalidDropTarget) {
                divProps.className += " invalid-drop-target";
            }
            return (React.DOM.div(divProps, !this.props.header ? null : React.DOM.div({
                className: "tradeable-items-header",
            }, this.props.header), TradeableItemsList_1.default({
                tradeableItems: this.props.tradeableItems,
                availableItems: this.props.availableItems,
                noListHeader: this.props.noListHeader,
                onDragStart: this.props.onDragStart,
                onDragEnd: this.props.onDragEnd,
                onItemClick: this.props.onItemClick,
                adjustItemAmount: this.props.adjustItemAmount,
            })));
        };
        return TradeableItemsComponent;
    }(React.Component));
    exports.TradeableItemsComponent = TradeableItemsComponent;
    var Factory = React.createFactory(TradeableItemsComponent);
    exports.default = Factory;
});
define("src/uicomponents/trade/TradeOverview", ["require", "exports", "react", "src/uicomponents/trade/TradeableItems", "src/Trade", "localization/localize"], function (require, exports, React, TradeableItems_1, Trade_1, localize_36) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TradeOverviewComponent = (function (_super) {
        __extends(TradeOverviewComponent, _super);
        function TradeOverviewComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "TradeOverview";
            _this.selfTrade = TradeOverviewComponent.makeInitialTradeResponse(props.selfPlayer, props.otherPlayer);
            _this.otherTrade = props.initialReceivedOffer ||
                props.otherPlayer.AIController.respondToTradeOffer(_this.selfTrade);
            _this.state = _this.getInitialStateTODO();
            _this.bindMethods();
            return _this;
        }
        TradeOverviewComponent.makeInitialTradeResponse = function (selfPlayer, otherPlayer) {
            var ownTrade = new Trade_1.Trade(selfPlayer);
            var willingnessToTradeItems = {};
            for (var key in ownTrade.allItems) {
                willingnessToTradeItems[key] = 1;
            }
            return ({
                proposedOwnTrade: ownTrade,
                proposedReceivedOffer: new Trade_1.Trade(otherPlayer),
                willingnessToTradeItems: willingnessToTradeItems,
                message: "",
                willingToAccept: false,
            });
        };
        TradeOverviewComponent.prototype.bindMethods = function () {
            this.handleDragEnd = this.handleDragEnd.bind(this);
            this.handleStagingDragStart = this.handleStagingDragStart.bind(this);
            this.handleAvailableDragStart = this.handleAvailableDragStart.bind(this);
            this.handleRemoveStagedItem = this.handleRemoveStagedItem.bind(this);
            this.handleStageItem = this.handleStageItem.bind(this);
            this.handleAdjustStagedItemAmount = this.handleAdjustStagedItemAmount.bind(this);
            this.handleStagingAreaMouseUp = this.handleStagingAreaMouseUp.bind(this);
            this.handleAvailableMouseUp = this.handleAvailableMouseUp.bind(this);
            this.handleOk = this.handleOk.bind(this);
            this.handleCancel = this.handleCancel.bind(this);
            this.getActiveTradeObjectForPlayer = this.getActiveTradeObjectForPlayer.bind(this);
        };
        TradeOverviewComponent.prototype.getInitialStateTODO = function () {
            return ({
                currentDragItemKey: undefined,
                currentDragItemPlayer: undefined,
                currentDragItemWasStaged: undefined,
                activeTrade: this.props.initialReceivedOffer ? this.otherTrade : this.selfTrade,
            });
        };
        TradeOverviewComponent.prototype.handleCancel = function () {
            this.props.handleClose();
        };
        TradeOverviewComponent.prototype.handleOk = function () {
            var activeTrade = this.state.activeTrade;
            if (activeTrade) {
                activeTrade.proposedOwnTrade.executeTrade(activeTrade.proposedReceivedOffer);
                this.forceUpdate();
            }
        };
        TradeOverviewComponent.prototype.getActiveTradeObjectForPlayer = function (player) {
            if (player === "self") {
                return this.state.activeTrade.proposedOwnTrade;
            }
            else if (player === "other") {
                return this.state.activeTrade.proposedReceivedOffer;
            }
            else {
                throw new Error("Invalid player key '" + player + "'");
            }
        };
        TradeOverviewComponent.prototype.handleStageItem = function (player, key) {
            var activeTrade = this.getActiveTradeObjectForPlayer(player);
            var availableItems = activeTrade.getItemsAvailableForTrade();
            var availableAmount = availableItems[key].amount;
            if (availableAmount === 1) {
                activeTrade.stageItem(key, 1);
            }
            else {
                activeTrade.stageItem(key, availableAmount);
            }
            if (!this.state.currentDragItemPlayer) {
                this.forceUpdate();
            }
        };
        TradeOverviewComponent.prototype.handleAdjustStagedItemAmount = function (player, key, newAmount) {
            var activeTrade = this.getActiveTradeObjectForPlayer(player);
            {
                activeTrade.setStagedItemAmount(key, newAmount);
            }
            this.forceUpdate();
        };
        TradeOverviewComponent.prototype.handleRemoveStagedItem = function (player, key) {
            var activeTrade = this.getActiveTradeObjectForPlayer(player);
            activeTrade.removeStagedItem(key);
            if (!this.state.currentDragItemPlayer) {
                this.forceUpdate();
            }
        };
        TradeOverviewComponent.prototype.handleAvailableDragStart = function (player, key) {
            this.setState({
                currentDragItemKey: key,
                currentDragItemPlayer: player,
                currentDragItemWasStaged: false,
            });
        };
        TradeOverviewComponent.prototype.handleStagingDragStart = function (player, key) {
            this.setState({
                currentDragItemKey: key,
                currentDragItemPlayer: player,
                currentDragItemWasStaged: true,
            });
        };
        TradeOverviewComponent.prototype.handleDragEnd = function () {
            this.setState({
                currentDragItemKey: undefined,
                currentDragItemPlayer: undefined,
                currentDragItemWasStaged: undefined,
            });
        };
        TradeOverviewComponent.prototype.handleAvailableMouseUp = function () {
            if (this.state.currentDragItemKey && this.state.currentDragItemWasStaged) {
                this.handleRemoveStagedItem(null, this.state.currentDragItemKey);
            }
        };
        TradeOverviewComponent.prototype.handleStagingAreaMouseUp = function () {
            if (this.state.currentDragItemKey && !this.state.currentDragItemWasStaged) {
                this.handleStageItem(null, this.state.currentDragItemKey);
            }
        };
        TradeOverviewComponent.prototype.render = function () {
            var hasDragItem = Boolean(this.state.currentDragItemKey);
            var selfPlayerAcceptsDrop = this.state.currentDragItemPlayer === "self";
            var otherPlayerAcceptsDrop = this.state.currentDragItemPlayer === "other";
            var selfAvailableItems = this.state.activeTrade.proposedOwnTrade.getItemsAvailableForTrade();
            var otherAvailableItems = this.state.activeTrade.proposedReceivedOffer.getItemsAvailableForTrade();
            var lastOfferWasByOtherPlayer = this.state.activeTrade === this.otherTrade;
            var ableToAcceptTrade = lastOfferWasByOtherPlayer && this.state.activeTrade.willingToAccept;
            return (React.DOM.div({
                className: "trade-overview",
            }, React.DOM.div({
                className: "tradeable-items-container available-items-container",
            }, TradeableItems_1.default({
                header: localize_36.localize("tradeableItems") + " " + this.props.selfPlayer.name.fullName,
                tradeableItems: selfAvailableItems,
                noListHeader: true,
                isInvalidDropTarget: hasDragItem && !selfPlayerAcceptsDrop,
                onDragStart: this.handleAvailableDragStart.bind(this, "self"),
                onDragEnd: this.handleDragEnd,
                onMouseUp: this.handleAvailableMouseUp,
                onItemClick: this.handleStageItem.bind(this, "self"),
            }), TradeableItems_1.default({
                header: localize_36.localize("tradeableItems") + " " + this.props.otherPlayer.name.fullName,
                tradeableItems: otherAvailableItems,
                noListHeader: true,
                isInvalidDropTarget: hasDragItem && !otherPlayerAcceptsDrop,
                onDragStart: this.handleAvailableDragStart.bind(this, "other"),
                onDragEnd: this.handleDragEnd,
                onMouseUp: this.handleAvailableMouseUp,
                onItemClick: this.handleStageItem.bind(this, "other"),
            })), React.DOM.div({
                className: "tradeable-items-container trade-staging-areas-container",
            }, TradeableItems_1.default({
                tradeableItems: this.state.activeTrade.proposedOwnTrade.stagedItems,
                availableItems: this.state.activeTrade.proposedOwnTrade.allItems,
                noListHeader: true,
                isInvalidDropTarget: hasDragItem && !selfPlayerAcceptsDrop,
                onDragStart: this.handleStagingDragStart.bind(this, "self"),
                onDragEnd: this.handleDragEnd,
                onMouseUp: this.handleStagingAreaMouseUp,
                onItemClick: this.handleRemoveStagedItem.bind(this, "self"),
                adjustItemAmount: this.handleAdjustStagedItemAmount.bind(this, "self"),
            }), TradeableItems_1.default({
                tradeableItems: this.state.activeTrade.proposedReceivedOffer.stagedItems,
                availableItems: this.state.activeTrade.proposedReceivedOffer.allItems,
                noListHeader: true,
                isInvalidDropTarget: hasDragItem && !otherPlayerAcceptsDrop,
                onDragStart: this.handleStagingDragStart.bind(this, "other"),
                onDragEnd: this.handleDragEnd,
                onMouseUp: this.handleStagingAreaMouseUp,
                onItemClick: this.handleRemoveStagedItem.bind(this, "other"),
                adjustItemAmount: this.handleAdjustStagedItemAmount.bind(this, "other"),
            })), React.DOM.div({
                className: "trade-buttons-container tradeable-items-reset-buttons-container",
            }, React.DOM.button({
                className: "trade-button tradeable-items-reset-button",
            }, localize_36.localize("reset")), React.DOM.button({
                className: "trade-button tradeable-items-reset-button",
            }, localize_36.localize("reset"))), React.DOM.div({
                className: "trade-buttons-container trade-controls-container",
            }, React.DOM.button({
                className: "trade-button trade-control-button",
                disabled: !ableToAcceptTrade,
            }, localize_36.localize("reject")), ableToAcceptTrade ?
                React.DOM.button({
                    className: "trade-button trade-control-button",
                }, localize_36.localize("accept")) :
                React.DOM.button({
                    className: "trade-button trade-control-button",
                }, localize_36.localize("propose")))));
        };
        return TradeOverviewComponent;
    }(React.Component));
    exports.TradeOverviewComponent = TradeOverviewComponent;
    var Factory = React.createFactory(TradeOverviewComponent);
    exports.default = Factory;
});
define("src/uicomponents/diplomacy/DiplomacyActions", ["require", "exports", "react", "src/uicomponents/trade/TradeOverview", "src/uicomponents/windows/DefaultWindow", "localization/localize"], function (require, exports, React, TradeOverview_1, DefaultWindow_6, localize_37) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DiplomacyActionsComponent = (function (_super) {
        __extends(DiplomacyActionsComponent, _super);
        function DiplomacyActionsComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "DiplomacyActions";
            _this.state =
                {
                    hasTradePopup: false,
                };
            _this.bindMethods();
            return _this;
        }
        DiplomacyActionsComponent.prototype.render = function () {
            var player = this.props.player;
            var targetPlayer = this.props.targetPlayer;
            var declareWarProps = {
                className: "diplomacy-action-button",
            };
            if (player.diplomacyStatus.canDeclareWarOn(targetPlayer)) {
                declareWarProps.onClick = this.handleDeclareWar;
            }
            else {
                declareWarProps.disabled = true;
                declareWarProps.className += " disabled";
            }
            var makePeaceProps = {
                className: "diplomacy-action-button",
            };
            if (player.diplomacyStatus.canMakePeaceWith(targetPlayer)) {
                makePeaceProps.onClick = this.handleMakePeace;
            }
            else {
                makePeaceProps.disabled = true;
                makePeaceProps.className += " disabled";
            }
            return (React.DOM.div({
                className: "diplomacy-actions",
            }, React.DOM.button(declareWarProps, localize_37.localize("declareWar")), React.DOM.button(makePeaceProps, localize_37.localize("makePeace")), React.DOM.button({
                className: "diplomacy-action-button",
                onClick: this.toggleTradePopup,
            }, localize_37.localize("trade_imperative")), !this.state.hasTradePopup ? null :
                DefaultWindow_6.default({
                    handleClose: this.closeTradePopup,
                    title: localize_37.localize("trade_noun"),
                    minWidth: 150,
                    minHeight: 50,
                }, TradeOverview_1.default({
                    selfPlayer: this.props.player,
                    otherPlayer: this.props.targetPlayer,
                    handleClose: this.closeTradePopup,
                }))));
        };
        DiplomacyActionsComponent.prototype.bindMethods = function () {
            this.openTradePopup = this.openTradePopup.bind(this);
            this.closeTradePopup = this.closeTradePopup.bind(this);
            this.toggleTradePopup = this.toggleTradePopup.bind(this);
            this.handleMakePeace = this.handleMakePeace.bind(this);
            this.handleDeclareWar = this.handleDeclareWar.bind(this);
        };
        DiplomacyActionsComponent.prototype.openTradePopup = function () {
            this.setState({ hasTradePopup: true });
        };
        DiplomacyActionsComponent.prototype.closeTradePopup = function () {
            this.setState({ hasTradePopup: false });
        };
        DiplomacyActionsComponent.prototype.toggleTradePopup = function () {
            if (this.state.hasTradePopup) {
                this.closeTradePopup();
            }
            else {
                this.openTradePopup();
            }
        };
        DiplomacyActionsComponent.prototype.handleDeclareWar = function () {
            this.props.player.diplomacyStatus.declareWarOn(this.props.targetPlayer);
            this.props.onUpdate();
        };
        DiplomacyActionsComponent.prototype.handleMakePeace = function () {
            this.props.player.diplomacyStatus.makePeaceWith(this.props.targetPlayer);
            this.props.onUpdate();
        };
        return DiplomacyActionsComponent;
    }(React.Component));
    exports.DiplomacyActionsComponent = DiplomacyActionsComponent;
    var Factory = React.createFactory(DiplomacyActionsComponent);
    exports.default = Factory;
});
define("src/uicomponents/diplomacy/AttitudeModifierInfo", ["require", "exports", "react", "src/utility"], function (require, exports, React, utility_33) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AttitudeModifierInfoComponent = (function (_super) {
        __extends(AttitudeModifierInfoComponent, _super);
        function AttitudeModifierInfoComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "AttitudeModifierInfo";
            _this.bindMethods();
            return _this;
        }
        AttitudeModifierInfoComponent.prototype.bindMethods = function () {
            this.makeCell = this.makeCell.bind(this);
        };
        AttitudeModifierInfoComponent.prototype.makeCell = function (type) {
            var cellProps = {
                key: type,
                className: "attitude-modifier-info-cell" + " attitude-modifier-info-" + type,
            };
            var cellContent;
            switch (type) {
                case "name":
                    {
                        cellContent = this.props.name;
                        break;
                    }
                case "endTurn":
                    {
                        if (this.props.endTurn < 0) {
                            cellContent = null;
                        }
                        break;
                    }
                case "strength":
                    {
                        var relativeValue = utility_33.getRelativeValue(this.props.strength, -20, 20);
                        relativeValue = utility_33.clamp(relativeValue, 0, 1);
                        var deviation = Math.abs(0.5 - relativeValue) * 2;
                        var hue = 110 * relativeValue;
                        var saturation = 0 + 50 * deviation;
                        if (deviation > 0.3)
                            saturation += 40;
                        var lightness = 70 - 20 * deviation;
                        cellProps.style =
                            {
                                color: "hsl(" +
                                    hue + "," +
                                    saturation + "%," +
                                    lightness + "%)",
                            };
                        cellContent = this.props.strength;
                        break;
                    }
            }
            return (React.DOM.td(cellProps, cellContent));
        };
        AttitudeModifierInfoComponent.prototype.render = function () {
            var columns = this.props.activeColumns;
            var cells = [];
            for (var i = 0; i < columns.length; i++) {
                var cell = this.makeCell(columns[i].key);
                cells.push(cell);
            }
            return (React.DOM.tr({
                className: "attitude-modifier-info",
                onClick: this.props.handleClick,
            }, cells));
        };
        return AttitudeModifierInfoComponent;
    }(React.Component));
    exports.AttitudeModifierInfoComponent = AttitudeModifierInfoComponent;
    var Factory = React.createFactory(AttitudeModifierInfoComponent);
    exports.default = Factory;
});
define("src/uicomponents/mixins/AutoPositioner", ["require", "exports", "react-dom"], function (require, exports, ReactDOM) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AutoPositioner = (function () {
        function AutoPositioner(owner) {
            this.hasResizeListener = false;
            this.owner = owner;
            this.setAutoPosition = this.setAutoPosition.bind(this);
        }
        Object.defineProperty(AutoPositioner.prototype, "props", {
            get: function () {
                return this.owner.props.autoPositionerProps;
            },
            enumerable: true,
            configurable: true
        });
        AutoPositioner.prototype.componentDidMount = function () {
            this.setAutoPosition();
            if (this.props.positionOnResize) {
                window.addEventListener("resize", this.setAutoPosition, false);
                this.hasResizeListener = true;
            }
        };
        AutoPositioner.prototype.componentWillUnmount = function () {
            if (this.hasResizeListener) {
                window.removeEventListener("resize", this.setAutoPosition);
            }
        };
        AutoPositioner.prototype.componentDidUpdate = function () {
            if (this.props.positionOnUpdate) {
                this.setAutoPosition();
            }
        };
        AutoPositioner.prototype.setAutoPosition = function () {
            var parentRect = this.props.getParentClientRect();
            var ownNode = ReactDOM.findDOMNode(this.owner);
            var ownRect = ownNode.getBoundingClientRect();
            var ySide = this.props.ySide;
            var xSide = this.props.xSide;
            var yMargin = this.props.yMargin || 0;
            var xMargin = this.props.xMargin || 0;
            var top = null;
            var left = null;
            switch (ySide) {
                case "outerTop":
                    {
                        top = parentRect.top - ownRect.height - yMargin;
                        break;
                    }
                case "outerBottom":
                    {
                        top = parentRect.bottom + yMargin;
                        break;
                    }
                case "innerTop":
                    {
                        top = parentRect.top + yMargin;
                        break;
                    }
                case "innerBottom":
                    {
                        top = parentRect.bottom - ownRect.height - yMargin;
                        break;
                    }
            }
            switch (xSide) {
                case "outerLeft":
                    {
                        left = parentRect.left - ownRect.width - xMargin;
                        break;
                    }
                case "outerRight":
                    {
                        left = parentRect.right + xMargin;
                        break;
                    }
                case "innerLeft":
                    {
                        left = parentRect.left + xMargin;
                        break;
                    }
                case "innerRight":
                    {
                        left = parentRect.right - ownRect.width - xMargin;
                        break;
                    }
            }
            if (left < 0) {
                left = 0;
            }
            else if (left + ownRect.width > window.innerWidth) {
                left = left - (left + ownRect.width - window.innerWidth);
            }
            if (top < 0) {
                top = 0;
            }
            else if (top + ownRect.height > window.innerHeight) {
                top = top - (top + ownRect.height - window.innerHeight);
            }
            ownNode.style.left = "" + left + "px";
            ownNode.style.top = "" + top + "px";
        };
        return AutoPositioner;
    }());
    exports.default = AutoPositioner;
});
define("src/uicomponents/diplomacy/AttitudeModifierList", ["require", "exports", "react", "src/uicomponents/list/List", "src/uicomponents/diplomacy/AttitudeModifierInfo", "src/uicomponents/mixins/AutoPositioner", "src/uicomponents/mixins/applyMixins", "localization/localize"], function (require, exports, React, List_5, AttitudeModifierInfo_1, AutoPositioner_1, applyMixins_12, localize_38) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AttitudeModifierListComponent = (function (_super) {
        __extends(AttitudeModifierListComponent, _super);
        function AttitudeModifierListComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "AttitudeModifierList";
            if (_this.props.autoPositionerProps) {
                applyMixins_12.default(_this, new AutoPositioner_1.default(_this));
            }
            return _this;
        }
        AttitudeModifierListComponent.prototype.render = function () {
            var modifiers = this.props.attitudeModifiers;
            var rows = [];
            rows.push({
                key: "baseOpinion",
                content: AttitudeModifierInfo_1.default({
                    name: localize_38.localize("aiPersonality"),
                    strength: this.props.baseOpinion,
                    endTurn: -1,
                    alwaysShowAtTopOfList: true,
                }),
            });
            for (var i = 0; i < modifiers.length; i++) {
                var modifier = modifiers[i];
                if (modifier.isOverRidden)
                    continue;
                rows.push({
                    key: modifier.template.type,
                    content: AttitudeModifierInfo_1.default({
                        name: modifier.template.displayName,
                        strength: modifier.getAdjustedStrength(),
                        endTurn: modifier.endTurn,
                        alwaysShowAtTopOfList: false,
                    }),
                });
            }
            var columns = [
                {
                    label: localize_38.localize("displayName"),
                    key: "name",
                    defaultOrder: "asc",
                    sortingFunction: function (a, b) {
                        var forcedSortOrder = 0;
                        if (b.content.props.alwaysShowAtTopOfList) {
                            forcedSortOrder += 10;
                        }
                        if (a.content.props.alwaysShowAtTopOfList) {
                            forcedSortOrder -= 10;
                        }
                        var alphabeticSortOrder = 0;
                        if (b.content.props.name > a.content.props.name) {
                            alphabeticSortOrder -= 1;
                        }
                        else if (b.content.props.name < a.content.props.name) {
                            alphabeticSortOrder += 1;
                        }
                        return forcedSortOrder + alphabeticSortOrder;
                    },
                },
                {
                    label: localize_38.localize("attitudeModifierEffect"),
                    key: "strength",
                    defaultOrder: "asc",
                },
                {
                    label: localize_38.localize("endsOn"),
                    key: "endTurn",
                    defaultOrder: "desc",
                },
            ];
            return (React.DOM.div({ className: "attitude-modifier-list auto-position fixed-table-parent" }, List_5.default({
                listItems: rows,
                initialColumns: columns,
                initialSortOrder: [columns[0], columns[1], columns[2]],
            })));
        };
        return AttitudeModifierListComponent;
    }(React.Component));
    exports.AttitudeModifierListComponent = AttitudeModifierListComponent;
    var Factory = React.createFactory(AttitudeModifierListComponent);
    exports.default = Factory;
});
define("src/uicomponents/diplomacy/Opinion", ["require", "exports", "react", "react-dom", "src/utility", "src/uicomponents/diplomacy/AttitudeModifierList"], function (require, exports, React, ReactDOM, utility_34, AttitudeModifierList_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var OpinionComponent = (function (_super) {
        __extends(OpinionComponent, _super);
        function OpinionComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "Opinion";
            _this.state = _this.getInitialStateTODO();
            _this.bindMethods();
            return _this;
        }
        OpinionComponent.prototype.bindMethods = function () {
            this.getColor = this.getColor.bind(this);
            this.getOpinionTextNodeRect = this.getOpinionTextNodeRect.bind(this);
            this.setTooltip = this.setTooltip.bind(this);
            this.clearTooltip = this.clearTooltip.bind(this);
        };
        OpinionComponent.prototype.getInitialStateTODO = function () {
            return ({
                hasAttitudeModifierTootlip: false,
            });
        };
        OpinionComponent.prototype.setTooltip = function () {
            this.setState({ hasAttitudeModifierTootlip: true });
        };
        OpinionComponent.prototype.clearTooltip = function () {
            this.setState({ hasAttitudeModifierTootlip: false });
        };
        OpinionComponent.prototype.getOpinionTextNodeRect = function () {
            var firstChild = ReactDOM.findDOMNode(this).firstChild;
            return firstChild.getBoundingClientRect();
        };
        OpinionComponent.prototype.getColor = function () {
            var relativeValue = utility_34.getRelativeValue(this.props.opinion, -30, 30);
            relativeValue = utility_34.clamp(relativeValue, 0, 1);
            var deviation = Math.abs(0.5 - relativeValue) * 2;
            var hue = 110 * relativeValue;
            var saturation = 0 + 50 * deviation;
            if (deviation > 0.3)
                saturation += 40;
            var lightness = 70 - 20 * deviation;
            return ("hsl(" +
                hue + "," +
                saturation + "%," +
                lightness + "%)");
        };
        OpinionComponent.prototype.render = function () {
            var tooltip = null;
            if (this.state.hasAttitudeModifierTootlip) {
                tooltip = AttitudeModifierList_1.default({
                    attitudeModifiers: this.props.attitudeModifiers,
                    baseOpinion: this.props.baseOpinion,
                    autoPositionerProps: {
                        getParentClientRect: this.getOpinionTextNodeRect,
                        positionOnUpdate: true,
                        ySide: "outerTop",
                        xSide: "outerRight",
                        yMargin: 10,
                    },
                });
            }
            return (React.DOM.div({
                className: "player-opinion",
                onMouseEnter: this.setTooltip,
                onMouseLeave: this.clearTooltip,
            }, React.DOM.span({
                style: {
                    color: this.getColor(),
                },
            }, this.props.opinion), tooltip));
        };
        return OpinionComponent;
    }(React.Component));
    exports.OpinionComponent = OpinionComponent;
    var Factory = React.createFactory(OpinionComponent);
    exports.default = Factory;
});
define("src/uicomponents/diplomacy/DiplomaticStatusPlayer", ["require", "exports", "react", "src/uicomponents/PlayerFlag", "src/uicomponents/diplomacy/Opinion"], function (require, exports, React, PlayerFlag_7, Opinion_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DiplomaticStatusPlayerComponent = (function (_super) {
        __extends(DiplomaticStatusPlayerComponent, _super);
        function DiplomaticStatusPlayerComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "DiplomaticStatusPlayer";
            _this.state = _this.getInitialStateTODO();
            _this.bindMethods();
            return _this;
        }
        DiplomaticStatusPlayerComponent.prototype.bindMethods = function () {
            this.makeCell = this.makeCell.bind(this);
        };
        DiplomaticStatusPlayerComponent.prototype.getInitialStateTODO = function () {
            return ({
                hasAttitudeModifierTootlip: false,
            });
        };
        DiplomaticStatusPlayerComponent.prototype.makeCell = function (type) {
            var className = "diplomatic-status-player-cell" + " diplomatic-status-" + type;
            var cellContent = this.props[type];
            if (type === "player") {
                className += " player-name";
            }
            if (type === "flag" && this.props.flag) {
                cellContent = PlayerFlag_7.default({
                    flag: this.props.flag,
                    props: {
                        className: "diplomacy-status-player-icon",
                    },
                });
            }
            if (type === "opinion") {
                cellContent = Opinion_1.default({
                    attitudeModifiers: this.props.attitudeModifiers,
                    opinion: this.props.opinion,
                    baseOpinion: this.props.baseOpinion,
                });
            }
            return (React.DOM.td({
                key: type,
                className: className,
            }, cellContent));
        };
        DiplomaticStatusPlayerComponent.prototype.render = function () {
            var columns = this.props.activeColumns;
            var cells = [];
            for (var i = 0; i < columns.length; i++) {
                var cell = this.makeCell(columns[i].key);
                cells.push(cell);
            }
            var rowProps = {
                className: "diplomatic-status-player",
                onClick: this.props.canInteractWith ?
                    this.props.handleClick :
                    null,
            };
            if (!this.props.canInteractWith) {
                rowProps.className += " disabled";
            }
            return (React.DOM.tr(rowProps, cells));
        };
        return DiplomaticStatusPlayerComponent;
    }(React.Component));
    exports.DiplomaticStatusPlayerComponent = DiplomaticStatusPlayerComponent;
    var Factory = React.createFactory(DiplomaticStatusPlayerComponent);
    exports.default = Factory;
});
define("src/uicomponents/diplomacy/DiplomacyOverview", ["require", "exports", "react", "src/uicomponents/list/List", "src/uicomponents/diplomacy/DiplomacyActions", "src/uicomponents/diplomacy/DiplomaticStatusPlayer", "src/uicomponents/windows/DefaultWindow", "src/DiplomacyState", "localization/localize"], function (require, exports, React, List_6, DiplomacyActions_1, DiplomaticStatusPlayer_1, DefaultWindow_7, DiplomacyState_2, localize_39) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DiplomacyOverviewComponent = (function (_super) {
        __extends(DiplomacyOverviewComponent, _super);
        function DiplomacyOverviewComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "DiplomacyOverview";
            _this.state =
                {
                    playersWithOpenedDiplomacyActionsPopup: [],
                };
            _this.bindMethods();
            return _this;
        }
        DiplomacyOverviewComponent.prototype.render = function () {
            var _this = this;
            var metPlayers = this.props.player.diplomacyStatus.getMetPlayers();
            var alivePlayers = metPlayers.filter(function (player) { return !player.isDead; });
            var deadPlayers = metPlayers.filter(function (player) { return player.isDead; });
            var rows = alivePlayers.map(function (player) {
                var status = _this.props.player.diplomacyStatus.statusByPlayer.get(player);
                return ({
                    key: "" + player.id,
                    content: DiplomaticStatusPlayer_1.default({
                        player: player,
                        name: player.name.fullName,
                        status: DiplomacyState_2.default[status],
                        opinion: player.diplomacyStatus.getOpinionOf(_this.props.player),
                        flag: player.flag,
                        canInteractWith: _this.props.player.diplomacyStatus.canDoDiplomacyWithPlayer(player),
                        baseOpinion: player.diplomacyStatus.getBaseOpinion(),
                        statusSortingNumber: status,
                        attitudeModifiers: player.diplomacyStatus.attitudeModifiersByPlayer.get(_this.props.player),
                    }),
                });
            }).concat(deadPlayers.map(function (player) {
                return ({
                    key: "" + player.id,
                    content: DiplomaticStatusPlayer_1.default({
                        player: player,
                        name: player.name.fullName,
                        status: localize_39.localize("deadPlayer"),
                        opinion: null,
                        flag: player.flag,
                        canInteractWith: _this.props.player.diplomacyStatus.canDoDiplomacyWithPlayer(player),
                        statusSortingNumber: -99999,
                    }),
                });
            }));
            var columns = [
                {
                    label: "",
                    key: "flag",
                    defaultOrder: "asc",
                    notSortable: true,
                },
                {
                    label: localize_39.localize("displayName"),
                    key: "name",
                    defaultOrder: "asc",
                },
                {
                    label: localize_39.localize("diplomaticStatus"),
                    key: "status",
                    defaultOrder: "desc",
                    propToSortBy: "statusSortingNumber",
                },
                {
                    label: localize_39.localize("opinion"),
                    key: "opinion",
                    defaultOrder: "desc",
                },
            ];
            return (React.DOM.div({ className: "diplomacy-overview" }, this.state.playersWithOpenedDiplomacyActionsPopup.map(function (targetPlayer) {
                return DefaultWindow_7.default({
                    key: targetPlayer.id,
                    handleClose: _this.closeDiplomacyActionsPopup.bind(null, targetPlayer),
                    title: "" + targetPlayer.name,
                    isResizable: false,
                    minWidth: 200,
                    minHeight: 200,
                }, DiplomacyActions_1.default({
                    player: _this.props.player,
                    targetPlayer: targetPlayer,
                    onUpdate: _this.forceUpdate.bind(_this),
                }));
            }), React.DOM.div({ className: "diplomacy-status-list fixed-table-parent" }, List_6.default({
                listItems: rows,
                initialColumns: columns,
                initialSortOrder: [columns[2], columns[1]],
                onRowChange: this.toggleDiplomacyActionsPopup,
            }))));
        };
        DiplomacyOverviewComponent.prototype.bindMethods = function () {
            this.hasDiplomacyActionsPopup = this.hasDiplomacyActionsPopup.bind(this);
            this.openDiplomacyActionsPopup = this.openDiplomacyActionsPopup.bind(this);
            this.closeDiplomacyActionsPopup = this.closeDiplomacyActionsPopup.bind(this);
            this.toggleDiplomacyActionsPopup = this.toggleDiplomacyActionsPopup.bind(this);
        };
        DiplomacyOverviewComponent.prototype.hasDiplomacyActionsPopup = function (player) {
            return this.state.playersWithOpenedDiplomacyActionsPopup.indexOf(player) !== -1;
        };
        DiplomacyOverviewComponent.prototype.openDiplomacyActionsPopup = function (player) {
            this.setState({
                playersWithOpenedDiplomacyActionsPopup: this.state.playersWithOpenedDiplomacyActionsPopup.concat(player),
            });
        };
        DiplomacyOverviewComponent.prototype.closeDiplomacyActionsPopup = function (playerToCloseFor) {
            this.setState({
                playersWithOpenedDiplomacyActionsPopup: this.state.playersWithOpenedDiplomacyActionsPopup.filter(function (player) {
                    return player !== playerToCloseFor;
                }),
            });
        };
        DiplomacyOverviewComponent.prototype.toggleDiplomacyActionsPopup = function (rowItem) {
            var player = rowItem.content.props.player;
            if (this.hasDiplomacyActionsPopup(player)) {
                this.closeDiplomacyActionsPopup(player);
            }
            else {
                this.openDiplomacyActionsPopup(player);
            }
        };
        return DiplomacyOverviewComponent;
    }(React.Component));
    exports.DiplomacyOverviewComponent = DiplomacyOverviewComponent;
    var Factory = React.createFactory(DiplomacyOverviewComponent);
    exports.default = Factory;
});
define("src/uicomponents/production/ManufactoryUpgradeButton", ["require", "exports", "react"], function (require, exports, React) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ManufactoryUpgradeButtonComponent = (function (_super) {
        __extends(ManufactoryUpgradeButtonComponent, _super);
        function ManufactoryUpgradeButtonComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "ManufactoryUpgradeButton";
            return _this;
        }
        ManufactoryUpgradeButtonComponent.prototype.componentWillReceiveProps = function (newProps) {
            this.setState({
                canAffordUpgrade: newProps.money >= newProps.upgradeCost,
                isDisabled: newProps.currentLevel >= newProps.maxLevel,
            });
        };
        ManufactoryUpgradeButtonComponent.prototype.render = function () {
            var unitUpgradeButtonBaseClassName = "manufactory-upgrade-button";
            var unitUpgradeCostBaseClassName = "manufactory-upgrade-button-cost";
            var isAtMaxLevel = this.props.currentLevel >= this.props.maxLevel;
            var canAffordUpgrade = this.props.money >= this.props.upgradeCost;
            var isDisabled = isAtMaxLevel || !canAffordUpgrade;
            if (isDisabled) {
                unitUpgradeButtonBaseClassName += " disabled";
            }
            if (!canAffordUpgrade) {
                unitUpgradeCostBaseClassName += " negative";
            }
            return (React.DOM.button({
                className: unitUpgradeButtonBaseClassName + " manufactory-units-upgrade-health-button",
                onClick: (isDisabled ? null : this.props.onClick),
                disabled: isDisabled,
                title: this.props.title,
            }, React.DOM.span({
                className: "manufactory-upgrade-button-action",
            }, this.props.actionString), React.DOM.br(), React.DOM.span({
                className: "manufactory-upgrade-button-level",
            }, "" + this.props.currentLevel.toFixed(this.props.levelDecimalPoints) + "/" +
                this.props.maxLevel.toFixed(this.props.levelDecimalPoints)), React.DOM.span({
                className: unitUpgradeCostBaseClassName,
            }, this.props.upgradeCost)));
        };
        return ManufactoryUpgradeButtonComponent;
    }(React.Component));
    exports.ManufactoryUpgradeButtonComponent = ManufactoryUpgradeButtonComponent;
    var Factory = React.createFactory(ManufactoryUpgradeButtonComponent);
    exports.default = Factory;
});
define("src/uicomponents/production/ManufacturableThingsListItem", ["require", "exports", "react"], function (require, exports, React) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ManufacturableThingsListItemComponent = (function (_super) {
        __extends(ManufacturableThingsListItemComponent, _super);
        function ManufacturableThingsListItemComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "ManufacturableThingsListItem";
            _this.state = _this.getInitialStateTODO();
            _this.bindMethods();
            return _this;
        }
        ManufacturableThingsListItemComponent.prototype.bindMethods = function () {
            this.handleClick = this.handleClick.bind(this);
        };
        ManufacturableThingsListItemComponent.prototype.getInitialStateTODO = function () {
            return ({
                canAfford: this.props.money >= this.props.template.buildCost,
                isDisabled: !this.props.onClick,
            });
        };
        ManufacturableThingsListItemComponent.prototype.componentWillReceiveProps = function (newProps) {
            this.setState({
                canAfford: newProps.money >= newProps.template.buildCost,
                isDisabled: !newProps.onClick,
            });
        };
        ManufacturableThingsListItemComponent.prototype.handleClick = function () {
            if (this.props.onClick) {
                this.props.onClick(this.props.template, this.props.parentIndex);
            }
        };
        ManufacturableThingsListItemComponent.prototype.render = function () {
            var canAfford = this.props.money >= this.props.template.buildCost;
            var isDisabled = !Boolean(this.props.onClick) || (this.props.showCost && !canAfford);
            return (React.DOM.li({
                className: "manufacturable-things-list-item" + (isDisabled ? " disabled" : ""),
                onClick: (isDisabled ? null : this.handleClick),
                title: this.props.template.description,
            }, React.DOM.div({
                className: "manufacturable-things-list-item-name",
            }, this.props.template.displayName), !this.props.showCost ? null : React.DOM.div({
                className: "manufacturable-things-list-item-cost money-style" +
                    (canAfford ? "" : " negative"),
            }, this.props.template.buildCost)));
        };
        return ManufacturableThingsListItemComponent;
    }(React.Component));
    exports.ManufacturableThingsListItemComponent = ManufacturableThingsListItemComponent;
    var Factory = React.createFactory(ManufacturableThingsListItemComponent);
    exports.default = Factory;
});
define("src/uicomponents/production/ManufacturableThingsList", ["require", "exports", "react", "src/uicomponents/production/ManufacturableThingsListItem"], function (require, exports, React, ManufacturableThingsListItem_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ManufacturableThingsListComponent = (function (_super) {
        __extends(ManufacturableThingsListComponent, _super);
        function ManufacturableThingsListComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "ManufacturableThingsList";
            return _this;
        }
        ManufacturableThingsListComponent.prototype.render = function () {
            var manufacturableThings = this.props.manufacturableThings;
            var items = [];
            var keyByTemplateType = {};
            for (var i = 0; i < manufacturableThings.length; i++) {
                var templateType = manufacturableThings[i].type;
                if (!keyByTemplateType[templateType]) {
                    keyByTemplateType[templateType] = 0;
                }
                items.push(ManufacturableThingsListItem_1.default({
                    template: manufacturableThings[i],
                    key: templateType + keyByTemplateType[templateType]++,
                    parentIndex: i,
                    onClick: this.props.onClick,
                    money: this.props.money,
                    showCost: this.props.showCost,
                }));
            }
            return (React.DOM.ol({
                className: "manufacturable-things-list",
            }, items));
        };
        return ManufacturableThingsListComponent;
    }(React.PureComponent));
    exports.ManufacturableThingsListComponent = ManufacturableThingsListComponent;
    var Factory = React.createFactory(ManufacturableThingsListComponent);
    exports.default = Factory;
});
define("src/uicomponents/production/BuildQueue", ["require", "exports", "react", "src/uicomponents/production/ManufactoryUpgradeButton", "src/uicomponents/production/ManufacturableThingsList", "localization/localize"], function (require, exports, React, ManufactoryUpgradeButton_1, ManufacturableThingsList_1, localize_40) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BuildQueueComponent = (function (_super) {
        __extends(BuildQueueComponent, _super);
        function BuildQueueComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "BuildQueue";
            _this.bindMethods();
            return _this;
        }
        BuildQueueComponent.prototype.removeItem = function (template, parentIndex) {
            var manufactory = this.props.manufactory;
            manufactory.removeThingAtIndex(parentIndex);
            this.props.triggerUpdate();
        };
        BuildQueueComponent.prototype.bindMethods = function () {
            this.removeItem = this.removeItem.bind(this);
            this.upgradeCapacity = this.upgradeCapacity.bind(this);
        };
        BuildQueueComponent.prototype.upgradeCapacity = function () {
            var manufactory = this.props.manufactory;
            manufactory.upgradeCapacity(1);
            this.props.triggerUpdate();
        };
        BuildQueueComponent.prototype.render = function () {
            var manufactory = this.props.manufactory;
            var convertedBuildQueue = [];
            for (var i = 0; i < manufactory.buildQueue.length; i++) {
                convertedBuildQueue.push(manufactory.buildQueue[i].template);
            }
            return (React.DOM.div({
                className: "build-queue",
            }, React.DOM.div({
                className: "manufactory-upgrade-buttons-container",
            }, ManufactoryUpgradeButton_1.default({
                money: this.props.money,
                upgradeCost: manufactory.getCapacityUpgradeCost(),
                onClick: this.upgradeCapacity,
                actionString: localize_40.localize("upgradeManufactoryCapacity"),
                currentLevel: manufactory.capacity,
                maxLevel: manufactory.maxCapacity,
                levelDecimalPoints: 0,
                title: localize_40.localize("upgradeManufactoryCapacityTooltip"),
            })), ManufacturableThingsList_1.default({
                manufacturableThings: convertedBuildQueue,
                onClick: this.removeItem,
                showCost: false,
                money: this.props.money,
            })));
        };
        return BuildQueueComponent;
    }(React.Component));
    exports.BuildQueueComponent = BuildQueueComponent;
    var Factory = React.createFactory(BuildQueueComponent);
    exports.default = Factory;
});
define("src/uicomponents/production/ConstructManufactory", ["require", "exports", "react", "src/activeModuleData", "localization/localize"], function (require, exports, React, activeModuleData_22, localize_41) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ConstructManufactoryComponent = (function (_super) {
        __extends(ConstructManufactoryComponent, _super);
        function ConstructManufactoryComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "ConstructManufactory";
            _this.state = _this.getInitialStateTODO();
            _this.bindMethods();
            return _this;
        }
        ConstructManufactoryComponent.prototype.bindMethods = function () {
            this.handleConstruct = this.handleConstruct.bind(this);
        };
        ConstructManufactoryComponent.prototype.getInitialStateTODO = function () {
            return ({
                canAfford: this.props.money >= activeModuleData_22.activeModuleData.ruleSet.manufactory.buildCost,
            });
        };
        ConstructManufactoryComponent.prototype.componentWillReceiveProps = function (newProps) {
            this.setState({
                canAfford: newProps.money >= activeModuleData_22.activeModuleData.ruleSet.manufactory.buildCost,
            });
        };
        ConstructManufactoryComponent.prototype.handleConstruct = function () {
            var star = this.props.star;
            var player = this.props.player;
            star.buildManufactory();
            player.money -= activeModuleData_22.activeModuleData.ruleSet.manufactory.buildCost;
            this.props.triggerUpdate();
        };
        ConstructManufactoryComponent.prototype.render = function () {
            return (React.DOM.div({
                className: "construct-manufactory-container",
            }, React.DOM.button({
                className: "construct-manufactory-button" + (this.state.canAfford ? "" : " disabled"),
                onClick: this.state.canAfford ? this.handleConstruct : null,
                disabled: !this.state.canAfford,
            }, React.DOM.span({
                className: "construct-manufactory-action",
            }, localize_41.localize("constructManufactory")), React.DOM.span({
                className: "construct-manufactory-cost money-style" +
                    (this.state.canAfford ? "" : " negative"),
            }, activeModuleData_22.activeModuleData.ruleSet.manufactory.buildCost))));
        };
        return ConstructManufactoryComponent;
    }(React.PureComponent));
    exports.ConstructManufactoryComponent = ConstructManufactoryComponent;
    var Factory = React.createFactory(ConstructManufactoryComponent);
    exports.default = Factory;
});
define("src/uicomponents/production/ManufactoryStarsListItem", ["require", "exports", "react"], function (require, exports, React) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ManufactoryStarsListItemComponent = (function (_super) {
        __extends(ManufactoryStarsListItemComponent, _super);
        function ManufactoryStarsListItemComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "ManufactoryStarsListItem";
            _this.bindMethods();
            return _this;
        }
        ManufactoryStarsListItemComponent.prototype.bindMethods = function () {
            this.handleClick = this.handleClick.bind(this);
        };
        ManufactoryStarsListItemComponent.prototype.handleClick = function () {
            var star = this.props.star;
            this.props.onClick(star);
        };
        ManufactoryStarsListItemComponent.prototype.render = function () {
            var hasManufactory = Boolean(this.props.totalCapacity);
            var hasCapacity = hasManufactory && this.props.usedCapacity < this.props.totalCapacity;
            return (React.DOM.div({
                className: "manufactory-stars-list-item" +
                    (!hasManufactory ? " no-manufactory" : "") +
                    (this.props.isHighlighted ? " highlighted" : ""),
                onClick: this.handleClick,
            }, React.DOM.div({
                className: "manufactory-stars-list-item-star-name",
            }, this.props.star.name), !hasManufactory ? null : React.DOM.div({
                className: "manufactory-stars-list-item-capacity" + (!hasCapacity ? " no-capacity" : ""),
            }, "" + this.props.usedCapacity + "/" + this.props.totalCapacity)));
        };
        return ManufactoryStarsListItemComponent;
    }(React.Component));
    exports.ManufactoryStarsListItemComponent = ManufactoryStarsListItemComponent;
    var Factory = React.createFactory(ManufactoryStarsListItemComponent);
    exports.default = Factory;
});
define("src/uicomponents/production/ManufactoryStarsList", ["require", "exports", "react", "src/utility", "src/uicomponents/production/ManufactoryStarsListItem"], function (require, exports, React, utility_35, ManufactoryStarsListItem_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ManufactoryStarsListComponent = (function (_super) {
        __extends(ManufactoryStarsListComponent, _super);
        function ManufactoryStarsListComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "ManufactoryStarsList";
            return _this;
        }
        ManufactoryStarsListComponent.prototype.render = function () {
            var rows = [];
            this.props.starsWithManufactories.sort(utility_35.sortByManufactoryCapacityFN);
            this.props.starsWithoutManufactories.sort(utility_35.sortByManufactoryCapacityFN);
            for (var i = 0; i < this.props.starsWithManufactories.length; i++) {
                var star = this.props.starsWithManufactories[i];
                var manufactory = star.manufactory;
                var isHighlighted = this.props.highlightedStars.indexOf(star) !== -1;
                rows.push(ManufactoryStarsListItem_1.default({
                    key: star.id,
                    star: star,
                    isHighlighted: isHighlighted,
                    usedCapacity: manufactory.buildQueue.length,
                    totalCapacity: manufactory.capacity,
                    onClick: this.props.handleStarSelect,
                }));
            }
            for (var i = 0; i < this.props.starsWithoutManufactories.length; i++) {
                var star = this.props.starsWithoutManufactories[i];
                var isHighlighted = this.props.highlightedStars.indexOf(star) !== -1;
                rows.push(ManufactoryStarsListItem_1.default({
                    key: star.id,
                    star: star,
                    isHighlighted: isHighlighted,
                    usedCapacity: 0,
                    totalCapacity: 0,
                    onClick: this.props.handleStarSelect,
                }));
            }
            return (React.DOM.div({
                className: "manufactory-stars-list",
            }, rows));
        };
        return ManufactoryStarsListComponent;
    }(React.Component));
    exports.ManufactoryStarsListComponent = ManufactoryStarsListComponent;
    var Factory = React.createFactory(ManufactoryStarsListComponent);
    exports.default = Factory;
});
define("src/uicomponents/production/ManufacturableItems", ["require", "exports", "react", "src/uicomponents/production/ManufactoryUpgradeButton", "src/uicomponents/production/ManufacturableThingsList", "localization/localize"], function (require, exports, React, ManufactoryUpgradeButton_2, ManufacturableThingsList_2, localize_42) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ManufacturableItemsComponent = (function (_super) {
        __extends(ManufacturableItemsComponent, _super);
        function ManufacturableItemsComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "ManufacturableItems";
            _this.bindMethods();
            return _this;
        }
        ManufacturableItemsComponent.prototype.shouldComponentUpdate = function (newProps) {
            if (this.props.selectedStar !== newProps.selectedStar) {
                return true;
            }
            if (this.props.manufacturableThings.length !== newProps.manufacturableThings.length) {
                return true;
            }
            else {
            }
            if (this.props.canBuild !== newProps.canBuild) {
                return true;
            }
            if (this.props.money !== newProps.money) {
                return true;
            }
            return false;
        };
        ManufacturableItemsComponent.prototype.addItemToBuildQueue = function (template) {
            var manufactory = this.props.selectedStar.manufactory;
            manufactory.addThingToQueue(template, "item");
            this.props.triggerUpdate();
        };
        ManufacturableItemsComponent.prototype.bindMethods = function () {
            this.upgradeItems = this.upgradeItems.bind(this);
            this.addItemToBuildQueue = this.addItemToBuildQueue.bind(this);
        };
        ManufacturableItemsComponent.prototype.upgradeItems = function () {
        };
        ManufacturableItemsComponent.prototype.render = function () {
            return (React.DOM.div({
                className: "manufacturable-items",
            }, (!this.props.selectedStar || !this.props.selectedStar.manufactory) ? null : React.DOM.div({
                className: "manufactory-upgrade-buttons-container",
            }, ManufactoryUpgradeButton_2.default({
                money: this.props.money,
                upgradeCost: 0,
                actionString: localize_42.localize("upgradeItems"),
                currentLevel: 0,
                maxLevel: 0,
                levelDecimalPoints: 0,
                onClick: this.upgradeItems,
            })), ManufacturableThingsList_2.default({
                manufacturableThings: this.props.manufacturableThings,
                onClick: (this.props.canBuild ? this.addItemToBuildQueue : null),
                showCost: true,
                money: this.props.money,
            })));
        };
        return ManufacturableItemsComponent;
    }(React.Component));
    exports.ManufacturableItemsComponent = ManufacturableItemsComponent;
    var Factory = React.createFactory(ManufacturableItemsComponent);
    exports.default = Factory;
});
define("src/uicomponents/production/ManufacturableUnits", ["require", "exports", "react", "src/uicomponents/production/ManufactoryUpgradeButton", "src/uicomponents/production/ManufacturableThingsList", "localization/localize"], function (require, exports, React, ManufactoryUpgradeButton_3, ManufacturableThingsList_3, localize_43) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ManufacturableUnitsComponent = (function (_super) {
        __extends(ManufacturableUnitsComponent, _super);
        function ManufacturableUnitsComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "ManufacturableUnits";
            _this.bindMethods();
            return _this;
        }
        ManufacturableUnitsComponent.prototype.shouldComponentUpdate = function (newProps) {
            if (this.props.selectedStar !== newProps.selectedStar) {
                return true;
            }
            if (this.props.manufacturableThings.length !== newProps.manufacturableThings.length) {
                return true;
            }
            else {
            }
            if (this.props.canBuild !== newProps.canBuild) {
                return true;
            }
            if (this.props.money !== newProps.money) {
                return true;
            }
            return false;
        };
        ManufacturableUnitsComponent.prototype.addUnitToBuildQueue = function (template) {
            var manufactory = this.props.selectedStar.manufactory;
            manufactory.addThingToQueue(template, "unit");
            this.props.triggerUpdate();
        };
        ManufacturableUnitsComponent.prototype.bindMethods = function () {
            this.addUnitToBuildQueue = this.addUnitToBuildQueue.bind(this);
            this.upgradeStats = this.upgradeStats.bind(this);
            this.upgradeHealth = this.upgradeHealth.bind(this);
        };
        ManufacturableUnitsComponent.prototype.upgradeHealth = function () {
            var manufactory = this.props.selectedStar.manufactory;
            manufactory.upgradeUnitHealthModifier(0.1);
            this.props.triggerUpdate();
        };
        ManufacturableUnitsComponent.prototype.upgradeStats = function () {
            var manufactory = this.props.selectedStar.manufactory;
            manufactory.upgradeUnitStatsModifier(0.1);
            this.props.triggerUpdate();
        };
        ManufacturableUnitsComponent.prototype.render = function () {
            var selectedStarHasManufactory = this.props.selectedStar && this.props.selectedStar.manufactory;
            var manufactoryUpgradeButtons = null;
            if (selectedStarHasManufactory) {
                var manufactory = this.props.selectedStar.manufactory;
                var unitUpgradeCost = manufactory.getUnitUpgradeCost();
                var canAffordUnitUpgrade = this.props.money >= unitUpgradeCost;
                var unitUpgradeButtonBaseClassName = "manufactory-upgrade-button";
                var unitUpgradeCostBaseClassName = "manufactory-upgrade-button-cost";
                if (!canAffordUnitUpgrade) {
                    unitUpgradeButtonBaseClassName += " disabled";
                    unitUpgradeCostBaseClassName += " negative";
                }
                manufactoryUpgradeButtons = React.DOM.div({
                    className: "manufactory-upgrade-buttons-container",
                }, ManufactoryUpgradeButton_3.default({
                    money: this.props.money,
                    upgradeCost: unitUpgradeCost,
                    actionString: localize_43.localize("upgradeHealth"),
                    currentLevel: manufactory.unitHealthModifier,
                    maxLevel: 5.0,
                    levelDecimalPoints: 1,
                    onClick: this.upgradeHealth,
                    title: localize_43.localize("increaseBaseHealthOfUnitsBuiltHere"),
                }), ManufactoryUpgradeButton_3.default({
                    money: this.props.money,
                    upgradeCost: unitUpgradeCost,
                    actionString: localize_43.localize("upgradeStats"),
                    currentLevel: manufactory.unitStatsModifier,
                    maxLevel: 5.0,
                    levelDecimalPoints: 1,
                    onClick: this.upgradeStats,
                    title: localize_43.localize("increaseBaseStatsOfUnitsBuiltHere"),
                }));
            }
            return (React.DOM.div({
                className: "manufacturable-units",
            }, manufactoryUpgradeButtons, ManufacturableThingsList_3.default({
                manufacturableThings: this.props.manufacturableThings,
                onClick: (this.props.canBuild ? this.addUnitToBuildQueue : null),
                showCost: true,
                money: this.props.money,
            })));
        };
        return ManufacturableUnitsComponent;
    }(React.Component));
    exports.ManufacturableUnitsComponent = ManufacturableUnitsComponent;
    var Factory = React.createFactory(ManufacturableUnitsComponent);
    exports.default = Factory;
});
define("src/uicomponents/production/ManufacturableThings", ["require", "exports", "react", "src/uicomponents/production/ManufacturableItems", "src/uicomponents/production/ManufacturableUnits", "localization/localize"], function (require, exports, React, ManufacturableItems_1, ManufacturableUnits_1, localize_44) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ManufacturableThingsComponent = (function (_super) {
        __extends(ManufacturableThingsComponent, _super);
        function ManufacturableThingsComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "ManufacturableThings";
            _this.state = _this.getInitialStateTODO();
            _this.bindMethods();
            return _this;
        }
        ManufacturableThingsComponent.prototype.bindMethods = function () {
            this.makeTabButton = this.makeTabButton.bind(this);
            this.getManufacturableThings = this.getManufacturableThings.bind(this);
            this.selectTab = this.selectTab.bind(this);
            this.makeTab = this.makeTab.bind(this);
        };
        ManufacturableThingsComponent.prototype.getInitialStateTODO = function () {
            return ({
                activeTab: "units",
            });
        };
        ManufacturableThingsComponent.prototype.selectTab = function (key) {
            if (this.state.activeTab === key)
                return;
            this.setState({
                activeTab: key,
            });
        };
        ManufacturableThingsComponent.prototype.makeTabButton = function (key) {
            var displayString;
            switch (key) {
                case "units":
                    {
                        displayString = localize_44.localizeF("unit", "plural").capitalize();
                        break;
                    }
                case "items":
                    {
                        displayString = localize_44.localizeF("item", "plural").capitalize();
                        break;
                    }
            }
            return (React.DOM.button({
                key: key,
                className: "manufacturable-things-tab-button" +
                    (this.state.activeTab === key ? " active-tab" : ""),
                onClick: this.selectTab.bind(this, key),
            }, displayString));
        };
        ManufacturableThingsComponent.prototype.getManufacturableThings = function (key) {
            var manufacturableThings;
            var selectedStar = this.props.selectedStar;
            var player = this.props.player;
            switch (key) {
                case "units":
                    {
                        var buildableUnits = player.getGloballyBuildableUnits();
                        if (selectedStar) {
                            if (selectedStar.manufactory) {
                                buildableUnits.push.apply(buildableUnits, selectedStar.manufactory.getUniqueLocalUnitTypes(buildableUnits));
                            }
                        }
                        manufacturableThings = buildableUnits;
                        break;
                    }
                case "items":
                    {
                        var buildableItems = player.getGloballyBuildableItems();
                        if (selectedStar) {
                            if (selectedStar.manufactory) {
                                buildableItems.push.apply(buildableItems, selectedStar.manufactory.getUniqueLocalItemTypes(buildableItems));
                            }
                        }
                        manufacturableThings = buildableItems;
                        break;
                    }
            }
            return manufacturableThings;
        };
        ManufacturableThingsComponent.prototype.makeTab = function (key) {
            var props = {
                key: key,
                selectedStar: this.props.selectedStar,
                manufacturableThings: this.getManufacturableThings(key),
                consolidateLocations: false,
                triggerUpdate: this.props.triggerUpdate,
                canBuild: Boolean(this.props.selectedStar && this.props.selectedStar.manufactory),
                money: this.props.money,
            };
            switch (key) {
                case "units":
                    {
                        return (ManufacturableUnits_1.default(props));
                    }
                case "items":
                    {
                        props.consolidateLocations = true;
                        return (ManufacturableItems_1.default(props));
                    }
            }
        };
        ManufacturableThingsComponent.prototype.render = function () {
            return (React.DOM.div({
                className: "manufacturable-things",
            }, React.DOM.div({
                className: "manufacturable-things-tab-buttons",
            }, this.makeTabButton("units"), this.makeTabButton("items")), React.DOM.div({
                className: "manufacturable-things-active-tab",
            }, this.makeTab(this.state.activeTab))));
        };
        return ManufacturableThingsComponent;
    }(React.Component));
    exports.ManufacturableThingsComponent = ManufacturableThingsComponent;
    var Factory = React.createFactory(ManufacturableThingsComponent);
    exports.default = Factory;
});
define("src/uicomponents/production/ProductionOverview", ["require", "exports", "react", "src/eventManager", "src/utility", "src/uicomponents/production/BuildQueue", "src/uicomponents/production/ConstructManufactory", "src/uicomponents/production/ManufactoryStarsList", "src/uicomponents/production/ManufacturableThings", "src/uicomponents/mixins/UpdateWhenMoneyChanges", "src/uicomponents/mixins/applyMixins"], function (require, exports, React, eventManager_31, utility_36, BuildQueue_1, ConstructManufactory_1, ManufactoryStarsList_1, ManufacturableThings_1, UpdateWhenMoneyChanges_3, applyMixins_13) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ProductionOverviewComponent = (function (_super) {
        __extends(ProductionOverviewComponent, _super);
        function ProductionOverviewComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "ProductionOverview";
            _this.state = _this.getInitialStateTODO();
            _this.bindMethods();
            applyMixins_13.default(_this, new UpdateWhenMoneyChanges_3.default(_this));
            return _this;
        }
        ProductionOverviewComponent.prototype.bindMethods = function () {
            this.clearSelection = this.clearSelection.bind(this);
            this.getStarsWithAndWithoutManufactories = this.getStarsWithAndWithoutManufactories.bind(this);
            this.handleStarSelect = this.handleStarSelect.bind(this);
            this.triggerUpdate = this.triggerUpdate.bind(this);
        };
        ProductionOverviewComponent.prototype.getInitialStateTODO = function () {
            var initialSelected = null;
            var player = this.props.player;
            var starsByManufactoryPresence = this.getStarsWithAndWithoutManufactories();
            if (starsByManufactoryPresence.withManufactories.length > 0) {
                starsByManufactoryPresence.withManufactories.sort(utility_36.sortByManufactoryCapacityFN);
                initialSelected = starsByManufactoryPresence.withManufactories[0];
            }
            else if (starsByManufactoryPresence.withoutManufactories.length > 0) {
                starsByManufactoryPresence.withoutManufactories.sort(utility_36.sortByManufactoryCapacityFN);
                initialSelected = starsByManufactoryPresence.withoutManufactories[0];
            }
            return ({
                selectedStar: initialSelected,
                highlightedStars: [initialSelected],
                money: player.money,
            });
        };
        ProductionOverviewComponent.prototype.triggerUpdate = function () {
            this.forceUpdate();
        };
        ProductionOverviewComponent.prototype.componentDidMount = function () {
            eventManager_31.default.addEventListener("playerManufactoryBuiltThings", this.triggerUpdate);
        };
        ProductionOverviewComponent.prototype.componentWillUnmount = function () {
            eventManager_31.default.removeEventListener("playerManufactoryBuiltThings", this.triggerUpdate);
        };
        ProductionOverviewComponent.prototype.getStarsWithAndWithoutManufactories = function () {
            var player = this.props.player;
            var starsWithManufactories = [];
            var starsWithoutManufactories = [];
            for (var i = 0; i < player.controlledLocations.length; i++) {
                var star = player.controlledLocations[i];
                if (star.manufactory) {
                    starsWithManufactories.push(star);
                }
                else {
                    starsWithoutManufactories.push(star);
                }
            }
            return ({
                withManufactories: starsWithManufactories,
                withoutManufactories: starsWithoutManufactories,
            });
        };
        ProductionOverviewComponent.prototype.handleStarSelect = function (star) {
            if (this.state.selectedStar === star) {
                this.clearSelection();
            }
            else {
                this.setState({
                    selectedStar: star,
                    highlightedStars: [star],
                });
            }
        };
        ProductionOverviewComponent.prototype.clearSelection = function () {
            this.setState({
                selectedStar: undefined,
                highlightedStars: [],
            });
        };
        ProductionOverviewComponent.prototype.render = function () {
            var player = this.props.player;
            var selectedStar = this.state.selectedStar;
            var starsByManufactoryPresence = this.getStarsWithAndWithoutManufactories();
            var queueElement = null;
            if (selectedStar) {
                if (selectedStar.manufactory) {
                    queueElement = BuildQueue_1.default({
                        manufactory: selectedStar.manufactory,
                        triggerUpdate: this.triggerUpdate,
                        money: this.state.money,
                    });
                }
                else {
                    queueElement = ConstructManufactory_1.default({
                        star: selectedStar,
                        player: player,
                        money: this.state.money,
                        triggerUpdate: this.triggerUpdate,
                    });
                }
            }
            return (React.DOM.div({
                className: "production-overview",
            }, ManufactoryStarsList_1.default({
                starsWithManufactories: starsByManufactoryPresence.withManufactories,
                starsWithoutManufactories: starsByManufactoryPresence.withoutManufactories,
                highlightedStars: this.state.highlightedStars,
                handleStarSelect: this.handleStarSelect,
            }), React.DOM.div({
                className: "production-overview-contents",
            }, queueElement, ManufacturableThings_1.default({
                selectedStar: selectedStar,
                player: player,
                money: this.state.money,
                triggerUpdate: this.triggerUpdate,
            }))));
        };
        return ProductionOverviewComponent;
    }(React.Component));
    exports.ProductionOverviewComponent = ProductionOverviewComponent;
    var Factory = React.createFactory(ProductionOverviewComponent);
    exports.default = Factory;
});
define("src/uicomponents/saves/ConfirmDeleteSavesContent", ["require", "exports", "react", "localization/localize"], function (require, exports, React, localize_45) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ConfirmDeleteSavesContentComponent = (function (_super) {
        __extends(ConfirmDeleteSavesContentComponent, _super);
        function ConfirmDeleteSavesContentComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "ConfirmDeleteSavesContent";
            return _this;
        }
        ConfirmDeleteSavesContentComponent.prototype.render = function () {
            return (React.DOM.div({
                className: "confirm-delete-saves-content",
            }, React.DOM.span({
                className: "confirm-delete-saves-content-title",
            }, localize_45.localize("confirmSaveDeletion", this.props.saveNames.length)), React.DOM.ol({
                className: "confirm-delete-saves-content-saves-list",
            }, this.props.saveNames.map(function (saveName) {
                return (React.DOM.li({
                    className: "confirm-delete-saves-content-save-name",
                    key: saveName,
                }, saveName));
            }))));
        };
        return ConfirmDeleteSavesContentComponent;
    }(React.PureComponent));
    exports.ConfirmDeleteSavesContentComponent = ConfirmDeleteSavesContentComponent;
    var Factory = React.createFactory(ConfirmDeleteSavesContentComponent);
    exports.default = Factory;
});
define("src/uicomponents/saves/SaveListItem", ["require", "exports", "react"], function (require, exports, React) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SaveListItemComponent = (function (_super) {
        __extends(SaveListItemComponent, _super);
        function SaveListItemComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "SaveListItem";
            _this.bindMethods();
            return _this;
        }
        SaveListItemComponent.prototype.bindMethods = function () {
            this.handleUndoDelete = this.handleUndoDelete.bind(this);
            this.handleDelete = this.handleDelete.bind(this);
            this.makeCell = this.makeCell.bind(this);
        };
        SaveListItemComponent.prototype.handleDelete = function (e) {
            e.stopPropagation();
            this.props.handleDelete();
        };
        SaveListItemComponent.prototype.handleUndoDelete = function (e) {
            e.stopPropagation();
            this.props.handleUndoDelete();
        };
        SaveListItemComponent.preventDefault = function (e) {
            e.preventDefault();
            e.stopPropagation();
        };
        SaveListItemComponent.prototype.makeCell = function (type) {
            var cellProps = {};
            cellProps.key = type;
            cellProps.className = "save-list-item-cell" + " save-list-" + type;
            var cellContent;
            switch (type) {
                case "delete":
                    {
                        cellContent = "";
                        cellProps.onDoubleClick = SaveListItemComponent.preventDefault;
                        if (this.props.isMarkedForDeletion) {
                            cellProps.className += " undo-delete-button";
                            cellProps.onClick = this.handleUndoDelete;
                        }
                        else {
                            cellProps.onClick = this.handleDelete;
                        }
                        break;
                    }
                default:
                    {
                        cellContent = this.props[type];
                        break;
                    }
            }
            return (React.DOM.td(cellProps, cellContent));
        };
        SaveListItemComponent.prototype.render = function () {
            var columns = this.props.activeColumns;
            var cells = [];
            for (var i = 0; i < columns.length; i++) {
                var cell = this.makeCell(columns[i].key);
                cells.push(cell);
            }
            var rowProps = {
                className: "save-list-item",
                onClick: this.props.handleClick,
                onDoubleClick: this.props.onDoubleClick,
            };
            if (this.props.isMarkedForDeletion) {
                rowProps.className += " marked-for-deletion";
            }
            return (React.DOM.tr(rowProps, cells));
        };
        return SaveListItemComponent;
    }(React.Component));
    exports.SaveListItemComponent = SaveListItemComponent;
    var Factory = React.createFactory(SaveListItemComponent);
    exports.default = Factory;
});
define("src/uicomponents/saves/SaveList", ["require", "exports", "react", "src/uicomponents/saves/SaveListItem", "src/uicomponents/list/List", "src/utility", "localization/localize"], function (require, exports, React, SaveListItem_1, List_7, utility_37, localize_46) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SaveListComponent = (function (_super) {
        __extends(SaveListComponent, _super);
        function SaveListComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "SaveList";
            return _this;
        }
        SaveListComponent.prototype.render = function () {
            var rows = [];
            var selected;
            var allKeys = Object.keys(localStorage);
            var saveKeys = allKeys.filter(function (key) {
                return (key.indexOf("Save") > -1);
            });
            for (var i = 0; i < saveKeys.length; i++) {
                var saveData = JSON.parse(localStorage.getItem(saveKeys[i]));
                var date = new Date(saveData.date);
                var isMarkedForDeletion = false;
                if (this.props.saveKeysToDelete) {
                    if (this.props.saveKeysToDelete.indexOf(saveKeys[i]) !== -1) {
                        isMarkedForDeletion = true;
                    }
                }
                var row = {
                    key: saveKeys[i],
                    content: SaveListItem_1.default({
                        storageKey: saveKeys[i],
                        name: saveData.name,
                        date: utility_37.prettifyDate(date),
                        accurateDate: saveData.date,
                        isMarkedForDeletion: isMarkedForDeletion,
                        handleDelete: this.props.onDelete ?
                            this.props.onDelete.bind(null, saveKeys[i]) :
                            null,
                        handleUndoDelete: this.props.onUndoDelete ?
                            this.props.onUndoDelete.bind(null, saveKeys[i]) :
                            null,
                        onDoubleClick: this.props.onDoubleClick,
                    }),
                };
                rows.push(row);
                if (this.props.selectedKey === saveKeys[i]) {
                    selected = row;
                }
            }
            var columns = [
                {
                    label: localize_46.localize("saveName"),
                    key: "name",
                    defaultOrder: "asc",
                },
                {
                    label: localize_46.localize("date"),
                    key: "date",
                    defaultOrder: "desc",
                    propToSortBy: "accurateDate",
                },
            ];
            if (this.props.allowDelete) {
                columns.push({
                    label: localize_46.localize("del"),
                    key: "delete",
                    defaultOrder: "asc",
                    notSortable: true,
                });
            }
            return (React.DOM.div({ className: "save-list fixed-table-parent" }, List_7.default({
                listItems: rows,
                initialColumns: columns,
                initialSortOrder: [columns[1], columns[0]],
                onRowChange: this.props.onRowChange,
                autoSelect: selected ? false : this.props.autoSelect,
                initialSelected: selected,
                keyboardSelect: true,
                addSpacer: true,
            })));
        };
        return SaveListComponent;
    }(React.Component));
    exports.SaveListComponent = SaveListComponent;
    var Factory = React.createFactory(SaveListComponent);
    exports.default = Factory;
});
define("src/uicomponents/saves/LoadGame", ["require", "exports", "react", "react-dom", "src/App", "src/uicomponents/saves/ConfirmDeleteSavesContent", "src/uicomponents/saves/SaveList", "src/uicomponents/windows/DialogBox", "localization/localize"], function (require, exports, React, ReactDOM, App_10, ConfirmDeleteSavesContent_1, SaveList_1, DialogBox_2, localize_47) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var LoadGameComponent = (function (_super) {
        __extends(LoadGameComponent, _super);
        function LoadGameComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "LoadGame";
            _this.state =
                {
                    saveKeysToDelete: [],
                    selectedSaveKey: null,
                    hasConfirmDeleteSavePopup: false,
                };
            _this.bindMethods();
            return _this;
        }
        LoadGameComponent.prototype.componentDidMount = function () {
            ReactDOM.findDOMNode(this.loadButtonElement).focus();
        };
        LoadGameComponent.prototype.render = function () {
            var _this = this;
            return (React.DOM.div({
                className: "save-game",
            }, !this.state.hasConfirmDeleteSavePopup ? null :
                DialogBox_2.default({
                    title: localize_47.localize("confirmDeletion"),
                    handleOk: function () {
                        _this.deleteSelectedKeys();
                        _this.closeConfirmDeleteSavesPopup();
                    },
                    handleCancel: this.closeConfirmDeleteSavesPopup,
                }, ConfirmDeleteSavesContent_1.default({
                    saveNames: this.state.saveKeysToDelete,
                })), SaveList_1.default({
                onRowChange: function (row) {
                    _this.setState({ selectedSaveKey: row.content.props.storageKey });
                    _this.handleUndoMarkForDeletion(row.content.props.storageKey);
                },
                autoSelect: !Boolean(App_10.default.game.gameStorageKey),
                selectedKey: App_10.default.game.gameStorageKey,
                allowDelete: true,
                onDelete: this.handleMarkForDeletion,
                onUndoDelete: this.handleUndoMarkForDeletion,
                saveKeysToDelete: this.state.saveKeysToDelete,
                onDoubleClick: this.handleLoad,
            }), React.DOM.form({
                className: "save-game-form",
                onSubmit: this.handleLoad,
                action: "javascript:void(0);",
            }, React.DOM.input({
                className: "save-game-name",
                type: "text",
                value: this.state.selectedSaveKey ? this.state.selectedSaveKey.replace("Rance.Save.", "") : "",
                readOnly: true,
            })), React.DOM.div({
                className: "save-game-buttons-container",
            }, React.DOM.button({
                className: "save-game-button",
                onClick: this.handleLoad,
                ref: function (component) {
                    _this.loadButtonElement = component;
                },
            }, localize_47.localize("load_imperative")), React.DOM.button({
                className: "save-game-button",
                onClick: this.handleClose.bind(this, true, null),
            }, localize_47.localize("cancel")), React.DOM.button({
                className: "save-game-button",
                onClick: this.openConfirmDeleteSavesPopup,
                disabled: this.state.saveKeysToDelete.length < 1,
            }, localize_47.localize("delete")))));
        };
        LoadGameComponent.prototype.openConfirmDeleteSavesPopup = function () {
            this.setState({ hasConfirmDeleteSavePopup: true });
        };
        LoadGameComponent.prototype.bindMethods = function () {
            this.handleLoad = this.handleLoad.bind(this);
            this.deleteSelectedKeys = this.deleteSelectedKeys.bind(this);
            this.handleMarkForDeletion = this.handleMarkForDeletion.bind(this);
            this.handleUndoMarkForDeletion = this.handleUndoMarkForDeletion.bind(this);
            this.openConfirmDeleteSavesPopup = this.openConfirmDeleteSavesPopup.bind(this);
            this.closeConfirmDeleteSavesPopup = this.closeConfirmDeleteSavesPopup.bind(this);
            this.handleClose = this.handleClose.bind(this);
        };
        LoadGameComponent.prototype.handleLoad = function () {
            App_10.default.load(this.state.selectedSaveKey);
        };
        LoadGameComponent.prototype.deleteSelectedKeys = function () {
            var _this = this;
            this.state.saveKeysToDelete.forEach(function (key) {
                localStorage.removeItem(key);
            });
            this.setState({ saveKeysToDelete: [] }, function () {
                if (_this.afterConfirmDeleteCallback) {
                    var afterConfirmDeleteCallback = _this.afterConfirmDeleteCallback;
                    _this.afterConfirmDeleteCallback = undefined;
                    afterConfirmDeleteCallback();
                }
            });
        };
        LoadGameComponent.prototype.handleMarkForDeletion = function (saveKey) {
            this.setState({
                saveKeysToDelete: this.state.saveKeysToDelete.concat(saveKey),
            });
        };
        LoadGameComponent.prototype.handleUndoMarkForDeletion = function (saveKey) {
            this.setState({
                saveKeysToDelete: this.state.saveKeysToDelete.filter(function (currentKey) {
                    return currentKey !== saveKey;
                }),
            });
        };
        LoadGameComponent.prototype.closeConfirmDeleteSavesPopup = function () {
            this.setState({ hasConfirmDeleteSavePopup: false });
        };
        LoadGameComponent.prototype.handleClose = function () {
            this.props.handleClose();
        };
        return LoadGameComponent;
    }(React.Component));
    exports.LoadGameComponent = LoadGameComponent;
    var Factory = React.createFactory(LoadGameComponent);
    exports.default = Factory;
});
define("src/uicomponents/saves/SaveGame", ["require", "exports", "react", "react-dom", "src/App", "src/uicomponents/saves/SaveList", "src/uicomponents/windows/DialogBox", "localization/localize"], function (require, exports, React, ReactDOM, App_11, SaveList_2, DialogBox_3, localize_48) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SaveGameComponent = (function (_super) {
        __extends(SaveGameComponent, _super);
        function SaveGameComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "SaveGame";
            _this.state = {
                saveName: "",
                hasConfirmOverwritePopup: false,
            };
            _this.bindMethods();
            return _this;
        }
        SaveGameComponent.prototype.componentDidMount = function () {
            if (App_11.default.game.gameStorageKey) {
                ReactDOM.findDOMNode(this.okButtonElement).focus();
            }
            else {
                ReactDOM.findDOMNode(this.saveNameElement).focus();
            }
        };
        SaveGameComponent.prototype.render = function () {
            var _this = this;
            return (React.DOM.div({
                className: "save-game",
            }, !this.state.hasConfirmOverwritePopup ? null :
                DialogBox_3.default({
                    title: localize_48.localize("confirmOverwrite"),
                    handleOk: this.saveGame,
                    handleCancel: this.closeConfirmOverwritePopup,
                }, localize_48.localizeF("promptOverwrite").format({
                    toOverWrite: this.state.saveName.replace("Rance.Save.", "")
                })), SaveList_2.default({
                onRowChange: this.handleRowChange,
                selectedKey: App_11.default.game.gameStorageKey,
                autoSelect: false,
                onDoubleClick: this.saveGame,
            }), React.DOM.form({
                className: "save-game-form",
                onSubmit: this.handleSave,
                action: "javascript:void(0);",
            }, React.DOM.input({
                className: "save-game-name",
                ref: function (component) {
                    _this.saveNameElement = component;
                },
                type: "text",
                value: this.state.saveName,
                onChange: this.handleSaveNameInput,
                maxLength: 64,
            })), React.DOM.div({
                className: "save-game-buttons-container",
            }, React.DOM.button({
                className: "save-game-button",
                onClick: this.handleSave,
                ref: function (component) {
                    _this.okButtonElement = component;
                },
            }, localize_48.localize("save_imperative")), React.DOM.button({
                className: "save-game-button",
                onClick: this.handleClose,
            }, localize_48.localize("cancel")))));
        };
        SaveGameComponent.prototype.bindMethods = function () {
            this.handleClose = this.handleClose.bind(this);
            this.setSaveName = this.setSaveName.bind(this);
            this.saveGame = this.saveGame.bind(this);
            this.handleSave = this.handleSave.bind(this);
            this.handleRowChange = this.handleRowChange.bind(this);
            this.handleSaveNameInput = this.handleSaveNameInput.bind(this);
            this.closeConfirmOverwritePopup = this.closeConfirmOverwritePopup.bind(this);
        };
        SaveGameComponent.prototype.setSaveName = function (newText) {
            this.setState({
                saveName: newText,
            });
        };
        SaveGameComponent.prototype.handleSaveNameInput = function (e) {
            var target = e.currentTarget;
            this.setSaveName(target.value);
        };
        SaveGameComponent.prototype.handleRowChange = function (row) {
            this.setSaveName(row.content.props.name);
        };
        SaveGameComponent.prototype.handleSave = function () {
            var saveName = this.state.saveName;
            var saveKey = "Rance.Save." + saveName;
            if (localStorage[saveKey]) {
                this.setState({ hasConfirmOverwritePopup: true });
            }
            else {
                this.saveGame();
            }
        };
        SaveGameComponent.prototype.closeConfirmOverwritePopup = function () {
            this.setState({ hasConfirmOverwritePopup: false });
        };
        SaveGameComponent.prototype.saveGame = function () {
            App_11.default.game.save(this.state.saveName);
            this.handleClose();
        };
        SaveGameComponent.prototype.handleClose = function () {
            this.props.handleClose();
        };
        return SaveGameComponent;
    }(React.Component));
    exports.SaveGameComponent = SaveGameComponent;
    var Factory = React.createFactory(SaveGameComponent);
    exports.default = Factory;
});
define("src/uicomponents/technologies/technologyPrioritySlider", ["require", "exports", "react", "src/eventManager"], function (require, exports, React, eventManager_32) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TechnologyPrioritySliderComponent = (function (_super) {
        __extends(TechnologyPrioritySliderComponent, _super);
        function TechnologyPrioritySliderComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "TechnologyPrioritySlider";
            _this.state = _this.getInitialStateTODO();
            _this.bindMethods();
            return _this;
        }
        TechnologyPrioritySliderComponent.prototype.bindMethods = function () {
            this.getPlayerPriority = this.getPlayerPriority.bind(this);
            this.updatePriority = this.updatePriority.bind(this);
            this.handlePriorityChange = this.handlePriorityChange.bind(this);
        };
        TechnologyPrioritySliderComponent.prototype.getInitialStateTODO = function () {
            return ({
                priority: this.getPlayerPriority(),
            });
        };
        TechnologyPrioritySliderComponent.prototype.componentDidMount = function () {
            eventManager_32.default.addEventListener("technologyPrioritiesUpdated", this.updatePriority);
        };
        TechnologyPrioritySliderComponent.prototype.componentWillUnmount = function () {
            eventManager_32.default.removeEventListener("technologyPrioritiesUpdated", this.updatePriority);
        };
        TechnologyPrioritySliderComponent.prototype.isTechnologyLocked = function () {
            return this.props.playerTechnology.technologies[this.props.technology.key].priorityIsLocked;
        };
        TechnologyPrioritySliderComponent.prototype.getPlayerPriority = function () {
            return this.props.playerTechnology.technologies[this.props.technology.key].priority;
        };
        TechnologyPrioritySliderComponent.prototype.updatePriority = function () {
            this.setState({
                priority: this.getPlayerPriority(),
            });
        };
        TechnologyPrioritySliderComponent.prototype.handlePriorityChange = function (e) {
            if (this.isTechnologyLocked()) {
                return;
            }
            var target = e.currentTarget;
            this.props.playerTechnology.setTechnologyPriority(this.props.technology, parseFloat(target.value));
        };
        TechnologyPrioritySliderComponent.prototype.render = function () {
            return (React.DOM.div({
                className: "technology-progress-bar-priority-container",
            }, React.DOM.span({
                className: "technology-progress-bar-predicted-research",
            }, "+" + (this.props.researchPoints * this.state.priority).toFixed(1)), React.DOM.input({
                className: "technology-progress-bar-priority",
                type: "range",
                min: 0,
                max: 1,
                step: 0.01,
                value: "" + this.state.priority,
                onChange: this.handlePriorityChange,
                disabled: this.isTechnologyLocked(),
            })));
        };
        return TechnologyPrioritySliderComponent;
    }(React.Component));
    exports.TechnologyPrioritySliderComponent = TechnologyPrioritySliderComponent;
    var Factory = React.createFactory(TechnologyPrioritySliderComponent);
    exports.default = Factory;
});
define("src/uicomponents/technologies/Technology", ["require", "exports", "react", "src/uicomponents/technologies/technologyPrioritySlider", "localization/localize"], function (require, exports, React, technologyPrioritySlider_1, localize_49) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TechnologyComponent = (function (_super) {
        __extends(TechnologyComponent, _super);
        function TechnologyComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "Technology";
            _this.bindMethods();
            return _this;
        }
        TechnologyComponent.prototype.bindMethods = function () {
            this.togglePriorityLock = this.togglePriorityLock.bind(this);
        };
        TechnologyComponent.prototype.togglePriorityLock = function () {
            var pt = this.props.playerTechnology;
            var technology = this.props.technology;
            pt.technologies[technology.key].priorityIsLocked = !pt.technologies[technology.key].priorityIsLocked;
            this.forceUpdate();
        };
        TechnologyComponent.prototype.render = function () {
            var technology = this.props.technology;
            var isAtMaxLevel = false;
            var playerTechnology = this.props.playerTechnology;
            var techData = playerTechnology.technologies[technology.key];
            var forCurrentLevel = playerTechnology.getResearchNeededForTechnologyLevel(techData.level);
            var forNextLevel = playerTechnology.getResearchNeededForTechnologyLevel(techData.level + 1);
            var progressForLevel = techData.totalResearch - forCurrentLevel;
            var neededToProgressLevel = forNextLevel - forCurrentLevel;
            var relativeProgress;
            if (techData.level === techData.maxLevel) {
                relativeProgress = 1;
                progressForLevel =
                    techData.totalResearch - playerTechnology.getResearchNeededForTechnologyLevel(techData.level - 1);
                neededToProgressLevel = progressForLevel;
                isAtMaxLevel = true;
            }
            else {
                relativeProgress = progressForLevel / neededToProgressLevel;
            }
            return (React.DOM.div({
                className: "technology-listing",
            }, React.DOM.div({
                className: "technology-name",
            }, technology.displayName), React.DOM.div({
                className: "technology-level",
            }, localize_49.localize("technologyLevel") + " " + techData.level), React.DOM.div({
                className: "technology-progress-bar-container",
            }, React.DOM.div({
                className: "technology-progress-bar" +
                    (isAtMaxLevel ? " technology-progress-bar-max-level" : ""),
                style: {
                    width: "" + (relativeProgress * 100) + "%",
                },
            }), React.DOM.div({
                className: "technology-progress-bar-value",
            }, "" + progressForLevel.toFixed(1) + " / " + Math.ceil(neededToProgressLevel)), technologyPrioritySlider_1.default({
                playerTechnology: this.props.playerTechnology,
                technology: this.props.technology,
                researchPoints: this.props.researchPoints,
            })), React.DOM.button({
                className: "technology-toggle-priority-lock" + (techData.priorityIsLocked ? " locked" : " unlocked"),
                onClick: this.togglePriorityLock,
                disabled: isAtMaxLevel,
            }, null)));
        };
        return TechnologyComponent;
    }(React.Component));
    exports.TechnologyComponent = TechnologyComponent;
    var Factory = React.createFactory(TechnologyComponent);
    exports.default = Factory;
});
define("src/uicomponents/technologies/TechnologiesList", ["require", "exports", "react", "src/eventManager", "src/uicomponents/technologies/Technology", "localization/localize"], function (require, exports, React, eventManager_33, Technology_1, localize_50) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TechnologiesListComponent = (function (_super) {
        __extends(TechnologiesListComponent, _super);
        function TechnologiesListComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "TechnologiesList";
            _this.updateListener = undefined;
            return _this;
        }
        TechnologiesListComponent.prototype.componentDidMount = function () {
            this.updateListener = eventManager_33.default.addEventListener("builtBuildingWithEffect_research", this.forceUpdate.bind(this));
        };
        TechnologiesListComponent.prototype.componentWillUnmount = function () {
            eventManager_33.default.removeEventListener("builtBuildingWithEffect_research", this.updateListener);
        };
        TechnologiesListComponent.prototype.render = function () {
            var playerTechnology = this.props.playerTechnology;
            var researchSpeed = playerTechnology.getResearchSpeed();
            var rows = [];
            for (var key in playerTechnology.technologies) {
                rows.push(Technology_1.default({
                    playerTechnology: playerTechnology,
                    technology: playerTechnology.technologies[key].technology,
                    researchPoints: researchSpeed,
                    key: key,
                }));
            }
            return (React.DOM.div({
                className: "technologies-list-container",
            }, React.DOM.div({
                className: "technologies-list",
            }, rows), React.DOM.div({
                className: "technologies-list-research-speed",
            }, localize_50.localize("researchSpeed") + ": " + researchSpeed + localize_50.localize("perTurn"))));
        };
        return TechnologiesListComponent;
    }(React.Component));
    exports.TechnologiesListComponent = TechnologiesListComponent;
    var Factory = React.createFactory(TechnologiesListComponent);
    exports.default = Factory;
});
define("src/uicomponents/unitlist/ItemEquip", ["require", "exports", "react", "src/uicomponents/unitlist/ItemList", "src/uicomponents/unitlist/MenuUnitInfo", "src/uicomponents/unitlist/UnitList"], function (require, exports, React, ItemList_2, MenuUnitInfo_2, UnitList_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ItemEquipComponent = (function (_super) {
        __extends(ItemEquipComponent, _super);
        function ItemEquipComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "ItemEquip";
            _this.state = _this.getInitialStateTODO();
            _this.bindMethods();
            return _this;
        }
        ItemEquipComponent.prototype.bindMethods = function () {
            this.handleDragStart = this.handleDragStart.bind(this);
            this.handleDragEnd = this.handleDragEnd.bind(this);
            this.handleDrop = this.handleDrop.bind(this);
            this.handleSelectRow = this.handleSelectRow.bind(this);
        };
        ItemEquipComponent.prototype.getInitialStateTODO = function () {
            return ({
                selectedUnit: null,
                currentDragItem: null,
            });
        };
        ItemEquipComponent.prototype.handleSelectRow = function (row) {
            if (!row.content.props.unit) {
                return;
            }
            this.setState({
                selectedUnit: row.content.props.unit,
            });
        };
        ItemEquipComponent.prototype.handleDragStart = function (item) {
            this.setState({
                currentDragItem: item,
            });
        };
        ItemEquipComponent.prototype.handleDragEnd = function (dropSuccesful) {
            if (dropSuccesful === void 0) { dropSuccesful = false; }
            if (!dropSuccesful && this.state.currentDragItem && this.state.selectedUnit) {
                var item = this.state.currentDragItem;
                if (this.state.selectedUnit.items.hasItem(item)) {
                    this.state.selectedUnit.items.removeItem(item);
                }
            }
            this.setState({
                currentDragItem: null,
            });
        };
        ItemEquipComponent.prototype.handleDrop = function (index) {
            var item = this.state.currentDragItem;
            var unit = this.state.selectedUnit;
            if (unit && item) {
                unit.items.addItemAtPosition(item, index);
            }
            this.handleDragEnd(true);
        };
        ItemEquipComponent.prototype.render = function () {
            var player = this.props.player;
            return (React.DOM.div({ className: "item-equip" }, React.DOM.div({ className: "item-equip-left" }, MenuUnitInfo_2.default({
                unit: this.state.selectedUnit,
                onMouseUp: this.handleDrop,
                isDraggable: true,
                onDragStart: this.handleDragStart,
                onDragEnd: this.handleDragEnd,
                currentDragItem: this.state.currentDragItem,
            }), ItemList_2.default({
                items: player.items,
                selectedUnit: this.state.selectedUnit,
                isDraggable: true,
                onDragStart: this.handleDragStart,
                onDragEnd: this.handleDragEnd,
                onRowChange: this.handleSelectRow,
            })), UnitList_2.default({
                units: player.units,
                selectedUnit: this.state.selectedUnit,
                reservedUnits: [],
                unavailableUnits: player.units.filter(function (unit) { return !unit.canFightOffensiveBattle(); }),
                isDraggable: false,
                onRowChange: this.handleSelectRow,
                autoSelect: true,
            })));
        };
        return ItemEquipComponent;
    }(React.Component));
    exports.ItemEquipComponent = ItemEquipComponent;
    var Factory = React.createFactory(ItemEquipComponent);
    exports.default = Factory;
});
define("src/uicomponents/galaxymap/EconomySummaryItem", ["require", "exports", "react"], function (require, exports, React) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var EconomySummaryItemComponent = (function (_super) {
        __extends(EconomySummaryItemComponent, _super);
        function EconomySummaryItemComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "EconomySummaryItem";
            _this.bindMethods();
            return _this;
        }
        EconomySummaryItemComponent.prototype.bindMethods = function () {
            this.makeCell = this.makeCell.bind(this);
        };
        EconomySummaryItemComponent.prototype.makeCell = function (type) {
            var cellProps = {
                key: type,
                className: "economy-summary-item-cell" + " economy-summary-" + type,
            };
            var cellContent;
            switch (type) {
                case "id":
                    {
                        cellContent = this.props.id;
                        break;
                    }
                case "name":
                    {
                        cellContent = this.props.name;
                        break;
                    }
                case "income":
                    {
                        cellContent = this.props.income;
                        break;
                    }
            }
            return (React.DOM.td(cellProps, cellContent));
        };
        EconomySummaryItemComponent.prototype.render = function () {
            var columns = this.props.activeColumns;
            var cells = [];
            for (var i = 0; i < columns.length; i++) {
                var cell = this.makeCell(columns[i].key);
                cells.push(cell);
            }
            var rowProps = {
                className: "economy-summary-item",
                onClick: this.props.handleClick,
            };
            return (React.DOM.tr(rowProps, cells));
        };
        return EconomySummaryItemComponent;
    }(React.Component));
    exports.EconomySummaryItemComponent = EconomySummaryItemComponent;
    var Factory = React.createFactory(EconomySummaryItemComponent);
    exports.default = Factory;
});
define("src/uicomponents/galaxymap/EconomySummary", ["require", "exports", "react", "src/uicomponents/galaxymap/EconomySummaryItem", "src/uicomponents/list/List", "localization/localize"], function (require, exports, React, EconomySummaryItem_1, List_8, localize_51) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var EconomySummaryComponent = (function (_super) {
        __extends(EconomySummaryComponent, _super);
        function EconomySummaryComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "EconomySummary";
            return _this;
        }
        EconomySummaryComponent.prototype.render = function () {
            var rows = [];
            var player = this.props.player;
            for (var i = 0; i < player.controlledLocations.length; i++) {
                var star = player.controlledLocations[i];
                rows.push({
                    key: "" + star.id,
                    content: EconomySummaryItem_1.default({
                        star: star,
                        id: star.id,
                        name: star.name,
                        income: star.getIncome(),
                    }),
                });
            }
            var columns = [
                {
                    label: localize_51.localize("id"),
                    key: "id",
                    defaultOrder: "asc",
                },
                {
                    label: localize_51.localize("displayName"),
                    key: "name",
                    defaultOrder: "asc",
                },
                {
                    label: localize_51.localize("income"),
                    key: "income",
                    defaultOrder: "desc",
                },
            ];
            return (React.DOM.div({ className: "economy-summary-list fixed-table-parent" }, List_8.default({
                listItems: rows,
                initialColumns: columns,
                initialSortOrder: [columns[2]],
            })));
        };
        return EconomySummaryComponent;
    }(React.Component));
    exports.EconomySummaryComponent = EconomySummaryComponent;
    var Factory = React.createFactory(EconomySummaryComponent);
    exports.default = Factory;
});
define("src/uicomponents/language/LanguageSelect", ["require", "exports", "react", "src/localization/languageSupport", "localization/localize"], function (require, exports, React, languageSupport_2, localize_52) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var LanguageSelectComponent = (function (_super) {
        __extends(LanguageSelectComponent, _super);
        function LanguageSelectComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "LanguageSelect";
            _this.handleLanguageChange = _this.handleLanguageChange.bind(_this);
            return _this;
        }
        LanguageSelectComponent.prototype.render = function () {
            var _this = this;
            var sortedLanguages = Object.keys(this.props.availableLanguagesByCode).map(function (code) {
                return _this.props.availableLanguagesByCode[code];
            }).sort(function (a, b) {
                var aSupportLevel = _this.props.languageSupportLevelByCode[a.code];
                var bSupportLevel = _this.props.languageSupportLevelByCode[b.code];
                var supportLevelSort = bSupportLevel - aSupportLevel;
                if (supportLevelSort) {
                    return supportLevelSort;
                }
                else {
                    return a.displayName.localeCompare(b.displayName);
                }
            });
            var languageOptionElements = sortedLanguages.map(function (language) {
                var supportLevel = _this.props.languageSupportLevelByCode[language.code];
                return React.DOM.option({
                    className: "language-select-option" + (supportLevel === languageSupport_2.LanguageSupportLevel.Full ?
                        " full-language-support" :
                        " partial-language-support"),
                    value: language.code,
                    key: language.code,
                    title: supportLevel === languageSupport_2.LanguageSupportLevel.Full ?
                        localize_52.localize("fullLanguageSupport") :
                        localize_52.localize("partialLanguageSupport"),
                }, language.displayName);
            });
            return (React.DOM.select({
                className: "language-select",
                value: this.props.activeLanguage.code,
                onChange: this.handleLanguageChange,
            }, languageOptionElements));
        };
        LanguageSelectComponent.prototype.handleLanguageChange = function (e) {
            var target = e.currentTarget;
            var selectedLanguageCode = target.value;
            var newLanguage = this.props.availableLanguagesByCode[selectedLanguageCode];
            if (!newLanguage) {
                throw new Error("Couldn't select language with code " + selectedLanguageCode + ".\n        Valid languages: " + Object.keys(this.props.availableLanguagesByCode));
            }
            this.props.onChange(newLanguage);
        };
        return LanguageSelectComponent;
    }(React.Component));
    exports.LanguageSelectComponent = LanguageSelectComponent;
    var Factory = React.createFactory(LanguageSelectComponent);
    exports.default = Factory;
});
define("src/uicomponents/language/AppLanguageSelect", ["require", "exports", "react", "src/uicomponents/language/LanguageSelect", "src/App", "src/activeModuleData", "src/localization/activeLanguage", "src/localization/languageSupport"], function (require, exports, React, LanguageSelect_1, App_12, activeModuleData_23, activeLanguage_2, languageSupport_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AppLanguageSelectComponent = (function (_super) {
        __extends(AppLanguageSelectComponent, _super);
        function AppLanguageSelectComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "AppLanguageSelect";
            _this.handleLanguageChange = _this.handleLanguageChange.bind(_this);
            return _this;
        }
        AppLanguageSelectComponent.prototype.render = function () {
            return (LanguageSelect_1.default({
                activeLanguage: this.props.activeLanguage,
                availableLanguagesByCode: languageSupport_3.getLanguagesByCode.apply(void 0, activeModuleData_23.activeModuleData.moduleFiles),
                languageSupportLevelByCode: languageSupport_3.getLanguageSupportLevelForModuleFiles.apply(void 0, activeModuleData_23.activeModuleData.moduleFiles),
                onChange: this.handleLanguageChange,
            }));
        };
        AppLanguageSelectComponent.prototype.handleLanguageChange = function (newLanguage) {
            activeLanguage_2.setActiveLanguageCode(newLanguage.code);
            localStorage.setItem("Rance.language", newLanguage.code);
            App_12.default.reactUI.render();
        };
        return AppLanguageSelectComponent;
    }(React.Component));
    exports.AppLanguageSelectComponent = AppLanguageSelectComponent;
    var Factory = React.createFactory(AppLanguageSelectComponent);
    exports.default = Factory;
});
define("src/uicomponents/galaxymap/OptionsCheckbox", ["require", "exports", "react"], function (require, exports, React) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var OptionsCheckboxComponent = (function (_super) {
        __extends(OptionsCheckboxComponent, _super);
        function OptionsCheckboxComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "OptionsCheckbox";
            return _this;
        }
        OptionsCheckboxComponent.prototype.render = function () {
            var checkboxId = "options-checkbox-" + this.props.label;
            return (React.DOM.div({
                className: "options-checkbox-container",
            }, React.DOM.input({
                type: "checkbox",
                id: checkboxId,
                checked: this.props.isChecked,
                onChange: this.props.onChangeFN,
            }), React.DOM.label({
                htmlFor: checkboxId,
            }, this.props.label)));
        };
        return OptionsCheckboxComponent;
    }(React.Component));
    exports.OptionsCheckboxComponent = OptionsCheckboxComponent;
    var Factory = React.createFactory(OptionsCheckboxComponent);
    exports.default = Factory;
});
define("src/FixedRateTicker", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var FixedRateTicker = (function () {
        function FixedRateTicker(onTick, tickRate) {
            this.accumulatedTime = 0;
            this.tickRate = tickRate;
            this.onTick = onTick;
            this.ticker = new PIXI.ticker.Ticker();
            this.ticker.add(this.onTickerUpdate, this);
        }
        FixedRateTicker.prototype.start = function () {
            this.accumulatedTime = 0;
            this.startTime = performance.now();
            this.ticker.start();
        };
        FixedRateTicker.prototype.stop = function () {
            this.ticker.stop();
        };
        FixedRateTicker.prototype.onTickerUpdate = function () {
            this.accumulatedTime += this.ticker.elapsedMS;
            var ticksToPlay = Math.floor(this.accumulatedTime / this.tickRate);
            if (ticksToPlay) {
                this.accumulatedTime -= ticksToPlay * this.tickRate;
                this.onTick(ticksToPlay);
            }
        };
        return FixedRateTicker;
    }());
    exports.FixedRateTicker = FixedRateTicker;
});
define("src/uicomponents/generic/Spinner", ["require", "exports", "react", "src/FixedRateTicker", "src/utility"], function (require, exports, React, FixedRateTicker_1, utility_38) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SpinnerComponent = (function (_super) {
        __extends(SpinnerComponent, _super);
        function SpinnerComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "Spinner";
            _this.timeBetweenSpins = 50;
            _this.spinStartDelay = 300;
            _this.stepUp = _this.stepUp.bind(_this);
            _this.stepDown = _this.stepDown.bind(_this);
            _this.startSpinUp = _this.startSpinUp.bind(_this);
            _this.startSpinDown = _this.startSpinDown.bind(_this);
            _this.stopSpin = _this.stopSpin.bind(_this);
            _this.onSpinTick = _this.onSpinTick.bind(_this);
            _this.ticker = new FixedRateTicker_1.FixedRateTicker(_this.onSpinTick, _this.timeBetweenSpins);
            return _this;
        }
        SpinnerComponent.prototype.componentWillUnmount = function () {
            this.stopSpin();
        };
        SpinnerComponent.prototype.render = function () {
            return (React.DOM.div({
                className: "spinner",
            }, React.DOM.button({
                className: "spinner-arrow spinner-arrow-up",
                onClick: this.stepUp,
                onMouseDown: this.startSpinUp,
                onTouchStart: this.startSpinUp,
            }), React.DOM.button({
                className: "spinner-arrow spinner-arrow-down",
                onClick: this.stepDown,
                onMouseDown: this.startSpinDown,
                onTouchStart: this.startSpinDown,
            })));
        };
        SpinnerComponent.prototype.adjust = function (delta) {
            var min = isFinite(this.props.min) ? this.props.min : -Infinity;
            var max = isFinite(this.props.max) ? this.props.max : Infinity;
            var newValue = utility_38.clamp(utility_38.roundToNearestMultiple(this.props.value + delta, this.props.step), min, max);
            this.props.onChange(newValue);
        };
        SpinnerComponent.prototype.stepUp = function () {
            this.adjust(this.props.step);
        };
        SpinnerComponent.prototype.stepDown = function () {
            this.adjust(-this.props.step);
        };
        SpinnerComponent.prototype.startSpinUp = function () {
            this.spinDirection = 1;
            this.startSpin();
        };
        SpinnerComponent.prototype.startSpinDown = function () {
            this.spinDirection = -1;
            this.startSpin();
        };
        SpinnerComponent.prototype.startSpin = function () {
            var _this = this;
            document.addEventListener("mouseup", this.stopSpin);
            document.addEventListener("touchend", this.stopSpin);
            this.startSpinTimeoutHandle = window.setTimeout(function () {
                _this.ticker.start();
            }, this.spinStartDelay);
        };
        SpinnerComponent.prototype.stopSpin = function () {
            this.ticker.stop();
            if (isFinite(this.startSpinTimeoutHandle)) {
                window.clearTimeout(this.startSpinTimeoutHandle);
            }
            this.startSpinTimeoutHandle = undefined;
            document.removeEventListener("mouseup", this.stopSpin);
            document.removeEventListener("touchend", this.stopSpin);
        };
        SpinnerComponent.prototype.onSpinTick = function (ticks) {
            this.adjust(this.spinDirection * this.props.step * ticks);
        };
        return SpinnerComponent;
    }(React.Component));
    exports.SpinnerComponent = SpinnerComponent;
    var Factory = React.createFactory(SpinnerComponent);
    exports.default = Factory;
});
define("src/uicomponents/generic/NumberInput", ["require", "exports", "react", "src/uicomponents/generic/Spinner", "src/utility"], function (require, exports, React, Spinner_1, utility_39) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var NumberInputComponent = (function (_super) {
        __extends(NumberInputComponent, _super);
        function NumberInputComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "NumberInput";
            _this.state =
                {
                    displayedValue: "" + _this.roundValue(_this.props.value),
                };
            _this.handleValueChange = _this.handleValueChange.bind(_this);
            _this.changeValue = _this.changeValue.bind(_this);
            _this.handleBlur = _this.handleBlur.bind(_this);
            return _this;
        }
        NumberInputComponent.prototype.componentWillReceiveProps = function (newProps) {
            if ("" + newProps.value !== this.state.displayedValue) {
                this.setState({
                    displayedValue: "" + this.roundValue(newProps.value),
                });
            }
        };
        NumberInputComponent.prototype.componentWillUnmount = function () {
            this.handleBlur();
        };
        NumberInputComponent.prototype.render = function () {
            var defaultAttributes = {
                className: "number-input-container",
            };
            ;
            var customAttributes = this.props.attributes || {};
            var attributes = utility_39.mergeReactAttributes(defaultAttributes, customAttributes);
            return (React.DOM.div(attributes, React.DOM.input({
                className: "number-input",
                type: "text",
                value: this.state.displayedValue,
                onChange: this.handleValueChange,
                onBlur: this.handleBlur,
            }), Spinner_1.default({
                value: this.props.value,
                step: this.getStep(),
                onChange: this.changeValue,
                min: this.props.canWrap ? -Infinity : this.props.min,
                max: this.props.canWrap ? Infinity : this.props.max,
            })));
        };
        NumberInputComponent.prototype.getStep = function () {
            return this.props.step || 1;
        };
        NumberInputComponent.prototype.getDecimalPlacesInStep = function () {
            var split = ("" + this.getStep()).split(".");
            return split[1] ? split[1].length : 0;
        };
        NumberInputComponent.prototype.roundValue = function (value) {
            var precision = this.getDecimalPlacesInStep();
            return parseFloat(value.toFixed(precision));
        };
        NumberInputComponent.prototype.handleBlur = function () {
            if (this.valueStringIsValid(this.state.displayedValue)) {
                this.changeValue(parseFloat(this.state.displayedValue));
            }
            else {
                this.setState({ displayedValue: "" + this.props.value });
            }
        };
        NumberInputComponent.prototype.handleValueChange = function (e) {
            e.stopPropagation();
            e.preventDefault();
            var target = e.currentTarget;
            var valueString = target.value;
            var isValid = this.valueStringIsValid(valueString);
            var isWithinBounds = this.valueIsWithinBounds(parseFloat(valueString));
            if (isValid && isWithinBounds) {
                this.changeValue(parseFloat(valueString));
            }
            else {
                this.setState({
                    displayedValue: valueString,
                });
            }
        };
        NumberInputComponent.prototype.changeValue = function (value) {
            if (value === this.props.value) {
                this.setState({ displayedValue: "" + value });
                return;
            }
            var roundedValue = this.roundValue(value);
            var min = isFinite(this.props.min) ? this.props.min : -Infinity;
            var max = isFinite(this.props.max) ? this.props.max : Infinity;
            if (this.props.canWrap) {
                if (!isFinite(min) || !isFinite(max)) {
                    throw new Error("NumberInput component with wrapping enabled must specify min and max values.");
                }
                if (roundedValue < min) {
                    var underMin = min - (roundedValue % max);
                    this.props.onChange(max - underMin);
                }
                else {
                    this.props.onChange(roundedValue % max);
                }
            }
            else {
                var clampedValue = utility_39.clamp(roundedValue, min, max);
                this.props.onChange(clampedValue);
            }
        };
        NumberInputComponent.prototype.valueStringIsValid = function (valueString) {
            if (!valueString.match(/^(-?(?:0|[1-9]\d*)(?:\.\d+)?)?$/)) {
                return false;
            }
            var value = parseFloat(valueString);
            if (!isFinite(value)) {
                return false;
            }
            return true;
        };
        NumberInputComponent.prototype.valueIsWithinBounds = function (value) {
            var min = isFinite(this.props.min) ? this.props.min : -Infinity;
            var max = isFinite(this.props.max) ? this.props.max : Infinity;
            return value >= min && value <= max;
        };
        return NumberInputComponent;
    }(React.Component));
    exports.NumberInputComponent = NumberInputComponent;
    var Factory = React.createFactory(NumberInputComponent);
    exports.default = Factory;
});
define("src/uicomponents/galaxymap/OptionsNumericField", ["require", "exports", "react", "src/uicomponents/generic/NumberInput"], function (require, exports, React, NumberInput_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var OptionsNumericFieldComponent = (function (_super) {
        __extends(OptionsNumericFieldComponent, _super);
        function OptionsNumericFieldComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "OptionsNumericField";
            return _this;
        }
        OptionsNumericFieldComponent.prototype.render = function () {
            var inputId = "" + this.props.id + "-input";
            return (React.DOM.div({
                className: "options-numeric-field-container",
                id: this.props.id,
            }, NumberInput_1.default({
                attributes: {
                    className: "options-numeric-field-input",
                    id: inputId,
                },
                value: this.props.value,
                onChange: this.props.onChange,
                min: this.props.min,
                max: this.props.max,
                step: this.props.step,
            }), React.DOM.label({
                className: "options-numeric-field-label",
                htmlFor: inputId,
            }, this.props.label)));
        };
        return OptionsNumericFieldComponent;
    }(React.Component));
    exports.OptionsNumericFieldComponent = OptionsNumericFieldComponent;
    var Factory = React.createFactory(OptionsNumericFieldComponent);
    exports.default = Factory;
});
define("src/uicomponents/galaxymap/OptionsList", ["require", "exports", "react", "src/Options", "src/eventManager", "src/tutorials/TutorialStatus", "src/uicomponents/notifications/NotificationFilterButton", "src/uicomponents/windows/DialogBox", "src/uicomponents/language/AppLanguageSelect", "src/uicomponents/galaxymap/OptionsCheckbox", "src/uicomponents/galaxymap/OptionsGroup", "src/uicomponents/galaxymap/OptionsNumericField", "localization/localize"], function (require, exports, React, Options_9, eventManager_34, TutorialStatus_4, NotificationFilterButton_2, DialogBox_4, AppLanguageSelect_1, OptionsCheckbox_1, OptionsGroup_2, OptionsNumericField_1, localize_53) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var OptionsListComponent = (function (_super) {
        __extends(OptionsListComponent, _super);
        function OptionsListComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "OptionsList";
            _this.state =
                {
                    hasConfirmResetAllDialog: false,
                };
            _this.bindMethods();
            return _this;
        }
        OptionsListComponent.prototype.render = function () {
            var _this = this;
            var allOptions = [];
            var languageOptions = [];
            languageOptions.push({
                key: "selectAppLanguage",
                content: AppLanguageSelect_1.default({
                    activeLanguage: this.props.activeLanguage,
                }),
            });
            allOptions.push(OptionsGroup_2.default({
                key: "language",
                header: localize_53.localize("language"),
                options: languageOptions,
            }));
            var battleAnimationOptions = [];
            var battleAnimationStages = [
                {
                    stage: "before",
                    displayName: localize_53.localize("beforeAbility"),
                    min: 0,
                    max: 5000,
                    step: 100,
                },
                {
                    stage: "effectDuration",
                    displayName: localize_53.localize("abilityEffectDuration"),
                    min: 0,
                    max: 10,
                    step: 0.1,
                },
                {
                    stage: "after",
                    displayName: localize_53.localize("afterAbility"),
                    min: 0,
                    max: 5000,
                    step: 100,
                },
                {
                    stage: "unitEnter",
                    displayName: localize_53.localize("unitEnter"),
                    min: 0,
                    max: 1000,
                    step: 50,
                },
                {
                    stage: "unitExit",
                    displayName: localize_53.localize("unitExit"),
                    min: 0,
                    max: 1000,
                    step: 50,
                },
                {
                    stage: "turnTransition",
                    displayName: localize_53.localize("turnTransition"),
                    min: 0,
                    max: 2000,
                    step: 100,
                },
            ];
            var _loop_7 = function (i) {
                var props = battleAnimationStages[i];
                var stage = props.stage;
                battleAnimationOptions.push({
                    key: stage,
                    content: OptionsNumericField_1.default({
                        label: props.displayName,
                        id: "options-battle-animation-" + stage,
                        value: Options_9.default.battleAnimationTiming[stage],
                        min: props.min,
                        max: props.max,
                        step: props.step,
                        onChange: function (value) {
                            Options_9.default.battleAnimationTiming[stage] = value;
                            _this.forceUpdate();
                        },
                    }),
                });
            };
            for (var i = 0; i < battleAnimationStages.length; i++) {
                _loop_7(i);
            }
            allOptions.push(OptionsGroup_2.default({
                key: "battleAnimationOptions",
                header: localize_53.localize("battleAnimationTiming"),
                options: battleAnimationOptions,
                resetFN: function () {
                    Options_9.default.setDefaultForCategory("battleAnimationTiming");
                    _this.forceUpdate();
                },
            }));
            var debugOptions = [];
            debugOptions.push({
                key: "debugMode",
                content: OptionsCheckbox_1.default({
                    isChecked: Options_9.default.debug.enabled,
                    label: localize_53.localize("debugMode"),
                    onChangeFN: function () {
                        Options_9.default.debug.enabled = !Options_9.default.debug.enabled;
                        _this.forceUpdate();
                        eventManager_34.default.dispatchEvent("renderUI");
                    },
                }),
            });
            if (Options_9.default.debug.enabled) {
                debugOptions.push({
                    key: "battleSimulationDepth",
                    content: React.DOM.div({}, OptionsNumericField_1.default({
                        label: localize_53.localize("aiVsAiBattleSimulationDepth"),
                        id: "battle-simulation-depth-input",
                        value: Options_9.default.debug.battleSimulationDepth,
                        min: 1,
                        max: 500,
                        step: 1,
                        onChange: function (value) {
                            Options_9.default.debug.battleSimulationDepth = value;
                            _this.forceUpdate();
                        },
                    })),
                });
            }
            allOptions.push(OptionsGroup_2.default({
                key: "debug",
                header: localize_53.localize("debug"),
                options: debugOptions,
                resetFN: function () {
                    Options_9.default.setDefaultForCategory("debug");
                    _this.forceUpdate();
                },
            }));
            var uiOptions = [];
            uiOptions.push({
                key: "noHamburger",
                content: OptionsCheckbox_1.default({
                    isChecked: Options_9.default.ui.noHamburger,
                    label: localize_53.localize("alwaysExpandTopRightMenuOnLowResolution"),
                    onChangeFN: function () {
                        Options_9.default.ui.noHamburger = !Options_9.default.ui.noHamburger;
                        eventManager_34.default.dispatchEvent("updateHamburgerMenu");
                        _this.forceUpdate();
                    },
                }),
            });
            uiOptions.push({
                key: "notificationLogFilter",
                content: NotificationFilterButton_2.default({
                    filter: this.props.log.notificationFilter,
                    text: localize_53.localize("messageSettings"),
                    highlightedOptionKey: null,
                }),
            });
            uiOptions.push({
                key: "resetTutorials",
                content: React.DOM.button({
                    className: "reset-tutorials-button",
                    onClick: TutorialStatus_4.default.reset,
                }, localize_53.localize("resetTutorials")),
            });
            allOptions.push(OptionsGroup_2.default({
                key: "ui",
                header: localize_53.localize("ui"),
                options: uiOptions,
                resetFN: function () {
                    Options_9.default.setDefaultForCategory("ui");
                },
            }));
            var displayOptions = [];
            displayOptions.push({
                key: "borderWidth",
                content: OptionsNumericField_1.default({
                    label: localize_53.localize("borderWidth"),
                    id: "options-border-width",
                    min: 0,
                    max: 50,
                    step: 1,
                    value: Options_9.default.display.borderWidth,
                    onChange: function (value) {
                        Options_9.default.display.borderWidth = value;
                        eventManager_34.default.dispatchEvent("renderMap");
                        _this.forceUpdate();
                    },
                }),
            });
            allOptions.push(OptionsGroup_2.default({
                key: "display",
                header: localize_53.localize("display"),
                options: displayOptions,
                resetFN: function () {
                    Options_9.default.setDefaultForCategory("display");
                    _this.forceUpdate();
                },
            }));
            return (React.DOM.div({ className: "options" }, !this.state.hasConfirmResetAllDialog ? null :
                DialogBox_4.default({
                    title: localize_53.localize("resetAllOptions"),
                    handleOk: function () {
                        Options_9.default.setDefaults();
                        _this.closeResetAllOptionsDialog();
                    },
                    handleCancel: function () {
                        _this.closeResetAllOptionsDialog();
                    },
                }, localize_53.localize("areYouSureYouWantToResetAllOptions")), React.DOM.div({ className: "options-header" }, React.DOM.button({
                className: "reset-options-button reset-all-options-button",
                onClick: this.openResetAllOptionsDialog,
            }, localize_53.localize("resetAllOptions"))), allOptions));
        };
        OptionsListComponent.prototype.bindMethods = function () {
            this.openResetAllOptionsDialog = this.openResetAllOptionsDialog.bind(this);
            this.closeResetAllOptionsDialog = this.closeResetAllOptionsDialog.bind(this);
        };
        OptionsListComponent.prototype.openResetAllOptionsDialog = function () {
            this.setState({
                hasConfirmResetAllDialog: true,
            });
        };
        OptionsListComponent.prototype.closeResetAllOptionsDialog = function () {
            this.setState({
                hasConfirmResetAllDialog: false,
            });
        };
        return OptionsListComponent;
    }(React.Component));
    exports.OptionsListComponent = OptionsListComponent;
    var Factory = React.createFactory(OptionsListComponent);
    exports.default = Factory;
});
define("src/uicomponents/galaxymap/TopMenuPopups", ["require", "exports", "react", "src/Options", "src/uicomponents/windows/DefaultWindow", "src/uicomponents/diplomacy/DiplomacyOverview", "src/uicomponents/production/ProductionOverview", "src/uicomponents/saves/LoadGame", "src/uicomponents/saves/SaveGame", "src/uicomponents/technologies/TechnologiesList", "src/uicomponents/unitlist/ItemEquip", "src/uicomponents/galaxymap/EconomySummary", "src/uicomponents/galaxymap/OptionsList", "localization/localize"], function (require, exports, React, Options_10, DefaultWindow_8, DiplomacyOverview_1, ProductionOverview_1, LoadGame_1, SaveGame_1, TechnologiesList_1, ItemEquip_1, EconomySummary_1, OptionsList_1, localize_54) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TopMenuPopupsComponent = (function (_super) {
        __extends(TopMenuPopupsComponent, _super);
        function TopMenuPopupsComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "TopMenuPopups";
            _this.popupComponents = {};
            _this.cachedPopupPositions = {};
            _this.popupConstructData = {
                production: {
                    makeContent: function () { return ProductionOverview_1.default({
                        player: _this.props.player,
                    }); },
                    title: localize_54.localize("production"),
                },
                equipItems: {
                    makeContent: function () { return ItemEquip_1.default({
                        player: _this.props.player,
                    }); },
                    title: localize_54.localize("equip"),
                },
                economySummary: {
                    makeContent: function () { return EconomySummary_1.default({
                        player: _this.props.player,
                    }); },
                    title: localize_54.localize("economy"),
                },
                saveGame: {
                    makeContent: function () { return SaveGame_1.default({
                        handleClose: _this.closePopup.bind(_this, "saveGame"),
                    }); },
                    title: localize_54.localize("save_imperative"),
                },
                loadGame: {
                    makeContent: function () { return LoadGame_1.default({
                        handleClose: _this.closePopup.bind(_this, "loadGame"),
                    }); },
                    title: localize_54.localize("load_imperative"),
                },
                options: {
                    makeContent: function () { return OptionsList_1.default({
                        log: _this.props.notificationLog,
                        activeLanguage: _this.props.activeLanguage,
                    }); },
                    title: localize_54.localize("options"),
                },
                diplomacy: {
                    makeContent: function () { return DiplomacyOverview_1.default({
                        player: _this.props.player,
                    }); },
                    title: localize_54.localize("diplomacy"),
                },
                technologies: {
                    makeContent: function () { return TechnologiesList_1.default({
                        playerTechnology: _this.props.player.playerTechnology,
                    }); },
                    title: localize_54.localize("technology"),
                },
            };
            _this.state = _this.getInitialStateTODO();
            _this.bindMethods();
            return _this;
        }
        TopMenuPopupsComponent.prototype.togglePopup = function (popupType) {
            if (this.state[popupType]) {
                this.closePopup(popupType);
            }
            else {
                this.openPopup(popupType);
            }
        };
        TopMenuPopupsComponent.prototype.render = function () {
            var popups = [];
            for (var popupType in this.state) {
                if (this.state[popupType]) {
                    popups.push(this.makePopup(popupType));
                }
            }
            return (React.DOM.div({
                className: "top-menu-popups-wrapper",
            }, popups));
        };
        TopMenuPopupsComponent.prototype.bindMethods = function () {
            this.openPopup = this.openPopup.bind(this);
            this.closePopup = this.closePopup.bind(this);
            this.togglePopup = this.togglePopup.bind(this);
        };
        TopMenuPopupsComponent.prototype.getInitialStateTODO = function () {
            return ({
                production: false,
                equipItems: false,
                economySummary: false,
                saveGame: false,
                loadGame: false,
                options: false,
                diplomacy: false,
                technologies: false,
            });
        };
        TopMenuPopupsComponent.prototype.closePopup = function (popupType) {
            var popupComponent = this.popupComponents[popupType];
            this.cachedPopupPositions[popupType] = popupComponent.windowContainerComponent.getPosition();
            if (popupType === "options") {
                Options_10.default.save();
            }
            this.popupComponents[popupType] = null;
            var stateObj = {};
            stateObj[popupType] = false;
            this.setState(stateObj);
        };
        TopMenuPopupsComponent.prototype.openPopup = function (popupType) {
            var stateObj = {};
            stateObj[popupType] = true;
            this.setState(stateObj);
        };
        TopMenuPopupsComponent.prototype.makePopup = function (popupType) {
            var _this = this;
            var constructData = this.popupConstructData[popupType];
            return DefaultWindow_8.default({
                key: popupType,
                ref: function (component) {
                    _this.popupComponents[popupType] = component;
                },
                title: constructData.title,
                handleClose: function () {
                    _this.closePopup(popupType);
                },
                getInitialPosition: !this.cachedPopupPositions[popupType] ?
                    undefined :
                    function (ownRect, container) {
                        return _this.cachedPopupPositions[popupType];
                    },
                minWidth: 150,
                minHeight: 100,
            }, constructData.makeContent());
        };
        return TopMenuPopupsComponent;
    }(React.Component));
    exports.TopMenuPopupsComponent = TopMenuPopupsComponent;
    var Factory = React.createFactory(TopMenuPopupsComponent);
    exports.default = Factory;
});
define("src/uicomponents/galaxymap/TopMenu", ["require", "exports", "react", "react-dom", "src/Options", "src/eventManager", "src/uicomponents/galaxymap/TopMenuPopups", "localization/localize"], function (require, exports, React, ReactDOM, Options_11, eventManager_35, TopMenuPopups_1, localize_55) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TopMenuComponent = (function (_super) {
        __extends(TopMenuComponent, _super);
        function TopMenuComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "TopMenu";
            _this.cachedTopMenuWidth = undefined;
            _this.cachedButtonWidths = [];
            _this.cachedMenuButtonWidth = 37;
            _this.state = _this.getInitialStateTODO();
            _this.bindMethods();
            return _this;
        }
        TopMenuComponent.prototype.bindMethods = function () {
            this.handleResize = this.handleResize.bind(this);
            this.togglePopup = this.togglePopup.bind(this);
            this.toggleCondensedMenu = this.toggleCondensedMenu.bind(this);
            this.handleToggleHamburger = this.handleToggleHamburger.bind(this);
            this.delayedResize = this.delayedResize.bind(this);
        };
        TopMenuComponent.prototype.getInitialStateTODO = function () {
            return ({
                hasCondensedMenu: false,
                buttonsToPlace: 999,
                condensedMenuOpened: Options_11.default.ui.noHamburger,
            });
        };
        TopMenuComponent.prototype.componentDidMount = function () {
            window.addEventListener("resize", this.handleResize, false);
            eventManager_35.default.addEventListener("playerControlUpdated", this.delayedResize);
            eventManager_35.default.addEventListener("updateHamburgerMenu", this.handleToggleHamburger);
            this.handleResize();
        };
        TopMenuComponent.prototype.componentWillUnmount = function () {
            window.removeEventListener("resize", this.handleResize);
            eventManager_35.default.removeEventListener("playerControlUpdated", this.delayedResize);
            eventManager_35.default.removeEventListener("updateHamburgerMenu", this.handleToggleHamburger);
        };
        TopMenuComponent.prototype.handleToggleHamburger = function () {
            this.handleResize();
            this.forceUpdate();
        };
        TopMenuComponent.prototype.delayedResize = function () {
            window.setTimeout(this.handleResize, 0);
        };
        TopMenuComponent.prototype.handleResize = function () {
            if (!this.cachedTopMenuWidth) {
                this.cachedTopMenuWidth = ReactDOM.findDOMNode(this.ref_TODO_topMenu).getBoundingClientRect().width;
                var buttons = ReactDOM.findDOMNode(this.ref_TODO_topMenuItems).children;
                var margin = parseInt(window.getComputedStyle(buttons[0]).margin) * 2;
                for (var i = 0; i < buttons.length; i++) {
                    var buttonWidth = buttons[i].getBoundingClientRect().width + margin;
                    this.cachedButtonWidths.push(buttonWidth);
                }
            }
            var topMenuHeight = window.innerHeight > 600 ? 50 : 32;
            var topBar = document.getElementsByClassName("top-bar-info")[0];
            var topBarRect = topBar.getBoundingClientRect();
            var rightmostElement = topBar;
            var rightmostRect = topBarRect;
            var fleetContainer = document.getElementsByClassName("fleet-selection")[0];
            if (fleetContainer) {
                var fleetElementToCheckAgainst = void 0;
                var firstChild = fleetContainer.firstChild;
                if (firstChild.classList.contains("fleet-selection-controls")) {
                    fleetElementToCheckAgainst = document.getElementsByClassName("fleet-selection-selected-wrapper")[0];
                }
                else {
                    fleetElementToCheckAgainst = firstChild;
                }
                if (fleetElementToCheckAgainst) {
                    var fleetRect = fleetElementToCheckAgainst.getBoundingClientRect();
                    if (fleetRect.top < topMenuHeight && fleetRect.right > topBarRect.right) {
                        rightmostElement = fleetElementToCheckAgainst;
                        rightmostRect = fleetRect;
                    }
                }
            }
            var spaceAvailable = window.innerWidth - rightmostRect.right;
            var hasCondensedMenu = spaceAvailable < this.cachedTopMenuWidth;
            var amountOfButtonsToPlace = 0;
            if (hasCondensedMenu) {
                if (!Options_11.default.ui.noHamburger) {
                    spaceAvailable -= this.cachedMenuButtonWidth;
                }
                var padding = window.innerHeight > 600 ? 25 : 0;
                for (var i = 0; i < this.cachedButtonWidths.length; i++) {
                    var buttonWidthToCheck = this.cachedButtonWidths[i];
                    if (spaceAvailable > buttonWidthToCheck + padding) {
                        amountOfButtonsToPlace++;
                        spaceAvailable -= buttonWidthToCheck;
                    }
                    else {
                        break;
                    }
                }
            }
            else {
                amountOfButtonsToPlace = this.cachedButtonWidths.length;
            }
            this.setState({
                hasCondensedMenu: hasCondensedMenu,
                buttonsToPlace: amountOfButtonsToPlace,
            });
        };
        TopMenuComponent.prototype.togglePopup = function (popupType) {
            this.ref_TODO_popups.togglePopup(popupType);
            this.forceUpdate();
        };
        TopMenuComponent.prototype.toggleCondensedMenu = function () {
            this.setState({
                condensedMenuOpened: !this.state.condensedMenuOpened,
            });
        };
        TopMenuComponent.prototype.render = function () {
            var _this = this;
            var menuItemTabIndex = this.state.opened ? -1 : 0;
            var topMenuButtons = [
                React.DOM.button({
                    className: "top-menu-items-button top-menu-items-button-production",
                    key: "production",
                    onClick: this.togglePopup.bind(this, "production"),
                    tabIndex: menuItemTabIndex,
                }, localize_55.localize("production")),
                React.DOM.button({
                    className: "top-menu-items-button top-menu-items-button-equip",
                    key: "equipItems",
                    onClick: this.togglePopup.bind(this, "equipItems"),
                    tabIndex: menuItemTabIndex,
                }, localize_55.localize("equip")),
                React.DOM.button({
                    className: "top-menu-items-button top-menu-items-button-diplomacy",
                    key: "diplomacy",
                    onClick: this.togglePopup.bind(this, "diplomacy"),
                    tabIndex: menuItemTabIndex,
                }, localize_55.localize("diplomacy")),
                React.DOM.button({
                    className: "top-menu-items-button top-menu-items-button-technology",
                    key: "technologies",
                    onClick: this.togglePopup.bind(this, "technologies"),
                    tabIndex: menuItemTabIndex,
                }, localize_55.localize("technology")),
                React.DOM.button({
                    className: "top-menu-items-button top-menu-items-button-load",
                    key: "loadGame",
                    onClick: this.togglePopup.bind(this, "loadGame"),
                    tabIndex: menuItemTabIndex,
                }, localize_55.localize("load_imperative")),
                React.DOM.button({
                    className: "top-menu-items-button top-menu-items-button-save",
                    key: "saveGame",
                    onClick: this.togglePopup.bind(this, "saveGame"),
                    tabIndex: menuItemTabIndex,
                }, localize_55.localize("save_imperative")),
                React.DOM.button({
                    className: "top-menu-items-button top-menu-items-button-options",
                    key: "options",
                    onClick: this.togglePopup.bind(this, "options"),
                    tabIndex: menuItemTabIndex,
                }, localize_55.localize("options")),
            ];
            var topMenuItems = topMenuButtons.slice(0, this.state.buttonsToPlace);
            var leftoverButtons = topMenuButtons.slice(this.state.buttonsToPlace);
            if (this.state.hasCondensedMenu && !Options_11.default.ui.noHamburger) {
                topMenuItems.push(React.DOM.button({
                    className: "top-menu-items-button top-menu-open-condensed-button",
                    key: "openCondensedMenu",
                    onClick: this.toggleCondensedMenu,
                    tabIndex: menuItemTabIndex,
                }));
            }
            var openedCondensedMenu = null;
            if ((this.state.condensedMenuOpened || Options_11.default.ui.noHamburger) && leftoverButtons.length > 0) {
                openedCondensedMenu = React.DOM.div({
                    className: "top-menu-opened-condensed-menu",
                }, leftoverButtons);
            }
            ;
            return (React.DOM.div({
                className: "top-menu-wrapper",
            }, React.DOM.div({
                className: "top-menu",
                ref: function (component) {
                    _this.ref_TODO_topMenu = component;
                },
            }, React.DOM.div({
                className: "top-menu-items",
                ref: function (component) {
                    _this.ref_TODO_topMenuItems = component;
                },
            }, topMenuItems)), openedCondensedMenu, TopMenuPopups_1.default({
                ref: function (component) {
                    _this.ref_TODO_popups = component;
                },
                player: this.props.player,
                game: this.props.game,
                activeLanguage: this.props.activeLanguage,
                notificationLog: this.props.notificationLog,
            })));
        };
        return TopMenuComponent;
    }(React.PureComponent));
    exports.TopMenuComponent = TopMenuComponent;
    var Factory = React.createFactory(TopMenuComponent);
    exports.default = Factory;
});
define("src/uicomponents/galaxymap/GalaxyMapUI", ["require", "exports", "react", "react-dom", "src/activePlayer", "src/eventManager", "src/uicomponents/mapmodes/MapModeSettings", "src/uicomponents/notifications/Notifications", "src/uicomponents/possibleactions/PossibleActions", "src/uicomponents/tutorials/IntroTutorial", "src/uicomponents/galaxymap/FleetSelection", "src/uicomponents/galaxymap/StarInfo", "src/uicomponents/galaxymap/TopBar", "src/uicomponents/galaxymap/TopMenu", "localization/localize"], function (require, exports, React, ReactDOM, activePlayer_4, eventManager_36, MapModeSettings_1, Notifications_1, PossibleActions_1, IntroTutorial_2, FleetSelection_1, StarInfo_1, TopBar_1, TopMenu_1, localize_56) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var GalaxyMapUIComponent = (function (_super) {
        __extends(GalaxyMapUIComponent, _super);
        function GalaxyMapUIComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "GalaxyMapUI";
            _this.state = _this.getInitialStateTODO();
            _this.bindMethods();
            return _this;
        }
        GalaxyMapUIComponent.prototype.bindMethods = function () {
            this.clampExpandedActionElement = this.clampExpandedActionElement.bind(this);
            this.setExpandedActionElement = this.setExpandedActionElement.bind(this);
            this.closeReorganization = this.closeReorganization.bind(this);
            this.endTurn = this.endTurn.bind(this);
            this.toggleMapModeSettingsExpanded = this.toggleMapModeSettingsExpanded.bind(this);
            this.updateSelection = this.updateSelection.bind(this);
            this.setPlayerTurn = this.setPlayerTurn.bind(this);
        };
        GalaxyMapUIComponent.prototype.getInitialStateTODO = function () {
            var pc = this.props.playerControl;
            return ({
                selectedFleets: pc.selectedFleets,
                inspectedFleets: pc.inspectedFleets,
                currentlyReorganizing: pc.currentlyReorganizing,
                selectedStar: pc.selectedStar,
                attackTargets: pc.currentAttackTargets,
                isPlayerTurn: this.props.game.playerToAct === activePlayer_4.activePlayer,
                expandedActionElement: null,
                hasMapModeSettingsExpanded: false,
            });
        };
        GalaxyMapUIComponent.prototype.componentWillMount = function () {
            eventManager_36.default.addEventListener("playerControlUpdated", this.updateSelection);
            eventManager_36.default.addEventListener("endTurn", this.setPlayerTurn);
        };
        GalaxyMapUIComponent.prototype.componentWillUnmount = function () {
            eventManager_36.default.removeEventListener("playerControlUpdated", this.updateSelection);
            eventManager_36.default.removeEventListener("endTurn", this.setPlayerTurn);
        };
        GalaxyMapUIComponent.prototype.componentDidUpdate = function () {
            this.clampExpandedActionElement();
        };
        GalaxyMapUIComponent.prototype.clampExpandedActionElement = function () {
            if (!this.state.expandedActionElement)
                return;
            var maxHeight = ReactDOM.findDOMNode(this.ref_TODO_leftColumnContent).getBoundingClientRect().height;
            var listElement = ReactDOM.findDOMNode(this.ref_TODO_expandedActionElementContainer).firstChild.firstChild;
            listElement.style.maxHeight = "" + (maxHeight - 10) + "px";
        };
        GalaxyMapUIComponent.prototype.endTurn = function () {
            this.props.game.endTurn();
        };
        GalaxyMapUIComponent.prototype.setPlayerTurn = function () {
            this.setState({
                isPlayerTurn: !this.props.game.playerToAct.isAI,
            });
        };
        GalaxyMapUIComponent.prototype.setExpandedActionElement = function (element) {
            this.setState({
                expandedActionElement: element,
            });
        };
        GalaxyMapUIComponent.prototype.toggleMapModeSettingsExpanded = function () {
            this.setState({ hasMapModeSettingsExpanded: !this.state.hasMapModeSettingsExpanded });
        };
        GalaxyMapUIComponent.prototype.updateSelection = function () {
            var pc = this.props.playerControl;
            var star = null;
            if (pc.selectedStar)
                star = pc.selectedStar;
            else if (pc.areAllFleetsInSameLocation()) {
                star = pc.selectedFleets[0].location;
            }
            ;
            this.setState({
                selectedFleets: pc.selectedFleets,
                inspectedFleets: pc.inspectedFleets,
                currentlyReorganizing: pc.currentlyReorganizing,
                selectedStar: star,
                attackTargets: pc.currentAttackTargets,
            });
        };
        GalaxyMapUIComponent.prototype.closeReorganization = function () {
            eventManager_36.default.dispatchEvent("endReorganizingFleets");
            this.updateSelection();
        };
        GalaxyMapUIComponent.prototype.render = function () {
            var _this = this;
            var endTurnButtonProps = {
                className: "end-turn-button",
                onClick: this.endTurn,
                tabIndex: -1,
            };
            if (!this.state.isPlayerTurn) {
                endTurnButtonProps.className += " disabled";
                endTurnButtonProps.disabled = true;
            }
            var selectionContainerClassName = "fleet-selection-container";
            if (this.state.currentlyReorganizing.length > 0) {
                selectionContainerClassName += " reorganizing";
            }
            var isInspecting = this.state.inspectedFleets.length > 0;
            var expandedActionElement = null;
            if (this.state.expandedActionElement) {
                expandedActionElement = React.DOM.div({
                    className: "galaxy-map-ui-bottom-left-column",
                    ref: function (component) {
                        _this.ref_TODO_expandedActionElementContainer = component;
                    },
                }, this.state.expandedActionElement);
            }
            return (React.DOM.div({
                className: "galaxy-map-ui",
            }, IntroTutorial_2.default(), React.DOM.div({
                className: "galaxy-map-ui-top",
            }, TopBar_1.default({
                player: this.props.player,
                game: this.props.game,
            }), TopMenu_1.default({
                player: this.props.player,
                game: this.props.game,
                activeLanguage: this.props.activeLanguage,
                notificationLog: this.props.notificationLog,
            }), React.DOM.div({
                className: selectionContainerClassName,
            }, FleetSelection_1.default({
                selectedFleets: (isInspecting ?
                    this.state.inspectedFleets : this.state.selectedFleets),
                isInspecting: isInspecting,
                selectedStar: this.state.selectedStar,
                currentlyReorganizing: this.state.currentlyReorganizing,
                closeReorganization: this.closeReorganization,
                player: this.props.player,
            }))), React.DOM.div({
                className: "galaxy-map-ui-bottom-left",
                key: "bottomLeft",
            }, React.DOM.div({
                className: "galaxy-map-ui-bottom-left-column align-bottom",
                key: "bottomLeftColumn",
            }, React.DOM.div({
                className: "galaxy-map-ui-bottom-left-leftmost-column-wrapper",
                ref: function (component) {
                    _this.ref_TODO_leftColumnContent = component;
                },
                key: "leftColumnContent",
            }, PossibleActions_1.default({
                attackTargets: this.state.attackTargets,
                selectedStar: this.state.selectedStar,
                player: this.props.player,
                setExpandedActionElementOnParent: this.setExpandedActionElement,
                key: "possibleActions",
            }), StarInfo_1.default({
                selectedStar: this.state.selectedStar,
                key: "starInfo",
            }))), expandedActionElement), React.DOM.div({
                className: "galaxy-map-ui-bottom-right",
                key: "bottomRight",
            }, !this.state.hasMapModeSettingsExpanded ? null : MapModeSettings_1.default({
                mapRenderer: this.props.mapRenderer,
                key: "mapRendererLayersList",
            }), React.DOM.button({
                className: "toggle-map-mode-settings-button",
                tabIndex: -1,
                onClick: this.toggleMapModeSettingsExpanded,
            }, localize_56.localize("mapMode")), Notifications_1.default({
                log: this.props.notificationLog,
                currentTurn: this.props.game.turnNumber,
                key: "notifications",
            }), React.DOM.button(endTurnButtonProps, localize_56.localize("endTurn")))));
        };
        return GalaxyMapUIComponent;
    }(React.Component));
    exports.GalaxyMapUIComponent = GalaxyMapUIComponent;
    var Factory = React.createFactory(GalaxyMapUIComponent);
    exports.default = Factory;
});
define("src/uicomponents/galaxymap/GameOverScreen", ["require", "exports", "react", "src/uicomponents/windows/DefaultWindow", "src/uicomponents/windows/DialogBox", "src/uicomponents/saves/LoadGame", "localization/localize"], function (require, exports, React, DefaultWindow_9, DialogBox_5, LoadGame_2, localize_57) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var GameOverScreenComponent = (function (_super) {
        __extends(GameOverScreenComponent, _super);
        function GameOverScreenComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "GameOverScreen";
            _this.state =
                {
                    hasLoadPopup: false,
                    hasConfirmNewGamePopup: false,
                };
            _this.toggleLoadPopup = _this.toggleLoadPopup.bind(_this);
            _this.closeLoadPopup = _this.closeLoadPopup.bind(_this);
            _this.toggleNewGamePopup = _this.toggleNewGamePopup.bind(_this);
            _this.closeNewGamePopup = _this.closeNewGamePopup.bind(_this);
            return _this;
        }
        GameOverScreenComponent.prototype.render = function () {
            return (React.DOM.div({
                className: "game-over-screen",
            }, React.DOM.div({
                className: "game-over-screen-inner",
            }, React.DOM.h1({
                className: "game-over-header",
            }, localize_57.localize("gameOver")), React.DOM.div({
                className: "game-over-buttons",
            }, React.DOM.button({
                className: "game-over-buttons-button",
                onClick: this.toggleLoadPopup,
            }, localize_57.localize("load_imperative")), React.DOM.button({
                className: "game-over-buttons-button",
                onClick: this.toggleNewGamePopup,
            }, localize_57.localize("newGame")))), !this.state.hasConfirmNewGamePopup ? null :
                DialogBox_5.default({
                    title: localize_57.localize("newGame"),
                    handleOk: function () {
                        window.location.reload(false);
                    },
                    handleCancel: this.closeNewGamePopup,
                }, localize_57.localize("areYouSureYouWantToStartANewGame")), !this.state.hasLoadPopup ? null :
                DefaultWindow_9.default({
                    title: localize_57.localize("loadGame"),
                    handleClose: this.closeLoadPopup,
                    minWidth: 200,
                    minHeight: 200,
                }, LoadGame_2.default({
                    handleClose: this.closeLoadPopup,
                }))));
        };
        GameOverScreenComponent.prototype.closeLoadPopup = function () {
            this.setState({ hasLoadPopup: false });
        };
        GameOverScreenComponent.prototype.closeNewGamePopup = function () {
            this.setState({ hasConfirmNewGamePopup: false });
        };
        GameOverScreenComponent.prototype.toggleLoadPopup = function () {
            if (this.state.hasLoadPopup) {
                this.closeLoadPopup();
            }
            else {
                this.setState({ hasLoadPopup: true });
            }
        };
        GameOverScreenComponent.prototype.toggleNewGamePopup = function () {
            if (this.state.hasConfirmNewGamePopup) {
                this.closeNewGamePopup();
            }
            else {
                this.setState({ hasConfirmNewGamePopup: true });
            }
        };
        return GameOverScreenComponent;
    }(React.Component));
    exports.GameOverScreenComponent = GameOverScreenComponent;
    var Factory = React.createFactory(GameOverScreenComponent);
    exports.default = Factory;
});
define("src/uicomponents/galaxymap/GalaxyMap", ["require", "exports", "react", "react-dom", "src/uicomponents/galaxymap/GalaxyMapUI", "src/uicomponents/galaxymap/GameOverScreen"], function (require, exports, React, ReactDOM, GalaxyMapUI_1, GameOverScreen_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var GalaxyMapComponent = (function (_super) {
        __extends(GalaxyMapComponent, _super);
        function GalaxyMapComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "GalaxyMap";
            return _this;
        }
        GalaxyMapComponent.prototype.render = function () {
            var _this = this;
            return (React.DOM.div({
                className: "galaxy-map",
            }, React.DOM.div({
                ref: function (component) {
                    _this.ref_TODO_pixiContainer = component;
                },
                id: "pixi-container",
            }, this.props.game.hasEnded ?
                GameOverScreen_1.default() :
                GalaxyMapUI_1.default({
                    playerControl: this.props.playerControl,
                    player: this.props.player,
                    game: this.props.game,
                    mapRenderer: this.props.mapRenderer,
                    activeLanguage: this.props.activeLanguage,
                    notificationLog: this.props.notificationLog,
                    key: "galaxyMapUI",
                }))));
        };
        GalaxyMapComponent.prototype.componentDidMount = function () {
            this.props.renderer.bindRendererView(ReactDOM.findDOMNode(this.ref_TODO_pixiContainer));
            this.props.mapRenderer.setMapModeByKey("defaultMapMode");
            this.props.renderer.camera.getBoundsObjectBoundsFN = this.props.mapRenderer.getMapBoundsForCamera.bind(this.props.mapRenderer);
            this.props.renderer.resume();
            this.props.mapRenderer.setAllLayersAsDirty();
        };
        GalaxyMapComponent.prototype.componentWillUnmount = function () {
            this.props.renderer.pause();
            this.props.renderer.removeRendererView();
        };
        return GalaxyMapComponent;
    }(React.Component));
    exports.GalaxyMapComponent = GalaxyMapComponent;
    var Factory = React.createFactory(GalaxyMapComponent);
    exports.default = Factory;
});
define("src/uicomponents/setupgame/MapGenOption", ["require", "exports", "react", "src/utility"], function (require, exports, React, utility_40) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MapGenOptionComponent = (function (_super) {
        __extends(MapGenOptionComponent, _super);
        function MapGenOptionComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "MapGenOption";
            _this.bindMethods();
            return _this;
        }
        MapGenOptionComponent.prototype.handleChange = function (e) {
            var target = e.currentTarget;
            var option = this.props.option;
            var newValue = utility_40.clamp(parseFloat(target.value), option.range.min, option.range.max);
            this.props.onChange(this.props.id, newValue);
        };
        MapGenOptionComponent.prototype.shouldComponentUpdate = function (newProps) {
            return newProps.value !== this.props.value;
        };
        MapGenOptionComponent.prototype.bindMethods = function () {
            this.handleChange = this.handleChange.bind(this);
        };
        MapGenOptionComponent.prototype.render = function () {
            var _this = this;
            var option = this.props.option;
            var range = option.range;
            var id = "mapGenOption_" + this.props.id;
            ["min", "max", "step"].forEach(function (prop) {
                if (!range[prop]) {
                    throw new Error("No property " + prop + " specified on map gen option " + _this.props.id);
                }
            });
            return (React.DOM.div({
                className: "map-gen-option",
            }, React.DOM.label({
                className: "map-gen-option-label",
                title: option.displayName,
                htmlFor: id,
            }, option.displayName), React.DOM.input({
                className: "map-gen-option-slider",
                id: id,
                type: "range",
                min: range.min,
                max: range.max,
                step: range.step,
                value: "" + this.props.value,
                onChange: this.handleChange,
            }), React.DOM.input({
                className: "map-gen-option-value",
                title: option.displayName,
                type: "number",
                min: range.min,
                max: range.max,
                step: range.step,
                value: "" + this.props.value,
                onChange: this.handleChange,
            })));
        };
        return MapGenOptionComponent;
    }(React.Component));
    exports.MapGenOptionComponent = MapGenOptionComponent;
    var Factory = React.createFactory(MapGenOptionComponent);
    exports.default = Factory;
});
define("src/uicomponents/setupgame/MapGenOptions", ["require", "exports", "react", "src/utility", "src/uicomponents/galaxymap/OptionsGroup", "src/uicomponents/setupgame/MapGenOption", "localization/localize"], function (require, exports, React, utility_41, OptionsGroup_3, MapGenOption_1, localize_58) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MapGenOptionsComponent = (function (_super) {
        __extends(MapGenOptionsComponent, _super);
        function MapGenOptionsComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "MapGenOptions";
            _this.state = _this.getInitialStateTODO();
            _this.bindMethods();
            return _this;
        }
        MapGenOptionsComponent.prototype.bindMethods = function () {
            this.resetValuesToDefault = this.resetValuesToDefault.bind(this);
            this.handleOptionChange = this.handleOptionChange.bind(this);
            this.getDefaultValues = this.getDefaultValues.bind(this);
            this.getOptionValue = this.getOptionValue.bind(this);
            this.randomizeOptions = this.randomizeOptions.bind(this);
            this.getOptionValuesForTemplate = this.getOptionValuesForTemplate.bind(this);
        };
        MapGenOptionsComponent.prototype.getInitialStateTODO = function () {
            return this.getDefaultValues(this.props.mapGenTemplate);
        };
        MapGenOptionsComponent.prototype.componentWillReceiveProps = function (newProps) {
            if (newProps.mapGenTemplate.key !== this.props.mapGenTemplate.key) {
                this.setState(this.getDefaultValues(newProps.mapGenTemplate));
            }
        };
        MapGenOptionsComponent.prototype.getDefaultValues = function (mapGenTemplate, unsetOnly) {
            var _this = this;
            if (unsetOnly === void 0) { unsetOnly = true; }
            var defaultValues = {};
            ["defaultOptions", "basicOptions", "advancedOptions"].forEach(function (optionGroup) {
                var options = mapGenTemplate.options[optionGroup];
                if (!options)
                    return;
                for (var optionName in options) {
                    var option = options[optionName].range;
                    var value = void 0;
                    if (unsetOnly && _this.state && isFinite(_this.getOptionValue(optionName))) {
                        if (!_this.props.mapGenTemplate.options[optionGroup])
                            continue;
                        var oldOption = _this.props.mapGenTemplate.options[optionGroup][optionName];
                        if (!oldOption)
                            continue;
                        var oldValuePercentage = utility_41.getRelativeValue(_this.getOptionValue(optionName), oldOption.range.min, oldOption.range.max);
                        value = option.min + (option.max - option.min) * oldValuePercentage;
                    }
                    else {
                        value = isFinite(option.defaultValue) ? option.defaultValue : (option.min + option.max) / 2;
                    }
                    value = utility_41.clamp(utility_41.roundToNearestMultiple(value, option.step), option.min, option.max);
                    defaultValues["optionValue_" + optionName] = value;
                }
            });
            return defaultValues;
        };
        MapGenOptionsComponent.prototype.resetValuesToDefault = function () {
            this.setState(this.getDefaultValues(this.props.mapGenTemplate, false));
        };
        MapGenOptionsComponent.prototype.handleOptionChange = function (optionName, newValue) {
            var changedState = {};
            changedState["optionValue_" + optionName] = newValue;
            this.setState(changedState);
        };
        MapGenOptionsComponent.prototype.getOptionValue = function (optionName) {
            return this.state["optionValue_" + optionName];
        };
        MapGenOptionsComponent.prototype.randomizeOptions = function () {
            var newValues = {};
            var optionGroups = this.props.mapGenTemplate.options;
            for (var optionGroupName in optionGroups) {
                var optionGroup = optionGroups[optionGroupName];
                for (var optionName in optionGroup) {
                    var option = optionGroup[optionName].range;
                    var optionValue = utility_41.clamp(utility_41.roundToNearestMultiple(utility_41.randInt(option.min, option.max), option.step), option.min, option.max);
                    newValues["optionValue_" + optionName] = optionValue;
                }
            }
            this.setState(newValues);
        };
        MapGenOptionsComponent.prototype.getOptionValuesForTemplate = function () {
            var optionValues = utility_41.extendObject(this.props.mapGenTemplate.options);
            for (var groupName in optionValues) {
                var optionsGroup = optionValues[groupName];
                for (var optionName in optionsGroup) {
                    var optionValue = this.getOptionValue(optionName);
                    if (!isFinite(optionValue)) {
                        throw new Error("Value " + optionValue + " for option " + optionName + " is invalid.");
                    }
                    optionValues[groupName][optionName] = optionValue;
                }
            }
            return optionValues;
        };
        MapGenOptionsComponent.prototype.render = function () {
            var optionGroups = [];
            var optionGroupsInfo = {
                defaultOptions: {
                    title: localize_58.localize("defaultOptions"),
                    isCollapsedInitially: false,
                },
                basicOptions: {
                    title: localize_58.localize("basicOptions"),
                    isCollapsedInitially: false,
                },
                advancedOptions: {
                    title: localize_58.localize("advancedOptions"),
                    isCollapsedInitially: true,
                },
            };
            for (var groupName in optionGroupsInfo) {
                if (!this.props.mapGenTemplate.options[groupName])
                    continue;
                var options = [];
                for (var optionName in this.props.mapGenTemplate.options[groupName]) {
                    var option = this.props.mapGenTemplate.options[groupName][optionName];
                    options.push({
                        key: optionName,
                        content: MapGenOption_1.default({
                            key: optionName,
                            id: optionName,
                            option: option,
                            value: this.getOptionValue(optionName),
                            onChange: this.handleOptionChange,
                        }),
                    });
                }
                optionGroups.push(OptionsGroup_3.default({
                    key: groupName,
                    header: optionGroupsInfo[groupName].title,
                    options: options,
                    isCollapsedInitially: optionGroupsInfo[groupName].isCollapsedInitially,
                }));
            }
            return (React.DOM.div({
                className: "map-gen-options",
            }, React.DOM.div({
                className: "map-gen-options-option-groups",
            }, optionGroups), React.DOM.div({
                className: "map-gen-options-buttons",
            }, React.DOM.button({
                className: "map-gen-options-button",
                onClick: this.randomizeOptions,
            }, localize_58.localize("randomize")), React.DOM.button({
                className: "map-gen-options-button",
                onClick: this.resetValuesToDefault,
            }, localize_58.localize("reset")))));
        };
        return MapGenOptionsComponent;
    }(React.Component));
    exports.MapGenOptionsComponent = MapGenOptionsComponent;
    var Factory = React.createFactory(MapGenOptionsComponent);
    exports.default = Factory;
});
define("src/uicomponents/setupgame/MapSetup", ["require", "exports", "react", "src/activeModuleData", "src/uicomponents/setupgame/MapGenOptions", "localization/localize"], function (require, exports, React, activeModuleData_24, MapGenOptions_1, localize_59) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MapSetupComponent = (function (_super) {
        __extends(MapSetupComponent, _super);
        function MapSetupComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "MapSetup";
            _this.state = _this.getInitialStateTODO();
            _this.bindMethods();
            return _this;
        }
        MapSetupComponent.prototype.bindMethods = function () {
            this.setTemplate = this.setTemplate.bind(this);
            this.getMapSetupInfo = this.getMapSetupInfo.bind(this);
            this.updatePlayerLimits = this.updatePlayerLimits.bind(this);
        };
        MapSetupComponent.prototype.getInitialStateTODO = function () {
            var mapGenTemplates = [];
            for (var template in activeModuleData_24.activeModuleData.Templates.MapGen) {
                if (activeModuleData_24.activeModuleData.Templates.MapGen[template].key) {
                    mapGenTemplates.push(activeModuleData_24.activeModuleData.Templates.MapGen[template]);
                }
            }
            return ({
                templates: mapGenTemplates,
                selectedTemplate: mapGenTemplates[0],
            });
        };
        MapSetupComponent.prototype.componentDidMount = function () {
            this.updatePlayerLimits();
        };
        MapSetupComponent.prototype.updatePlayerLimits = function () {
            this.props.setPlayerLimits({
                min: this.state.selectedTemplate.minPlayers,
                max: this.state.selectedTemplate.maxPlayers,
            });
        };
        MapSetupComponent.prototype.setTemplate = function (e) {
            var target = e.currentTarget;
            this.setState({
                selectedTemplate: activeModuleData_24.activeModuleData.Templates.MapGen[target.value],
            }, this.updatePlayerLimits);
        };
        MapSetupComponent.prototype.getMapSetupInfo = function () {
            return ({
                template: this.state.selectedTemplate,
                optionValues: this.ref_TODO_mapGenOptions.getOptionValuesForTemplate(),
            });
        };
        MapSetupComponent.prototype.render = function () {
            var _this = this;
            var mapGenTemplateOptions = [];
            for (var i = 0; i < this.state.templates.length; i++) {
                var template = this.state.templates[i];
                mapGenTemplateOptions.push(React.DOM.option({
                    value: template.key,
                    key: template.key,
                    title: template.description,
                }, template.displayName));
            }
            return (React.DOM.div({
                className: "map-setup",
            }, React.DOM.select({
                className: "map-setup-template-selector",
                value: this.state.selectedTemplate.key,
                onChange: this.setTemplate,
            }, mapGenTemplateOptions), React.DOM.div({
                className: "map-setup-player-limit",
            }, localize_59.localizeF("player", "plural").capitalize() + ": " +
                (this.state.selectedTemplate.minPlayers + " - " + this.state.selectedTemplate.maxPlayers)), React.DOM.div({
                className: "map-setup-description",
            }, this.state.selectedTemplate.description), MapGenOptions_1.default({
                mapGenTemplate: this.state.selectedTemplate,
                ref: function (component) {
                    _this.ref_TODO_mapGenOptions = component;
                },
            })));
        };
        return MapSetupComponent;
    }(React.Component));
    exports.MapSetupComponent = MapSetupComponent;
    var Factory = React.createFactory(MapSetupComponent);
    exports.default = Factory;
});
define("src/uicomponents/setupgame/ColorPickerSlider", ["require", "exports", "react"], function (require, exports, React) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ColorPickerSliderComponent = (function (_super) {
        __extends(ColorPickerSliderComponent, _super);
        function ColorPickerSliderComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "ColorPickerSlider";
            _this.handleChangeEvent = _this.handleChangeEvent.bind(_this);
            return _this;
        }
        ColorPickerSliderComponent.prototype.render = function () {
            return (React.DOM.div({
                className: "color-picker-slider-background",
                style: {
                    background: this.props.backgroundStyle,
                },
            }, React.DOM.input({
                className: "color-picker-slider",
                type: "range",
                min: 0,
                max: this.props.max,
                step: 1,
                value: "" + this.props.value,
                onChange: this.handleChangeEvent,
                onMouseUp: this.handleChangeEvent,
                onTouchEnd: this.handleChangeEvent,
            })));
        };
        ColorPickerSliderComponent.prototype.handleChangeEvent = function (e) {
            var target = e.currentTarget;
            var value = parseInt(target.value);
            this.props.onChange(value);
        };
        return ColorPickerSliderComponent;
    }(React.Component));
    exports.ColorPickerSliderComponent = ColorPickerSliderComponent;
    var Factory = React.createFactory(ColorPickerSliderComponent);
    exports.default = Factory;
});
define("src/uicomponents/generic/NumericTextInput", ["require", "exports", "react", "src/utility"], function (require, exports, React, utility_42) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var NumericTextInputComponent = (function (_super) {
        __extends(NumericTextInputComponent, _super);
        function NumericTextInputComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "NumericTextInput";
            _this.state =
                {
                    valueString: _this.getValueString(_this.props.value),
                };
            _this.handleValueChange = _this.handleValueChange.bind(_this);
            _this.getValueString = _this.getValueString.bind(_this);
            return _this;
        }
        NumericTextInputComponent.prototype.componentWillReceiveProps = function (newProps) {
            var didChange = newProps.value !== this.props.getValueFromValueString(this.state.valueString);
            if (didChange) {
                this.setState({
                    valueString: this.getValueString(newProps.value),
                });
            }
        };
        NumericTextInputComponent.prototype.render = function () {
            var valueStringIsValid = this.props.valueStringIsValid(this.state.valueString);
            var defaultAttributes = {
                className: "numeric-text-input" +
                    (valueStringIsValid ? "" : " invalid-value"),
                onChange: this.handleValueChange,
                value: this.state.valueString,
                spellCheck: false,
            };
            var customAttributes = this.props.attributes || {};
            var attributes = utility_42.mergeReactAttributes(defaultAttributes, customAttributes);
            return (React.DOM.input(attributes));
        };
        NumericTextInputComponent.prototype.getValueString = function (value) {
            if (this.props.stylizeValue) {
                return this.props.stylizeValue(value);
            }
            else {
                return "" + value;
            }
        };
        NumericTextInputComponent.prototype.handleValueChange = function (e) {
            var _this = this;
            e.stopPropagation();
            e.preventDefault();
            var target = e.currentTarget;
            var valueString = target.value;
            this.setState({
                valueString: valueString,
            }, function () {
                var isValid = _this.props.valueStringIsValid(valueString);
                if (isValid) {
                    var value = _this.props.getValueFromValueString(valueString);
                    _this.props.onValueChange(value);
                }
            });
        };
        return NumericTextInputComponent;
    }(React.Component));
    exports.NumericTextInputComponent = NumericTextInputComponent;
    var Factory = React.createFactory(NumericTextInputComponent);
    exports.default = Factory;
});
define("src/uicomponents/setupgame/ColorPicker", ["require", "exports", "react", "src/Color", "src/uicomponents/setupgame/ColorPickerSlider", "src/uicomponents/generic/NumberInput", "src/uicomponents/generic/NumericTextInput", "src/uicomponents/mixins/AutoPositioner", "src/uicomponents/mixins/applyMixins", "localization/localize"], function (require, exports, React, Color_4, ColorPickerSlider_1, NumberInput_2, NumericTextInput_1, AutoPositioner_2, applyMixins_14, localize_60) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ColorPickerComponent = (function (_super) {
        __extends(ColorPickerComponent, _super);
        function ColorPickerComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "ColorPicker";
            _this.onChangeTimeoutHandle = null;
            if (_this.props.autoPositionerProps) {
                applyMixins_14.default(_this, new AutoPositioner_2.default(_this));
            }
            var initialColor = _this.props.initialColor || new Color_4.default(1, 1, 1);
            _this.state = _this.getStateFromColor(initialColor);
            _this.bindMethods();
            return _this;
        }
        ColorPickerComponent.prototype.render = function () {
            var _this = this;
            return (React.DOM.div({ className: "color-picker" }, React.DOM.div({ className: "color-picker-hsv" }, this.makeHsvInputs("hue"), this.makeHsvInputs("sat"), this.makeHsvInputs("val")), React.DOM.div({ className: "color-picker-input-container", key: "hex" }, React.DOM.label({ className: "color-picker-label" }, "Hex:"), !this.props.generateColor ? null :
                React.DOM.button({
                    className: "color-picker-button",
                    onClick: this.autoGenerateColor,
                }, localize_60.localize("auto")), !this.props.isNullable ? null :
                React.DOM.button({
                    className: "color-picker-button",
                    onClick: this.nullifyColor,
                }, localize_60.localize("clear")), NumericTextInput_1.default({
                attributes: {
                    className: "color-picker-input",
                },
                value: this.state.hexColor,
                valueStringIsValid: function (valueString) {
                    return /^#*[0-9A-F]{6}$/i.test(valueString);
                },
                stylizeValue: function (value) {
                    return "#" + Color_4.default.fromHex(value).getHexString();
                },
                getValueFromValueString: function (valueString) {
                    return Color_4.default.fromHexString(valueString).getHex();
                },
                onValueChange: function (value) {
                    _this.setState({
                        hexColor: value,
                    });
                    _this.updateFromHex(value);
                },
            }))));
        };
        ColorPickerComponent.prototype.bindMethods = function () {
            this.setHue = this.setHue.bind(this);
            this.setSat = this.setSat.bind(this);
            this.makeHsvInputs = this.makeHsvInputs.bind(this);
            this.autoGenerateColor = this.autoGenerateColor.bind(this);
            this.updateFromHex = this.updateFromHex.bind(this);
            this.updateFromHsv = this.updateFromHsv.bind(this);
            this.makeGradientStyle = this.makeGradientStyle.bind(this);
            this.triggerParentOnChange = this.triggerParentOnChange.bind(this);
            this.setVal = this.setVal.bind(this);
            this.makeGradientString = this.makeGradientString.bind(this);
            this.nullifyColor = this.nullifyColor.bind(this);
        };
        ColorPickerComponent.prototype.getStateFromColor = function (color) {
            var hsvColor = Color_4.default.convertScalarsToDegrees(color.getHSV());
            return ({
                hexColor: color.getHex(),
                hue: hsvColor[0],
                sat: hsvColor[1],
                val: hsvColor[2],
            });
        };
        ColorPickerComponent.prototype.triggerParentOnChange = function (color, isNull) {
            if (this.onChangeTimeoutHandle) {
                window.clearTimeout(this.onChangeTimeoutHandle);
                this.onChangeTimeoutHandle = null;
            }
            if (this.props.minUpdateBuffer) {
                this.onChangeTimeoutHandle = window.setTimeout(function () {
                }, this.props.minUpdateBuffer || 0);
            }
            else {
                this.props.onChange(color, isNull);
            }
        };
        ColorPickerComponent.prototype.updateFromHsv = function (hue, sat, val, e) {
            if (e && e.type !== "change") {
                return;
            }
            var color = Color_4.default.fromHSV.apply(null, Color_4.default.convertDegreesToScalars([hue, sat, val]));
            this.setState({
                hexColor: color.getHex(),
            });
            if (this.props.onChange) {
                this.triggerParentOnChange(color, false);
            }
        };
        ColorPickerComponent.prototype.updateFromHex = function (hexColor) {
            var color = Color_4.default.fromHex(hexColor);
            var hsvColor = Color_4.default.convertScalarsToDegrees(color.getHSV());
            this.setState({
                hue: Math.round(hsvColor[0]),
                sat: Math.round(hsvColor[1]),
                val: Math.round(hsvColor[2]),
            });
            if (this.props.onChange) {
                this.triggerParentOnChange(color, false);
            }
        };
        ColorPickerComponent.prototype.setHue = function (hue) {
            this.setState({ hue: hue });
            this.updateFromHsv(hue, this.state.sat, this.state.val);
        };
        ColorPickerComponent.prototype.setSat = function (sat) {
            this.setState({ sat: sat });
            this.updateFromHsv(this.state.hue, sat, this.state.val);
        };
        ColorPickerComponent.prototype.setVal = function (val) {
            this.setState({ val: val });
            this.updateFromHsv(this.state.hue, this.state.sat, val);
        };
        ColorPickerComponent.prototype.autoGenerateColor = function () {
            var color = this.props.generateColor();
            var hexColor = color.getHex();
            this.setState({
                hexColor: hexColor,
            });
            this.updateFromHex(hexColor);
        };
        ColorPickerComponent.prototype.nullifyColor = function () {
            if (this.props.onChange) {
                this.triggerParentOnChange(Color_4.default.fromHex(this.state.hexColor), true);
            }
        };
        ColorPickerComponent.prototype.makeGradientString = function (min, max) {
            return ("linear-gradient(to right, " +
                min + " 0%, " +
                max + " 100%)");
        };
        ColorPickerComponent.prototype.makeHexStringFromHSVDegreeArray = function (hsv) {
            var color = Color_4.default.fromHSV.apply(null, Color_4.default.convertDegreesToScalars(hsv));
            return color.getHexString();
        };
        ColorPickerComponent.prototype.makeGradientStyle = function (type) {
            var hue = this.state.hue;
            var sat = this.state.sat;
            var val = this.state.val;
            switch (type) {
                case "hue":
                    {
                        return "linear-gradient(to right, #FF0000 0%, #FFFF00 17%, #00FF00 33%, #00FFFF 50%, #0000FF 67%, #FF00FF 83%, #FF0000 100%)";
                    }
                case "sat":
                    {
                        var min = "#" + this.makeHexStringFromHSVDegreeArray([hue, 0, val]);
                        var max = "#" + this.makeHexStringFromHSVDegreeArray([hue, 100, val]);
                        return this.makeGradientString(min, max);
                    }
                case "val":
                    {
                        var min = "#" + this.makeHexStringFromHSVDegreeArray([hue, sat, 0]);
                        var max = "#" + this.makeHexStringFromHSVDegreeArray([hue, sat, 100]);
                        return this.makeGradientString(min, max);
                    }
            }
        };
        ColorPickerComponent.prototype.makeHsvInputs = function (type) {
            var label = "" + type[0].toUpperCase() + ":";
            var max = type === "hue" ? 360 : 100;
            var updateFunctions = {
                hue: this.setHue,
                sat: this.setSat,
                val: this.setVal,
            };
            return (React.DOM.div({ className: "color-picker-input-container", key: type }, React.DOM.label({ className: "color-picker-label" }, label), ColorPickerSlider_1.default({
                value: this.state[type],
                max: max,
                onChange: updateFunctions[type],
                backgroundStyle: this.makeGradientStyle(type),
            }), NumberInput_2.default({
                attributes: {
                    className: "color-picker-input",
                },
                value: this.state[type],
                onChange: updateFunctions[type],
                min: 0,
                max: max,
                step: 1,
                canWrap: type === "hue",
            })));
        };
        return ColorPickerComponent;
    }(React.Component));
    exports.ColorPickerComponent = ColorPickerComponent;
    var Factory = React.createFactory(ColorPickerComponent);
    exports.default = Factory;
});
define("src/uicomponents/setupgame/ColorSetter", ["require", "exports", "react", "react-dom", "src/uicomponents/setupgame/ColorPicker"], function (require, exports, React, ReactDOM, ColorPicker_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ColorSetterComponent = (function (_super) {
        __extends(ColorSetterComponent, _super);
        function ColorSetterComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "ColorSetter";
            _this.state = _this.getInitialStateTODO();
            _this.bindMethods();
            return _this;
        }
        ColorSetterComponent.prototype.bindMethods = function () {
            this.handleClick = this.handleClick.bind(this);
            this.toggleActive = this.toggleActive.bind(this);
            this.setAsInactive = this.setAsInactive.bind(this);
            this.getClientRect = this.getClientRect.bind(this);
        };
        ColorSetterComponent.prototype.getInitialStateTODO = function () {
            return ({
                isActive: false,
            });
        };
        ColorSetterComponent.prototype.componentWillUnmount = function () {
            document.removeEventListener("click", this.handleClick);
        };
        ColorSetterComponent.prototype.handleClick = function (e) {
            var node = ReactDOM.findDOMNode(this.ownNode);
            var target = e.target;
            if (target === node || node.contains(target)) {
                return;
            }
            else {
                this.setAsInactive();
            }
        };
        ColorSetterComponent.prototype.toggleActive = function () {
            if (this.state.isActive) {
                this.setAsInactive();
            }
            else {
                if (this.props.setAsActive) {
                    this.props.setAsActive(this);
                }
                this.setState({ isActive: true });
                document.addEventListener("click", this.handleClick, false);
            }
        };
        ColorSetterComponent.prototype.setAsInactive = function () {
            if (this.state.isActive) {
                this.setState({ isActive: false });
                document.removeEventListener("click", this.handleClick);
            }
        };
        ColorSetterComponent.prototype.updateColor = function (color, isNull) {
            this.props.onChange(color, isNull);
        };
        ColorSetterComponent.prototype.getClientRect = function () {
            var ownNode = ReactDOM.findDOMNode(this);
            var firstChild = ownNode.firstChild;
            return firstChild.getBoundingClientRect();
        };
        ColorSetterComponent.prototype.render = function () {
            var _this = this;
            var displayElement = this.props.color === null ?
                React.DOM.img({
                    className: "color-setter-display",
                    src: "img/icons/nullcolor.png",
                    onClick: this.toggleActive,
                }) :
                React.DOM.div({
                    className: "color-setter-display",
                    style: {
                        backgroundColor: "#" + this.props.color.getHexString(),
                    },
                    onClick: this.toggleActive,
                });
            return (React.DOM.div({ className: "color-setter", ref: function (component) {
                    _this.ownNode = component;
                } }, displayElement, this.state.isActive ?
                ColorPicker_1.default({
                    initialColor: this.props.color,
                    generateColor: this.props.generateColor,
                    onChange: this.props.onChange,
                    minUpdateBuffer: this.props.minUpdateBuffer,
                    isNullable: true,
                    autoPositionerProps: {
                        getParentClientRect: this.getClientRect,
                        positionOnUpdate: true,
                        ySide: "outerBottom",
                        xSide: "innerLeft",
                        positionOnResize: true,
                    },
                }) : null));
        };
        return ColorSetterComponent;
    }(React.Component));
    exports.ColorSetterComponent = ColorSetterComponent;
    var Factory = React.createFactory(ColorSetterComponent);
    exports.default = Factory;
});
define("src/ImageFileProcessing", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function getFirstValidImageFromFiles(files) {
        for (var i = 0; i < files.length; i++) {
            var file = files[i];
            if (file.type.indexOf("image") !== -1) {
                return file;
            }
        }
        return null;
    }
    exports.getFirstValidImageFromFiles = getFirstValidImageFromFiles;
    function getHTMLImageElementFromDataTransfer(dataTransfer, onComplete, onError) {
        var htmlContent = dataTransfer.getData("text/html");
        var imageSourceMatches = htmlContent ? htmlContent.match(/src\s*=\s*"(.+?)"/) : null;
        var imageSource = imageSourceMatches ? imageSourceMatches[1] : null;
        if (!imageSource) {
            if (onError) {
                onError("noImage");
            }
            return null;
        }
        var img = new Image();
        img.crossOrigin = "Anonymous";
        img.onload = function (e) {
            onComplete(img);
        };
        img.onerror = function (e) {
            onError("couldntLoad", e);
        };
        img.src = imageSource;
        if (img.complete || img.complete === undefined) {
            onComplete(img);
        }
    }
    exports.getHTMLImageElementFromDataTransfer = getHTMLImageElementFromDataTransfer;
});
define("src/uicomponents/Emblem", ["require", "exports", "react", "src/Emblem", "src/utility"], function (require, exports, React, Emblem_3, utility_43) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var EmblemComponent = (function (_super) {
        __extends(EmblemComponent, _super);
        function EmblemComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "Emblem";
            return _this;
        }
        EmblemComponent.prototype.renderEmblemCanvas = function () {
            var containerRect = this.container.getBoundingClientRect();
            var emblem = new Emblem_3.default(this.props.colors, this.props.template, 1);
            var drawn = emblem.draw(containerRect.width, containerRect.height, true);
            if (this.container.firstChild) {
                var canvas = this.container.firstChild;
                canvas.width = drawn.width;
                canvas.height = drawn.height;
                var ctx = canvas.getContext("2d");
                ctx.drawImage(drawn, 0, 0);
            }
            else {
                drawn.style.maxWidth = "100%";
                drawn.style.maxHeight = "100%";
                this.container.appendChild(drawn);
            }
        };
        EmblemComponent.prototype.componentDidMount = function () {
            this.renderEmblemCanvas();
        };
        EmblemComponent.prototype.componentDidUpdate = function () {
            this.renderEmblemCanvas();
        };
        EmblemComponent.prototype.render = function () {
            var _this = this;
            var baseClassName = "emblem";
            var containerProps = utility_43.shallowExtend(this.props.containerProps, {
                className: baseClassName + (this.props.containerProps && this.props.containerProps.className ?
                    " " + this.props.containerProps.className :
                    ""),
                ref: function (component) {
                    _this.container = component;
                },
            });
            return (React.DOM.div(containerProps, null));
        };
        return EmblemComponent;
    }(React.PureComponent));
    exports.EmblemComponent = EmblemComponent;
    var Factory = React.createFactory(EmblemComponent);
    exports.default = Factory;
});
define("src/uicomponents/setupgame/EmblemPicker", ["require", "exports", "react", "src/activeModuleData", "src/colorGeneration", "src/uicomponents/Emblem", "src/uicomponents/setupgame/ColorPicker", "localization/localize"], function (require, exports, React, activeModuleData_25, colorGeneration_5, Emblem_4, ColorPicker_2, localize_61) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var EmblemPickerComponent = (function (_super) {
        __extends(EmblemPickerComponent, _super);
        function EmblemPickerComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "EmblemPicker";
            _this.handleEmblemColorChange = _this.handleEmblemColorChange.bind(_this);
            return _this;
        }
        EmblemPickerComponent.prototype.handleSelectEmblem = function (emblem) {
            if (this.props.selectedEmblemTemplate === emblem) {
                this.props.setEmblemTemplate(null, this.props.color);
            }
            else {
                this.props.setEmblemTemplate(emblem, this.props.color);
            }
        };
        EmblemPickerComponent.prototype.handleEmblemColorChange = function (color, isNull) {
            this.props.setEmblemColor(isNull ? null : color);
        };
        EmblemPickerComponent.prototype.render = function () {
            var _this = this;
            var emblemElements = [];
            for (var emblemType in activeModuleData_25.activeModuleData.Templates.SubEmblems) {
                var template = activeModuleData_25.activeModuleData.Templates.SubEmblems[emblemType];
                var className = "emblem-picker-image";
                var templateIsSelected = this.props.selectedEmblemTemplate && this.props.selectedEmblemTemplate.key === template.key;
                if (templateIsSelected) {
                    className += " selected-emblem";
                }
                emblemElements.push(React.DOM.div({
                    className: "emblem-picker-container",
                    key: template.key,
                    onClick: this.handleSelectEmblem.bind(this, template),
                    style: !this.props.backgroundColor ? null :
                        {
                            backgroundColor: "#" + this.props.backgroundColor.getHexString(),
                        },
                }, Emblem_4.default({
                    template: template,
                    colors: [this.props.color],
                    containerProps: {
                        className: className,
                    },
                })));
            }
            return (React.DOM.div({
                className: "emblem-picker",
            }, React.DOM.div({ className: "flag-picker-title" }, localize_61.localize("emblemColor")), ColorPicker_2.default({
                initialColor: this.props.color,
                onChange: this.handleEmblemColorChange,
                generateColor: function () {
                    if (_this.props.backgroundColor) {
                        return colorGeneration_5.generateSecondaryColor(_this.props.backgroundColor);
                    }
                    else {
                        return colorGeneration_5.generateMainColor();
                    }
                },
            }), React.DOM.div({ className: "flag-picker-title" }, localize_61.localize("emblems")), React.DOM.div({ className: "emblem-picker-emblem-list" }, emblemElements)));
        };
        return EmblemPickerComponent;
    }(React.PureComponent));
    exports.EmblemPickerComponent = EmblemPickerComponent;
    var Factory = React.createFactory(EmblemPickerComponent);
    exports.default = Factory;
});
define("src/uicomponents/setupgame/EmblemSetter", ["require", "exports", "react", "src/uicomponents/Emblem", "localization/localize"], function (require, exports, React, Emblem_5, localize_62) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var EmblemSetterComponent = (function (_super) {
        __extends(EmblemSetterComponent, _super);
        function EmblemSetterComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "EmblemSetter";
            return _this;
        }
        EmblemSetterComponent.prototype.render = function () {
            var _this = this;
            return (React.DOM.div({
                className: "emblem-setter",
            }, Emblem_5.default({
                key: "emblem",
                template: this.props.emblem.template,
                colors: this.props.emblem.colors,
                containerProps: {
                    style: !this.props.backgroundColor ? null :
                        {
                            backgroundColor: "#" + this.props.backgroundColor.getHexString(),
                        },
                    title: this.props.emblem.template.key + "\n\n" + localize_62.localize("emblemSetterTooltip"),
                    onClick: this.props.toggleActive,
                    onContextMenu: function (e) {
                        e.stopPropagation();
                        e.preventDefault();
                        _this.props.remove();
                    },
                },
            })));
        };
        return EmblemSetterComponent;
    }(React.PureComponent));
    exports.EmblemSetterComponent = EmblemSetterComponent;
    var Factory = React.createFactory(EmblemSetterComponent);
    exports.default = Factory;
});
define("src/uicomponents/setupgame/EmblemSetterList", ["require", "exports", "react", "src/uicomponents/setupgame/EmblemSetter", "localization/localize"], function (require, exports, React, EmblemSetter_1, localize_63) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var EmblemSetterListComponent = (function (_super) {
        __extends(EmblemSetterListComponent, _super);
        function EmblemSetterListComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "EmblemSetterList";
            return _this;
        }
        EmblemSetterListComponent.prototype.render = function () {
            var _this = this;
            var canAddNewEmblem = this.props.emblems.length < this.props.maxEmblems;
            return (React.DOM.ol({
                className: "emblem-setter-list",
            }, this.props.emblems.map(function (emblemProps) {
                var id = emblemProps.id;
                return EmblemSetter_1.default({
                    key: id,
                    toggleActive: _this.props.toggleActiveEmblem.bind(null, id),
                    remove: _this.props.removeEmblem.bind(null, id),
                    emblem: emblemProps,
                    backgroundColor: _this.props.backgroundColor,
                });
            }), React.DOM.button({
                className: "add-new-emblem-button",
                onClick: this.props.addEmblem,
                title: localize_63.localize("addNewEmblem"),
                disabled: !canAddNewEmblem,
            })));
        };
        return EmblemSetterListComponent;
    }(React.Component));
    exports.EmblemSetterListComponent = EmblemSetterListComponent;
    var Factory = React.createFactory(EmblemSetterListComponent);
    exports.default = Factory;
});
define("src/uicomponents/setupgame/FlagEditor", ["require", "exports", "react", "src/Emblem", "src/Flag", "src/uicomponents/setupgame/EmblemPicker", "src/uicomponents/setupgame/EmblemSetterList", "src/uicomponents/mixins/AutoPositioner", "src/uicomponents/mixins/applyMixins"], function (require, exports, React, Emblem_6, Flag_4, EmblemPicker_1, EmblemSetterList_1, AutoPositioner_3, applyMixins_15) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var maxEmblems = 4;
    var FlagEditorComponent = (function (_super) {
        __extends(FlagEditorComponent, _super);
        function FlagEditorComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "FlagEditor";
            _this.idGenerator = 0;
            _this.state =
                {
                    emblems: _this.getEmblemDataFromFlag(props.parentFlag),
                    activeEmblemSetterId: null,
                };
            if (_this.props.autoPositionerProps) {
                applyMixins_15.default(_this, new AutoPositioner_3.default(_this));
            }
            _this.randomize = _this.randomize.bind(_this);
            _this.generateFlag = _this.generateFlag.bind(_this);
            _this.getEmblemDataFromFlag = _this.getEmblemDataFromFlag.bind(_this);
            _this.addEmblem = _this.addEmblem.bind(_this);
            _this.getEmblemProps = _this.getEmblemProps.bind(_this);
            _this.removeEmblem = _this.removeEmblem.bind(_this);
            _this.setEmblemTemplate = _this.setEmblemTemplate.bind(_this);
            _this.setEmblemColor = _this.setEmblemColor.bind(_this);
            _this.toggleActiveEmblemSetter = _this.toggleActiveEmblemSetter.bind(_this);
            return _this;
        }
        FlagEditorComponent.prototype.randomize = function () {
            var flag = Flag_4.Flag.generateRandom(this.props.backgroundColor, this.props.playerSecondaryColor);
            this.setState({
                emblems: this.getEmblemDataFromFlag(flag),
            });
        };
        FlagEditorComponent.prototype.generateFlag = function () {
            var emblems = this.state.emblems.map(function (emblemData) { return FlagEditorComponent.emblemDataToEmblem(emblemData); });
            var flag = new Flag_4.Flag(this.props.backgroundColor, emblems);
            return flag;
        };
        FlagEditorComponent.emblemDataToEmblem = function (emblemData) {
            return new Emblem_6.default(emblemData.colors, emblemData.template, 1);
        };
        FlagEditorComponent.emblemToEmblemData = function (emblem, id) {
            return ({
                colors: emblem.colors.slice(0),
                template: emblem.template,
                id: id,
            });
        };
        FlagEditorComponent.prototype.triggerParentFlagUpdate = function () {
            this.props.updateParentFlag(this.generateFlag());
        };
        FlagEditorComponent.prototype.getEmblemDataFromFlag = function (flag) {
            var _this = this;
            if (!flag) {
                return [];
            }
            else {
                return flag.emblems.map(function (emblem) { return FlagEditorComponent.emblemToEmblemData(emblem, _this.idGenerator++); });
            }
        };
        FlagEditorComponent.prototype.toggleActiveEmblemSetter = function (id) {
            if (this.state.activeEmblemSetterId === id) {
                this.setState({ activeEmblemSetterId: null });
            }
            else {
                this.setState({ activeEmblemSetterId: id });
            }
        };
        FlagEditorComponent.prototype.addEmblem = function () {
            var _this = this;
            var emblem = Emblem_6.default.generateRandom(this.props.backgroundColor);
            var emblemData = FlagEditorComponent.emblemToEmblemData(emblem, this.idGenerator++);
            this.setState({
                emblems: this.state.emblems.concat([emblemData]),
            }, function () {
                _this.triggerParentFlagUpdate();
            });
        };
        FlagEditorComponent.prototype.getEmblemProps = function (id) {
            for (var i = 0; i < this.state.emblems.length; i++) {
                if (this.state.emblems[i].id === id) {
                    return this.state.emblems[i];
                }
            }
            return null;
        };
        FlagEditorComponent.prototype.removeEmblem = function (idToFilter) {
            var _this = this;
            this.setState({
                emblems: this.state.emblems.filter(function (emblemProps) {
                    return emblemProps.id !== idToFilter;
                }),
            }, function () {
                _this.triggerParentFlagUpdate();
            });
        };
        FlagEditorComponent.prototype.setEmblemTemplate = function (id, template) {
            var emblem = this.getEmblemProps(id);
            emblem.template = template;
            this.triggerParentFlagUpdate();
        };
        FlagEditorComponent.prototype.setEmblemColor = function (id, color) {
            var emblem = this.getEmblemProps(id);
            emblem.colors = [color];
            this.triggerParentFlagUpdate();
        };
        FlagEditorComponent.prototype.getActiveEmblemData = function () {
            var id = this.state.activeEmblemSetterId;
            if (isFinite(id) && !isNaN(id)) {
                for (var i = 0; i < this.state.emblems.length; i++) {
                    if (this.state.emblems[i].id === id) {
                        return this.state.emblems[i];
                    }
                }
            }
            return null;
        };
        FlagEditorComponent.prototype.render = function () {
            var activeEmblemData = this.getActiveEmblemData();
            return (React.DOM.div({
                className: "flag-editor",
            }, EmblemSetterList_1.default({
                backgroundColor: this.props.backgroundColor,
                emblems: this.state.emblems,
                maxEmblems: maxEmblems,
                toggleActiveEmblem: this.toggleActiveEmblemSetter,
                addEmblem: this.addEmblem,
                removeEmblem: this.removeEmblem,
            }), !activeEmblemData ? null :
                EmblemPicker_1.default({
                    key: "emblemPicker",
                    color: activeEmblemData.colors[0],
                    backgroundColor: this.props.backgroundColor,
                    selectedEmblemTemplate: activeEmblemData.template,
                    setEmblemTemplate: this.setEmblemTemplate.bind(this, this.state.activeEmblemSetterId),
                    setEmblemColor: this.setEmblemColor.bind(this, this.state.activeEmblemSetterId),
                })));
        };
        return FlagEditorComponent;
    }(React.PureComponent));
    exports.FlagEditorComponent = FlagEditorComponent;
    var Factory = React.createFactory(FlagEditorComponent);
    exports.default = Factory;
});
define("src/uicomponents/setupgame/FlagSetter", ["require", "exports", "react", "react-dom", "src/Emblem", "src/ImageFileProcessing", "src/uicomponents/PlayerFlag", "src/uicomponents/setupgame/FlagEditor", "src/uicomponents/windows/DefaultWindow", "localization/localize"], function (require, exports, React, ReactDOM, Emblem_7, ImageFileProcessing_1, PlayerFlag_8, FlagEditor_1, DefaultWindow_10, localize_64) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var FlagSetterComponent = (function (_super) {
        __extends(FlagSetterComponent, _super);
        function FlagSetterComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "FlagSetter";
            _this.state = _this.getInitialStateTODO();
            _this.bindMethods();
            return _this;
        }
        FlagSetterComponent.prototype.componentWillUnmount = function () {
            this.clearFailMessageTimeout();
        };
        FlagSetterComponent.prototype.render = function () {
            var _this = this;
            return (React.DOM.div({
                className: "flag-setter",
                ref: function (component) {
                    _this.flagSetterContainer = component;
                },
                onDragEnter: this.stopEvent,
                onDragOver: this.stopEvent,
                onDrop: this.handleDrop,
            }, PlayerFlag_8.default({
                flag: this.props.flag,
                isMutable: true,
                props: {
                    className: "flag-setter-display",
                    onClick: this.toggleActive,
                },
                ref: function (component) {
                    _this.playerFlagContainer = component;
                },
            }), !this.state.isActive ? null :
                React.DOM.div({
                    className: "popup-container",
                }, DefaultWindow_10.default({
                    title: localize_64.localize("editFlag"),
                    handleClose: this.setAsInactive,
                    isResizable: false,
                    getInitialPosition: function (popupRect, containerRect) {
                        var parentRect = _this.getClientRect();
                        return ({
                            left: parentRect.right,
                            top: parentRect.top - popupRect.height / 3,
                            width: popupRect.width,
                            height: popupRect.height,
                        });
                    },
                    minWidth: 0,
                    minHeight: 0,
                }, FlagEditor_1.default({
                    parentFlag: this.props.flag,
                    backgroundColor: this.props.mainColor,
                    playerSecondaryColor: this.props.secondaryColor,
                    updateParentFlag: this.props.updateParentFlag,
                })))));
        };
        FlagSetterComponent.prototype.bindMethods = function () {
            this.setAsInactive = this.setAsInactive.bind(this);
            this.setForegroundEmblem = this.setForegroundEmblem.bind(this);
            this.setFailMessage = this.setFailMessage.bind(this);
            this.clearFailMessage = this.clearFailMessage.bind(this);
            this.setCustomImageFromFile = this.setCustomImageFromFile.bind(this);
            this.handleSuccessfulUpdate = this.handleSuccessfulUpdate.bind(this);
            this.handleUpload = this.handleUpload.bind(this);
            this.handleDrop = this.handleDrop.bind(this);
            this.toggleActive = this.toggleActive.bind(this);
            this.stopEvent = this.stopEvent.bind(this);
            this.getClientRect = this.getClientRect.bind(this);
        };
        FlagSetterComponent.prototype.getInitialStateTODO = function () {
            return ({
                isActive: false,
                failMessageElement: null,
                customImageFile: null,
            });
        };
        FlagSetterComponent.prototype.makeFailMessage = function (messageHandle, timeout) {
            return React.DOM.div({
                className: "image-info-message image-loading-fail-message",
                style: {
                    animationDuration: "" + timeout + "ms",
                },
            }, localize_64.localize(messageHandle));
        };
        FlagSetterComponent.prototype.clearFailMessageTimeout = function () {
            if (this.failMessageTimeoutHandle) {
                window.clearTimeout(this.failMessageTimeoutHandle);
            }
        };
        FlagSetterComponent.prototype.clearFailMessage = function () {
            this.clearFailMessageTimeout();
            this.setState({ failMessageElement: null });
        };
        FlagSetterComponent.prototype.setFailMessage = function (messageHandle, timeout) {
            var _this = this;
            this.setState({
                failMessageElement: this.makeFailMessage(messageHandle, timeout),
                customImageFile: null,
            });
            this.failMessageTimeoutHandle = window.setTimeout(function () {
                _this.clearFailMessage();
            }, timeout);
        };
        FlagSetterComponent.prototype.toggleActive = function () {
            if (this.state.isActive) {
                this.setAsInactive();
            }
            else {
                if (this.props.setAsActive) {
                    this.props.setAsActive(this);
                }
                this.setState({ isActive: true });
            }
        };
        FlagSetterComponent.prototype.setAsInactive = function () {
            if (this.state.isActive) {
                this.setState({ isActive: false });
            }
        };
        FlagSetterComponent.prototype.setForegroundEmblem = function (emblemTemplate, color) {
            var emblem = null;
            if (emblemTemplate) {
                emblem = new Emblem_7.default([color], emblemTemplate, 1);
            }
            this.props.flag.addEmblem(emblem);
            this.handleSuccessfulUpdate();
        };
        FlagSetterComponent.prototype.stopEvent = function (e) {
            e.stopPropagation();
            e.preventDefault();
        };
        FlagSetterComponent.prototype.handleDrop = function (e) {
            var _this = this;
            if (!e.dataTransfer) {
                return;
            }
            this.stopEvent(e);
            var files = e.dataTransfer.files;
            var imageFile = ImageFileProcessing_1.getFirstValidImageFromFiles(files);
            if (imageFile) {
                this.setCustomImageFromFile(imageFile);
            }
            else {
                ImageFileProcessing_1.getHTMLImageElementFromDataTransfer(e.dataTransfer, function (image) {
                    var canvas = document.createElement("canvas");
                    var ctx = canvas.getContext("2d");
                    canvas.width = image.width;
                    canvas.height = image.height;
                    ctx.drawImage(image, 0, 0);
                    var dataURL = canvas.toDataURL();
                    _this.props.flag.setCustomImage(dataURL);
                    _this.handleSuccessfulUpdate();
                }, function (errorType) {
                    switch (errorType) {
                        case "noImage":
                            {
                                _this.setFailMessage("noValidImageFile", 2000);
                                break;
                            }
                        case "couldntLoad":
                            {
                                _this.setFailMessage("hotLinkedImageLoadingFailed", 2000);
                                break;
                            }
                    }
                });
            }
        };
        FlagSetterComponent.prototype.handleUpload = function (files) {
            var image = ImageFileProcessing_1.getFirstValidImageFromFiles(files);
            if (image) {
                this.setCustomImageFromFile(image);
            }
            else {
                this.setFailMessage("noValidImageFile", 2000);
            }
        };
        FlagSetterComponent.prototype.setCustomImageFromFile = function (file) {
            var _this = this;
            var setImageFN = function () {
                var reader = new FileReader();
                reader.onloadend = function () {
                    _this.props.flag.setCustomImage(reader.result);
                    _this.setState({
                        customImageFile: file,
                    }, function () {
                        _this.handleSuccessfulUpdate();
                    });
                };
                reader.readAsDataURL(file);
            };
            var fileSizeInMegaBytes = file.size / 1024 / 1024;
            if (fileSizeInMegaBytes > 20) {
                var confirmMessage = localize_64.localizeF("confirmUseLargeImage").format({
                    fileSize: fileSizeInMegaBytes.toFixed(2),
                });
                if (window.confirm(confirmMessage)) {
                    setImageFN();
                }
            }
            else {
                setImageFN();
            }
        };
        FlagSetterComponent.prototype.handleSuccessfulUpdate = function () {
            if (this.state.failMessageElement) {
                this.clearFailMessage();
            }
            else {
                this.forceUpdate();
            }
        };
        FlagSetterComponent.prototype.getClientRect = function () {
            var ownNode = ReactDOM.findDOMNode(this.playerFlagContainer);
            return ownNode.getBoundingClientRect();
        };
        return FlagSetterComponent;
    }(React.Component));
    exports.FlagSetterComponent = FlagSetterComponent;
    var Factory = React.createFactory(FlagSetterComponent);
    exports.default = Factory;
});
define("src/uicomponents/setupgame/RacePicker", ["require", "exports", "react"], function (require, exports, React) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var RacePickerComponent = (function (_super) {
        __extends(RacePickerComponent, _super);
        function RacePickerComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "RacePicker";
            _this.handleChangeRace = _this.handleChangeRace.bind(_this);
            return _this;
        }
        RacePickerComponent.prototype.handleChangeRace = function (e) {
            var target = e.currentTarget;
            var newRace = this.props.availableRaces.filter(function (raceTemplate) {
                return raceTemplate.type === target.value;
            })[0];
            this.props.changeRace(newRace);
        };
        RacePickerComponent.prototype.render = function () {
            return (React.DOM.select({
                className: "race-picker",
                value: this.props.selectedRace.type,
                onChange: this.handleChangeRace,
                title: this.props.selectedRace.description,
            }, this.props.availableRaces.map(function (race) {
                return React.DOM.option({
                    key: race.type,
                    value: race.type,
                    title: race.description,
                }, race.displayName.toString());
            })));
        };
        return RacePickerComponent;
    }(React.PureComponent));
    exports.RacePickerComponent = RacePickerComponent;
    var Factory = React.createFactory(RacePickerComponent);
    exports.default = Factory;
});
define("src/uicomponents/setupgame/PlayerSetup", ["require", "exports", "react", "src/activeModuleData", "src/Flag", "src/Player", "src/colorGeneration", "src/utility", "src/uicomponents/setupgame/ColorSetter", "src/uicomponents/setupgame/FlagSetter", "src/uicomponents/setupgame/RacePicker"], function (require, exports, React, activeModuleData_26, Flag_5, Player_3, colorGeneration_6, utility_44, ColorSetter_1, FlagSetter_1, RacePicker_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function getRandomPlayerRaceTemplate() {
        var candidateRaces = Object.keys(activeModuleData_26.activeModuleData.Templates.Races).map(function (raceKey) {
            return activeModuleData_26.activeModuleData.Templates.Races[raceKey];
        }).filter(function (raceTemplate) {
            return !raceTemplate.isNotPlayable;
        });
        return utility_44.getRandomArrayItem(candidateRaces);
    }
    var PlayerSetupComponent = (function (_super) {
        __extends(PlayerSetupComponent, _super);
        function PlayerSetupComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "PlayerSetup";
            _this.state = _this.getInitialStateTODO();
            _this.bindMethods();
            _this.flag = new Flag_5.Flag(null);
            return _this;
        }
        PlayerSetupComponent.prototype.bindMethods = function () {
            this.randomize = this.randomize.bind(this);
            this.setSubColor = this.setSubColor.bind(this);
            this.generateSubColor = this.generateSubColor.bind(this);
            this.setMainColor = this.setMainColor.bind(this);
            this.generateMainColor = this.generateMainColor.bind(this);
            this.handleRemove = this.handleRemove.bind(this);
            this.handleNameChange = this.handleNameChange.bind(this);
            this.makePlayer = this.makePlayer.bind(this);
            this.handleSetHuman = this.handleSetHuman.bind(this);
            this.handleSetCustomImage = this.handleSetCustomImage.bind(this);
            this.setRace = this.setRace.bind(this);
        };
        PlayerSetupComponent.prototype.getInitialStateTODO = function () {
            return ({
                name: this.props.initialName,
                mainColor: null,
                secondaryColor: null,
                race: getRandomPlayerRaceTemplate(),
            });
        };
        PlayerSetupComponent.prototype.componentWillUpdate = function (nextProps, nextState) {
            this.flag.backgroundColor = nextState.mainColor;
        };
        PlayerSetupComponent.prototype.generateMainColor = function (subColor) {
            if (subColor === void 0) { subColor = this.state.secondaryColor; }
            if (subColor === null) {
                return colorGeneration_6.generateMainColor();
            }
            else {
                return colorGeneration_6.generateSecondaryColor(subColor);
            }
        };
        PlayerSetupComponent.prototype.generateSubColor = function (mainColor) {
            if (mainColor === void 0) { mainColor = this.state.mainColor; }
            if (mainColor === null) {
                return colorGeneration_6.generateMainColor();
            }
            else {
                return colorGeneration_6.generateSecondaryColor(mainColor);
            }
        };
        PlayerSetupComponent.prototype.handleSetHuman = function () {
            this.props.setHuman(this.props.keyTODO);
        };
        PlayerSetupComponent.prototype.handleNameChange = function (e) {
            var target = e.currentTarget;
            this.setState({ name: target.value });
        };
        PlayerSetupComponent.prototype.setMainColor = function (color, isNull) {
            this.setState({ mainColor: isNull ? null : color });
        };
        PlayerSetupComponent.prototype.setSubColor = function (color, isNull) {
            this.setState({ secondaryColor: isNull ? null : color });
        };
        PlayerSetupComponent.prototype.handleRemove = function () {
            this.props.removePlayers([this.props.keyTODO]);
        };
        PlayerSetupComponent.prototype.handleSetCustomImage = function (image) {
        };
        PlayerSetupComponent.prototype.setRace = function (race) {
            this.setState({
                race: race,
            });
        };
        PlayerSetupComponent.prototype.randomize = function () {
            var mainColor = colorGeneration_6.generateMainColor();
            var secondaryColor = colorGeneration_6.generateSecondaryColor(mainColor);
            this.flag = Flag_5.Flag.generateRandom(mainColor, secondaryColor);
            this.setState({
                mainColor: mainColor,
                secondaryColor: secondaryColor,
                race: getRandomPlayerRaceTemplate(),
            });
        };
        PlayerSetupComponent.prototype.makePlayer = function () {
            var mainColor = this.state.mainColor || this.generateMainColor();
            var secondaryColor = this.state.secondaryColor || this.generateSubColor(mainColor);
            if (!this.flag.backgroundColor) {
                this.flag = Flag_5.Flag.generateRandom(mainColor, secondaryColor);
            }
            var player = new Player_3.default({
                isAI: !this.props.isHuman,
                isIndependent: false,
                race: this.state.race,
                money: 1000,
                name: this.state.name,
                color: {
                    main: mainColor,
                    secondary: secondaryColor,
                    alpha: 1,
                },
                flag: this.flag,
            });
            this.setState({
                mainColor: player.color,
                secondaryColor: player.secondaryColor,
            });
            return player;
        };
        PlayerSetupComponent.prototype.render = function () {
            var _this = this;
            return (React.DOM.div({
                className: "player-setup" + (this.props.isHuman ? " human-player-setup" : ""),
            }, React.DOM.input({
                className: "player-setup-is-human",
                type: "checkbox",
                checked: this.props.isHuman,
                onChange: this.handleSetHuman,
            }), React.DOM.input({
                className: "player-setup-name",
                value: this.state.name,
                onChange: this.handleNameChange,
            }), RacePicker_1.default({
                availableRaces: Object.keys(activeModuleData_26.activeModuleData.Templates.Races).map(function (raceKey) {
                    return activeModuleData_26.activeModuleData.Templates.Races[raceKey];
                }).filter(function (race) {
                    return !race.isNotPlayable;
                }),
                selectedRace: this.state.race,
                changeRace: this.setRace,
            }), ColorSetter_1.default({
                onChange: this.setMainColor,
                setAsActive: this.props.setActiveSetterComponent,
                generateColor: this.generateMainColor,
                color: this.state.mainColor,
            }), ColorSetter_1.default({
                onChange: this.setSubColor,
                setAsActive: this.props.setActiveSetterComponent,
                generateColor: this.generateSubColor,
                color: this.state.secondaryColor,
            }), FlagSetter_1.default({
                flag: this.flag,
                mainColor: this.state.mainColor,
                secondaryColor: this.state.secondaryColor,
                setAsActive: this.props.setActiveSetterComponent,
                updateParentFlag: function (flag) {
                    _this.flag = flag;
                    _this.forceUpdate();
                },
            }), React.DOM.button({
                className: "player-setup-remove-player",
                onClick: this.handleRemove,
            })));
        };
        return PlayerSetupComponent;
    }(React.Component));
    exports.PlayerSetupComponent = PlayerSetupComponent;
    var Factory = React.createFactory(PlayerSetupComponent);
    exports.default = Factory;
});
define("src/uicomponents/setupgame/SetupGamePlayers", ["require", "exports", "react", "react-dom", "src/uicomponents/setupgame/PlayerSetup", "localization/localize"], function (require, exports, React, ReactDOM, PlayerSetup_1, localize_65) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SetupGamePlayersComponent = (function (_super) {
        __extends(SetupGamePlayersComponent, _super);
        function SetupGamePlayersComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "SetupGamePlayers";
            _this.newPlayerId = 0;
            _this.playerSetupComponentsById = {};
            _this.state = _this.getInitialStateTODO();
            _this.bindMethods();
            return _this;
        }
        SetupGamePlayersComponent.prototype.bindMethods = function () {
            this.makeNewPlayers = this.makeNewPlayers.bind(this);
            this.makeAllPlayers = this.makeAllPlayers.bind(this);
            this.setActiveColorSetter = this.setActiveColorSetter.bind(this);
            this.setHumanPlayer = this.setHumanPlayer.bind(this);
            this.randomizeAllPlayers = this.randomizeAllPlayers.bind(this);
            this.removePlayers = this.removePlayers.bind(this);
        };
        SetupGamePlayersComponent.prototype.getInitialStateTODO = function () {
            var players = [];
            for (var i = 0; i < this.props.maxPlayers; i++) {
                players.push(this.newPlayerId++);
            }
            return ({
                playerKeys: players,
                activeColorSetter: null,
            });
        };
        SetupGamePlayersComponent.prototype.componentWillReceiveProps = function (newProps) {
            if (newProps.minPlayers > this.state.playerKeys.length) {
                this.makeNewPlayers(newProps.minPlayers - this.state.playerKeys.length);
            }
            else if (newProps.maxPlayers < this.state.playerKeys.length) {
                var overflowCount = this.state.playerKeys.length - newProps.maxPlayers;
                this.removePlayers(this.state.playerKeys.slice(-overflowCount));
            }
        };
        SetupGamePlayersComponent.prototype.makeNewPlayers = function (amountToMake) {
            var _this = this;
            if (amountToMake === void 0) { amountToMake = 1; }
            if (this.state.playerKeys.length >= this.props.maxPlayers) {
                return;
            }
            var newIds = [];
            for (var i = 0; i < amountToMake; i++) {
                newIds.push(this.newPlayerId++);
            }
            this.setState({
                playerKeys: this.state.playerKeys.concat(newIds),
            }, function () {
                var ownDOMNode = ReactDOM.findDOMNode(_this);
                ownDOMNode.scrollTop = ownDOMNode.scrollHeight;
            });
        };
        SetupGamePlayersComponent.prototype.setHumanPlayer = function (playerId) {
            var index = this.state.playerKeys.indexOf(playerId);
            var newPlayerOrder = this.state.playerKeys.slice(0);
            newPlayerOrder.unshift(newPlayerOrder.splice(index, 1)[0]);
            this.setState({ playerKeys: newPlayerOrder });
        };
        SetupGamePlayersComponent.prototype.removePlayers = function (toRemove) {
            var _this = this;
            if (this.state.playerKeys.length <= this.props.minPlayers) {
                return;
            }
            this.setState({
                playerKeys: this.state.playerKeys.filter(function (playerId) {
                    return toRemove.indexOf(playerId) === -1;
                }),
            }, function () {
                _this.cleanSetupComponentsById();
            });
        };
        SetupGamePlayersComponent.prototype.cleanSetupComponentsById = function () {
            for (var playerId in this.playerSetupComponentsById) {
                if (!this.playerSetupComponentsById[playerId]) {
                    delete this.playerSetupComponentsById[playerId];
                }
            }
            ;
        };
        SetupGamePlayersComponent.prototype.setActiveColorSetter = function (colorSetter) {
            if (this.state.activeColorSetter) {
                this.state.activeColorSetter.setAsInactive();
            }
            this.setState({ activeColorSetter: colorSetter });
        };
        SetupGamePlayersComponent.prototype.randomizeAllPlayers = function () {
            for (var id in this.playerSetupComponentsById) {
                var player = this.playerSetupComponentsById[id];
                player.randomize();
            }
        };
        SetupGamePlayersComponent.prototype.makeAllPlayers = function () {
            var players = [];
            for (var id in this.playerSetupComponentsById) {
                players.push(this.playerSetupComponentsById[id].makePlayer());
            }
            return players;
        };
        SetupGamePlayersComponent.prototype.render = function () {
            var _this = this;
            var playerSetups = [];
            this.state.playerKeys.forEach(function (playerId, i) {
                playerSetups.push(PlayerSetup_1.default({
                    key: playerId,
                    keyTODO: playerId,
                    ref: function (component) {
                        _this.playerSetupComponentsById[playerId] = component;
                    },
                    removePlayers: _this.removePlayers,
                    setActiveSetterComponent: _this.setActiveColorSetter,
                    initialName: "Player " + playerId,
                    isHuman: i === 0,
                    setHuman: _this.setHumanPlayer,
                }));
            });
            var canAddPlayers = this.state.playerKeys.length < this.props.maxPlayers;
            return (React.DOM.div({ className: "setup-game-players" }, React.DOM.div({
                className: "player-setup setup-game-players-header",
            }, React.DOM.div({
                className: "player-setup-is-human",
            }), React.DOM.div({
                className: "player-setup-name",
            }, localize_65.localize("playerName")), React.DOM.div({
                className: "player-setup-race-picker",
            }, localize_65.localize("race")), React.DOM.div({
                className: "color-setter",
            }, localize_65.localize("color_1")), React.DOM.div({
                className: "color-setter",
            }, localize_65.localize("color_2")), React.DOM.div({
                className: "flag-setter",
            }, localize_65.localize("flag")), React.DOM.div({
                className: "player-setup-remove-player",
            }, localize_65.localize("remove"))), React.DOM.div({
                className: "player-setup-players-list",
            }, playerSetups), React.DOM.div({
                className: "setup-game-players-buttons",
            }, React.DOM.button({
                className: "setup-game-button",
                onClick: this.randomizeAllPlayers,
            }, localize_65.localize("randomize")), React.DOM.button({
                className: "setup-game-players-add-new" + (canAddPlayers ? "" : " disabled"),
                onClick: this.makeNewPlayers.bind(this, 1),
                disabled: !canAddPlayers,
            }, localize_65.localize("addNewPlayer")))));
        };
        return SetupGamePlayersComponent;
    }(React.Component));
    exports.SetupGamePlayersComponent = SetupGamePlayersComponent;
    var Factory = React.createFactory(SetupGamePlayersComponent);
    exports.default = Factory;
});
define("src/uicomponents/setupgame/SetupGame", ["require", "exports", "react", "src/App", "src/ModuleFileLoadingPhase", "src/eventManager", "src/uicomponents/setupgame/MapSetup", "src/uicomponents/setupgame/SetupGamePlayers", "localization/localize"], function (require, exports, React, App_13, ModuleFileLoadingPhase_2, eventManager_37, MapSetup_1, SetupGamePlayers_1, localize_66) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SetupGameComponent = (function (_super) {
        __extends(SetupGameComponent, _super);
        function SetupGameComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "SetupGame";
            _this.state = _this.getInitialStateTODO();
            _this.bindMethods();
            return _this;
        }
        SetupGameComponent.prototype.bindMethods = function () {
            this.startGame = this.startGame.bind(this);
            this.randomize = this.randomize.bind(this);
            this.setPlayerLimits = this.setPlayerLimits.bind(this);
        };
        SetupGameComponent.prototype.getInitialStateTODO = function () {
            return ({
                minPlayers: 1,
                maxPlayers: 5,
            });
        };
        SetupGameComponent.prototype.setPlayerLimits = function (props) {
            this.setState({
                minPlayers: props.min,
                maxPlayers: props.max,
            });
        };
        SetupGameComponent.prototype.startGame = function () {
            var _this = this;
            eventManager_37.default.dispatchEvent("loadModulesNeededForPhase", ModuleFileLoadingPhase_2.default.MapGen, function () {
                var players = _this.ref_TODO_players.makeAllPlayers();
                var mapSetupInfo = _this.ref_TODO_mapSetup.getMapSetupInfo();
                var mapGenFunction = mapSetupInfo.template.mapGenFunction;
                var mapGenResult = mapGenFunction(mapSetupInfo.optionValues, players);
                var map = mapGenResult.makeMap();
                App_13.default.makeGameFromSetup(map, players);
            });
        };
        SetupGameComponent.prototype.randomize = function () {
            this.ref_TODO_players.randomizeAllPlayers();
            this.ref_TODO_mapSetup.ref_TODO_mapGenOptions.randomizeOptions();
        };
        SetupGameComponent.prototype.render = function () {
            var _this = this;
            return (React.DOM.div({
                className: "setup-game-wrapper",
            }, React.DOM.div({
                className: "setup-game",
            }, React.DOM.div({
                className: "setup-game-options",
            }, SetupGamePlayers_1.default({
                ref: function (component) {
                    _this.ref_TODO_players = component;
                },
                minPlayers: this.state.minPlayers,
                maxPlayers: this.state.maxPlayers,
            }), MapSetup_1.default({
                setPlayerLimits: this.setPlayerLimits,
                ref: function (component) {
                    _this.ref_TODO_mapSetup = component;
                },
            })), React.DOM.div({
                className: "setup-game-buttons",
            }, React.DOM.button({
                className: "setup-game-button setup-game-button-randomize",
                onClick: this.randomize,
            }, localize_66.localize("randomize")), React.DOM.button({
                className: "setup-game-button setup-game-button-start",
                onClick: this.startGame,
            }, localize_66.localize("startGame"))))));
        };
        return SetupGameComponent;
    }(React.Component));
    exports.SetupGameComponent = SetupGameComponent;
    var Factory = React.createFactory(SetupGameComponent);
    exports.default = Factory;
});
define("modules/common/battlesfxfunctions/sfxfragments/RampingValue", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var RampingValue = (function () {
        function RampingValue(base, up, down) {
            if (up === void 0) { up = 0; }
            if (down === void 0) { down = 0; }
            this.base = base;
            this.up = up;
            this.down = down;
        }
        RampingValue.prototype.getValue = function (up, down) {
            if (up === void 0) { up = 0; }
            if (down === void 0) { down = 0; }
            return this.base + this.up * up + this.down * down;
        };
        RampingValue.prototype.clone = function () {
            return new RampingValue(this.base, this.up, this.down);
        };
        return RampingValue;
    }());
    exports.default = RampingValue;
});
define("modules/common/battlesfxfunctions/sfxfragments/props/PropInfoType", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PropInfoType;
    (function (PropInfoType) {
        PropInfoType[PropInfoType["Boolean"] = 0] = "Boolean";
        PropInfoType[PropInfoType["Function"] = 1] = "Function";
        PropInfoType[PropInfoType["Number"] = 2] = "Number";
        PropInfoType[PropInfoType["Point"] = 3] = "Point";
        PropInfoType[PropInfoType["Range"] = 4] = "Range";
        PropInfoType[PropInfoType["Color"] = 5] = "Color";
        PropInfoType[PropInfoType["RampingValue"] = 6] = "RampingValue";
    })(PropInfoType = exports.PropInfoType || (exports.PropInfoType = {}));
});
define("modules/common/battlesfxfunctions/sfxfragments/props/PropInfo", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PropInfo = (function () {
        function PropInfo(defaultValue) {
            this.defaultValue = defaultValue;
        }
        PropInfo.prototype.getDefaultValue = function () {
            return this.copyValue(this.defaultValue);
        };
        return PropInfo;
    }());
    exports.PropInfo = PropInfo;
});
define("modules/common/battlesfxfunctions/sfxfragments/SFXFragment", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var idGenerator = 0;
    var SFXFragment = (function () {
        function SFXFragment() {
            this.props = {};
            this.id = idGenerator++;
        }
        Object.defineProperty(SFXFragment.prototype, "displayObject", {
            get: function () {
                return this._displayObject;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SFXFragment.prototype, "bounds", {
            get: function () {
                return this.displayObject.getBounds();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SFXFragment.prototype, "position", {
            get: function () {
                return this.displayObject.position;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SFXFragment.prototype, "scale", {
            get: function () {
                return this.displayObject.scale;
            },
            set: function (scale) {
                this.displayObject.scale.set(scale.x, scale.y);
            },
            enumerable: true,
            configurable: true
        });
        SFXFragment.prototype.setDefaultProps = function () {
            for (var key in this.propInfo) {
                this.props[key] = this.propInfo[key].getDefaultValue();
            }
        };
        SFXFragment.prototype.initializeProps = function (initialValues) {
            this.setDefaultProps();
            if (initialValues) {
                this.setProps(initialValues);
            }
        };
        SFXFragment.prototype.setDisplayObject = function (newDisplayObject) {
            var oldDisplayObject = this.displayObject;
            if (oldDisplayObject) {
                newDisplayObject.position.copy(oldDisplayObject.position);
                var parent_1 = oldDisplayObject.parent;
                if (parent_1) {
                    var childIndex = parent_1.children.indexOf(oldDisplayObject);
                    parent_1.removeChildAt(childIndex);
                    parent_1.addChildAt(newDisplayObject, childIndex);
                }
            }
            this._displayObject = newDisplayObject;
        };
        SFXFragment.prototype.setProps = function (props) {
            for (var key in props) {
                this.props[key] = this.propInfo[key].copyValue(props[key]);
            }
        };
        return SFXFragment;
    }());
    exports.default = SFXFragment;
});
define("modules/common/battlesfxfunctions/sfxfragments/props/BasePropInfoClasses", ["require", "exports", "modules/common/battlesfxfunctions/sfxfragments/props/PropInfo", "src/utility"], function (require, exports, PropInfo_1, utility_45) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Primitive = (function (_super) {
        __extends(Primitive, _super);
        function Primitive() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Primitive.prototype.copyValue = function (value) {
            return value;
        };
        return Primitive;
    }(PropInfo_1.PropInfo));
    exports.Primitive = Primitive;
    var ShallowObject = (function (_super) {
        __extends(ShallowObject, _super);
        function ShallowObject() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ShallowObject.prototype.copyValue = function (value) {
            return utility_45.shallowCopy(value);
        };
        return ShallowObject;
    }(PropInfo_1.PropInfo));
    exports.ShallowObject = ShallowObject;
    var Clonable = (function (_super) {
        __extends(Clonable, _super);
        function Clonable() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Clonable.prototype.copyValue = function (value) {
            return value.clone();
        };
        return Clonable;
    }(PropInfo_1.PropInfo));
    exports.Clonable = Clonable;
});
define("modules/common/battlesfxfunctions/sfxfragments/props/PropInfoClasses", ["require", "exports", "modules/common/battlesfxfunctions/sfxfragments/props/BasePropInfoClasses"], function (require, exports, BasePropInfoClasses_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Boolean = (function (_super) {
        __extends(Boolean, _super);
        function Boolean() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Boolean;
    }(BasePropInfoClasses_1.Primitive));
    exports.Boolean = Boolean;
    var Number = (function (_super) {
        __extends(Number, _super);
        function Number() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Number;
    }(BasePropInfoClasses_1.Primitive));
    exports.Number = Number;
    var FunctionPropType = (function (_super) {
        __extends(FunctionPropType, _super);
        function FunctionPropType() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return FunctionPropType;
    }(BasePropInfoClasses_1.Primitive));
    exports.Function = FunctionPropType;
    var Point = (function (_super) {
        __extends(Point, _super);
        function Point() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Point;
    }(BasePropInfoClasses_1.ShallowObject));
    exports.Point = Point;
    var Range = (function (_super) {
        __extends(Range, _super);
        function Range() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Range;
    }(BasePropInfoClasses_1.ShallowObject));
    exports.Range = Range;
    var Color = (function (_super) {
        __extends(Color, _super);
        function Color() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Color;
    }(BasePropInfoClasses_1.Clonable));
    exports.Color = Color;
    var RampingValue = (function (_super) {
        __extends(RampingValue, _super);
        function RampingValue() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return RampingValue;
    }(BasePropInfoClasses_1.Clonable));
    exports.RampingValue = RampingValue;
});
define("modules/common/battlesfxfunctions/shaders/Beam", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Beam = (function (_super) {
        __extends(Beam, _super);
        function Beam(initialUniformValues) {
            var _this = this;
            var uniformData = Beam.makeUniformDataObject(initialUniformValues);
            _this = _super.call(this, null, sourceLines.join("\n"), uniformData) || this;
            return _this;
        }
        Beam.makeUniformDataObject = function (initialValues) {
            if (initialValues === void 0) { initialValues = {}; }
            return ({
                aspectRatio: { type: "float", value: initialValues.aspectRatio },
                beamColor: { type: "vec4", value: initialValues.beamColor },
                beamYPosition: { type: "float", value: initialValues.beamYPosition },
                bulgeIntensity: { type: "float", value: initialValues.bulgeIntensity },
                bulgeSharpness: { type: "float", value: initialValues.bulgeSharpness },
                bulgeSize: { type: "vec2", value: initialValues.bulgeSize },
                bulgeXPosition: { type: "float", value: initialValues.bulgeXPosition },
                lineIntensity: { type: "float", value: initialValues.lineIntensity },
                lineXSharpness: { type: "float", value: initialValues.lineXSharpness },
                lineXSize: { type: "vec2", value: initialValues.lineXSize },
                lineYSharpness: { type: "float", value: initialValues.lineYSharpness },
                lineYSize: { type: "float", value: initialValues.lineYSize },
                noiseAmplitude: { type: "float", value: initialValues.noiseAmplitude },
                seed: { type: "float", value: initialValues.seed },
                time: { type: "float", value: initialValues.time },
            });
        };
        Beam.prototype.setUniforms = function (uniforms) {
            for (var key in uniforms) {
                this.uniforms[key] = uniforms[key];
            }
        };
        return Beam;
    }(PIXI.Filter));
    exports.default = Beam;
    var sourceLines = [
        "precision mediump float;",
        "",
        "#define DOMAIN 0 // 0 == pixi, 1 == shdr.bkcore.com",
        "",
        "#if DOMAIN == 0",
        "  varying vec2 vTextureCoord;",
        "  uniform sampler2D uSampler;",
        "",
        "  uniform float time;",
        "  uniform float seed;",
        "  uniform float noiseAmplitude;",
        "",
        "  uniform float aspectRatio;",
        "",
        "  uniform vec4 beamColor;",
        "  uniform float beamYPosition;",
        "",
        "  uniform float lineIntensity;",
        "  uniform float bulgeIntensity;",
        "",
        "  uniform float bulgeXPosition;",
        "  uniform vec2 bulgeSize;",
        "  uniform float bulgeSharpness;",
        "",
        "  uniform vec2 lineXSize;",
        "  uniform float lineXSharpness;",
        "",
        "  uniform float lineYSize;",
        "  uniform float lineYSharpness;",
        "",
        "",
        "#elif DOMAIN == 1",
        "  uniform vec2 resolution;",
        "  uniform float time;",
        "",
        "  const float seed = 420.69;",
        "  const float noiseAmplitude = 0.5;",
        "  float aspectRatio = resolution.x / resolution.y;",
        "",
        "  const vec4 beamColor = vec4(1.0, 0.5, 0.5, 1.0);",
        "  const float beamYPosition = 0.5;",
        "",
        "  const float bulgeXPosition = 0.4;",
        "  const vec2 bulgeSize = vec2(0.8, 0.4);",
        "  const float bulgeSharpness = 0.4;",
        "  const float bulgeIntensity = 3.0;",
        "",
        "  const vec2 lineXSize = vec2(0.4, 1.0);",
        "  const float lineXSharpness = 0.3;",
        "",
        "  const float lineYSize = 0.02;",
        "  const float lineYSharpness = 0.8;",
        "  const float lineIntensity = 5.0;",
        "",
        "",
        "#endif",
        "",
        "float hash(vec2 p)",
        "{",
        "  return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x))));",
        "}",
        "",
        "float noise(vec2 x)",
        "{",
        "  vec2 i = floor(x);",
        "  vec2 f = fract(x);",
        "  float a = hash(i);",
        "  float b = hash(i + vec2(1.0, 0.0));",
        "  float c = hash(i + vec2(0.0, 1.0));",
        "  float d = hash(i + vec2(1.0, 1.0));",
        "  vec2 u = f * f * (3.0 - 2.0 * f);",
        "  return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;",
        "}",
        "",
        "float ellipseGradient(vec2 p, float ellipseXPosition, vec2 ellipseSize)",
        "{",
        "  vec2 q = vec2(-1.0 + 2.0 * p.x, p.y); // (-1, -1) -> (1, 1)",
        "  q.x -= -1.0 + 2.0 * ellipseXPosition;",
        "  q.x *= aspectRatio;",
        "  q /= ellipseSize;",
        "",
        "  float dist = length(q);",
        "",
        "  return dist;",
        "}",
        "",
        "void main()",
        "{",
        "  #if DOMAIN == 0",
        "    vec2 uv = vTextureCoord;",
        "    vec4 color = texture2D(uSampler, vTextureCoord);",
        "  #elif DOMAIN == 1",
        "    vec2 uv = gl_FragCoord.xy / resolution;",
        "    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);",
        "  #endif",
        "",
        "  vec2 q = vec2(uv.x, (uv.y - beamYPosition) * 2.0);",
        "  float noiseValue = -1.0 + 2.0 * noise(vec2(q.x - time, seed));",
        "  noiseValue *= noiseAmplitude;",
        "",
        "  float yDistFromCenter = abs(q.y);",
        "  float insideLineY = step(yDistFromCenter, lineYSize);",
        "  float lineYDistanceFromEdge = distance(yDistFromCenter, lineYSize);",
        "  float lineYGradient = smoothstep(0.0, 1.0 - lineYSharpness, lineYDistanceFromEdge) * insideLineY;",
        "",
        "  float insideLineX = step(lineXSize.x, q.x) * step(q.x, lineXSize.y);",
        "  float lineXDist = 1.0 - min(distance(q.x, lineXSize.x), distance(q.x, lineXSize.y));",
        "  lineXDist = max(insideLineX, lineXDist);",
        "",
        "  float lineXGradient = smoothstep(lineXSharpness, 1.0, lineXDist);",
        "",
        "  float lineGradient = (lineYGradient * lineXGradient) * lineIntensity;",
        "  lineGradient *= 1.0 + noiseValue;",
        "",
        "  float bulgeGradient = 1.0 - ellipseGradient(q, bulgeXPosition, bulgeSize);",
        "  bulgeGradient = smoothstep(0.0, 1.0 - bulgeSharpness, bulgeGradient) * bulgeIntensity;",
        "  bulgeGradient *= 1.0 + noiseValue * 0.5;",
        "",
        "  float beamGradient = lineGradient + bulgeGradient;",
        "  color += beamGradient * beamColor;",
        "",
        "  gl_FragColor = color;",
        "}",
    ];
});
define("modules/common/battlesfxfunctions/sfxfragments/Beam", ["require", "exports", "modules/common/battlesfxfunctions/sfxfragments/RampingValue", "modules/common/battlesfxfunctions/sfxfragments/SFXFragment", "modules/common/battlesfxfunctions/sfxfragments/props/PropInfoClasses", "modules/common/battlesfxfunctions/shaders/Beam", "src/Color", "src/pixiWrapperFunctions", "src/utility"], function (require, exports, RampingValue_1, SFXFragment_1, PropInfo, Beam_1, Color_5, pixiWrapperFunctions_3, utility_46) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Beam = (function (_super) {
        __extends(Beam, _super);
        function Beam(props) {
            var _this = _super.call(this) || this;
            _this.displayName = "Beam";
            _this.key = "beam";
            _this.propInfo = {
                size: new PropInfo.Point({ x: 500, y: 500 }),
                relativeImpactTime: new PropInfo.Number(0.2),
                relativeBeamOrigin: new PropInfo.Point({ x: 0, y: 0.5 }),
                color: new PropInfo.Color(new Color_5.default(1, 0.9, 0.9)),
                timeScale: new PropInfo.Number(100),
                noiseAmplitude: new PropInfo.RampingValue(new RampingValue_1.default(0.0, 0.4, -0.4)),
                lineIntensity: new PropInfo.RampingValue(new RampingValue_1.default(2.0, 5.0, -5.0)),
                bulgeIntensity: new PropInfo.RampingValue(new RampingValue_1.default(0.0, 6.0, -6.0)),
                lineYSize: new PropInfo.RampingValue(new RampingValue_1.default(0.01, 0.2, -0.21)),
                bulgeSizeX: new PropInfo.RampingValue(new RampingValue_1.default(0.0, 0.7, -0.7)),
                bulgeSizeY: new PropInfo.RampingValue(new RampingValue_1.default(0.0, 0.4, -0.4)),
                bulgeSharpness: new PropInfo.RampingValue(new RampingValue_1.default(0.3, 0.35, -0.35)),
                lineXSharpness: new PropInfo.RampingValue(new RampingValue_1.default(0.99, -0.99, 0.99)),
                lineYSharpness: new PropInfo.RampingValue(new RampingValue_1.default(0.99, -0.15, 0.16)),
            };
            _this.seed = Math.random() * 100;
            _this.initializeProps(props);
            return _this;
        }
        Beam.prototype.animate = function (time) {
            var rampUpValue = Math.pow(Math.min(time / this.props.relativeImpactTime, 1.0), 7.0);
            var timeAfterImpact = Math.max(time - this.props.relativeImpactTime, 0.0);
            var relativeTimeAfterImpact = utility_46.getRelativeValue(timeAfterImpact, 0.0, 1.0 - this.props.relativeImpactTime);
            var rampDownValue = utility_46.clamp(Math.pow(relativeTimeAfterImpact * 1.2, 12.0), 0.0, 1.0);
            this.animateFromRampValues(time, rampUpValue, rampDownValue);
        };
        Beam.prototype.animateFromRampValues = function (time, rampUpValue, rampDownValue) {
            this.beamFilter.setUniforms({
                time: time * this.props.timeScale,
                noiseAmplitude: this.props.noiseAmplitude.getValue(rampUpValue, rampDownValue),
                lineIntensity: this.props.lineIntensity.getValue(rampUpValue, rampDownValue),
                bulgeIntensity: this.props.bulgeIntensity.getValue(rampUpValue, rampDownValue),
                bulgeSize: [
                    this.props.bulgeSizeX.getValue(Math.pow(rampUpValue, 1.5), rampDownValue),
                    this.props.bulgeSizeY.getValue(Math.pow(rampUpValue, 1.5), rampDownValue),
                ],
                bulgeSharpness: this.props.bulgeSharpness.getValue(rampUpValue, rampDownValue),
                lineXSize: [
                    this.props.relativeBeamOrigin.x * rampUpValue,
                    1.0,
                ],
                lineYSize: this.props.lineYSize.getValue(rampUpValue, rampDownValue),
                lineXSharpness: this.props.lineXSharpness.getValue(rampUpValue, rampDownValue),
                lineYSharpness: this.props.lineYSharpness.getValue(rampUpValue, rampDownValue),
            });
        };
        Beam.prototype.draw = function () {
            this.beamFilter = new Beam_1.default({
                seed: this.seed,
                beamColor: this.props.color.getRGBA(1.0),
                aspectRatio: this.props.size.x / this.props.size.y,
                bulgeXPosition: this.props.relativeBeamOrigin.x + 0.1,
                beamYPosition: this.props.relativeBeamOrigin.y,
            });
            var beamSprite = pixiWrapperFunctions_3.makeShaderSprite(this.beamFilter, 0, 0, this.props.size.x, this.props.size.y);
            beamSprite.blendMode = PIXI.BLEND_MODES.SCREEN;
            this.setDisplayObject(beamSprite);
        };
        return Beam;
    }(SFXFragment_1.default));
    exports.default = Beam;
});
define("modules/common/battlesfxfunctions/sfxfragments/FocusingBeam", ["require", "exports", "modules/common/battlesfxfunctions/sfxfragments/RampingValue", "modules/common/battlesfxfunctions/sfxfragments/SFXFragment", "modules/common/battlesfxfunctions/sfxfragments/props/PropInfoClasses", "modules/common/battlesfxfunctions/sfxfragments/Beam", "src/Color", "src/utility"], function (require, exports, RampingValue_2, SFXFragment_2, PropInfo, Beam_2, Color_6, utility_47) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var FocusingBeam = (function (_super) {
        __extends(FocusingBeam, _super);
        function FocusingBeam(props) {
            var _this = _super.call(this) || this;
            _this.displayName = "FocusingBeam";
            _this.key = "focusingBeam";
            _this.propInfo = {
                color: new PropInfo.Color(new Color_6.default(1.0, 1.0, 1.0)),
                size: new PropInfo.Point({ x: 500, y: 500 }),
                focusStartTime: new PropInfo.Number(0.0),
                focusEndTime: new PropInfo.Number(0.3),
                decayStartTime: new PropInfo.Number(0.8),
                decayEndtime: new PropInfo.Number(1.0),
                focusTimeExponent: new PropInfo.Number(0.75),
                relativeYPosition: new PropInfo.Number(0.5),
                beamIntensity: new PropInfo.RampingValue(new RampingValue_2.default(5.0, 20.0, -25.0)),
                beamSharpness: new PropInfo.RampingValue(new RampingValue_2.default(0.75, 0.24, 0.0)),
                beamSize: new PropInfo.RampingValue(new RampingValue_2.default(0.12, -0.115, -0.005)),
            };
            _this.initializeProps(props);
            return _this;
        }
        FocusingBeam.prototype.animate = function (time) {
            var relativeFocusTime = Math.pow(utility_47.getRelativeValue(time, this.props.focusStartTime, this.props.focusEndTime), this.props.focusTimeExponent);
            var rampUpValue = utility_47.clamp(relativeFocusTime, 0.0, 1.0);
            var relativeDecayTime = utility_47.getRelativeValue(time, this.props.decayStartTime, this.props.decayEndtime);
            var rampDownValue = utility_47.clamp(relativeDecayTime, 0.0, 1.0);
            this.beamFragment.animateFromRampValues(time, rampUpValue, rampDownValue);
        };
        FocusingBeam.prototype.draw = function () {
            this.beamFragment = new Beam_2.default({
                color: this.props.color,
                size: this.props.size,
                relativeImpactTime: this.props.focusStartTime,
                relativeBeamOrigin: {
                    x: 0.0,
                    y: this.props.relativeYPosition,
                },
                timeScale: 0,
                noiseAmplitude: new RampingValue_2.default(0.0),
                lineIntensity: this.props.beamIntensity,
                bulgeIntensity: new RampingValue_2.default(0.0),
                bulgeSharpness: new RampingValue_2.default(0.0),
                lineYSize: this.props.beamSize,
                bulgeSizeX: new RampingValue_2.default(0.0),
                bulgeSizeY: new RampingValue_2.default(0.0),
                lineXSharpness: new RampingValue_2.default(0.99),
                lineYSharpness: this.props.beamSharpness,
            });
            this.beamFragment.draw();
            this.setDisplayObject(this.beamFragment.displayObject);
        };
        return FocusingBeam;
    }(SFXFragment_2.default));
    exports.default = FocusingBeam;
});
define("modules/common/battlesfxfunctions/shaders/LightBurst", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var LightBurst = (function (_super) {
        __extends(LightBurst, _super);
        function LightBurst(initialUniformValues) {
            var _this = this;
            var uniformData = LightBurst.makeUniformDataObject(initialUniformValues);
            _this = _super.call(this, null, sourceLines.join("\n"), uniformData) || this;
            return _this;
        }
        LightBurst.makeUniformDataObject = function (initialValues) {
            if (initialValues === void 0) { initialValues = {}; }
            return ({
                centerBloomStrength: { type: "float", value: initialValues.centerBloomStrength },
                centerSize: { type: "float", value: initialValues.centerSize },
                rayColor: { type: "vec4", value: initialValues.rayColor },
                raySharpness: { type: "float", value: initialValues.raySharpness },
                rayStrength: { type: "float", value: initialValues.rayStrength },
                rotation: { type: "float", value: initialValues.rotation },
                seed: { type: "vec2", value: initialValues.seed },
            });
        };
        LightBurst.prototype.setUniforms = function (uniforms) {
            for (var key in uniforms) {
                this.uniforms[key] = uniforms[key];
            }
        };
        return LightBurst;
    }(PIXI.Filter));
    exports.default = LightBurst;
    var sourceLines = [
        "precision mediump float;",
        "",
        "",
        "#define PI 3.14159265359",
        "#define DOMAIN 0 // 0 == pixi, 1 == shdr.bkcore.com",
        "",
        "#if DOMAIN == 0",
        "  varying vec2 vTextureCoord;",
        "  uniform sampler2D uSampler;",
        "",
        "  uniform vec2 seed;",
        "  uniform float rotation;",
        "  uniform float rayStrength;",
        "  uniform float raySharpness;",
        "  uniform vec4 rayColor;",
        "  uniform float centerSize;",
        "  uniform float centerBloomStrength;",
        "",
        "#elif DOMAIN == 1",
        "  uniform vec2 resolution;",
        "  uniform float time;",
        "",
        "  const vec2 seed = vec2(3.3492333784616219, 0.38182701375708206);",
        "  const float rotation = 0.0;",
        "  const float rayStrength = 0.9;",
        "  const float raySharpness = 2.0;",
        "  const vec4 rayColor = vec4(1.0, 0.4, 0.4, 1.0);",
        "  const float centerSize = 1.0;",
        "  const float centerBloomStrength = 5.0;",
        "#endif",
        "",
        "//--------------------------------------------------------------------",
        "",
        "// https://www.shadertoy.com/view/4dlGW2",
        "// Tileable noise, for creating useful textures. By David Hoskins, Sept. 2013.",
        "// It can be extrapolated to other types of randomised texture.",
        "",
        "// https://www.shadertoy.com/terms says default license is CC BY-NC-SA 3.0 which should be fine",
        "",
        "float hash(in vec2 p, in float scale)",
        "{",
        "  // This is tiling part, adjusts with the scale...",
        "  p = mod(p, scale);",
        "  return fract(sin(dot(p, seed)) * 5151.5473453);",
        "}",
        "",
        "float noise(in vec2 p, in float scale)",
        "{",
        "  vec2 f;",
        "",
        "  p *= scale;",
        "",
        "",
        "  f = fract(p);   // Separate integer from fractional",
        "    p = floor(p);",
        "",
        "    f = f*f*(3.0-2.0*f);  // Cosine interpolation approximation",
        "",
        "    float res = mix(mix(hash(p,          scale),",
        "            hash(p + vec2(1.0, 0.0), scale), f.x),",
        "          mix(hash(p + vec2(0.0, 1.0), scale),",
        "            hash(p + vec2(1.0, 1.0), scale), f.x), f.y);",
        "    return res;",
        "}",
        "",
        "float fbm(in vec2 p)",
        "{",
        "  float f = 0.0;",
        "  // Change starting scale to any integer value...",
        "  float scale = 20.0;",
        "  float amp   = 0.5;",
        "",
        "  for (int i = 0; i < 5; i++)",
        "  {",
        "    f += noise(p, scale) * amp;",
        "    amp *= .65;",
        "    // Scale must be multiplied by an integer value...",
        "    scale *= 2.0;",
        "  }",
        "  // Clamp it just in case....",
        "  return min(f, 1.0);",
        "}",
        "",
        "//--------------------------------------------------------------------",
        "",
        "float ray(vec2 q, float angleAdjust)",
        "{",
        "  float angle = (atan(q.y, q.x) + PI + angleAdjust) / (2.0 * PI);",
        "  return fbm(vec2(angle, seed.y));",
        "}",
        "",
        "void main()",
        "{",
        "  #if DOMAIN == 0",
        "    vec2 uv = vTextureCoord;",
        "    vec4 color = texture2D(uSampler, vTextureCoord);",
        "  #elif DOMAIN == 1",
        "    vec2 uv = gl_FragCoord.xy / resolution;",
        "    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);",
        "  #endif",
        "",
        "  vec2 q = uv - 0.5;",
        "  q *= 1.8;",
        "",
        "  float dist = length(q);",
        "",
        "  float centerIntensity = pow(1.0 - dist, 8.0);",
        "  centerIntensity = smoothstep(1.0 - centerSize, 1.0, centerIntensity);",
        "",
        "  float rayIntensity = ray(q, rotation);",
        "  rayIntensity = smoothstep(0.4, 1.0, rayIntensity) * rayStrength;",
        "  rayIntensity -= dist;",
        "  rayIntensity *= max(1.0, raySharpness + 1.0 - dist);",
        "  rayIntensity += centerIntensity * centerBloomStrength;",
        "  rayIntensity = max(0.0, rayIntensity);",
        "  color += rayColor * rayIntensity;",
        "",
        "  gl_FragColor = color;",
        "}",
    ];
});
define("modules/common/battlesfxfunctions/sfxfragments/LightBurst", ["require", "exports", "modules/common/battlesfxfunctions/sfxfragments/SFXFragment", "modules/common/battlesfxfunctions/sfxfragments/props/PropInfoClasses", "modules/common/battlesfxfunctions/shaders/LightBurst", "src/Color", "src/pixiWrapperFunctions"], function (require, exports, SFXFragment_3, PropInfo, LightBurst_1, Color_7, pixiWrapperFunctions_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var LightBurst = (function (_super) {
        __extends(LightBurst, _super);
        function LightBurst(props) {
            var _this = _super.call(this) || this;
            _this.displayName = "LightBurst";
            _this.key = "lightBurst";
            _this.propInfo = {
                size: new PropInfo.Point({ x: 200, y: 200 }),
                delay: new PropInfo.Number(0.3),
                sharpness: new PropInfo.Number(2.0),
                color: new PropInfo.Color(new Color_7.default(0.75, 0.75, 0.62)),
                centerSize: new PropInfo.Number(1.0),
                rayStrength: new PropInfo.Number(1.0),
            };
            _this.seed = [Math.random() * 69, Math.random() * 420];
            _this.initializeProps(props);
            return _this;
        }
        LightBurst.prototype.animate = function (time) {
            var rampUpValue = Math.pow(Math.min(time / this.props.delay, 1.0), 7.0);
            var timeAfterImpact = Math.max(time - this.props.delay, 0.0);
            var rampDownValue = Math.pow(timeAfterImpact * 5.0, 2.0);
            var lightBurstIntensity = Math.max(rampUpValue - rampDownValue, 0.0);
            this.lightBurstFilter.setUniforms({
                centerSize: Math.pow(lightBurstIntensity, 2.0) * this.props.centerSize,
                centerBloomStrength: Math.pow(lightBurstIntensity, 2.0) * 5.0,
                rayStrength: Math.pow(lightBurstIntensity, 3.0) * this.props.rayStrength,
            });
        };
        LightBurst.prototype.draw = function () {
            this.lightBurstFilter = new LightBurst_1.default({
                seed: this.seed,
                rotation: 0,
                raySharpness: this.props.sharpness,
                rayColor: this.props.color.getRGBA(1.0),
            });
            var lightBurstSprite = pixiWrapperFunctions_4.makeShaderSprite(this.lightBurstFilter, 0, 0, this.props.size.x, this.props.size.y);
            lightBurstSprite.blendMode = PIXI.BLEND_MODES.SCREEN;
            this.setDisplayObject(lightBurstSprite);
        };
        return LightBurst;
    }(SFXFragment_3.default));
    exports.default = LightBurst;
});
define("modules/common/battlesfxfunctions/shaders/IntersectingEllipses", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var IntersectingEllipses = (function (_super) {
        __extends(IntersectingEllipses, _super);
        function IntersectingEllipses(initialUniformValues) {
            var _this = this;
            var uniformData = IntersectingEllipses.makeUniformDataObject(initialUniformValues);
            _this = _super.call(this, null, sourceLines.join("\n"), uniformData) || this;
            return _this;
        }
        IntersectingEllipses.makeUniformDataObject = function (initialValues) {
            if (initialValues === void 0) { initialValues = {}; }
            return ({
                intersectingEllipseCenter: { type: "vec2", value: initialValues.intersectingEllipseCenter },
                intersectingEllipseSharpness: { type: "float", value: initialValues.intersectingEllipseSharpness },
                intersectingEllipseSize: { type: "vec2", value: initialValues.intersectingEllipseSize },
                mainAlpha: { type: "float", value: initialValues.mainAlpha },
                mainColor: { type: "vec4", value: initialValues.mainColor },
                mainEllipseSharpness: { type: "float", value: initialValues.mainEllipseSharpness },
                mainEllipseSize: { type: "vec2", value: initialValues.mainEllipseSize },
            });
        };
        IntersectingEllipses.prototype.setUniforms = function (uniforms) {
            for (var key in uniforms) {
                this.uniforms[key] = uniforms[key];
            }
        };
        return IntersectingEllipses;
    }(PIXI.Filter));
    exports.default = IntersectingEllipses;
    var sourceLines = [
        "precision mediump float;",
        "",
        "#define DOMAIN 0 // 0 == pixi, 1 == shdr.bkcore.com",
        "",
        "#if DOMAIN == 0",
        "  varying vec2 vTextureCoord;",
        "  uniform sampler2D uSampler;",
        "",
        "  uniform vec4 mainColor;",
        "  uniform float mainAlpha;",
        "",
        "  uniform vec2 intersectingEllipseCenter;",
        "  uniform vec2 intersectingEllipseSize;",
        "  uniform float intersectingEllipseSharpness;",
        "",
        "  uniform vec2 mainEllipseSize;",
        "  uniform float mainEllipseSharpness;",
        "",
        "#elif DOMAIN == 1",
        "  uniform vec2 resolution;",
        "  uniform float time;",
        "",
        "  const vec4 mainColor = vec4(1.0, 1.0, 1.0, 1.0);",
        "  const float mainAlpha = 1.0;",
        "",
        "  const vec2 intersectingEllipseCenter = vec2(0.4, 0.0);",
        "  const vec2 intersectingEllipseSize = vec2(0.8, 1.0);",
        "  const float intersectingEllipseSharpness = 0.6;",
        "",
        "  const vec2 mainEllipseSize = vec2(0.5, 0.9);",
        "  const float mainEllipseSharpness = 0.8;",
        "",
        "#endif",
        "",
        "",
        "float ellipseGradient(vec2 p, vec2 ellipseCenter, vec2 ellipseSize)",
        "{",
        "  vec2 q = p - ellipseCenter;",
        "  q /= ellipseSize;",
        "",
        "  float dist = length(q);",
        "",
        "  return dist;",
        "}",
        "",
        "void main()",
        "{",
        "  #if DOMAIN == 0",
        "    vec2 uv = vTextureCoord;",
        "    vec4 color = texture2D(uSampler, vTextureCoord);",
        "  #elif DOMAIN == 1",
        "    vec2 uv = gl_FragCoord.xy / resolution;",
        "    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);",
        "  #endif",
        "",
        "  vec2 q = -1.0 + 2.0 * uv;",
        "",
        "  float mainDist = 1.0 - ellipseGradient(q, vec2(0.0, 0.0), mainEllipseSize);",
        "  float mainGradient = smoothstep(0.0, 1.0 - mainEllipseSharpness, mainDist);",
        "  color += mainColor * mainGradient;",
        "",
        "",
        "  float intersectingDist = ellipseGradient(q, intersectingEllipseCenter, intersectingEllipseSize);",
        "",
        "  float intersectingMask = step(intersectingEllipseSharpness, intersectingDist);",
        "  color *= intersectingMask;",
        "",
        "  float intersectingGradient = smoothstep(intersectingEllipseSharpness, 1.0, intersectingDist);",
        "  color *=  intersectingGradient;",
        "",
        "  gl_FragColor = color * mainAlpha;",
        "}",
    ];
});
define("modules/common/battlesfxfunctions/sfxfragments/ShockWave", ["require", "exports", "modules/common/battlesfxfunctions/sfxfragments/RampingValue", "modules/common/battlesfxfunctions/sfxfragments/SFXFragment", "modules/common/battlesfxfunctions/sfxfragments/props/PropInfoClasses", "modules/common/battlesfxfunctions/shaders/IntersectingEllipses", "src/Color", "src/pixiWrapperFunctions"], function (require, exports, RampingValue_3, SFXFragment_4, PropInfo, IntersectingEllipses_1, Color_8, pixiWrapperFunctions_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ShockWave = (function (_super) {
        __extends(ShockWave, _super);
        function ShockWave(props) {
            var _this = _super.call(this) || this;
            _this.displayName = "ShockWave";
            _this.key = "shockWave";
            _this.propInfo = {
                size: new PropInfo.Point({ x: 200, y: 200 }),
                intersectingEllipseOrigin: new PropInfo.Point({ x: 0.0, y: 0.0 }),
                intersectingEllipseDrift: new PropInfo.Point({ x: 0.0, y: 0.0 }),
                alpha: new PropInfo.RampingValue(new RampingValue_3.default(1.0, -1.0, 0.0)),
                mainEllipseScaleX: new PropInfo.RampingValue(new RampingValue_3.default(0.0, 0.9, 0.0)),
                mainEllipseScaleY: new PropInfo.RampingValue(new RampingValue_3.default(0.0, 0.9, 0.0)),
                mainEllipseSharpness: new PropInfo.RampingValue(new RampingValue_3.default(1.0, -0.2, 0.0)),
                intersectingEllipseScaleX: new PropInfo.RampingValue(new RampingValue_3.default(0.0, 1.0, 0.0)),
                intersectingEllipseScaleY: new PropInfo.RampingValue(new RampingValue_3.default(0.0, 1.0, 0.0)),
                intersectingEllipseSharpness: new PropInfo.RampingValue(new RampingValue_3.default(0.8, -0.4, 0.0)),
                color: new PropInfo.Color(new Color_8.default(1, 1, 1)),
                delay: new PropInfo.Number(0.3),
            };
            _this.initializeProps(props);
            return _this;
        }
        ShockWave.CreateFromPartialProps = function (props) {
            return new ShockWave(props);
        };
        ShockWave.prototype.animate = function (time) {
            var p = this.props;
            var burstX = time < p.delay - 0.02 ?
                0 :
                time - (p.delay - 0.02);
            var shockWaveTime = TWEEN.Easing.Quintic.Out(burstX);
            this.shockWaveFilter.setUniforms({
                mainEllipseSize: [
                    p.mainEllipseScaleX.getValue(shockWaveTime),
                    p.mainEllipseScaleY.getValue(shockWaveTime),
                ],
                intersectingEllipseSize: [
                    p.intersectingEllipseScaleX.getValue(shockWaveTime),
                    p.intersectingEllipseScaleY.getValue(shockWaveTime),
                ],
                intersectingEllipseCenter: [
                    p.intersectingEllipseOrigin.x + p.intersectingEllipseDrift.x * shockWaveTime,
                    p.intersectingEllipseOrigin.y + p.intersectingEllipseDrift.y * shockWaveTime,
                ],
                mainEllipseSharpness: p.mainEllipseSharpness.getValue(shockWaveTime),
                intersectingEllipseSharpness: p.intersectingEllipseSharpness.getValue(shockWaveTime),
                mainAlpha: p.alpha.getValue(shockWaveTime),
            });
        };
        ShockWave.prototype.draw = function () {
            var shockWaveFilter = this.shockWaveFilter = new IntersectingEllipses_1.default({
                mainColor: this.props.color.getRGBA(1.0),
            });
            var shockWaveSprite = pixiWrapperFunctions_5.makeShaderSprite(shockWaveFilter, 0, 0, this.props.size.x, this.props.size.y);
            this.setDisplayObject(shockWaveSprite);
        };
        return ShockWave;
    }(SFXFragment_4.default));
    exports.default = ShockWave;
});
define("src/uicomponents/sfxeditor/SFXEditorDisplay", ["require", "exports", "react"], function (require, exports, React) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SFXEditorDisplayComponent = (function (_super) {
        __extends(SFXEditorDisplayComponent, _super);
        function SFXEditorDisplayComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "SFXEditorDisplay";
            _this.fragments = [];
            _this.renderer = PIXI.autoDetectRenderer(0, 0, {
                autoResize: false,
            });
            _this.stage = new PIXI.Container();
            _this.fragmentContainer = new PIXI.Container();
            _this.stage.addChild(_this.fragmentContainer);
            _this.updateRenderer = _this.updateRenderer.bind(_this);
            _this.handleResize = _this.handleResize.bind(_this);
            return _this;
        }
        SFXEditorDisplayComponent.prototype.componentDidMount = function () {
            this.bindRendererView();
            this.updateRenderer();
            window.addEventListener("resize", this.handleResize, false);
        };
        SFXEditorDisplayComponent.prototype.componentWillUnmount = function () {
            window.removeEventListener("resize", this.handleResize);
        };
        SFXEditorDisplayComponent.prototype.handleResize = function () {
            var containerBounds = this.containerDiv.getBoundingClientRect();
            this.renderer.resize(containerBounds.width, containerBounds.height);
        };
        SFXEditorDisplayComponent.prototype.bindRendererView = function () {
            this.containerDiv.appendChild(this.renderer.view);
            this.handleResize();
        };
        SFXEditorDisplayComponent.prototype.addFragment = function (fragment) {
            this.fragmentContainer.addChild(fragment.displayObject);
            this.fragments.push(fragment);
            this.updateRenderer();
        };
        SFXEditorDisplayComponent.prototype.removeFragment = function (fragment) {
            this.fragmentContainer.removeChild(fragment.displayObject);
            this.fragments.splice(this.fragments.indexOf(fragment), 1);
            this.updateRenderer();
        };
        SFXEditorDisplayComponent.prototype.animateFragments = function (relativeTime) {
            this.fragments.forEach(function (fragment) {
                fragment.animate(relativeTime);
            });
        };
        SFXEditorDisplayComponent.prototype.updateRenderer = function () {
            this.renderer.render(this.stage);
        };
        SFXEditorDisplayComponent.prototype.render = function () {
            var _this = this;
            return (React.DOM.div({
                className: "sfx-editor-display",
                ref: function (element) {
                    _this.containerDiv = element;
                },
                onMouseMove: !this.props.hasDraggingFragment ? null :
                    this.props.moveDraggingFragment,
            }));
        };
        return SFXEditorDisplayComponent;
    }(React.Component));
    exports.SFXEditorDisplayComponent = SFXEditorDisplayComponent;
    var Factory = React.createFactory(SFXEditorDisplayComponent);
    exports.default = Factory;
});
define("src/uicomponents/sfxeditor/SFXEditorSelectionTab", ["require", "exports", "react"], function (require, exports, React) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var displayString = {
        fragmentConstructors: "Fragments",
        placedFragments: "Placed",
    };
    var SFXEditorSelectionTabComponent = (function (_super) {
        __extends(SFXEditorSelectionTabComponent, _super);
        function SFXEditorSelectionTabComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "SFXEditorSelectionTab";
            _this.handleClick = _this.handleClick.bind(_this);
            return _this;
        }
        SFXEditorSelectionTabComponent.prototype.handleClick = function () {
            this.props.setTab(this.props.type);
        };
        SFXEditorSelectionTabComponent.prototype.render = function () {
            return (React.DOM.button({
                className: "sfx-editor-selection-tab" +
                    " sfx-editor-selection-tab-" + this.props.type,
                disabled: this.props.isActive,
                onClick: this.handleClick,
            }, displayString[this.props.type]));
        };
        return SFXEditorSelectionTabComponent;
    }(React.Component));
    exports.SFXEditorSelectionTabComponent = SFXEditorSelectionTabComponent;
    var Factory = React.createFactory(SFXEditorSelectionTabComponent);
    exports.default = Factory;
});
define("src/uicomponents/sfxeditor/props/Color", ["require", "exports", "react", "src/uicomponents/setupgame/ColorSetter"], function (require, exports, React, ColorSetter_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SFXFragmentPropColorComponent = (function (_super) {
        __extends(SFXFragmentPropColorComponent, _super);
        function SFXFragmentPropColorComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "SFXFragmentPropColor";
            _this.onColorChange = _this.onColorChange.bind(_this);
            return _this;
        }
        SFXFragmentPropColorComponent.prototype.onColorChange = function (color, isNull) {
            if (isNull) {
                return;
            }
            this.props.fragment.props[this.props.propName] = color;
            this.props.onValueChange();
        };
        SFXFragmentPropColorComponent.prototype.render = function () {
            return (ColorSetter_2.default({
                color: this.props.color,
                onChange: this.onColorChange,
            }));
        };
        return SFXFragmentPropColorComponent;
    }(React.Component));
    exports.SFXFragmentPropColorComponent = SFXFragmentPropColorComponent;
    var Factory = React.createFactory(SFXFragmentPropColorComponent);
    exports.default = Factory;
});
define("src/uicomponents/sfxeditor/props/Number", ["require", "exports", "react", "src/uicomponents/generic/NumericTextInput"], function (require, exports, React, NumericTextInput_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SFXFragmentPropNumberComponent = (function (_super) {
        __extends(SFXFragmentPropNumberComponent, _super);
        function SFXFragmentPropNumberComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "SFXFragmentPropNumber";
            _this.handleChange = _this.handleChange.bind(_this);
            return _this;
        }
        SFXFragmentPropNumberComponent.prototype.handleChange = function (e) {
            var target = e.currentTarget;
            var value = parseFloat(target.value);
            var valueIsValid = isFinite(value);
            if (!valueIsValid) {
                return;
            }
            this.props.fragment.props[this.props.propName] = value;
            this.props.onValueChange();
        };
        SFXFragmentPropNumberComponent.prototype.render = function () {
            var _this = this;
            return (React.DOM.div({
                className: "sfx-fragment-prop-number-input",
            }, NumericTextInput_2.default({
                value: this.props.value,
                valueStringIsValid: function (valueString) { return isFinite(Number(valueString)); },
                getValueFromValueString: parseFloat,
                onValueChange: function (newValue) {
                    _this.props.fragment.props[_this.props.propName] = newValue;
                    _this.props.onValueChange();
                },
            })));
        };
        return SFXFragmentPropNumberComponent;
    }(React.Component));
    exports.SFXFragmentPropNumberComponent = SFXFragmentPropNumberComponent;
    var Factory = React.createFactory(SFXFragmentPropNumberComponent);
    exports.default = Factory;
});
define("src/uicomponents/sfxeditor/props/InlineNumberProp", ["require", "exports", "react", "src/uicomponents/generic/NumericTextInput"], function (require, exports, React, NumericTextInput_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var InlineNumberPropComponent = (function (_super) {
        __extends(InlineNumberPropComponent, _super);
        function InlineNumberPropComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "InlineNumberProp";
            return _this;
        }
        InlineNumberPropComponent.prototype.render = function () {
            var baseId = "sfx-fragment-prop-inline-number-" + this.props.propName + "-" + this.props.label;
            return (React.DOM.div({
                className: "sfx-fragment-prop-inline-number-wrapper",
            }, React.DOM.label({
                className: "sfx-fragment-prop-inline-number-label",
                htmlFor: baseId,
            }, this.props.label + ":"), NumericTextInput_3.default({
                value: this.props.value,
                valueStringIsValid: function (valueString) { return isFinite(Number(valueString)); },
                getValueFromValueString: parseFloat,
                onValueChange: this.props.onValueChange,
            })));
        };
        return InlineNumberPropComponent;
    }(React.Component));
    exports.InlineNumberPropComponent = InlineNumberPropComponent;
    var Factory = React.createFactory(InlineNumberPropComponent);
    exports.default = Factory;
});
define("src/uicomponents/sfxeditor/props/VecBase", ["require", "exports", "react", "src/uicomponents/sfxeditor/props/InlineNumberProp"], function (require, exports, React, InlineNumberProp_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SFXFragmentPropVecBaseComponent = (function (_super) {
        __extends(SFXFragmentPropVecBaseComponent, _super);
        function SFXFragmentPropVecBaseComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "SFXFragmentPropVecBase";
            return _this;
        }
        SFXFragmentPropVecBaseComponent.prototype.handleValueChange = function (prop, newValue) {
            var valueIsValid = isFinite(newValue);
            if (!valueIsValid) {
                return;
            }
            this.props.fragment.props[this.props.propName][prop.key] = newValue;
            this.props.onValueChange();
        };
        SFXFragmentPropVecBaseComponent.prototype.render = function () {
            var _this = this;
            return (React.DOM.div({
                className: "sfx-fragment-prop-vec-wrapper",
            }, this.props.propProps.map(function (prop) {
                return InlineNumberProp_1.default({
                    key: prop.key,
                    propName: _this.props.propName,
                    label: prop.label,
                    value: prop.value,
                    onValueChange: _this.handleValueChange.bind(_this, prop),
                });
            })));
        };
        return SFXFragmentPropVecBaseComponent;
    }(React.Component));
    exports.SFXFragmentPropVecBaseComponent = SFXFragmentPropVecBaseComponent;
    var Factory = React.createFactory(SFXFragmentPropVecBaseComponent);
    exports.default = Factory;
});
define("src/uicomponents/sfxeditor/props/Point", ["require", "exports", "react", "src/uicomponents/sfxeditor/props/VecBase"], function (require, exports, React, VecBase_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SFXFragmentPropPointComponent = (function (_super) {
        __extends(SFXFragmentPropPointComponent, _super);
        function SFXFragmentPropPointComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "SFXFragmentPropPoint";
            return _this;
        }
        SFXFragmentPropPointComponent.prototype.render = function () {
            return (React.DOM.div({
                className: "sfx-fragment-prop-point",
            }, VecBase_1.default({
                propName: this.props.propName,
                fragment: this.props.fragment,
                onValueChange: this.props.onValueChange,
                propProps: [
                    {
                        key: "x",
                        label: "X",
                        value: this.props.x,
                    },
                    {
                        key: "y",
                        label: "Y",
                        value: this.props.y,
                    },
                ],
            })));
        };
        return SFXFragmentPropPointComponent;
    }(React.Component));
    exports.SFXFragmentPropPointComponent = SFXFragmentPropPointComponent;
    var Factory = React.createFactory(SFXFragmentPropPointComponent);
    exports.default = Factory;
});
define("src/uicomponents/sfxeditor/props/RampingValue", ["require", "exports", "react", "src/uicomponents/sfxeditor/props/VecBase"], function (require, exports, React, VecBase_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SFXFragmentPropRampingValueComponent = (function (_super) {
        __extends(SFXFragmentPropRampingValueComponent, _super);
        function SFXFragmentPropRampingValueComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "SFXFragmentPropRampingValue";
            return _this;
        }
        SFXFragmentPropRampingValueComponent.prototype.render = function () {
            return (React.DOM.div({
                className: "sfx-fragment-prop-ramping-value",
            }, VecBase_2.default({
                propName: this.props.propName,
                fragment: this.props.fragment,
                onValueChange: this.props.onValueChange,
                propProps: [
                    {
                        key: "base",
                        label: "base",
                        value: this.props.base,
                    },
                    {
                        key: "up",
                        label: "up",
                        value: this.props.up,
                    },
                    {
                        key: "down",
                        label: "down",
                        value: this.props.down,
                    },
                ],
            })));
        };
        return SFXFragmentPropRampingValueComponent;
    }(React.Component));
    exports.SFXFragmentPropRampingValueComponent = SFXFragmentPropRampingValueComponent;
    var Factory = React.createFactory(SFXFragmentPropRampingValueComponent);
    exports.default = Factory;
});
define("src/uicomponents/sfxeditor/props/Range", ["require", "exports", "react", "src/uicomponents/sfxeditor/props/VecBase"], function (require, exports, React, VecBase_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SFXFragmentPropRangeComponent = (function (_super) {
        __extends(SFXFragmentPropRangeComponent, _super);
        function SFXFragmentPropRangeComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "SFXFragmentPropRange";
            return _this;
        }
        SFXFragmentPropRangeComponent.prototype.render = function () {
            return (React.DOM.div({
                className: "sfx-fragment-prop-range",
            }, VecBase_3.default({
                propName: this.props.propName,
                fragment: this.props.fragment,
                onValueChange: this.props.onValueChange,
                propProps: [
                    {
                        key: "min",
                        label: "Min",
                        value: this.props.min,
                    },
                    {
                        key: "max",
                        label: "Max",
                        value: this.props.max,
                    },
                ],
            })));
        };
        return SFXFragmentPropRangeComponent;
    }(React.Component));
    exports.SFXFragmentPropRangeComponent = SFXFragmentPropRangeComponent;
    var Factory = React.createFactory(SFXFragmentPropRangeComponent);
    exports.default = Factory;
});
define("src/uicomponents/sfxeditor/props/SFXFragmentProp", ["require", "exports", "react", "modules/common/battlesfxfunctions/sfxfragments/props/PropInfoType", "src/uicomponents/sfxeditor/props/Color", "src/uicomponents/sfxeditor/props/Number", "src/uicomponents/sfxeditor/props/Point", "src/uicomponents/sfxeditor/props/RampingValue", "src/uicomponents/sfxeditor/props/Range"], function (require, exports, React, PropInfoType_1, Color_9, Number_1, Point_1, RampingValue_4, Range_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SFXFragmentPropComponent = (function (_super) {
        __extends(SFXFragmentPropComponent, _super);
        function SFXFragmentPropComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "SFXFragmentProp";
            _this.state =
                {
                    isCollapsed: false,
                };
            _this.toggleCollapsed = _this.toggleCollapsed.bind(_this);
            return _this;
        }
        SFXFragmentPropComponent.prototype.toggleCollapsed = function () {
            this.setState({
                isCollapsed: !this.state.isCollapsed,
            });
        };
        SFXFragmentPropComponent.prototype.render = function () {
            var propValuesElement;
            switch (this.props.propType) {
                case PropInfoType_1.PropInfoType.Number:
                    {
                        var propValue = this.props.fragment.props[this.props.propName];
                        propValuesElement = Number_1.default({
                            value: propValue,
                            propName: this.props.propName,
                            fragment: this.props.fragment,
                            onValueChange: this.props.onPropValueChange,
                        });
                        break;
                    }
                case PropInfoType_1.PropInfoType.Point:
                    {
                        var propValue = this.props.fragment.props[this.props.propName];
                        propValuesElement = Point_1.default({
                            x: propValue.x,
                            y: propValue.y,
                            propName: this.props.propName,
                            fragment: this.props.fragment,
                            onValueChange: this.props.onPropValueChange,
                        });
                        break;
                    }
                case PropInfoType_1.PropInfoType.Color:
                    {
                        var propValue = this.props.fragment.props[this.props.propName];
                        propValuesElement = Color_9.default({
                            color: propValue,
                            propName: this.props.propName,
                            fragment: this.props.fragment,
                            onValueChange: this.props.onPropValueChange,
                        });
                        break;
                    }
                case PropInfoType_1.PropInfoType.Range:
                    {
                        var propValue = this.props.fragment.props[this.props.propName];
                        propValuesElement = Range_1.default({
                            min: propValue.min,
                            max: propValue.max,
                            propName: this.props.propName,
                            fragment: this.props.fragment,
                            onValueChange: this.props.onPropValueChange,
                        });
                        break;
                    }
                case PropInfoType_1.PropInfoType.RampingValue:
                    {
                        var propValue = this.props.fragment.props[this.props.propName];
                        propValuesElement = RampingValue_4.default({
                            base: propValue.base,
                            up: propValue.up,
                            down: propValue.down,
                            propName: this.props.propName,
                            fragment: this.props.fragment,
                            onValueChange: this.props.onPropValueChange,
                        });
                        break;
                    }
            }
            return (React.DOM.div({
                className: "sfx-fragment-prop sfx-fragment-prop-" + this.props.propType,
            }, React.DOM.div({
                className: "sfx-fragment-prop-name-container" + (this.state.isCollapsed ? " collapsed" : " collapsible"),
                onClick: this.toggleCollapsed,
            }, React.DOM.div({
                className: "sfx-fragment-prop-name",
            }, this.props.propName)), this.state.isCollapsed ? null : React.DOM.div({
                className: "sfx-fragment-prop-value",
            }, propValuesElement)));
        };
        return SFXFragmentPropComponent;
    }(React.Component));
    exports.SFXFragmentPropComponent = SFXFragmentPropComponent;
    var Factory = React.createFactory(SFXFragmentPropComponent);
    exports.default = Factory;
});
define("src/uicomponents/sfxeditor/SFXFragmentPropsList", ["require", "exports", "react", "src/uicomponents/sfxeditor/props/SFXFragmentProp"], function (require, exports, React, SFXFragmentProp_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SFXFragmentPropsListComponent = (function (_super) {
        __extends(SFXFragmentPropsListComponent, _super);
        function SFXFragmentPropsListComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "SFXFragmentPropsList";
            return _this;
        }
        SFXFragmentPropsListComponent.prototype.render = function () {
            var _this = this;
            var fragment = this.props.fragment;
            return (React.DOM.ul({
                className: "sfx-fragment-props-list",
            }, Object.keys(fragment.props).sort().map(function (propName) {
                var propType = fragment.propInfo[propName].type;
                return SFXFragmentProp_1.default({
                    key: propName,
                    propName: propName,
                    propType: propType,
                    fragment: fragment,
                    onPropValueChange: _this.props.onPropValueChange,
                });
            })));
        };
        return SFXFragmentPropsListComponent;
    }(React.Component));
    exports.SFXFragmentPropsListComponent = SFXFragmentPropsListComponent;
    var Factory = React.createFactory(SFXFragmentPropsListComponent);
    exports.default = Factory;
});
define("src/uicomponents/sfxeditor/SFXFragmentEditor", ["require", "exports", "react", "src/uicomponents/sfxeditor/SFXFragmentPropsList"], function (require, exports, React, SFXFragmentPropsList_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SFXFragmentEditorComponent = (function (_super) {
        __extends(SFXFragmentEditorComponent, _super);
        function SFXFragmentEditorComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "SFXFragmentEditor";
            _this.handleReset = _this.handleReset.bind(_this);
            return _this;
        }
        SFXFragmentEditorComponent.prototype.handleReset = function () {
            this.props.fragment.setDefaultProps();
            this.props.onActiveFragmentPropValueChange();
        };
        SFXFragmentEditorComponent.prototype.render = function () {
            return (React.DOM.div({
                className: "sfx-fragment-editor",
            }, React.DOM.button({
                className: "sfx-fragment-reset-props-button",
                onClick: this.handleReset,
            }, "Reset"), SFXFragmentPropsList_1.default({
                fragment: this.props.fragment,
                onPropValueChange: this.props.onActiveFragmentPropValueChange,
            })));
        };
        return SFXFragmentEditorComponent;
    }(React.Component));
    exports.SFXFragmentEditorComponent = SFXFragmentEditorComponent;
    var Factory = React.createFactory(SFXFragmentEditorComponent);
    exports.default = Factory;
});
define("src/uicomponents/sfxeditor/SFXFragmentListItem", ["require", "exports", "react", "src/uicomponents/mixins/DragPositioner", "src/uicomponents/mixins/applyMixins"], function (require, exports, React, DragPositioner_10, applyMixins_16) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SFXFragmentListItemComponent = (function (_super) {
        __extends(SFXFragmentListItemComponent, _super);
        function SFXFragmentListItemComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "SFXFragmentListItem";
            _this.onDragStart = _this.onDragStart.bind(_this);
            _this.onDragEnd = _this.onDragEnd.bind(_this);
            _this.handleClick = _this.handleClick.bind(_this);
            if (_this.props.isDraggable) {
                _this.dragPositioner = new DragPositioner_10.default(_this, {});
                _this.dragPositioner.onDragStart = _this.onDragStart;
                _this.dragPositioner.onDragEnd = _this.onDragEnd;
                applyMixins_16.default(_this, _this.dragPositioner);
            }
            return _this;
        }
        SFXFragmentListItemComponent.prototype.onDragStart = function () {
            this.props.onDragStart(this.props.fragment);
        };
        SFXFragmentListItemComponent.prototype.onDragEnd = function () {
            this.props.onDragEnd();
        };
        SFXFragmentListItemComponent.prototype.handleClick = function () {
            this.props.onClick(this.props.fragment);
        };
        SFXFragmentListItemComponent.prototype.render = function () {
            var listItemProps = {
                className: "sfx-fragment-list-item",
            };
            if (this.props.isDraggable) {
                listItemProps.className += " draggable";
                listItemProps.onTouchStart = listItemProps.onMouseDown =
                    this.dragPositioner.handleReactDownEvent;
            }
            if (this.props.onClick) {
                listItemProps.className += " clickable";
                listItemProps.onClick = this.handleClick;
            }
            return (React.DOM.li(listItemProps, this.props.fragment.displayName));
        };
        return SFXFragmentListItemComponent;
    }(React.Component));
    exports.SFXFragmentListItemComponent = SFXFragmentListItemComponent;
    var Factory = React.createFactory(SFXFragmentListItemComponent);
    exports.default = Factory;
});
define("src/uicomponents/sfxeditor/SFXFragmentList", ["require", "exports", "react", "src/uicomponents/sfxeditor/SFXFragmentListItem"], function (require, exports, React, SFXFragmentListItem_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SFXFragmentListComponent = (function (_super) {
        __extends(SFXFragmentListComponent, _super);
        function SFXFragmentListComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "SFXFragmentList";
            return _this;
        }
        SFXFragmentListComponent.prototype.render = function () {
            var _this = this;
            return (React.DOM.ol({
                className: "sfx-fragment-list",
            }, this.props.fragments.map(function (fragment) {
                return SFXFragmentListItem_1.default({
                    key: fragment.key,
                    fragment: fragment,
                    isDraggable: _this.props.isDraggable,
                    onDragStart: _this.props.onDragStart,
                    onDragEnd: _this.props.onDragEnd,
                    onClick: _this.props.onClick,
                });
            })));
        };
        return SFXFragmentListComponent;
    }(React.Component));
    exports.SFXFragmentListComponent = SFXFragmentListComponent;
    var Factory = React.createFactory(SFXFragmentListComponent);
    exports.default = Factory;
});
define("src/uicomponents/sfxeditor/SFXEditorSelection", ["require", "exports", "react", "src/uicomponents/sfxeditor/SFXEditorSelectionTab", "src/uicomponents/sfxeditor/SFXFragmentEditor", "src/uicomponents/sfxeditor/SFXFragmentList"], function (require, exports, React, SFXEditorSelectionTab_1, SFXFragmentEditor_1, SFXFragmentList_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SFXEditorSelectionComponent = (function (_super) {
        __extends(SFXEditorSelectionComponent, _super);
        function SFXEditorSelectionComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "SFXEditorSelection";
            _this.state =
                {
                    activeTab: "fragmentConstructors",
                };
            _this.setActiveTab = _this.setActiveTab.bind(_this);
            return _this;
        }
        SFXEditorSelectionComponent.prototype.setActiveTab = function (tabType) {
            this.setState({
                activeTab: tabType,
            });
        };
        SFXEditorSelectionComponent.prototype.render = function () {
            var _this = this;
            var activeSelectionElements = [];
            switch (this.state.activeTab) {
                case "placedFragments":
                    if (this.props.selectedFragment) {
                        activeSelectionElements.push(SFXFragmentEditor_1.default({
                            key: "fragmentEditor",
                            fragment: this.props.selectedFragment,
                            onActiveFragmentPropValueChange: this.props.onSelectedFragmentPropValueChange,
                        }));
                    }
                    break;
                case "fragmentConstructors":
                    activeSelectionElements.push(SFXFragmentList_1.default({
                        key: "fragmentConstructors",
                        fragments: this.props.availableFragmentConstructors,
                        isDraggable: true,
                        onDragStart: this.props.onFragmentListDragStart,
                        onDragEnd: this.props.onFragmentListDragEnd,
                    }));
                    break;
            }
            return (React.DOM.div({
                className: "sfx-editor-selection",
            }, React.DOM.div({
                className: "sfx-editor-selection-tabs-container",
            }, ["fragmentConstructors", "placedFragments"].map(function (tabType) {
                return SFXEditorSelectionTab_1.default({
                    key: tabType,
                    type: tabType,
                    setTab: _this.setActiveTab,
                    isActive: tabType === _this.state.activeTab,
                });
            })), React.DOM.div({
                className: "sfx-editor-selection-active-selector-container",
            }, activeSelectionElements)));
        };
        return SFXEditorSelectionComponent;
    }(React.Component));
    exports.SFXEditorSelectionComponent = SFXEditorSelectionComponent;
    var Factory = React.createFactory(SFXEditorSelectionComponent);
    exports.default = Factory;
});
define("src/uicomponents/sfxeditor/SFXEditor", ["require", "exports", "react", "modules/common/battlesfxfunctions/sfxfragments/Beam", "modules/common/battlesfxfunctions/sfxfragments/FocusingBeam", "modules/common/battlesfxfunctions/sfxfragments/LightBurst", "modules/common/battlesfxfunctions/sfxfragments/ShockWave", "src/utility", "src/uicomponents/sfxeditor/SFXEditorDisplay", "src/uicomponents/sfxeditor/SFXEditorSelection"], function (require, exports, React, Beam_3, FocusingBeam_1, LightBurst_2, ShockWave_1, utility_48, SFXEditorDisplay_1, SFXEditorSelection_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var availableFragmentConstructors = [
        {
            key: "shockWave",
            displayName: "ShockWave",
            constructorFN: ShockWave_1.default,
        },
        {
            key: "lightBurst",
            displayName: "LightBurst",
            constructorFN: LightBurst_2.default,
        },
        {
            key: "beam",
            displayName: "Beam",
            constructorFN: Beam_3.default,
        },
        {
            key: "foucsingBeam",
            displayName: "FocusingBeam",
            constructorFN: FocusingBeam_1.default,
        },
    ];
    function AlphabeticallyByProp(a2, b2, props) {
        for (var i = 0; i < props.length; i++) {
            var prop = props[i];
            var a = a2[prop].toLowerCase();
            var b = b2[prop].toLowerCase();
            if (a < b) {
                return -1;
            }
            else if (a > b) {
                return 1;
            }
        }
        return 0;
    }
    availableFragmentConstructors.sort(function (a, b) {
        return AlphabeticallyByProp(a, b, ["displayName", "key"]);
    });
    var SFXEditorComponent = (function (_super) {
        __extends(SFXEditorComponent, _super);
        function SFXEditorComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "SFXEditor";
            _this.state =
                {
                    isPlaying: false,
                    currentTime: 0,
                    SFXDuration: 1000,
                };
            _this.handleChangeTime = _this.handleChangeTime.bind(_this);
            _this.handleChangeSFXDuration = _this.handleChangeSFXDuration.bind(_this);
            _this.togglePlay = _this.togglePlay.bind(_this);
            _this.handleFragmentConstructorDragStart = _this.handleFragmentConstructorDragStart.bind(_this);
            _this.handleFragmentConstructorDragEnd = _this.handleFragmentConstructorDragEnd.bind(_this);
            _this.handleFragmentDragMove = _this.handleFragmentDragMove.bind(_this);
            _this.selectFragment = _this.selectFragment.bind(_this);
            _this.handleSelectedFragmentPropValueChange = _this.handleSelectedFragmentPropValueChange.bind(_this);
            _this.advanceTime = _this.advanceTime.bind(_this);
            return _this;
        }
        SFXEditorComponent.prototype.handleChangeTime = function (e) {
            var target = e.currentTarget;
            var newTime = utility_48.clamp(parseFloat(target.value), 0, 1);
            if (this.state.isPlaying) {
                this.togglePlay();
            }
            this.updateTime(newTime);
        };
        SFXEditorComponent.prototype.handleChangeSFXDuration = function (e) {
            var target = e.currentTarget;
            var SFXDuration = Math.max(parseInt(target.value), 0);
            this.setState({
                SFXDuration: SFXDuration,
            });
        };
        SFXEditorComponent.prototype.togglePlay = function () {
            if (this.state.isPlaying) {
                this.stopAnimating();
            }
            else {
                this.startAnimating();
            }
        };
        SFXEditorComponent.prototype.startAnimating = function () {
            var _this = this;
            this.setState({
                isPlaying: true,
            }, function () {
                _this.lastAnimationTickTime = window.performance.now();
                _this.animationHandle = window.requestAnimationFrame(_this.advanceTime);
            });
        };
        SFXEditorComponent.prototype.stopAnimating = function () {
            var _this = this;
            this.setState({
                isPlaying: false,
            }, function () {
                if (isFinite(_this.animationHandle)) {
                    window.cancelAnimationFrame(_this.animationHandle);
                    _this.animationHandle = undefined;
                    _this.lastAnimationTickTime = undefined;
                }
            });
        };
        SFXEditorComponent.prototype.advanceTime = function (timeStamp) {
            var elapsedTime = timeStamp - this.lastAnimationTickTime;
            this.lastAnimationTickTime = timeStamp;
            var elapsedRelativeTime = elapsedTime / this.state.SFXDuration;
            var newRelativeTime = (this.state.currentTime + elapsedRelativeTime) % 1;
            this.updateTime(newRelativeTime);
            this.animationHandle = window.requestAnimationFrame(this.advanceTime);
        };
        SFXEditorComponent.prototype.updateTime = function (relativeTime) {
            this.display.animateFragments(relativeTime);
            this.display.updateRenderer();
            this.setState({
                currentTime: relativeTime,
            });
        };
        SFXEditorComponent.prototype.handleFragmentConstructorDragStart = function (fragmentConstructor) {
            var fragment = new fragmentConstructor.constructorFN();
            fragment.draw();
            fragment.animate(this.state.currentTime);
            this.display.addFragment(fragment);
            this.setState({
                selectedFragment: fragment,
                draggingFragment: fragment,
            });
        };
        SFXEditorComponent.prototype.handleFragmentConstructorDragEnd = function () {
            this.setState({
                draggingFragment: undefined,
            });
        };
        SFXEditorComponent.prototype.handleFragmentDragMove = function (e) {
            this.state.draggingFragment.position.set(e.clientX, e.clientY);
            this.display.updateRenderer();
        };
        SFXEditorComponent.prototype.selectFragment = function (fragment) {
            this.setState({
                selectedFragment: fragment,
            });
        };
        SFXEditorComponent.prototype.updateFragment = function (fragment) {
            fragment.draw();
            fragment.animate(this.state.currentTime);
            this.display.updateRenderer();
        };
        SFXEditorComponent.prototype.handleSelectedFragmentPropValueChange = function () {
            this.updateFragment(this.state.selectedFragment);
            this.forceUpdate();
        };
        SFXEditorComponent.prototype.render = function () {
            var _this = this;
            return (React.DOM.div({
                className: "sfx-editor",
            }, React.DOM.div({
                className: "sfx-editor-main",
            }, SFXEditorDisplay_1.default({
                hasDraggingFragment: Boolean(this.state.draggingFragment),
                moveDraggingFragment: this.handleFragmentDragMove,
                ref: function (component) {
                    _this.display = component;
                },
            }), React.DOM.input({
                className: "sfx-editor-time-control",
                type: "range",
                min: 0,
                max: 1,
                step: 0.002,
                value: "" + this.state.currentTime,
                onChange: this.handleChangeTime,
                title: "Current time",
            }), React.DOM.div({
                className: "sfx-editor-play-wrapper",
            }, React.DOM.button({
                className: "sfx-editor-play-button",
                onClick: this.togglePlay,
            }, this.state.isPlaying ?
                "Pause" :
                "Play"), React.DOM.label({
                className: "sfx-editor-duration-label",
                htmlFor: "sfx-editor-duration",
            }, "SFX Duration (ms)"), React.DOM.input({
                className: "sfx-editor-duration",
                id: "sfx-editor-duration",
                type: "number",
                min: 0,
                step: 100,
                value: "" + this.state.SFXDuration,
                onChange: this.handleChangeSFXDuration,
            }))), SFXEditorSelection_1.default({
                availableFragmentConstructors: availableFragmentConstructors,
                selectedFragment: this.state.selectedFragment,
                onSelectedFragmentPropValueChange: this.handleSelectedFragmentPropValueChange,
                selectFragment: this.selectFragment,
                onFragmentListDragStart: this.handleFragmentConstructorDragStart,
                onFragmentListDragEnd: this.handleFragmentConstructorDragEnd,
            })));
        };
        return SFXEditorComponent;
    }(React.Component));
    exports.SFXEditorComponent = SFXEditorComponent;
    var Factory = React.createFactory(SFXEditorComponent);
    exports.default = Factory;
});
define("src/uicomponents/Stage", ["require", "exports", "react", "src/uicomponents/BattleSceneTester", "src/uicomponents/FlagMaker", "src/uicomponents/battle/Battle", "src/uicomponents/battleprep/BattlePrep", "src/uicomponents/galaxymap/GalaxyMap", "src/uicomponents/setupgame/SetupGame", "src/uicomponents/sfxeditor/SFXEditor"], function (require, exports, React, BattleSceneTester_1, FlagMaker_1, Battle_3, BattlePrep_2, GalaxyMap_2, SetupGame_1, SFXEditor_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var StageComponent = (function (_super) {
        __extends(StageComponent, _super);
        function StageComponent(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "Stage";
            return _this;
        }
        StageComponent.prototype.render = function () {
            var elementsToRender = [];
            switch (this.props.sceneToRender) {
                case "battle":
                    {
                        elementsToRender.push(Battle_3.default({
                            battle: this.props.battle,
                            humanPlayer: this.props.player,
                            key: "battle",
                        }));
                        break;
                    }
                case "battlePrep":
                    {
                        elementsToRender.push(BattlePrep_2.default({
                            battlePrep: this.props.battlePrep,
                            key: "battlePrep",
                        }));
                        break;
                    }
                case "galaxyMap":
                    {
                        elementsToRender.push(GalaxyMap_2.default({
                            renderer: this.props.renderer,
                            mapRenderer: this.props.mapRenderer,
                            playerControl: this.props.playerControl,
                            player: this.props.player,
                            game: this.props.game,
                            activeLanguage: this.props.activeLanguage,
                            notificationLog: this.props.notificationLog,
                            key: "galaxyMap",
                        }));
                        break;
                    }
                case "flagMaker":
                    {
                        elementsToRender.push(FlagMaker_1.default({
                            key: "flagMaker",
                        }));
                        break;
                    }
                case "setupGame":
                    {
                        elementsToRender.push(SetupGame_1.default({
                            key: "setupGame",
                        }));
                        break;
                    }
                case "battleSceneTester":
                    {
                        elementsToRender.push(BattleSceneTester_1.default({
                            key: "battleSceneTester",
                        }));
                        break;
                    }
                case "SFXEditor":
                    {
                        elementsToRender.push(SFXEditor_1.default({
                            key: "SFXEditor",
                        }));
                        break;
                    }
            }
            return (React.DOM.div({ className: "react-stage" }, elementsToRender));
        };
        return StageComponent;
    }(React.Component));
    exports.StageComponent = StageComponent;
    var Factory = React.createFactory(StageComponent);
    exports.default = Factory;
});
define("src/ReactUI", ["require", "exports", "react-dom", "src/ModuleFileLoadingPhase", "src/activeNotificationLog", "src/eventManager", "src/localization/activeLanguage", "src/uicomponents/Stage"], function (require, exports, ReactDOM, ModuleFileLoadingPhase_3, activeNotificationLog_3, eventManager_38, activeLanguage_3, Stage_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var moduleLoadingPhaseByScene = {
        battle: ModuleFileLoadingPhase_3.default.Battle,
        battlePrep: ModuleFileLoadingPhase_3.default.BattlePrep,
        galaxyMap: ModuleFileLoadingPhase_3.default.Game,
        setupGame: ModuleFileLoadingPhase_3.default.Setup,
        flagMaker: ModuleFileLoadingPhase_3.default.Setup,
        battleSceneTester: ModuleFileLoadingPhase_3.default.Battle,
    };
    var ReactUI = (function () {
        function ReactUI(container, moduleLoader) {
            this.container = container;
            this.moduleLoader = moduleLoader;
            this.addEventListeners();
        }
        ReactUI.prototype.switchScene = function (newScene) {
            var _this = this;
            this.currentScene = newScene;
            this.loadModulesNeededForCurrentScene(function () {
                _this.render();
            });
        };
        ReactUI.prototype.destroy = function () {
            eventManager_38.default.removeAllListeners("switchScene");
            eventManager_38.default.removeAllListeners("renderUI");
            ReactDOM.unmountComponentAtNode(this.container);
            this.container = null;
        };
        ReactUI.prototype.render = function () {
            ReactDOM.render(Stage_1.default({
                sceneToRender: this.currentScene,
                battle: this.battle,
                battlePrep: this.battlePrep,
                renderer: this.renderer,
                mapRenderer: this.mapRenderer,
                playerControl: this.playerControl,
                player: this.player,
                game: this.game,
                activeLanguage: activeLanguage_3.getActiveLanguage(),
                notificationLog: activeNotificationLog_3.activeNotificationLog,
            }), this.container);
        };
        ReactUI.prototype.addEventListeners = function () {
            eventManager_38.default.addEventListener("switchScene", this.switchScene.bind(this));
            eventManager_38.default.addEventListener("renderUI", this.render.bind(this));
        };
        ReactUI.prototype.loadModulesNeededForCurrentScene = function (afterLoaded) {
            var phase = moduleLoadingPhaseByScene[this.currentScene];
            this.moduleLoader.loadModulesNeededForPhase(phase, afterLoaded);
        };
        return ReactUI;
    }());
    exports.default = ReactUI;
});
define("modules/core/modulescripts/unitScripts", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unitScripts = {
        onCapture: [
            {
                key: "transferCapturedUnit",
                priority: 0,
                script: function (unit, oldPlayer, newPlayer) {
                    unit.transferToPlayer(newPlayer);
                },
            },
            {
                key: "resetExperience",
                priority: 0,
                script: function (unit, oldPlayer, newPlayer) {
                    unit.experienceForCurrentLevel = 0;
                },
            },
            {
                key: "exhaustUnit",
                priority: 0,
                script: function (unit, oldPlayer, newPlayer) {
                    unit.currentMovePoints = 0;
                    unit.offensiveBattlesFoughtThisTurn = Infinity;
                },
            },
        ],
    };
});
define("modules/core/modulescripts/allScripts", ["require", "exports", "modules/core/modulescripts/unitScripts"], function (require, exports, unitScripts_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.allScripts = {
        unit: unitScripts_1.unitScripts,
    };
});
define("modules/core/core", ["require", "exports", "src/ModuleFileLoadingPhase", "localization/defaultLanguages", "modules/core/modulescripts/allScripts"], function (require, exports, ModuleFileLoadingPhase_4, Languages, allScripts_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = {
        key: "core",
        metaData: {
            name: "core",
            version: "0.1.0",
            author: "giraluna",
            description: "Core gameplay functionality",
        },
        needsToBeLoadedBefore: ModuleFileLoadingPhase_4.default.Setup,
        supportedLanguages: [Languages.en],
        constructModule: function (moduleData) {
            moduleData.scripts.add(allScripts_1.allScripts);
            return moduleData;
        },
    };
    exports.default = core;
});
define("modules/defaultai/mapai/UnitEvaluator", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var UnitEvaluator = (function () {
        function UnitEvaluator() {
        }
        UnitEvaluator.prototype.evaluateCombatStrength = function () {
            var units = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                units[_i] = arguments[_i];
            }
            var strength = 0;
            units.forEach(function (unit) {
                strength += unit.currentHealth;
            });
            return strength;
        };
        UnitEvaluator.prototype.evaluateMapStrength = function () {
            var units = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                units[_i] = arguments[_i];
            }
            return this.evaluateCombatStrength.apply(this, units);
        };
        UnitEvaluator.prototype.evaluateUnitScoutingAbility = function (unit) {
            var score = 0;
            var visionRange = unit.getVisionRange();
            if (visionRange < 0) {
                return -Infinity;
            }
            else {
                score += Math.pow(visionRange, 1.5) / 2;
            }
            var isStealthy = unit.isStealthy();
            if (isStealthy) {
                score *= 1.5;
            }
            score /= unit.getTotalCost();
            return score;
        };
        return UnitEvaluator;
    }());
    exports.UnitEvaluator = UnitEvaluator;
});
define("modules/defaultai/mapai/MapEvaluator", ["require", "exports", "src/Star", "src/ValuesByPlayer", "src/ValuesByStar", "src/utility"], function (require, exports, Star_2, ValuesByPlayer_2, ValuesByStar_2, utility_49) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultEvaluationParameters = {
        starDesirability: {
            neighborRange: 1,
            neighborWeight: 0.5,
            defendabilityWeight: 1,
            totalIncomeWeight: 1,
            baseIncomeWeight: 0.5,
            infrastructureWeight: 1,
            productionWeight: 1,
        },
    };
    var MapEvaluator = (function () {
        function MapEvaluator(map, player, unitEvaluator) {
            this.map = map;
            this.player = player;
            this.unitEvaluator = unitEvaluator;
            this.evaluationParameters = exports.defaultEvaluationParameters;
        }
        MapEvaluator.prototype.evaluateStarIncome = function (star) {
            var evaluation = 0;
            evaluation += star.baseIncome;
            evaluation += (star.getIncome() - star.baseIncome) *
                (1 - this.evaluationParameters.starDesirability.baseIncomeWeight);
            return evaluation;
        };
        MapEvaluator.prototype.evaluateStarInfrastructure = function (star) {
            var evaluation = 0;
            for (var category in star.buildings) {
                for (var i = 0; i < star.buildings[category].length; i++) {
                    evaluation += star.buildings[category][i].totalCost / 25;
                }
            }
            return evaluation;
        };
        MapEvaluator.prototype.evaluateStarProduction = function (star) {
            var evaluation = 0;
            return evaluation;
        };
        MapEvaluator.prototype.evaluateStarDefendability = function (star) {
            var evaluation = 0;
            var nearbyStars = star.getLinkedInRange(2).byRange;
            for (var rangeString in nearbyStars) {
                var distanceMultiplier = 1 / parseInt(rangeString);
                var starsInRange = nearbyStars[rangeString];
                for (var i = 0; i < starsInRange.length; i++) {
                    var neighbor = starsInRange[i];
                    var neighborDefendability = void 0;
                    if (neighbor.owner === this.player) {
                        neighborDefendability = 3;
                    }
                    else if (neighbor.owner.isIndependent) {
                        neighborDefendability = -0.75;
                    }
                    else {
                        neighborDefendability = -2;
                    }
                    evaluation += neighborDefendability * distanceMultiplier;
                }
            }
            if (star.owner === this.player) {
                evaluation += 3;
            }
            return evaluation * 5;
        };
        MapEvaluator.prototype.evaluateIndividualStarDesirability = function (star) {
            var evaluation = 0;
            var p = this.evaluationParameters.starDesirability;
            var incomeEvaluation = this.evaluateStarIncome(star) * p.totalIncomeWeight;
            incomeEvaluation *= incomeEvaluation / (this.player.getIncome() / 4);
            evaluation += incomeEvaluation;
            var infrastructureEvaluation = this.evaluateStarInfrastructure(star) * p.infrastructureWeight;
            evaluation += infrastructureEvaluation;
            var productionEvaluation = this.evaluateStarProduction(star) * p.productionWeight;
            evaluation += productionEvaluation;
            var defendabilityEvaluation = this.evaluateStarDefendability(star) * p.defendabilityWeight;
            evaluation += defendabilityEvaluation;
            return evaluation;
        };
        MapEvaluator.prototype.evaluateNeighboringStarsDesirability = function (star, range) {
            var evaluation = 0;
            var getDistanceFalloff = function (distance) {
                return 1 / (distance + 1);
            };
            var inRange = star.getLinkedInRange(range).byRange;
            for (var distanceString in inRange) {
                var stars = inRange[distanceString];
                var distanceFalloff = getDistanceFalloff(parseInt(distanceString));
                for (var i = 0; i < stars.length; i++) {
                    evaluation += this.evaluateIndividualStarDesirability(stars[i]) * distanceFalloff;
                }
            }
            return evaluation;
        };
        MapEvaluator.prototype.evaluateStarDesirability = function (star) {
            var evaluation = 0;
            var p = this.evaluationParameters.starDesirability;
            evaluation += this.evaluateIndividualStarDesirability(star);
            evaluation += this.evaluateNeighboringStarsDesirability(star, p.neighborRange) *
                p.neighborWeight;
            return evaluation;
        };
        MapEvaluator.prototype.evaluateStarTargets = function (targetStars) {
            var _this = this;
            var evaluationByStar = new ValuesByStar_2.default(targetStars, function (star) {
                var desirability = _this.evaluateStarDesirability(star);
                var hostileStrength = _this.getHostileStrengthAtStar(star);
                var ownInfluenceMap = _this.getPlayerInfluenceMap(_this.player);
                var ownInfluenceAtStar = ownInfluenceMap.get(star) || 1;
                return ({
                    desirability: desirability,
                    hostileStrength: hostileStrength,
                    ownInfluence: ownInfluenceAtStar,
                });
            });
            return evaluationByStar;
        };
        MapEvaluator.prototype.scoreStarTargets = function (evaluations, getScoreFN) {
            var scores = new ValuesByStar_2.default();
            evaluations.forEach(function (star, evaluation) {
                scores.set(star, getScoreFN(star, evaluation));
            });
            return scores;
        };
        MapEvaluator.prototype.scoreIndependentTargets = function (evaluations) {
            var _this = this;
            return this.scoreStarTargets(evaluations, function (star, evaluation) {
                var easeOfCapturing = evaluation.ownInfluence / evaluation.hostileStrength;
                var score = evaluation.desirability * easeOfCapturing;
                if (star.getSecondaryController() === _this.player) {
                    score *= 1.5;
                }
                return score;
            });
        };
        MapEvaluator.prototype.getIndependentNeighborStars = function () {
            var _this = this;
            var independentNeighborStars = this.player.getNeighboringStars().filter(function (star) {
                var secondaryController = star.getSecondaryController();
                return star.owner.isIndependent && (!secondaryController || secondaryController === _this.player);
            });
            return independentNeighborStars;
        };
        MapEvaluator.prototype.getIndependentNeighborStarIslands = function (earlyReturnSize) {
            var _this = this;
            var islandQualifierFN = function (a, b) {
                var secondaryController = b.getSecondaryController();
                return b.owner.isIndependent && (!secondaryController || secondaryController === _this.player);
            };
            return Star_2.default.getIslandForQualifier(this.player.controlledLocations, earlyReturnSize, islandQualifierFN);
        };
        MapEvaluator.prototype.getHostileUnitsAtStar = function (star) {
            var _this = this;
            return star.getUnits(function (player) {
                return _this.player.diplomacyStatus.canAttackFleetOfPlayer(player);
            });
        };
        MapEvaluator.prototype.getHostileStrengthAtStar = function (star) {
            return (_a = this.unitEvaluator).evaluateMapStrength.apply(_a, this.getHostileUnitsAtStar(star));
            var _a;
        };
        MapEvaluator.prototype.getIndependentStrengthAtStar = function (star) {
            var independentUnits = star.getUnits(function (player) { return player.isIndependent; });
            return (_a = this.unitEvaluator).evaluateMapStrength.apply(_a, independentUnits);
            var _a;
        };
        MapEvaluator.prototype.getDefenceBuildingStrengthAtStarByPlayer = function (star) {
            var byPlayer = new ValuesByPlayer_2.default();
            for (var i = 0; i < star.buildings["defence"].length; i++) {
                var building = star.buildings["defence"][i];
                var previousValue = byPlayer.get(building.controller) || 0;
                byPlayer.set(building.controller, previousValue + building.totalCost);
            }
            return byPlayer;
        };
        MapEvaluator.prototype.getTotalDefenceBuildingStrengthAtStar = function (star) {
            var strength = 0;
            for (var i = 0; i < star.buildings["defence"].length; i++) {
                var building = star.buildings["defence"][i];
                if (building.controller.id === this.player.id)
                    continue;
                strength += building.totalCost;
            }
            return strength;
        };
        MapEvaluator.prototype.getVisibleFleetsOfPlayer = function (player) {
            var _this = this;
            var visibleFleets = [];
            this.player.getVisibleStars().forEach(function (star) {
                var playerFleetsAtStar = star.fleets[player.id];
                if (playerFleetsAtStar) {
                    var hasDetectionInStar = _this.player.starIsDetected(star);
                    var visibleFleetsAtStar = hasDetectionInStar ? playerFleetsAtStar :
                        playerFleetsAtStar.filter(function (fleet) {
                            return !fleet.isStealthy;
                        });
                    visibleFleets.push.apply(visibleFleets, visibleFleetsAtStar);
                }
            });
            return visibleFleets;
        };
        MapEvaluator.prototype.getPlayerInfluenceMap = function (player) {
            var _this = this;
            var stars = this.player.getRevealedStars();
            var influence = new ValuesByStar_2.default(stars, function (star) {
                var defenceBuildingStrength = _this.getDefenceBuildingStrengthAtStarByPlayer(star);
                return defenceBuildingStrength.get(player) || 0;
            });
            var fleets = this.getVisibleFleetsOfPlayer(player);
            function getDistanceFalloff(distance) {
                return 1 / (distance + 1);
            }
            for (var i = 0; i < fleets.length; i++) {
                var fleet = fleets[i];
                var strength = (_a = this.unitEvaluator).evaluateMapStrength.apply(_a, fleet.units);
                var location_1 = fleet.location;
                var range = fleet.getMinMaxMovePoints();
                var turnsToCheck = 4;
                var inFleetRange = location_1.getLinkedInRange(range * turnsToCheck).byRange;
                inFleetRange[0] = [location_1];
                for (var distance in inFleetRange) {
                    var numericDistance = parseInt(distance);
                    var turnsToReach = Math.floor((numericDistance - 1) / range);
                    if (turnsToReach < 0)
                        turnsToReach = 0;
                    var distanceFalloff = getDistanceFalloff(turnsToReach);
                    var adjustedStrength = strength * distanceFalloff;
                    for (var j = 0; j < inFleetRange[distance].length; j++) {
                        var star = inFleetRange[distance][j];
                        var previousInfluence = influence.get(star) || 0;
                        influence.set(star, previousInfluence + adjustedStrength);
                    }
                }
            }
            return influence;
            var _a;
        };
        MapEvaluator.prototype.getInfluenceMapsForKnownPlayers = function () {
            var _this = this;
            var byPlayer = new ValuesByPlayer_2.default();
            this.player.diplomacyStatus.getMetPlayers().filter(function (player) { return !player.isDead; }).forEach(function (player) {
                byPlayer.set(player, _this.getPlayerInfluenceMap(player));
            });
            return byPlayer;
        };
        MapEvaluator.prototype.getKnownPlayersInfluenceOnStar = function (star) {
            var influenceMaps = this.getInfluenceMapsForKnownPlayers();
            var influenceByPlayer = new ValuesByPlayer_2.default();
            influenceMaps.forEach(function (player, influenceMap) {
                var influenceOnStar = influenceMap.get(star);
                if (isFinite(influenceOnStar)) {
                    influenceByPlayer.set(player, influenceOnStar);
                }
            });
            return influenceByPlayer;
        };
        MapEvaluator.prototype.getVisibleStarsOfPlayer = function (player) {
            return this.player.getVisibleStars().filter(function (star) {
                return star.owner === player;
            });
        };
        MapEvaluator.prototype.getVisibleStarsOfKnownPlayers = function () {
            var _this = this;
            var byPlayer = new ValuesByPlayer_2.default();
            this.player.diplomacyStatus.getMetPlayers().filter(function (player) { return !player.isDead; }).forEach(function (player) {
                byPlayer.set(player, _this.getVisibleStarsOfPlayer(player));
            });
            return byPlayer;
        };
        MapEvaluator.prototype.estimateGlobalStrength = function (player) {
            var visibleStrength = 0;
            var invisibleStrength = 0;
            var fleets = this.getVisibleFleetsOfPlayer(player);
            for (var i = 0; i < fleets.length; i++) {
                visibleStrength += (_a = this.unitEvaluator).evaluateMapStrength.apply(_a, fleets[i].units);
            }
            if (player !== this.player) {
                invisibleStrength = visibleStrength * 0.5;
            }
            return visibleStrength + invisibleStrength;
            var _a;
        };
        MapEvaluator.prototype.getPerceivedThreatOfPlayer = function (player) {
            if (!this.player.diplomacyStatus.hasMetPlayer(player)) {
                throw new Error(this.player.name.fullName +
                    " tried to call getPerceivedThreatOfPlayer on unmet player " + player.name.fullName);
            }
            var otherInfluenceMap = this.getPlayerInfluenceMap(player);
            var ownInfluenceMap = this.getPlayerInfluenceMap(this.player);
            var totalInfluenceInOwnStars = 0;
            this.player.controlledLocations.forEach(function (star) {
                var ownInfluence = ownInfluenceMap.get(star);
                var otherInfluence = otherInfluenceMap.get(star);
                totalInfluenceInOwnStars += otherInfluence - 0.5 * ownInfluence;
            });
            var globalStrengthDifference = this.estimateGlobalStrength(player) - this.estimateGlobalStrength(this.player);
            return totalInfluenceInOwnStars + globalStrengthDifference;
        };
        MapEvaluator.prototype.getPerceivedThreatOfAllKnownPlayers = function () {
            var _this = this;
            var byPlayer = new ValuesByPlayer_2.default();
            this.player.diplomacyStatus.getMetPlayers().filter(function (player) { return !player.isDead; }).forEach(function (player) {
                byPlayer.set(player, _this.getPerceivedThreatOfPlayer(player));
            });
            return byPlayer;
        };
        MapEvaluator.prototype.getRelativePerceivedThreatOfAllKnownPlayers = function () {
            var byPlayer = this.getPerceivedThreatOfAllKnownPlayers();
            var relative = new ValuesByPlayer_2.default();
            var min, max;
            byPlayer.forEach(function (player, threat) {
                min = isFinite(min) ? Math.min(min, threat) : threat;
                max = isFinite(max) ? Math.max(max, threat) : threat;
            });
            byPlayer.forEach(function (player, threat) {
                relative.set(player, utility_49.getRelativeValue(threat, min, max));
            });
            return relative;
        };
        MapEvaluator.prototype.getVisionCoverageAroundStar = function (star, range, useDetection) {
            if (useDetection === void 0) { useDetection = false; }
            var toCheck = star.getLinkedInRange(range).all;
            var scorePerVisibleStar = 1 / toCheck.length;
            var coverageScore = 0;
            var visibilityCheckFN = useDetection ? this.player.starIsDetected : this.player.starIsVisible;
            for (var i = 0; i < toCheck.length; i++) {
                var neighbor = toCheck[i];
                if (visibilityCheckFN.call(this.player, neighbor)) {
                    coverageScore += scorePerVisibleStar;
                }
            }
            return coverageScore;
        };
        MapEvaluator.prototype.estimateFleetVisionRange = function (fleet) {
            var _this = this;
            var fleetLikelyHasScoutingUnit = fleet.units.length >= 5;
            var estimatedRange = fleetLikelyHasScoutingUnit ? 2 : 1;
            fleet.units.forEach(function (unit) {
                if (_this.player.unitIsIdentified(unit)) {
                    estimatedRange = Math.max(estimatedRange, unit.getVisionRange());
                }
            });
            return estimatedRange;
        };
        MapEvaluator.prototype.estimateFleetDetectionRange = function (fleet) {
            var _this = this;
            var fleetLikelyHasScoutingUnit = fleet.units.length >= 5;
            var estimatedRange = fleetLikelyHasScoutingUnit ? 0 : -1;
            fleet.units.forEach(function (unit) {
                if (_this.player.unitIsIdentified(unit)) {
                    estimatedRange = Math.max(estimatedRange, unit.getDetectionRange());
                }
            });
            return estimatedRange;
        };
        MapEvaluator.prototype.getPlayerVisionMap = function (player) {
            var detectedStars = {};
            var visibleStars = {};
            var revealedStarsOfPlayer = this.player.getRevealedStars().filter(function (star) {
                return star.owner === player;
            });
            var visibleFleetsOfPlayer = this.getVisibleFleetsOfPlayer(player);
            var processDetectionSource = function (source, detectionRange, visionRange) {
                var detected = source.getLinkedInRange(detectionRange).all;
                for (var i = 0; i < detected.length; i++) {
                    var star = detected[i];
                    if (!detectedStars[star.id]) {
                        detectedStars[star.id] = star;
                    }
                }
                var visible = source.getLinkedInRange(visionRange).all;
                for (var i = 0; i < visible.length; i++) {
                    var star = visible[i];
                    if (!visibleStars[star.id]) {
                        visibleStars[star.id] = star;
                    }
                }
            };
            for (var i = 0; i < revealedStarsOfPlayer.length; i++) {
                var star = revealedStarsOfPlayer[i];
                var detectionRange = this.player.starIsDetected(star) ? star.getDetectionRange() : 0;
                var visionRange = this.player.starIsDetected(star) ? star.getVisionRange() : 1;
                processDetectionSource(star, detectionRange, visionRange);
            }
            for (var i = 0; i < visibleFleetsOfPlayer.length; i++) {
                var fleet = visibleFleetsOfPlayer[i];
                var detectionRange = this.estimateFleetDetectionRange(fleet);
                var visionRange = this.estimateFleetVisionRange(fleet);
                processDetectionSource(fleet.location, detectionRange, visionRange);
            }
            return ({
                visible: visibleStars,
                detected: detectedStars,
            });
        };
        MapEvaluator.prototype.getScoredPerimeterLocationsAgainstPlayer = function (player, safetyFactor, forScouting) {
            var _this = this;
            var ownInfluence = this.getPlayerInfluenceMap(this.player);
            var enemyInfluence = this.getPlayerInfluenceMap(player);
            var enemyVision = this.getPlayerVisionMap(player);
            var revealedStars = this.player.getRevealedStars();
            var stars = revealedStars.filter(function (star) {
                return star.owner.isIndependent || star.owner === _this.player;
            });
            var scores = new ValuesByStar_2.default(stars, function (star) {
                var score;
                var nearestOwnedStar = player.getNearestOwnedStarTo(star);
                var distanceToEnemy = star.getDistanceToStar(nearestOwnedStar);
                distanceToEnemy = Math.max(distanceToEnemy - 1, 1);
                var distanceScore = Math.pow(1 / distanceToEnemy, 2);
                var danger = enemyInfluence.get(star) || 1;
                if (!enemyVision.visible[star.id]) {
                    danger *= 0.5;
                }
                danger *= safetyFactor;
                if (forScouting) {
                    var safety = ownInfluence.get(star) / (danger * safetyFactor);
                    score = safety * distanceScore;
                }
                else {
                    score = (danger / ownInfluence.get(star)) / safetyFactor;
                }
                return score;
            });
            return scores;
        };
        MapEvaluator.prototype.getDesireToGoToWarWith = function (player) {
            return Math.random();
        };
        MapEvaluator.prototype.getAbilityToGoToWarWith = function (player) {
            return Math.random();
        };
        MapEvaluator.prototype.getDiplomacyEvaluations = function (currentTurn) {
            var _this = this;
            var evaluations = new ValuesByPlayer_2.default();
            var neighborStarsByPlayer = new ValuesByPlayer_2.default();
            this.player.getNeighboringStars().forEach(function (star) {
                neighborStarsByPlayer.setIfDoesntExist(star.owner, []);
                neighborStarsByPlayer.get(star.owner).push(star);
            });
            this.player.diplomacyStatus.getMetPlayers().filter(function (player) { return !player.isDead; }).forEach(function (player) {
                neighborStarsByPlayer.setIfDoesntExist(player, []);
                evaluations.set(player, {
                    currentTurn: currentTurn,
                    opinion: _this.player.diplomacyStatus.getOpinionOf(player),
                    neighborStars: neighborStarsByPlayer.get(player).length,
                    currentStatus: _this.player.diplomacyStatus.statusByPlayer.get(player),
                });
            });
            return evaluations;
        };
        return MapEvaluator;
    }());
    exports.default = MapEvaluator;
});
define("modules/defaultai/mapai/DiplomacyAI", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DiplomacyAI = (function () {
        function DiplomacyAI(mapEvaluator, game) {
            this.game = game;
            this.player = mapEvaluator.player;
            this.diplomacyStatus = this.player.diplomacyStatus;
            this.mapEvaluator = mapEvaluator;
        }
        DiplomacyAI.prototype.setAttitudes = function () {
            var _this = this;
            var diplomacyEvaluations = this.mapEvaluator.getDiplomacyEvaluations(this.game.turnNumber);
            diplomacyEvaluations.forEach(function (player, evaluation) {
                _this.diplomacyStatus.processAttitudeModifiersForPlayer(player, evaluation);
            });
        };
        return DiplomacyAI;
    }());
    exports.default = DiplomacyAI;
});
define("modules/defaultai/mapai/tradeEvaluationFunctions", ["require", "exports", "src/Trade"], function (require, exports, Trade_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function evaluateValueOfOffer(offeredTrade) {
        var value = 0;
        for (var key in offeredTrade.stagedItems) {
            var item = offeredTrade.stagedItems[key];
            value += evaluateTradeableItemValue(item);
        }
        return value;
    }
    exports.evaluateValueOfOffer = evaluateValueOfOffer;
    function evaluateTradeableItemValue(item) {
        switch (item.type) {
            case Trade_2.TradeableItemType.Money:
                {
                    return item.amount;
                }
            default:
                {
                    throw new Error("Unrecognized trade item " + item + ".");
                }
        }
    }
    exports.evaluateTradeableItemValue = evaluateTradeableItemValue;
});
define("modules/defaultai/localization/en/tradeMessages", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tradeMessages = {
        requestOffer: [
            "Please make an offer.",
            "What do you propose?",
        ],
        willingToAcceptOffer: [
            "Seems good to me.",
        ],
        notWillingToAcceptOffer: [
            "That won't work for us.",
            "We can't do that.",
        ],
        proposeOffer: [
            "How does this sound?",
            "Here's my offer.",
        ],
        acceptOffer: [
            "We accept your terms.",
            "Looks fair. We accept.",
        ],
        willingToAcceptGift: [
            "How generous. We'll gladly accept.",
        ],
        notWillingToAcceptDemand: [
            "Over my dead body.",
        ],
    };
});
define("modules/defaultai/localization/localize", ["require", "exports", "src/localization/Localizer"], function (require, exports, Localizer_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.localizer = new Localizer_2.Localizer("tradeMessages");
    exports.localize = exports.localizer.localize.bind(exports.localizer);
});
define("modules/defaultai/mapai/EconomicAI", ["require", "exports", "modules/defaultai/mapai/tradeEvaluationFunctions", "modules/defaultai/localization/localize"], function (require, exports, tradeEvaluationFunctions_1, localize_67) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var EconomicAI = (function () {
        function EconomicAI() {
        }
        EconomicAI.prototype.respondToTradeOffer = function (incomingResponse) {
            var receivedOffer = incomingResponse.proposedReceivedOffer;
            var ownTrade = incomingResponse.proposedOwnTrade;
            var offeredValue = tradeEvaluationFunctions_1.evaluateValueOfOffer(receivedOffer);
            var ownValue = tradeEvaluationFunctions_1.evaluateValueOfOffer(ownTrade);
            if (offeredValue === 0 && ownValue === 0) {
                return ({
                    proposedOwnTrade: ownTrade.clone(),
                    proposedReceivedOffer: receivedOffer.clone(),
                    willingnessToTradeItems: this.getWillingnessToTradeItems(ownTrade),
                    message: localize_67.localize("requestOffer").format(),
                    willingToAccept: false,
                });
            }
            else if (offeredValue === 0) {
                return this.respondToDemand(receivedOffer, ownTrade);
            }
            else if (ownValue === 0) {
                return this.respondToGift(receivedOffer, ownTrade);
            }
            var valueRatio = offeredValue / ownValue;
            var isFavourable = valueRatio > 1;
            var valueRatioDifference = Math.abs(1 - valueRatio);
            var willingToAccept = isFavourable || valueRatioDifference < 0.04;
            var message = willingToAccept ?
                localize_67.localize("willingToAcceptOffer").format() :
                localize_67.localize("notWillingToAcceptOffer").format();
            return ({
                proposedOwnTrade: ownTrade.clone(),
                proposedReceivedOffer: receivedOffer.clone(),
                willingnessToTradeItems: this.getWillingnessToTradeItems(ownTrade),
                message: message,
                willingToAccept: willingToAccept,
            });
        };
        EconomicAI.prototype.respondToDemand = function (receivedOffer, ownTrade) {
            return ({
                proposedOwnTrade: ownTrade.clone(),
                proposedReceivedOffer: receivedOffer.clone(),
                willingnessToTradeItems: this.getWillingnessToTradeItems(ownTrade),
                message: localize_67.localize("notWillingToAcceptDemand").format(),
                willingToAccept: false,
            });
        };
        EconomicAI.prototype.respondToGift = function (receivedOffer, ownTrade) {
            return ({
                proposedOwnTrade: ownTrade.clone(),
                proposedReceivedOffer: receivedOffer.clone(),
                willingnessToTradeItems: this.getWillingnessToTradeItems(ownTrade),
                message: localize_67.localize("willingToAcceptGift").format(),
                willingToAccept: true,
            });
        };
        EconomicAI.prototype.getWillingnessToTradeItems = function (ownTrade) {
            var willingnessPerItem = {};
            for (var key in ownTrade.allItems) {
                willingnessPerItem[key] = 1;
            }
            return willingnessPerItem;
        };
        return EconomicAI;
    }());
    exports.EconomicAI = EconomicAI;
});
define("src/ValuesByUnit", ["require", "exports", "src/IdDictionary"], function (require, exports, IdDictionary_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ValuesByUnit = (function (_super) {
        __extends(ValuesByUnit, _super);
        function ValuesByUnit(units, getValueFN) {
            return _super.call(this, units, getValueFN) || this;
        }
        return ValuesByUnit;
    }(IdDictionary_4.IdDictionary));
    exports.default = ValuesByUnit;
});
define("modules/common/attachedUnitData", ["require", "exports", "src/ValuesByUnit", "src/utility"], function (require, exports, ValuesByUnit_1, utility_50) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AttachedUnitDataManager = (function () {
        function AttachedUnitDataManager() {
            this.byUnit = new ValuesByUnit_1.default();
        }
        AttachedUnitDataManager.prototype.get = function (unit) {
            if (!this.byUnit.has(unit)) {
                this.byUnit.set(unit, {});
            }
            return this.byUnit.get(unit);
        };
        AttachedUnitDataManager.prototype.set = function (unit, data) {
            if (this.byUnit.has(unit)) {
                var oldData = this.byUnit.get(unit);
                var mergedData = utility_50.shallowExtend(oldData, data);
                this.byUnit.set(unit, mergedData);
            }
            else {
                this.byUnit.set(unit, data);
            }
        };
        AttachedUnitDataManager.prototype.delete = function (unit) {
            this.byUnit.delete(unit);
        };
        AttachedUnitDataManager.prototype.deleteAll = function () {
            this.byUnit = new ValuesByUnit_1.default();
        };
        return AttachedUnitDataManager;
    }());
    var attachedUnitData = new AttachedUnitDataManager();
    exports.default = attachedUnitData;
    exports.attachedUnitDataScripts = {
        unit: {
            removeFromPlayer: [
                {
                    key: "removeFromFront",
                    priority: 0,
                    script: function (unit) {
                        var front = attachedUnitData.get(unit).front;
                        if (front) {
                            front.removeUnit(unit);
                        }
                        attachedUnitData.delete(unit);
                    },
                },
            ],
        },
    };
});
define("modules/defaultai/mapai/Front", ["require", "exports", "src/Fleet", "modules/common/attachedUnitData"], function (require, exports, Fleet_4, attachedUnitData_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Front = (function () {
        function Front(id, units) {
            this.id = id;
            this.units = units || [];
        }
        Front.prototype.destroy = function () {
            this.units.forEach(function (unit) {
                attachedUnitData_1.default.get(unit).front = null;
            });
        };
        Front.prototype.addUnit = function (unit) {
            var unitData = attachedUnitData_1.default.get(unit);
            if (unitData.front) {
                unitData.front.removeUnit(unit);
            }
            unitData.front = this;
            this.units.push(unit);
        };
        Front.prototype.removeUnit = function (unit) {
            attachedUnitData_1.default.get(unit).front = null;
            var unitIndex = this.getUnitIndex(unit);
            this.units.splice(unitIndex, 1);
        };
        Front.prototype.getUnitsByLocation = function (units) {
            if (units === void 0) { units = this.units; }
            var byLocation = {};
            units.forEach(function (unit) {
                var star = unit.fleet.location;
                if (!byLocation[star.id]) {
                    byLocation[star.id] = [];
                }
                byLocation[star.id].push(unit);
            });
            return byLocation;
        };
        Front.prototype.getFleetsByLocation = function (fleets) {
            if (fleets === void 0) { fleets = this.getAssociatedFleets(); }
            var byLocation = {};
            fleets.forEach(function (fleet) {
                var star = fleet.location;
                if (!byLocation[star.id]) {
                    byLocation[star.id] = [];
                }
                byLocation[star.id].push(fleet);
            });
            return byLocation;
        };
        Front.prototype.getAssociatedFleets = function () {
            var fleetsById = {};
            for (var i = 0; i < this.units.length; i++) {
                if (!this.units[i].fleet) {
                    continue;
                }
                if (!fleetsById[this.units[i].fleet.id]) {
                    fleetsById[this.units[i].fleet.id] = this.units[i].fleet;
                }
            }
            var allFleets = [];
            for (var fleetId in fleetsById) {
                allFleets.push(fleetsById[fleetId]);
            }
            return allFleets;
        };
        Front.prototype.organizeAllFleets = function () {
            this.organizeFleets(this.getAssociatedFleets().filter(function (fleet) { return !fleet.isStealthy; }), this.units.filter(function (unit) { return !unit.isStealthy(); }));
            this.organizeFleets(this.getAssociatedFleets().filter(function (fleet) { return fleet.isStealthy; }), this.units.filter(function (unit) { return unit.isStealthy(); }));
        };
        Front.prototype.hasUnit = function (unit) {
            return this.getUnitIndex(unit) !== -1;
        };
        Front.prototype.getUnitCountByArchetype = function () {
            var unitCountByArchetype = {};
            for (var i = 0; i < this.units.length; i++) {
                var archetype = this.units[i].template.archetype;
                if (!unitCountByArchetype[archetype.type]) {
                    unitCountByArchetype[archetype.type] = 0;
                }
                unitCountByArchetype[archetype.type]++;
            }
            return unitCountByArchetype;
        };
        Front.prototype.organizeFleets = function (fleetsToOrganize, unitsToOrganize) {
            var _this = this;
            var pureFleetsBeforeMerge = fleetsToOrganize.filter(function (fleet) { return _this.isFleetPure(fleet); });
            this.mergeFleetsWithSharedLocation(pureFleetsBeforeMerge);
            var pureFleets = pureFleetsBeforeMerge.filter(function (fleet) { return fleet.units.length > 0; });
            var unitsInImpureFleets = this.getUnitsInImpureFleets(unitsToOrganize);
            var pureFleetsByLocation = this.getFleetsByLocation(pureFleets);
            var impureUnitsByLocation = this.getUnitsByLocation(unitsInImpureFleets);
            var _loop_8 = function (locationId) {
                if (pureFleetsByLocation[locationId]) {
                    var fleet_2 = pureFleetsByLocation[locationId][0];
                    impureUnitsByLocation[locationId].forEach(function (unitToTransfer) {
                        var fleetToTransferFrom = unitToTransfer.fleet;
                        fleetToTransferFrom.transferUnit(fleet_2, unitToTransfer);
                        if (fleetToTransferFrom.units.length <= 0) {
                            fleetToTransferFrom.deleteFleet();
                        }
                    });
                    delete impureUnitsByLocation[locationId];
                }
            };
            for (var locationId in impureUnitsByLocation) {
                _loop_8(locationId);
            }
            var _loop_9 = function (locationId) {
                var units = impureUnitsByLocation[locationId];
                var player = units[0].fleet.player;
                var location_2 = units[0].fleet.location;
                units.forEach(function (unitToRemove) {
                    unitToRemove.fleet.removeUnit(unitToRemove);
                });
                var fleets = Fleet_4.Fleet.createFleetsFromUnits(units);
                fleets.forEach(function (fleet) {
                    player.addFleet(fleet);
                    location_2.addFleet(fleet);
                });
            };
            for (var locationId in impureUnitsByLocation) {
                _loop_9(locationId);
            }
        };
        Front.prototype.isFleetPure = function (fleet) {
            var _this = this;
            return fleet.units.every(function (unit) { return _this.hasUnit(unit); });
        };
        Front.prototype.getUnitIndex = function (unit) {
            return this.units.indexOf(unit);
        };
        Front.prototype.mergeFleetsWithSharedLocation = function (fleetsToMerge) {
            var fleetsByLocationId = this.getFleetsByLocation(fleetsToMerge);
            for (var locationId in fleetsByLocationId) {
                var fleetsAtLocation = fleetsByLocationId[locationId].sort(Fleet_4.Fleet.sortByImportance);
                for (var i = fleetsAtLocation.length - 1; i >= 1; i--) {
                    fleetsAtLocation[i].mergeWith(fleetsAtLocation[0]);
                }
            }
        };
        Front.prototype.getUnitsInImpureFleets = function (units) {
            var _this = this;
            var fleetPurityById = {};
            return units.filter(function (unit) {
                if (fleetPurityById.hasOwnProperty("" + unit.fleet.id)) {
                    return !fleetPurityById[unit.fleet.id];
                }
                else {
                    var fleetIsPure = _this.isFleetPure(unit.fleet);
                    fleetPurityById[unit.fleet.id] = fleetIsPure;
                    return !fleetIsPure;
                }
            });
        };
        return Front;
    }());
    exports.Front = Front;
});
define("modules/defaultai/mapai/GrandStrategyAI", ["require", "exports", "src/Star", "src/utility"], function (require, exports, Star_3, utility_51) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var GrandStrategyAI = (function () {
        function GrandStrategyAI(personality, mapEvaluator, game) {
            this.personality = personality;
            this.mapEvaluator = mapEvaluator;
            this.game = game;
        }
        GrandStrategyAI.prototype.setDesires = function () {
            this.desireForExpansion = this.getDesireForExpansion();
            this.desireForWar = this.getDesireForWar();
            this.desireForConsolidation = 0.4 + 0.6 * (1 - this.desireForExpansion);
            this.desireForExploration = this.getDesireForExploration();
        };
        GrandStrategyAI.prototype.setDesiredStars = function () {
            var totalStarsInMap = this.mapEvaluator.map.stars.length;
            var majorPlayersCount = this.game.getLiveMajorPlayers().length;
            var starsPerPlayer = totalStarsInMap / majorPlayersCount;
            var baseMinStarsDesired = starsPerPlayer * 0.34;
            var baseMaxStarsDesired = starsPerPlayer;
            var extraMinStarsDesired = this.personality.expansiveness * (starsPerPlayer * 0.66);
            var extraMaxStarsDesired = this.personality.expansiveness * (starsPerPlayer * (majorPlayersCount / 4));
            var minStarsDesired = baseMinStarsDesired + extraMinStarsDesired;
            var maxStarsDesired = baseMaxStarsDesired + extraMaxStarsDesired;
            this.desiredStars =
                {
                    min: minStarsDesired,
                    max: maxStarsDesired,
                };
        };
        GrandStrategyAI.prototype.getDesireForExpansion = function () {
            if (!this.desiredStars) {
                this.setDesiredStars();
            }
            var starsOwned = this.mapEvaluator.player.controlledLocations.length;
            var desire = 1 - utility_51.getRelativeValue(starsOwned, this.desiredStars.min, this.desiredStars.max);
            return utility_51.clamp(desire, 0.1, 1);
        };
        GrandStrategyAI.prototype.getDesireForExploration = function () {
            var _this = this;
            var percentageOfUnrevealedStars = 1 -
                this.mapEvaluator.player.getRevealedStars().length / this.mapEvaluator.map.stars.length;
            var surroundingStars = Star_3.default.getIslandForQualifier(this.mapEvaluator.player.controlledLocations, null, function (parent, candidate) {
                var nearestOwnedStar = _this.mapEvaluator.player.getNearestOwnedStarTo(candidate);
                return candidate.getDistanceToStar(nearestOwnedStar) <= 2;
            });
            var unrevealedSurroundingStars = surroundingStars.filter(function (star) {
                return !_this.mapEvaluator.player.revealedStars[star.id];
            });
            var percentageOfUnrevealedSurroundingStars = unrevealedSurroundingStars.length / surroundingStars.length;
            return percentageOfUnrevealedSurroundingStars * 0.8 + percentageOfUnrevealedStars * 0.2;
        };
        GrandStrategyAI.prototype.getDesireForWar = function () {
            if (!this.desiredStars) {
                this.setDesiredStars();
            }
            var fromAggressiveness = this.personality.aggressiveness;
            var fromExpansiveness = 0;
            var minStarsStillDesired = this.mapEvaluator.player.controlledLocations.length - this.desiredStars.min;
            var availableExpansionTargets = this.mapEvaluator.getIndependentNeighborStarIslands(minStarsStillDesired);
            if (availableExpansionTargets.length < minStarsStillDesired) {
                fromExpansiveness += this.personality.expansiveness / (1 + availableExpansionTargets.length);
            }
            var desire = fromAggressiveness + fromExpansiveness;
            return utility_51.clamp(desire, 0, 1);
        };
        return GrandStrategyAI;
    }());
    exports.GrandStrategyAI = GrandStrategyAI;
});
define("modules/defaultai/objectives/common/ObjectiveFamily", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ObjectiveFamily;
    (function (ObjectiveFamily) {
        ObjectiveFamily[ObjectiveFamily["Diplomatic"] = 0] = "Diplomatic";
        ObjectiveFamily[ObjectiveFamily["Economic"] = 1] = "Economic";
        ObjectiveFamily[ObjectiveFamily["Front"] = 2] = "Front";
    })(ObjectiveFamily = exports.ObjectiveFamily || (exports.ObjectiveFamily = {}));
});
define("modules/defaultai/objectives/common/Objective", ["require", "exports", "src/IdDictionary", "src/idGenerators"], function (require, exports, IdDictionary_5, idGenerators_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Objective = (function () {
        function Objective(score) {
            this.isOngoing = false;
            this.ongoingMultiplier = 1.25;
            this.id = idGenerators_9.default.objective++;
            this.score = score;
        }
        Object.defineProperty(Objective.prototype, "score", {
            get: function () {
                return this.isOngoing ? this.baseScore * this.ongoingMultiplier : this.baseScore;
            },
            set: function (score) {
                this.baseScore = score;
            },
            enumerable: true,
            configurable: true
        });
        Objective.makeCreatorTemplate = function () {
            var _this = this;
            [
                { member: this.type, memberIdentifier: "type" },
                { member: this.family, memberIdentifier: "family" },
                { member: this.createObjectives, memberIdentifier: "createObjectives" },
                { member: this.updateOngoingObjectivesList, memberIdentifier: "updateOngoingObjectivesList" },
                { member: this.evaluatePriority, memberIdentifier: "evaluatePriority" },
            ].forEach(function (toCheck) {
                if (toCheck.member === undefined) {
                    throw new Error("Objective " + (_this.type || _this) + " lacks required static member " + toCheck.memberIdentifier);
                }
            });
            return ({
                type: this.type,
                family: this.family,
                getUpdatedObjectivesList: function (mapEvaluator, allOngoingObjectives) {
                    var createdObjectives = _this.createObjectives(mapEvaluator, allOngoingObjectives);
                    return _this.updateOngoingObjectivesList(allOngoingObjectives, createdObjectives);
                },
                evaluatePriority: this.evaluatePriority.bind(this),
            });
        };
        Objective.getObjectivesByTarget = function (objectives) {
            var byTarget = new IdDictionary_5.IdDictionary();
            objectives.forEach(function (objective) {
                if (byTarget.has(objective.target)) {
                    throw new Error("Duplicate target id:'" + objective.target.id + "' for objectives of type '" + objective.type + "'");
                }
                else {
                    byTarget.set(objective.target, objective);
                }
            });
            return byTarget;
        };
        Objective.updateTargetedObjectives = function (allOngoingObjectives, createdObjectives) {
            var _this = this;
            var resultingObjectives = [];
            var createdObjectivesByTarget = Objective.getObjectivesByTarget(createdObjectives);
            allOngoingObjectives.forEach(function (objective) {
                if (objective.type === _this.type) {
                    if (createdObjectivesByTarget.has(objective.target)) {
                        var createdObjective = createdObjectivesByTarget.get(objective.target);
                        objective.score = createdObjective.score;
                        objective.isOngoing = true;
                        resultingObjectives.push(objective);
                        createdObjectivesByTarget.delete(objective.target);
                    }
                    else {
                    }
                }
                else {
                    resultingObjectives.push(objective);
                }
            });
            createdObjectivesByTarget.forEach(function (target, objective) {
                resultingObjectives.push(objective);
            });
            return resultingObjectives;
        };
        Objective.updateUniqueObjective = function (allOngoingObjectives, createdObjective) {
            for (var i = 0; i < allOngoingObjectives.length; i++) {
                var objective = allOngoingObjectives[i];
                if (objective.type === createdObjective.type) {
                    objective.score = createdObjective.score;
                    return allOngoingObjectives;
                }
            }
            allOngoingObjectives.push(createdObjective);
            return allOngoingObjectives;
        };
        Objective.replaceObjectives = function (allOngoingObjectives, createdObjectives) {
            var _this = this;
            var resultingObjectives = allOngoingObjectives.filter(function (objective) {
                return objective.type !== _this.type;
            });
            resultingObjectives.push.apply(resultingObjectives, createdObjectives);
            return resultingObjectives;
        };
        return Objective;
    }());
    exports.Objective = Objective;
});
define("modules/defaultai/mapai/ObjectiveQueue", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ObjectiveQueue = (function () {
        function ObjectiveQueue() {
            this.objectivesToExecute = [];
        }
        ObjectiveQueue.sortByFinalPriority = function (a, b) {
            return b.finalPriority - a.finalPriority;
        };
        ObjectiveQueue.prototype.executeObjectives = function (objectivesToExecute, onAllFinished) {
            this.objectivesToExecute = objectivesToExecute;
            this.onAllFinished = onAllFinished;
            this.executeNextObjective();
        };
        ObjectiveQueue.prototype.executeNextObjective = function () {
            this.currentObjective = this.objectivesToExecute.shift();
            console.log("execute", this.currentObjective);
            this.clearExecutionFailureTimeout();
            if (!this.currentObjective) {
                this.onAllFinished();
                return;
            }
            this.setExecutionFailureTimeout();
            this.currentObjective.execute(this.executeNextObjective.bind(this));
        };
        ObjectiveQueue.prototype.setExecutionFailureTimeout = function (delay) {
            var _this = this;
            if (delay === void 0) { delay = 5000; }
            this.executionFailureTimeoutHandle = window.setTimeout(function () {
                console.warn("Objective of type " + _this.currentObjective.type + " failed to trigger finish callback for objective execution after " + delay + "ms");
                _this.clearExecutionFailureTimeout();
            }, delay);
        };
        ObjectiveQueue.prototype.clearExecutionFailureTimeout = function () {
            window.clearTimeout(this.executionFailureTimeoutHandle);
            this.executionFailureTimeoutHandle = null;
        };
        return ObjectiveQueue;
    }());
    exports.ObjectiveQueue = ObjectiveQueue;
});
define("modules/defaultai/objectives/common/EconomicObjective", ["require", "exports", "modules/defaultai/objectives/common/Objective", "modules/defaultai/objectives/common/ObjectiveFamily"], function (require, exports, Objective_1, ObjectiveFamily_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var EconomicObjective = (function (_super) {
        __extends(EconomicObjective, _super);
        function EconomicObjective(priority) {
            var _this = _super.call(this, priority) || this;
            _this.family = ObjectiveFamily_1.ObjectiveFamily.Economic;
            return _this;
        }
        EconomicObjective.family = ObjectiveFamily_1.ObjectiveFamily.Economic;
        return EconomicObjective;
    }(Objective_1.Objective));
    exports.EconomicObjective = EconomicObjective;
});
define("modules/defaultai/objectives/common/FrontObjective", ["require", "exports", "modules/defaultai/objectives/common/Objective", "modules/defaultai/objectives/common/ObjectiveFamily", "modules/defaultai/mapai/Front"], function (require, exports, Objective_2, ObjectiveFamily_2, Front_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var frontIdGenerator = 0;
    var FrontObjective = (function (_super) {
        __extends(FrontObjective, _super);
        function FrontObjective(score, mapEvaluator, unitEvaluator) {
            var _this = _super.call(this, score) || this;
            _this.family = ObjectiveFamily_2.ObjectiveFamily.Front;
            _this.front = new Front_1.Front(frontIdGenerator++);
            _this.mapEvaluator = mapEvaluator;
            _this.unitEvaluator = unitEvaluator;
            return _this;
        }
        FrontObjective.prototype.evaluateCurrentCombatStrength = function () {
            return (_a = this.unitEvaluator).evaluateCombatStrength.apply(_a, this.front.units);
            var _a;
        };
        FrontObjective.prototype.getRallyPoint = function () {
            return this.mapEvaluator.player.controlledLocations[0];
        };
        FrontObjective.family = ObjectiveFamily_2.ObjectiveFamily.Front;
        return FrontObjective;
    }(Objective_2.Objective));
    exports.FrontObjective = FrontObjective;
});
define("modules/defaultai/objectives/BuildUnitsForFront", ["require", "exports", "modules/defaultai/objectives/common/EconomicObjective", "modules/defaultai/objectives/common/ObjectiveFamily", "src/utility"], function (require, exports, EconomicObjective_1, ObjectiveFamily_3, utility_52) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BuildUnitsForFront = (function (_super) {
        __extends(BuildUnitsForFront, _super);
        function BuildUnitsForFront(objective, player) {
            var _this = _super.call(this, objective.finalPriority) || this;
            _this.type = "BuildUnitsForFront";
            _this.ongoingMultiplier = 1;
            _this.objective = objective;
            _this.player = player;
            return _this;
        }
        BuildUnitsForFront.createObjectives = function (mapEvaluator, allOngoingObjectives) {
            var frontObjectives = allOngoingObjectives.filter(function (objective) {
                return objective.family === ObjectiveFamily_3.ObjectiveFamily.Front;
            });
            var frontObjectivesRequestingUnits = frontObjectives.filter(function (objective) {
                return objective.evaluateCurrentCombatStrength() < objective.getIdealRequiredCombatStrength();
            });
            return frontObjectivesRequestingUnits.map(function (objective) {
                return new BuildUnitsForFront(objective, mapEvaluator.player);
            });
        };
        BuildUnitsForFront.evaluatePriority = function (mapEvaluator, grandStrategyAI) {
            return 0.66;
        };
        BuildUnitsForFront.updateOngoingObjectivesList = function (allOngoingObjectives, createdObjectives) {
            return this.replaceObjectives(allOngoingObjectives, createdObjectives);
        };
        BuildUnitsForFront.prototype.execute = function (afterDoneCallback) {
            var _this = this;
            var manufactoryLocation = this.objective.getRallyPoint().getNearestStarForQualifier(function (location) {
                return location.owner === _this.player && location.manufactory && !location.manufactory.queueIsFull();
            });
            if (!manufactoryLocation) {
                afterDoneCallback();
                return;
            }
            var manufactory = manufactoryLocation.manufactory;
            var unitType = utility_52.getRandomArrayItem(manufactory.getManufacturableThingsForType("unit"));
            if (this.player.money >= unitType.buildCost) {
                manufactory.addThingToQueue(unitType, "unit");
            }
            afterDoneCallback();
        };
        BuildUnitsForFront.type = "BuildUnitsForFront";
        return BuildUnitsForFront;
    }(EconomicObjective_1.EconomicObjective));
    exports.BuildUnitsForFront = BuildUnitsForFront;
});
define("modules/defaultai/objectives/common/TargetedFrontObjective", ["require", "exports", "modules/defaultai/objectives/common/FrontObjective"], function (require, exports, FrontObjective_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TargetedFrontObjective = (function (_super) {
        __extends(TargetedFrontObjective, _super);
        function TargetedFrontObjective(score, target, mapEvaluator, unitEvaluator) {
            var _this = _super.call(this, score, mapEvaluator, unitEvaluator) || this;
            _this.hasMustered = false;
            _this.target = target;
            _this.musterLocation = mapEvaluator.player.getNearestOwnedStarTo(target);
            return _this;
        }
        TargetedFrontObjective.updateOngoingObjectivesList = function (allOngoingObjectives, createdObjectives) {
            return this.updateTargetedObjectives(allOngoingObjectives, createdObjectives);
        };
        TargetedFrontObjective.prototype.getRallyPoint = function () {
            return this.hasMustered ? this.target : this.musterLocation;
        };
        TargetedFrontObjective.prototype.evaluateDefaultUnitFit = function (unit, front, lowHealthThreshhold, healthAdjust, distanceAdjust) {
            if (lowHealthThreshhold === void 0) { lowHealthThreshhold = 0.75; }
            if (healthAdjust === void 0) { healthAdjust = 1; }
            if (distanceAdjust === void 0) { distanceAdjust = 1; }
            var score = 1;
            var healthPercentage = unit.currentHealth / unit.maxHealth;
            if (healthPercentage < lowHealthThreshhold) {
                score *= healthPercentage * healthAdjust;
            }
            var turnsToReach = unit.getTurnsToReachStar(this.target);
            if (turnsToReach > 0) {
                turnsToReach *= distanceAdjust;
                var distanceMultiplier = 1 / (Math.log(turnsToReach + 2.5) / Math.log(2.5));
                score *= distanceMultiplier;
            }
            if (this.front.hasUnit(unit)) {
                score *= 1.2;
                if (this.hasMustered) {
                    score *= 1.2;
                }
            }
            return score;
        };
        TargetedFrontObjective.prototype.musterAndAttack = function (afterMoveCallback, targetFilter) {
            var _this = this;
            var moveTarget = this.getMoveTarget();
            var fleets = this.front.getAssociatedFleets();
            if (fleets.length <= 0) {
                afterMoveCallback();
                return;
            }
            var finishAllMoveFN = function () {
                var unitsByLocation = _this.front.getUnitsByLocation();
                var strengthAtTarget = (_a = _this.unitEvaluator).evaluateCombatStrength.apply(_a, unitsByLocation[_this.target.id]);
                if (strengthAtTarget >= _this.getMinimumRequiredCombatStrength()) {
                    var targetLocation = _this.target;
                    var player = _this.mapEvaluator.player;
                    var attackTargets = targetLocation.getTargetsForPlayer(player);
                    var targetToAttack = targetFilter ?
                        attackTargets.filter(targetFilter)[0] :
                        attackTargets[0];
                    player.attackTarget(targetLocation, targetToAttack, afterMoveCallback);
                }
                else {
                    afterMoveCallback();
                }
                var _a;
            };
            var finishedMovingCount = 0;
            var finishFleetMoveFN = function () {
                finishedMovingCount++;
                if (finishedMovingCount >= fleets.length) {
                    finishAllMoveFN();
                }
            };
            for (var i = 0; i < fleets.length; i++) {
                fleets[i].pathFind(moveTarget, null, finishFleetMoveFN);
            }
        };
        TargetedFrontObjective.prototype.getMoveTarget = function () {
            var _this = this;
            var shouldMoveToTarget = false;
            var unitsByLocation = this.front.getUnitsByLocation();
            var fleets = this.front.getAssociatedFleets();
            if (this.hasMustered) {
                shouldMoveToTarget = true;
            }
            else {
                var minimumRequiredStrength = this.getMinimumRequiredCombatStrength();
                var strengthAtMuster = (_a = this.unitEvaluator).evaluateCombatStrength.apply(_a, unitsByLocation[this.musterLocation.id]);
                if (strengthAtMuster >= minimumRequiredStrength) {
                    this.hasMustered = true;
                    shouldMoveToTarget = true;
                }
                else {
                    var fleetsInRange = fleets.filter(function (fleet) { return fleet.hasEnoughMovePointsToMoveTo(_this.target); });
                    var strengthInRange = fleetsInRange.map(function (fleet) { return fleet.units; }).reduce(function (total, units) {
                        return total + (_a = _this.unitEvaluator).evaluateCombatStrength.apply(_a, units);
                        var _a;
                    }, 0);
                    if (strengthInRange >= minimumRequiredStrength) {
                        this.hasMustered = true;
                        shouldMoveToTarget = true;
                    }
                }
            }
            var moveTarget = shouldMoveToTarget ? this.target : this.musterLocation;
            return moveTarget;
            var _a;
        };
        return TargetedFrontObjective;
    }(FrontObjective_1.FrontObjective));
    exports.TargetedFrontObjective = TargetedFrontObjective;
});
define("modules/defaultai/objectives/common/movePriority", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var movePriority;
    (function (movePriority) {
        movePriority[movePriority["Discovery"] = 999] = "Discovery";
        movePriority[movePriority["ScoutingPerimeter"] = 8] = "ScoutingPerimeter";
        movePriority[movePriority["FightInvadingEnemy"] = 7] = "FightInvadingEnemy";
        movePriority[movePriority["Conquer"] = 6] = "Conquer";
        movePriority[movePriority["Expansion"] = 4] = "Expansion";
        movePriority[movePriority["CleanUpPirates"] = 3] = "CleanUpPirates";
        movePriority[movePriority["Heal"] = -1] = "Heal";
    })(movePriority = exports.movePriority || (exports.movePriority = {}));
});
define("modules/defaultai/objectives/CleanUpPirates", ["require", "exports", "modules/defaultai/objectives/common/TargetedFrontObjective", "modules/defaultai/objectives/common/movePriority"], function (require, exports, TargetedFrontObjective_1, movePriority_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CleanUpPirates = (function (_super) {
        __extends(CleanUpPirates, _super);
        function CleanUpPirates(score, target, mapEvaluator, unitEvaluator) {
            var _this = _super.call(this, score, target, mapEvaluator, unitEvaluator) || this;
            _this.type = "CleanUpPirates";
            _this.movePriority = movePriority_1.movePriority.CleanUpPirates;
            return _this;
        }
        CleanUpPirates.createObjectives = function (mapEvaluator, allOngoingObjectives) {
            var ownedStarsWithPirates = mapEvaluator.player.controlledLocations.filter(function (star) {
                if (star.getSecondaryController) {
                    return false;
                }
                else {
                    return star.getUnits(function (player) { return player.isIndependent; }).length > 0;
                }
            });
            var evaluations = mapEvaluator.evaluateStarTargets(ownedStarsWithPirates);
            var scores = mapEvaluator.scoreIndependentTargets(evaluations);
            return scores.mapToArray(function (star, score) {
                return new CleanUpPirates(score, star, mapEvaluator, mapEvaluator.unitEvaluator);
            });
        };
        CleanUpPirates.evaluatePriority = function (mapEvaluator, grandStrategyAI) {
            return grandStrategyAI.desireForConsolidation;
        };
        CleanUpPirates.prototype.execute = function (afterDoneCallback) {
            this.musterAndAttack(afterDoneCallback, function (target) {
                return target.enemy.isIndependent;
            });
        };
        CleanUpPirates.prototype.evaluateUnitFit = function (unit) {
            var strengthScore = this.unitEvaluator.evaluateCombatStrength(unit);
            return strengthScore * this.evaluateDefaultUnitFit(unit, this.front);
        };
        CleanUpPirates.prototype.getMinimumRequiredCombatStrength = function () {
            var enemyStrength = this.mapEvaluator.getIndependentStrengthAtStar(this.target);
            return enemyStrength * 1.5;
        };
        CleanUpPirates.prototype.getIdealRequiredCombatStrength = function () {
            var enemyStrength = this.mapEvaluator.getIndependentStrengthAtStar(this.target);
            return enemyStrength * 2;
        };
        CleanUpPirates.type = "CleanUpPirates";
        return CleanUpPirates;
    }(TargetedFrontObjective_1.TargetedFrontObjective));
    exports.CleanUpPirates = CleanUpPirates;
});
define("modules/defaultai/objectives/Conquer", ["require", "exports", "modules/defaultai/objectives/common/TargetedFrontObjective", "modules/defaultai/objectives/common/movePriority"], function (require, exports, TargetedFrontObjective_2, movePriority_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Conquer = (function (_super) {
        __extends(Conquer, _super);
        function Conquer(score, target, mapEvaluator, unitEvaluator) {
            var _this = _super.call(this, score, target, mapEvaluator, unitEvaluator) || this;
            _this.type = "Conquer";
            _this.movePriority = movePriority_2.movePriority.Conquer;
            return _this;
        }
        Conquer.createObjectives = function (mapEvaluator, allOngoingObjectives) {
            var possibleTargets = mapEvaluator.player.getNeighboringStars().filter(function (star) {
                if (star.owner.isIndependent) {
                    return false;
                }
                if (!mapEvaluator.player.starIsRevealed(star)) {
                    return false;
                }
                return star.hasBuildingTargetForPlayer(mapEvaluator.player);
            });
            var evaluations = mapEvaluator.evaluateStarTargets(possibleTargets);
            var scores = mapEvaluator.scoreStarTargets(evaluations, function (star, evaluation) {
                var strengthRatio = evaluation.ownInfluence / evaluation.hostileStrength;
                var score = evaluation.desirability * strengthRatio;
                return score;
            });
            return scores.mapToArray(function (star, score) {
                return new Conquer(score, star, mapEvaluator, mapEvaluator.unitEvaluator);
            });
        };
        Conquer.evaluatePriority = function (mapEvaluator, grandStrategyAI) {
            return grandStrategyAI.desireForExpansion;
        };
        Conquer.prototype.execute = function (afterDoneCallback) {
            this.musterAndAttack(afterDoneCallback, function (target) {
                return target.building && target.enemy === target.building.controller;
            });
        };
        Conquer.prototype.evaluateUnitFit = function (unit) {
            var strengthScore = this.unitEvaluator.evaluateCombatStrength(unit);
            return strengthScore * this.evaluateDefaultUnitFit(unit, this.front);
        };
        Conquer.prototype.getMinimumRequiredCombatStrength = function () {
            var enemyStrength = this.mapEvaluator.getHostileStrengthAtStar(this.target);
            return enemyStrength * 1.3;
        };
        Conquer.prototype.getIdealRequiredCombatStrength = function () {
            var enemyStrength = this.mapEvaluator.getHostileStrengthAtStar(this.target);
            return enemyStrength * 1.75;
        };
        Conquer.type = "Conquer";
        return Conquer;
    }(TargetedFrontObjective_2.TargetedFrontObjective));
    exports.Conquer = Conquer;
});
define("modules/defaultai/objectives/common/DiplomaticObjective", ["require", "exports", "modules/defaultai/objectives/common/Objective", "modules/defaultai/objectives/common/ObjectiveFamily"], function (require, exports, Objective_3, ObjectiveFamily_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DiplomaticObjective = (function (_super) {
        __extends(DiplomaticObjective, _super);
        function DiplomaticObjective(priority, diplomacyStatus) {
            var _this = _super.call(this, priority) || this;
            _this.family = ObjectiveFamily_4.ObjectiveFamily.Diplomatic;
            _this.diplomacyStatus = diplomacyStatus;
            return _this;
        }
        DiplomaticObjective.family = ObjectiveFamily_4.ObjectiveFamily.Diplomatic;
        return DiplomaticObjective;
    }(Objective_3.Objective));
    exports.DiplomaticObjective = DiplomaticObjective;
});
define("modules/defaultai/objectives/DeclareWar", ["require", "exports", "modules/defaultai/objectives/common/DiplomaticObjective"], function (require, exports, DiplomaticObjective_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DeclareWar = (function (_super) {
        __extends(DeclareWar, _super);
        function DeclareWar(score, target, diplomacyStatus) {
            var _this = _super.call(this, score, diplomacyStatus) || this;
            _this.type = "DeclareWar";
            _this.target = target;
            return _this;
        }
        DeclareWar.createObjectives = function (mapEvaluator, allOngoingObjectives) {
            var metNeighborPlayers = mapEvaluator.player.getNeighboringPlayers().filter(function (player) {
                return mapEvaluator.player.diplomacyStatus.hasMetPlayer(player);
            });
            var declarableNeighbors = metNeighborPlayers.filter(function (player) {
                return mapEvaluator.player.diplomacyStatus.canDeclareWarOn(player);
            });
            return declarableNeighbors.map(function (player) {
                var score = mapEvaluator.getDesireToGoToWarWith(player) *
                    mapEvaluator.getAbilityToGoToWarWith(player);
                return new DeclareWar(score, player, mapEvaluator.player.diplomacyStatus);
            });
        };
        DeclareWar.evaluatePriority = function (mapEvaluator, grandStrategyAI) {
            return grandStrategyAI.desireForWar;
        };
        DeclareWar.updateOngoingObjectivesList = function (allOngoingObjectives, createdObjectives) {
            return this.updateTargetedObjectives(allOngoingObjectives, createdObjectives);
        };
        DeclareWar.prototype.execute = function (afterDoneCallback) {
            this.diplomacyStatus.declareWarOn(this.target);
            afterDoneCallback();
        };
        DeclareWar.type = "DeclareWar";
        return DeclareWar;
    }(DiplomaticObjective_1.DiplomaticObjective));
    exports.DeclareWar = DeclareWar;
});
define("modules/defaultai/objectives/common/moveroutines/moveToTarget", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function moveToTarget(front, afterDoneCallback, getMoveTarget) {
        var fleets = front.getAssociatedFleets();
        if (fleets.length <= 0) {
            afterDoneCallback();
            return;
        }
        var finishedMovingCount = 0;
        var afterFleetMoveCallback = function () {
            finishedMovingCount++;
            if (finishedMovingCount >= fleets.length) {
                afterDoneCallback();
            }
        };
        fleets.forEach(function (fleet) {
            var moveTarget = getMoveTarget(fleet);
            fleet.pathFind(moveTarget, null, afterFleetMoveCallback);
        });
    }
    exports.moveToTarget = moveToTarget;
});
define("modules/defaultai/objectives/Discovery", ["require", "exports", "modules/defaultai/objectives/common/TargetedFrontObjective", "modules/defaultai/objectives/common/movePriority", "modules/defaultai/objectives/common/moveroutines/moveToTarget"], function (require, exports, TargetedFrontObjective_3, movePriority_3, moveToTarget_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Discovery = (function (_super) {
        __extends(Discovery, _super);
        function Discovery(score, target, mapEvaluator, unitEvaluator) {
            var _this = _super.call(this, score, target, mapEvaluator, unitEvaluator) || this;
            _this.type = "Discovery";
            _this.movePriority = movePriority_3.movePriority.Discovery;
            return _this;
        }
        Discovery.createObjectives = function (mapEvaluator, allOngoingObjectives) {
            var linksToUnRevealedStars = mapEvaluator.player.getLinksToUnRevealedStars();
            return linksToUnRevealedStars.mapToArray(function (targetStar, linkedStars) {
                var nearestOwnedStar = mapEvaluator.player.getNearestOwnedStarTo(targetStar);
                var distanceToNearestOwnedStar = nearestOwnedStar.getDistanceToStar(targetStar);
                var desirabilityScore = mapEvaluator.evaluateIndividualStarDesirability(targetStar);
                var linksMultiplier = linkedStars.length;
                var distanceMultiplier = 1 / distanceToNearestOwnedStar;
                var score = desirabilityScore * linksMultiplier * distanceMultiplier;
                return new Discovery(score, targetStar, mapEvaluator, mapEvaluator.unitEvaluator);
            });
        };
        Discovery.evaluatePriority = function (mapEvaluator, grandStrategyAI) {
            return grandStrategyAI.desireForExploration;
        };
        Discovery.prototype.execute = function (afterDoneCallback) {
            var _this = this;
            moveToTarget_1.moveToTarget(this.front, afterDoneCallback, function (fleet) {
                return _this.target;
            });
        };
        Discovery.prototype.evaluateUnitFit = function (unit) {
            var scoutingScore = this.unitEvaluator.evaluateUnitScoutingAbility(unit);
            var movementMultiplier = unit.maxMovePoints;
            var score = scoutingScore * movementMultiplier;
            return score * this.evaluateDefaultUnitFit(unit, this.front, 0, 0, 2);
        };
        Discovery.prototype.getMinimumRequiredCombatStrength = function () {
            return 0;
        };
        Discovery.prototype.getIdealRequiredCombatStrength = function () {
            return 0;
        };
        Discovery.type = "Discovery";
        return Discovery;
    }(TargetedFrontObjective_3.TargetedFrontObjective));
    exports.Discovery = Discovery;
});
define("modules/defaultai/objectives/ExpandManufactoryCapacity", ["require", "exports", "modules/defaultai/objectives/common/EconomicObjective", "src/Manufactory"], function (require, exports, EconomicObjective_2, Manufactory_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExpandManufactoryCapacity = (function (_super) {
        __extends(ExpandManufactoryCapacity, _super);
        function ExpandManufactoryCapacity(score, player, target) {
            var _this = _super.call(this, score) || this;
            _this.type = "ExpandManufactoryCapacity";
            _this.player = player;
            _this.target = target;
            return _this;
        }
        ExpandManufactoryCapacity.createObjectives = function (mapEvaluator, allOngoingObjectives) {
            var starsThatCanExpand = mapEvaluator.player.controlledLocations.filter(function (star) {
                return !star.manufactory || star.manufactory.capacity < star.manufactory.maxCapacity;
            });
            return starsThatCanExpand.map(function (star) {
                var upgradeScore = star.manufactory ?
                    1 * star.manufactory.unitStatsModifier * star.manufactory.unitHealthModifier :
                    1;
                var upgradeCost = ExpandManufactoryCapacity.getCostForStar(star);
                var costScore = Manufactory_3.default.getBuildCost() / upgradeCost;
                var score = costScore + Math.pow(upgradeScore, 2);
                return new ExpandManufactoryCapacity(score, mapEvaluator.player, star);
            });
        };
        ExpandManufactoryCapacity.evaluatePriority = function (mapEvaluator, grandStrategyAI) {
            return grandStrategyAI.desireForConsolidation;
        };
        ExpandManufactoryCapacity.updateOngoingObjectivesList = function (allOngoingObjectives, createdObjectives) {
            return this.updateTargetedObjectives(allOngoingObjectives, createdObjectives);
        };
        ExpandManufactoryCapacity.getCostForStar = function (star) {
            return star.manufactory ?
                star.manufactory.getCapacityUpgradeCost() :
                Manufactory_3.default.getBuildCost();
        };
        ExpandManufactoryCapacity.prototype.execute = function (afterDoneCallback) {
            var upgradeCost = ExpandManufactoryCapacity.getCostForStar(this.target);
            var canAffordUpgrade = upgradeCost <= this.player.money;
            if (canAffordUpgrade) {
                if (this.target.manufactory) {
                    this.target.manufactory.upgradeCapacity(1);
                }
                else {
                    this.target.buildManufactory();
                    this.player.money -= Manufactory_3.default.getBuildCost();
                }
            }
            afterDoneCallback();
        };
        ExpandManufactoryCapacity.type = "ExpandManufactoryCapacity";
        return ExpandManufactoryCapacity;
    }(EconomicObjective_2.EconomicObjective));
    exports.ExpandManufactoryCapacity = ExpandManufactoryCapacity;
});
define("modules/defaultai/objectives/Expansion", ["require", "exports", "modules/defaultai/objectives/common/TargetedFrontObjective", "modules/defaultai/objectives/common/movePriority"], function (require, exports, TargetedFrontObjective_4, movePriority_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Expansion = (function (_super) {
        __extends(Expansion, _super);
        function Expansion(score, target, mapEvaluator, unitEvaluator) {
            var _this = _super.call(this, score, target, mapEvaluator, unitEvaluator) || this;
            _this.type = "Expansion";
            _this.movePriority = movePriority_4.movePriority.Expansion;
            return _this;
        }
        Expansion.createObjectives = function (mapEvaluator, allOngoingObjectives) {
            var independentNeighborStars = mapEvaluator.getIndependentNeighborStars();
            var evaluations = mapEvaluator.evaluateStarTargets(independentNeighborStars);
            var scores = mapEvaluator.scoreIndependentTargets(evaluations);
            return scores.mapToArray(function (star, score) {
                return new Expansion(score, star, mapEvaluator, mapEvaluator.unitEvaluator);
            });
        };
        Expansion.evaluatePriority = function (mapEvaluator, grandStrategyAI) {
            return grandStrategyAI.desireForExpansion;
        };
        Expansion.prototype.execute = function (afterDoneCallback) {
            this.musterAndAttack(afterDoneCallback, function (target) {
                return target.enemy.isIndependent;
            });
        };
        Expansion.prototype.evaluateUnitFit = function (unit) {
            var strengthScore = this.unitEvaluator.evaluateCombatStrength(unit);
            return strengthScore * this.evaluateDefaultUnitFit(unit, this.front);
        };
        Expansion.prototype.getMinimumRequiredCombatStrength = function () {
            var enemyStrength = this.mapEvaluator.getHostileStrengthAtStar(this.target);
            return enemyStrength * 1.2;
        };
        Expansion.prototype.getIdealRequiredCombatStrength = function () {
            var enemyStrength = this.mapEvaluator.getHostileStrengthAtStar(this.target);
            return enemyStrength * 1.6;
        };
        Expansion.type = "Expansion";
        return Expansion;
    }(TargetedFrontObjective_4.TargetedFrontObjective));
    exports.Expansion = Expansion;
});
define("modules/defaultai/objectives/FightInvadingEnemy", ["require", "exports", "modules/defaultai/objectives/common/TargetedFrontObjective", "modules/defaultai/objectives/common/movePriority"], function (require, exports, TargetedFrontObjective_5, movePriority_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var FightInvadingEnemy = (function (_super) {
        __extends(FightInvadingEnemy, _super);
        function FightInvadingEnemy(score, target, mapEvaluator, unitEvaluator) {
            var _this = _super.call(this, score, target, mapEvaluator, unitEvaluator) || this;
            _this.type = "FightInvadingEnemy";
            _this.movePriority = movePriority_5.movePriority.FightInvadingEnemy;
            return _this;
        }
        FightInvadingEnemy.createObjectives = function (mapEvaluator, allOngoingObjectives) {
            var ownedStarsWithInvaders = mapEvaluator.player.controlledLocations.filter(function (star) {
                var hostileUnits = star.getUnits(function (player) {
                    return (!player.isIndependent &&
                        mapEvaluator.player.diplomacyStatus.canAttackFleetOfPlayer(player));
                });
                return hostileUnits.length > 0;
            });
            var evaluations = mapEvaluator.evaluateStarTargets(ownedStarsWithInvaders);
            var scores = mapEvaluator.scoreStarTargets(evaluations, function (star, evaluation) {
                var strengthRatio = evaluation.ownInfluence / evaluation.hostileStrength;
                var score = evaluation.desirability * strengthRatio;
                return score;
            });
            return scores.mapToArray(function (star, score) {
                return new FightInvadingEnemy(score, star, mapEvaluator, mapEvaluator.unitEvaluator);
            });
        };
        FightInvadingEnemy.evaluatePriority = function (mapEvaluator, grandStrategyAI) {
            return grandStrategyAI.desireForConsolidation;
        };
        FightInvadingEnemy.prototype.execute = function (afterDoneCallback) {
            this.musterAndAttack(afterDoneCallback, function (target) {
                return !target.enemy.isIndependent;
            });
        };
        FightInvadingEnemy.prototype.evaluateUnitFit = function (unit) {
            var strengthScore = this.unitEvaluator.evaluateCombatStrength(unit);
            return strengthScore * this.evaluateDefaultUnitFit(unit, this.front);
        };
        FightInvadingEnemy.prototype.getMinimumRequiredCombatStrength = function () {
            var enemyStrength = this.mapEvaluator.getIndependentStrengthAtStar(this.target);
            return enemyStrength * 1.2;
        };
        FightInvadingEnemy.prototype.getIdealRequiredCombatStrength = function () {
            var enemyStrength = this.mapEvaluator.getIndependentStrengthAtStar(this.target);
            return enemyStrength * 2;
        };
        FightInvadingEnemy.type = "FightInvadingEnemy";
        return FightInvadingEnemy;
    }(TargetedFrontObjective_5.TargetedFrontObjective));
    exports.FightInvadingEnemy = FightInvadingEnemy;
});
define("modules/defaultai/objectives/Heal", ["require", "exports", "modules/defaultai/objectives/common/FrontObjective", "modules/defaultai/objectives/common/movePriority", "modules/defaultai/objectives/common/moveroutines/moveToTarget"], function (require, exports, FrontObjective_2, movePriority_6, moveToTarget_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Heal = (function (_super) {
        __extends(Heal, _super);
        function Heal(score, mapEvaluator, unitEvaluator) {
            var _this = _super.call(this, score, mapEvaluator, unitEvaluator) || this;
            _this.type = "Heal";
            _this.movePriority = movePriority_6.movePriority.Heal;
            return _this;
        }
        Heal.createObjectives = function (mapEvaluator, allOngoingObjectives) {
            return [new Heal(1, mapEvaluator, mapEvaluator.unitEvaluator)];
        };
        Heal.evaluatePriority = function (mapEvaluator, grandStrategyAI) {
            return 0.5;
        };
        Heal.updateOngoingObjectivesList = function (allOngoingObjectives, createdObjectives) {
            return this.updateUniqueObjective(allOngoingObjectives, createdObjectives[0]);
        };
        Heal.prototype.execute = function (afterDoneCallback) {
            moveToTarget_2.moveToTarget(this.front, afterDoneCallback, function (fleet) {
                return fleet.player.getNearestOwnedStarTo(fleet.location);
            });
        };
        Heal.prototype.evaluateUnitFit = function (unit) {
            var healthPercentage = unit.currentHealth / unit.maxHealth;
            return 1 - healthPercentage;
        };
        Heal.prototype.getMinimumRequiredCombatStrength = function () {
            return 0;
        };
        Heal.prototype.getIdealRequiredCombatStrength = function () {
            return 0;
        };
        Heal.type = "Heal";
        return Heal;
    }(FrontObjective_2.FrontObjective));
    exports.Heal = Heal;
});
define("modules/defaultai/objectives/ScoutingPerimeter", ["require", "exports", "modules/defaultai/objectives/common/TargetedFrontObjective", "modules/defaultai/objectives/common/movePriority", "modules/defaultai/objectives/common/moveroutines/moveToTarget", "src/ValuesByStar"], function (require, exports, TargetedFrontObjective_6, movePriority_7, moveToTarget_3, ValuesByStar_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ScoutingPerimeter = (function (_super) {
        __extends(ScoutingPerimeter, _super);
        function ScoutingPerimeter(score, target, mapEvaluator, unitEvaluator) {
            var _this = _super.call(this, score, target, mapEvaluator, unitEvaluator) || this;
            _this.type = "ScoutingPerimeter";
            _this.movePriority = movePriority_7.movePriority.ScoutingPerimeter;
            return _this;
        }
        ScoutingPerimeter.createObjectives = function (mapEvaluator, allOngoingObjectives) {
            var playersToEstablishPerimeterAgainst = mapEvaluator.player.diplomacyStatus.getMetPlayers().filter(function (player) {
                return player.diplomacyStatus.canAttackBuildingOfPlayer(mapEvaluator.player);
            });
            var allScores = playersToEstablishPerimeterAgainst.map(function (player) {
                return mapEvaluator.getScoredPerimeterLocationsAgainstPlayer(player, 1, true);
            });
            var mergedScores = new ValuesByStar_3.default();
            mergedScores.merge.apply(mergedScores, [function () {
                    var scores = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        scores[_i] = arguments[_i];
                    }
                    return scores.reduce(function (total, current) {
                        return total + current;
                    }, 0);
                }].concat(allScores));
            return mergedScores.mapToArray(function (star, score) {
                return new ScoutingPerimeter(score, star, mapEvaluator, mapEvaluator.unitEvaluator);
            });
        };
        ScoutingPerimeter.evaluatePriority = function (mapEvaluator, grandStrategyAI) {
            return grandStrategyAI.desireForConsolidation;
        };
        ScoutingPerimeter.prototype.execute = function (afterDoneCallback) {
            var _this = this;
            moveToTarget_3.moveToTarget(this.front, afterDoneCallback, function (fleet) {
                return _this.target;
            });
        };
        ScoutingPerimeter.prototype.evaluateUnitFit = function (unit) {
            var scoutingScore = this.unitEvaluator.evaluateUnitScoutingAbility(unit);
            ;
            return scoutingScore * this.evaluateDefaultUnitFit(unit, this.front, 0, 0, 2);
        };
        ScoutingPerimeter.prototype.getMinimumRequiredCombatStrength = function () {
            return 0;
        };
        ScoutingPerimeter.prototype.getIdealRequiredCombatStrength = function () {
            return 0;
        };
        ScoutingPerimeter.type = "ScoutingPerimeter";
        return ScoutingPerimeter;
    }(TargetedFrontObjective_6.TargetedFrontObjective));
    exports.ScoutingPerimeter = ScoutingPerimeter;
});
define("modules/defaultai/mapai/objectiveCreatorTemplates", ["require", "exports", "modules/defaultai/objectives/BuildUnitsForFront", "modules/defaultai/objectives/CleanUpPirates", "modules/defaultai/objectives/Conquer", "modules/defaultai/objectives/DeclareWar", "modules/defaultai/objectives/Discovery", "modules/defaultai/objectives/ExpandManufactoryCapacity", "modules/defaultai/objectives/Expansion", "modules/defaultai/objectives/FightInvadingEnemy", "modules/defaultai/objectives/Heal", "modules/defaultai/objectives/ScoutingPerimeter"], function (require, exports, BuildUnitsForFront_1, CleanUpPirates_1, Conquer_1, DeclareWar_1, Discovery_1, ExpandManufactoryCapacity_1, Expansion_1, FightInvadingEnemy_1, Heal_1, ScoutingPerimeter_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objectiveCreatorTemplates = [
        BuildUnitsForFront_1.BuildUnitsForFront.makeCreatorTemplate(),
        CleanUpPirates_1.CleanUpPirates.makeCreatorTemplate(),
        Conquer_1.Conquer.makeCreatorTemplate(),
        DeclareWar_1.DeclareWar.makeCreatorTemplate(),
        Discovery_1.Discovery.makeCreatorTemplate(),
        ExpandManufactoryCapacity_1.ExpandManufactoryCapacity.makeCreatorTemplate(),
        Expansion_1.Expansion.makeCreatorTemplate(),
        FightInvadingEnemy_1.FightInvadingEnemy.makeCreatorTemplate(),
        Heal_1.Heal.makeCreatorTemplate(),
        ScoutingPerimeter_1.ScoutingPerimeter.makeCreatorTemplate(),
    ];
});
define("modules/defaultai/mapai/ObjectivesAI", ["require", "exports", "modules/defaultai/mapai/ObjectiveQueue", "modules/defaultai/mapai/objectiveCreatorTemplates", "modules/defaultai/objectives/common/ObjectiveFamily", "src/IdDictionary", "src/utility"], function (require, exports, ObjectiveQueue_1, objectiveCreatorTemplates_1, ObjectiveFamily_5, IdDictionary_6, utility_53) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ObjectivesAI = (function () {
        function ObjectivesAI(mapEvaluator, grandStrategyAI) {
            this.ongoingObjectives = [];
            this.mapEvaluator = mapEvaluator;
            this.grandStrategyAI = grandStrategyAI;
        }
        ObjectivesAI.diplomaticFilter = function (toFilter) {
            return toFilter.family === ObjectiveFamily_5.ObjectiveFamily.Diplomatic;
        };
        ObjectivesAI.economicFilter = function (toFilter) {
            return toFilter.family === ObjectiveFamily_5.ObjectiveFamily.Economic;
        };
        ObjectivesAI.frontFilter = function (toFilter) {
            return toFilter.family === ObjectiveFamily_5.ObjectiveFamily.Front;
        };
        ObjectivesAI.groupObjectivesByType = function (objectives) {
            var grouped = {};
            objectives.forEach(function (objective) {
                if (!grouped[objective.type]) {
                    grouped[objective.type] = [];
                }
                grouped[objective.type].push(objective);
            });
            return grouped;
        };
        ObjectivesAI.prototype.processDiplomaticObjectives = function (onAllFinished) {
            this.updateAndExecuteObjectives(ObjectivesAI.diplomaticFilter, onAllFinished);
        };
        ObjectivesAI.prototype.processEconomicObjectives = function (onAllFinished) {
            this.updateAndExecuteObjectives(ObjectivesAI.economicFilter, onAllFinished);
        };
        ObjectivesAI.prototype.createFrontObjectives = function () {
            this.updateObjectivesForFilter(ObjectivesAI.frontFilter);
            this.calculateFinalPrioritiesForObjectivesMatchingFilter(ObjectivesAI.frontFilter);
        };
        ObjectivesAI.prototype.getFrontObjectives = function () {
            return this.ongoingObjectives.filter(ObjectivesAI.frontFilter);
        };
        ObjectivesAI.prototype.executeFrontObjectives = function (onAllFinished) {
            var objectives = this.getFrontObjectives();
            objectives.sort(function (a, b) {
                var movePrioritySort = b.movePriority - a.movePriority;
                if (movePrioritySort) {
                    return movePrioritySort;
                }
                var finalPrioritySort = b.finalPriority - a.finalPriority;
                if (finalPrioritySort) {
                    return finalPrioritySort;
                }
                return a.id - b.id;
            });
            var objectiveQueue = new ObjectiveQueue_1.ObjectiveQueue();
            objectiveQueue.executeObjectives(objectives, onAllFinished);
        };
        ObjectivesAI.prototype.updateAndExecuteObjectives = function (filterFN, onAllFinished) {
            this.updateObjectivesForFilter(filterFN);
            this.calculateFinalPrioritiesForObjectivesMatchingFilter(filterFN);
            var objectiveQueue = new ObjectiveQueue_1.ObjectiveQueue();
            objectiveQueue.executeObjectives(this.ongoingObjectives.filter(filterFN).sort(ObjectiveQueue_1.ObjectiveQueue.sortByFinalPriority), onAllFinished);
        };
        ObjectivesAI.prototype.updateObjectivesForFilter = function (filterFN) {
            var _this = this;
            var creatorTemplates = objectiveCreatorTemplates_1.objectiveCreatorTemplates.filter(filterFN);
            creatorTemplates.forEach(function (template) {
                var newObjectives = template.getUpdatedObjectivesList(_this.mapEvaluator, _this.ongoingObjectives);
                _this.ongoingObjectives = newObjectives;
            });
        };
        ObjectivesAI.prototype.getRelativeScoresForObjectives = function (objectives) {
            var objectivesByType = ObjectivesAI.groupObjectivesByType(objectives);
            var relativeScores = new IdDictionary_6.IdDictionary();
            var _loop_10 = function (type) {
                var min;
                var max;
                objectivesByType[type].forEach(function (objective) {
                    var score = objective.score;
                    min = isFinite(min) ? Math.min(min, score) : score;
                    max = isFinite(max) ? Math.max(max, score) : score;
                });
                objectivesByType[type].forEach(function (objective) {
                    var relativeScore = utility_53.getRelativeValue(objective.score, min, max);
                    relativeScores.set(objective, relativeScore);
                });
            };
            for (var type in objectivesByType) {
                _loop_10(type);
            }
            return relativeScores;
        };
        ObjectivesAI.prototype.calculateFinalPrioritiesForObjectivesMatchingFilter = function (filterFN) {
            var _this = this;
            var priorities = {};
            objectiveCreatorTemplates_1.objectiveCreatorTemplates.filter(filterFN).forEach(function (template) {
                priorities[template.type] = template.evaluatePriority(_this.mapEvaluator, _this.grandStrategyAI);
            });
            var relativeScores = this.getRelativeScoresForObjectives(this.ongoingObjectives.filter(filterFN));
            relativeScores.forEach(function (objective, score) {
                objective.finalPriority = score * priorities[objective.type];
            });
        };
        return ObjectivesAI;
    }());
    exports.ObjectivesAI = ObjectivesAI;
});
define("modules/defaultai/mapai/FrontsAI", ["require", "exports", "src/IdDictionary"], function (require, exports, IdDictionary_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var FrontsAI = (function () {
        function FrontsAI(mapEvaluator, objectivesAI, personality, game) {
            this.fronts = [];
            this.mapEvaluator = mapEvaluator;
            this.map = mapEvaluator.map;
            this.player = mapEvaluator.player;
            this.objectivesAI = objectivesAI;
            this.personality = personality;
            this.game = game;
        }
        FrontsAI.prototype.assignUnits = function () {
            var units = this.player.units;
            var allUnitScores = [];
            var unitScoresByFront = {};
            var objectivesByFront = new IdDictionary_7.IdDictionary();
            this.objectivesAI.getFrontObjectives().forEach(function (objective) {
                objectivesByFront.set(objective.front, objective);
            });
            var recalculateScoresForFront = function (front) {
                var frontScores = unitScoresByFront[front.id];
                var objective = objectivesByFront.get(front);
                for (var i = 0; i < frontScores.length; i++) {
                    frontScores[i].score = objective.evaluateUnitFit(frontScores[i].unit);
                }
            };
            var removeUnit = function (unit) {
                for (var frontId in unitScoresByFront) {
                    unitScoresByFront[frontId] = unitScoresByFront[frontId].filter(function (score) {
                        return score.unit !== unit;
                    });
                }
            };
            for (var i = 0; i < this.fronts.length; i++) {
                var frontScores = this.getUnitScoresForFront(units, this.fronts[i]);
                unitScoresByFront[this.fronts[i].id] = frontScores;
                allUnitScores.push.apply(allUnitScores, frontScores);
            }
            var alreadyAdded = {};
            var sortByScoreFN = function (a, b) {
                return a.score - b.score;
            };
            while (allUnitScores.length > 0) {
                allUnitScores.sort(sortByScoreFN);
                var bestScore = allUnitScores.pop();
                if (alreadyAdded[bestScore.unit.id]) {
                    continue;
                }
                bestScore.front.addUnit(bestScore.unit);
                removeUnit(bestScore.unit);
                alreadyAdded[bestScore.unit.id] = true;
                recalculateScoresForFront(bestScore.front);
            }
        };
        FrontsAI.prototype.organizeFleets = function () {
            for (var i = 0; i < this.fronts.length; i++) {
                this.fronts[i].organizeAllFleets();
            }
        };
        FrontsAI.prototype.formFronts = function () {
            this.destroyInactiveFronts();
            this.fronts = this.objectivesAI.getFrontObjectives().map(function (objective) { return objective.front; });
        };
        FrontsAI.prototype.getUnitScoresForFront = function (units, front) {
            var scores = [];
            var activeObjectives = this.objectivesAI.getFrontObjectives();
            var objective;
            for (var i = 0; i < activeObjectives.length; i++) {
                if (activeObjectives[i].front === front) {
                    objective = activeObjectives[i];
                    break;
                }
            }
            for (var i = 0; i < units.length; i++) {
                scores.push({
                    unit: units[i],
                    score: objective.evaluateUnitFit(units[i]),
                    front: front,
                });
            }
            return scores;
        };
        FrontsAI.prototype.destroyInactiveFronts = function () {
            var activeObjectives = this.objectivesAI.getFrontObjectives();
            var activeFrontsWithObjective = new IdDictionary_7.IdDictionary();
            activeObjectives.forEach(function (objective) {
                activeFrontsWithObjective.set(objective.front, objective);
            });
            this.fronts.filter(function (front) {
                return !activeFrontsWithObjective.has(front);
            }).forEach(function (front) {
                front.destroy();
            });
        };
        return FrontsAI;
    }());
    exports.default = FrontsAI;
});
define("modules/defaultai/mapai/DefaultAI", ["require", "exports", "modules/defaultai/mapai/DiplomacyAI", "modules/defaultai/mapai/EconomicAI", "modules/defaultai/mapai/FrontsAI", "modules/defaultai/mapai/GrandStrategyAI", "modules/defaultai/mapai/MapEvaluator", "modules/defaultai/mapai/ObjectivesAI", "modules/defaultai/mapai/UnitEvaluator", "src/activeModuleData", "src/getNullFormation", "src/utility"], function (require, exports, DiplomacyAI_1, EconomicAI_1, FrontsAI_1, GrandStrategyAI_1, MapEvaluator_1, ObjectivesAI_1, UnitEvaluator_1, activeModuleData_27, getNullFormation_2, utility_54) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DefaultAI = (function () {
        function DefaultAI(player, game, personality) {
            this.type = "DefaultAI";
            this.turnProcessingQueue = [];
            this.personality = personality || utility_54.makeRandomPersonality();
            this.player = player;
            this.game = game;
            this.map = game.galaxyMap;
            this.unitEvaluator = new UnitEvaluator_1.UnitEvaluator();
            this.mapEvaluator = new MapEvaluator_1.default(this.map, this.player, this.unitEvaluator);
            this.grandStrategyAI = new GrandStrategyAI_1.GrandStrategyAI(this.personality, this.mapEvaluator, this.game);
            this.objectivesAI = new ObjectivesAI_1.ObjectivesAI(this.mapEvaluator, this.grandStrategyAI);
            this.frontsAI = new FrontsAI_1.default(this.mapEvaluator, this.objectivesAI, this.personality, this.game);
            this.diplomacyAI = new DiplomacyAI_1.default(this.mapEvaluator, this.game);
            this.economicAI = new EconomicAI_1.EconomicAI();
        }
        DefaultAI.prototype.processTurn = function (afterFinishedCallback) {
            this.afterTurnHasProcessed = afterFinishedCallback;
            this.turnProcessingQueue = this.constructTurnProcessingQueue();
            this.processTurnStep();
        };
        DefaultAI.prototype.createBattleFormation = function (availableUnits, hasScouted, enemyUnits, enemyFormation) {
            var _this = this;
            var scoutedUnits = hasScouted ? enemyUnits : null;
            var scoutedFormation = hasScouted ? enemyFormation : null;
            var formation = getNullFormation_2.default();
            var unitsToPlace = availableUnits.slice();
            var maxUnitsPerRow = formation[0].length;
            var maxUnitsPerSide = activeModuleData_27.activeModuleData.ruleSet.battle.maxUnitsPerSide;
            var placedInFront = 0;
            var placedInBack = 0;
            var totalPlaced = 0;
            var unitsPlacedByArchetype = {};
            var getUnitScoreFN = function (unit, row) {
                var baseScore = _this.unitEvaluator.evaluateCombatStrength(unit);
                var archetype = unit.template.archetype;
                var idealMaxUnitsOfArchetype = Math.ceil(maxUnitsPerSide / archetype.idealWeightInBattle);
                var unitsPlacedOfArchetype = unitsPlacedByArchetype[archetype.type] || 0;
                var overMaxOfArchetypeIdeal = Math.max(0, unitsPlacedOfArchetype - idealMaxUnitsOfArchetype);
                var archetypeIdealAdjust = 1 - overMaxOfArchetypeIdeal * 0.15;
                var rowUnits = row === "ROW_FRONT" ? formation[1] : formation[0];
                var rowModifier = archetype.scoreMultiplierForRowFN ?
                    archetype.scoreMultiplierForRowFN(row, rowUnits, scoutedUnits, scoutedFormation) :
                    archetype.rowScores[row];
                return ({
                    unit: unit,
                    score: baseScore * archetypeIdealAdjust * rowModifier,
                    row: row,
                });
            };
            while (unitsToPlace.length > 0 && totalPlaced < maxUnitsPerSide) {
                var positionScores = [];
                for (var i = 0; i < unitsToPlace.length; i++) {
                    var unit = unitsToPlace[i];
                    if (placedInFront < maxUnitsPerRow) {
                        positionScores.push(getUnitScoreFN(unit, "ROW_FRONT"));
                    }
                    if (placedInBack < maxUnitsPerRow) {
                        positionScores.push(getUnitScoreFN(unit, "ROW_BACK"));
                    }
                }
                positionScores.sort(function (a, b) {
                    return (b.score - a.score);
                });
                var topScore = positionScores[0];
                if (topScore.row === "ROW_FRONT") {
                    placedInFront++;
                    formation[1][placedInFront - 1] = topScore.unit;
                }
                else {
                    placedInBack++;
                    formation[0][placedInBack - 1] = topScore.unit;
                }
                totalPlaced++;
                if (!unitsPlacedByArchetype[topScore.unit.template.archetype.type]) {
                    unitsPlacedByArchetype[topScore.unit.template.archetype.type] = 0;
                }
                unitsPlacedByArchetype[topScore.unit.template.archetype.type]++;
                unitsToPlace.splice(unitsToPlace.indexOf(topScore.unit), 1);
            }
            return formation;
        };
        DefaultAI.prototype.respondToTradeOffer = function (receivedOffer) {
            return this.economicAI.respondToTradeOffer(receivedOffer);
        };
        DefaultAI.prototype.serialize = function () {
            return undefined;
        };
        DefaultAI.prototype.constructTurnProcessingQueue = function () {
            var _this = this;
            var queue = [];
            queue.push(function (triggerFinish) {
                _this.grandStrategyAI.setDesires();
                _this.diplomacyAI.setAttitudes();
                _this.objectivesAI.processDiplomaticObjectives(triggerFinish);
            });
            queue.push(function (triggerFinish) {
                _this.objectivesAI.createFrontObjectives();
                _this.frontsAI.formFronts();
                _this.frontsAI.assignUnits();
                _this.objectivesAI.processEconomicObjectives(triggerFinish);
            });
            queue.push(function (triggerFinish) {
                _this.frontsAI.organizeFleets();
                _this.objectivesAI.executeFrontObjectives(triggerFinish);
            });
            queue.push(function (triggerFinish) {
                _this.frontsAI.organizeFleets();
                triggerFinish();
            });
            return queue;
        };
        DefaultAI.prototype.processTurnStep = function () {
            var nextStep = this.turnProcessingQueue.shift();
            if (!nextStep) {
                var afterFinishedCallback = this.afterTurnHasProcessed;
                this.afterTurnHasProcessed = null;
                afterFinishedCallback();
                return;
            }
            nextStep(this.processTurnStep.bind(this));
        };
        DefaultAI.type = "DefaultAI";
        return DefaultAI;
    }());
    exports.default = DefaultAI;
});
define("modules/defaultai/mapai/DefaultAIConstructor", ["require", "exports", "modules/defaultai/mapai/DefaultAI"], function (require, exports, DefaultAI_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DefaultAIConstructor = {
        type: DefaultAI_1.default.type,
        construct: function (props) {
            return new DefaultAI_1.default(props.player, props.game, props.personality);
        },
    };
    exports.default = DefaultAIConstructor;
});
define("modules/defaultai/defaultAI", ["require", "exports", "src/ModuleFileLoadingPhase", "modules/defaultai/mapai/DefaultAIConstructor", "localization/defaultLanguages"], function (require, exports, ModuleFileLoadingPhase_5, DefaultAIConstructor_1, Languages) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var defaultAI = {
        key: "defaultAI",
        metaData: {
            name: "Default AI",
            version: "0.1.0",
            author: "giraluna",
            description: "",
        },
        needsToBeLoadedBefore: ModuleFileLoadingPhase_5.default.Game,
        supportedLanguages: [Languages.en],
        constructModule: function (moduleData) {
            moduleData.copyTemplates((_a = {},
                _a[DefaultAIConstructor_1.default.type] = DefaultAIConstructor_1.default,
                _a), "AITemplateConstructors");
            return moduleData;
            var _a;
        },
    };
    exports.default = defaultAI;
});
define("modules/defaultattitudemodifiers/AttitudeModifierTemplates", ["require", "exports", "src/DiplomacyState"], function (require, exports, DiplomacyState_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var neighborStars = {
        type: "neighborStars",
        displayName: "neighborStars",
        family: "geographic",
        duration: -1,
        startCondition: function (evaluation) {
            return (evaluation.neighborStars >= 2 && evaluation.opinion < 50);
        },
        getEffectFromEvaluation: function (evaluation) {
            return -2 * evaluation.neighborStars;
        },
    };
    var atWar = {
        type: "atWar",
        displayName: "At war",
        family: "current",
        duration: -1,
        startCondition: function (evaluation) {
            return (evaluation.currentStatus >= DiplomacyState_3.default.War);
        },
        constantEffect: -30,
    };
    var declaredWar = {
        type: "declaredWar",
        displayName: "Declared war",
        family: "history",
        duration: 15,
        triggers: ["addDeclaredWarAttitudeModifier"],
        constantEffect: -35,
    };
    var AttitudeModifierTemplates = (_a = {},
        _a[neighborStars.type] = neighborStars,
        _a[atWar.type] = atWar,
        _a[declaredWar.type] = declaredWar,
        _a);
    exports.default = AttitudeModifierTemplates;
    var _a;
});
define("src/setDynamicTemplateProperties", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function setAttitudeModifierOverride(attitudeModifiers) {
        for (var modifierType in attitudeModifiers) {
            var modifier = attitudeModifiers[modifierType];
            if (modifier.canBeOverriddenBy) {
                for (var i = 0; i < modifier.canBeOverriddenBy.length; i++) {
                    if (!modifier.canBeOverriddenBy[i].canOverride) {
                        modifier.canBeOverriddenBy[i].canOverride = [];
                    }
                    modifier.canBeOverriddenBy[i].canOverride.push(modifier);
                }
            }
        }
    }
    exports.setAttitudeModifierOverride = setAttitudeModifierOverride;
    function setTechnologyRequirements(technologyTemplates) {
        var _loop_11 = function (technologyKey) {
            var technology = technologyTemplates[technologyKey];
            var _loop_12 = function (level) {
                var unlockedTemplatesForLevel = technology.unlocksPerLevel[level];
                unlockedTemplatesForLevel.forEach(function (template) {
                    if (!template.technologyRequirements) {
                        template.technologyRequirements = [];
                    }
                    template.technologyRequirements.push({
                        technology: technology,
                        level: parseInt(level),
                    });
                });
            };
            for (var level in technology.unlocksPerLevel) {
                _loop_12(level);
            }
        };
        for (var technologyKey in technologyTemplates) {
            _loop_11(technologyKey);
        }
    }
    exports.setTechnologyRequirements = setTechnologyRequirements;
});
define("modules/defaultattitudemodifiers/defaultAttitudemodifiers", ["require", "exports", "modules/defaultattitudemodifiers/AttitudeModifierTemplates", "src/ModuleFileLoadingPhase", "src/setDynamicTemplateProperties", "localization/defaultLanguages"], function (require, exports, AttitudeModifierTemplates_1, ModuleFileLoadingPhase_6, setDynamicTemplateProperties_1, Languages) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var defaultAttitudeModifiers = {
        key: "defaultAttitudeModifiers",
        metaData: {
            name: "Default attitude modifiers",
            version: "0.1.0",
            author: "giraluna",
            description: "",
        },
        needsToBeLoadedBefore: ModuleFileLoadingPhase_6.default.MapGen,
        supportedLanguages: [Languages.en],
        constructModule: function (moduleData) {
            setDynamicTemplateProperties_1.setAttitudeModifierOverride(AttitudeModifierTemplates_1.default);
            moduleData.copyTemplates(AttitudeModifierTemplates_1.default, "AttitudeModifiers");
            return moduleData;
        },
    };
    exports.default = defaultAttitudeModifiers;
});
define("modules/defaultbackgrounds/Nebula", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Nebula = (function (_super) {
        __extends(Nebula, _super);
        function Nebula(initialUniformValues) {
            var _this = this;
            var uniformData = Nebula.makeUniformDataObject(initialUniformValues);
            _this = _super.call(this, null, sourceLines.join("\n"), uniformData) || this;
            return _this;
        }
        Nebula.makeUniformDataObject = function (initialValues) {
            if (initialValues === void 0) { initialValues = {}; }
            return ({
                baseColor: { type: "vec3", value: initialValues.baseColor },
                cloudLightness: { type: "float", value: initialValues.cloudLightness },
                coverage: { type: "float", value: initialValues.coverage },
                diffusion: { type: "float", value: initialValues.diffusion },
                highlightA: { type: "float", value: initialValues.highlightA },
                highlightB: { type: "float", value: initialValues.highlightB },
                highlightColor: { type: "vec3", value: initialValues.highlightColor },
                nebulaStarConcentration: { type: "float", value: initialValues.nebulaStarConcentration },
                overlayColor: { type: "vec3", value: initialValues.overlayColor },
                scale: { type: "float", value: initialValues.scale },
                seed: { type: "vec2", value: initialValues.seed },
                starBrightness: { type: "float", value: initialValues.starBrightness },
                starDensity: { type: "float", value: initialValues.starDensity },
                streakLightness: { type: "float", value: initialValues.streakLightness },
                streakiness: { type: "float", value: initialValues.streakiness },
            });
        };
        Nebula.prototype.setUniforms = function (uniforms) {
            for (var key in uniforms) {
                this.uniforms[key] = uniforms[key];
            }
        };
        return Nebula;
    }(PIXI.Filter));
    exports.default = Nebula;
    var sourceLines = [
        "precision mediump float;",
        "",
        "#define DOMAIN 0 // 0 == pixi, 1 == shdr.bkcore.com",
        "",
        "#if DOMAIN == 0",
        "  uniform vec3 baseColor;",
        "  uniform vec3 overlayColor;",
        "  uniform vec3 highlightColor;",
        "",
        "  uniform float coverage;",
        "",
        "  uniform float scale;",
        "",
        "  uniform float diffusion;",
        "  uniform float streakiness;",
        "",
        "  uniform float streakLightness;",
        "  uniform float cloudLightness;",
        "",
        "  uniform float highlightA;",
        "  uniform float highlightB;",
        "",
        "  uniform float starDensity;",
        "  uniform float nebulaStarConcentration;",
        "  uniform float starBrightness;",
        "",
        "  uniform vec2 seed;",
        "#elif DOMAIN == 1",
        "  const vec3 baseColor = vec3(1.0, 0.0, 0.0);",
        "  const vec3 overlayColor = vec3(0.0, 0.0, 1.0);",
        "  const vec3 highlightColor = vec3(1.0, 1.0, 1.0);",
        "",
        "  const float coverage = 0.3;",
        "  const float coverage2 = coverage / 2.0;",
        "",
        "  const float scale = 4.0;",
        "",
        "  const float diffusion = 3.0;",
        "  const float streakiness = 2.0;",
        "",
        "  const float streakLightness = 1.0;",
        "  const float cloudLightness = 1.0;",
        "",
        "  const float highlightA = 0.9;",
        "  const float highlightB = 2.2;",
        "",
        "  const float starDensity = 0.0008;",
        "  const float nebulaStarConcentration = 0.01;",
        "  const float starBrightness = 0.6;",
        "",
        "  const vec2 seed = vec2(69.0, 42.0);",
        "#endif",
        "",
        "const int sharpness = 6;",
        "",
        "float hash(vec2 p)",
        "{",
        "  return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x))));",
        "}",
        "",
        "float noise(vec2 x)",
        "{",
        "  vec2 i = floor(x);",
        "  vec2 f = fract(x);",
        "  float a = hash(i);",
        "  float b = hash(i + vec2(1.0, 0.0));",
        "  float c = hash(i + vec2(0.0, 1.0));",
        "  float d = hash(i + vec2(1.0, 1.0));",
        "  vec2 u = f * f * (3.0 - 2.0 * f);",
        "  return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;",
        "}",
        "",
        "float fbm(vec2 x)",
        "{",
        "  float v = 0.0;",
        "  float a = 0.5;",
        "  vec2 shift = vec2(100);",
        "  mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));",
        "  for (int i = 0; i < sharpness; ++i)",
        "  {",
        "    v += a * noise(x);",
        "    x = rot * x * 2.0 + shift;",
        "    a *= 0.5;",
        "    }",
        "  return v;",
        "}",
        "",
        "float relativeValue(float v, float min, float max)",
        "{",
        "  return (v - min) / (max - min);",
        "}",
        "",
        "float displace(vec2 pos, out vec2 q)",
        "{",
        "  q = vec2(fbm(pos),",
        "    fbm(pos + vec2(23.3, 46.7)));",
        "  return fbm(pos + vec2(q.x * streakiness, q.y));",
        "}",
        "",
        "vec3 colorLayer(vec2 pos, vec3 color)",
        "{",
        "  float v = fbm(pos);",
        "  return mix(vec3(0.0), color, v);",
        "}",
        "",
        "vec3 nebula(vec2 pos, out float volume)",
        "{",
        "  vec2 on = vec2(0.0);",
        "",
        "  volume = displace(pos, on);",
        "  volume = relativeValue(volume, coverage, streakLightness);",
        "  volume += relativeValue(fbm(pos), coverage, cloudLightness);",
        "  volume = pow(volume, diffusion);",
        "",
        "  vec3 c = colorLayer(pos + vec2(42.0, 6.9), baseColor);",
        "  c = mix(c, overlayColor, dot(on.x, on.y));",
        "  c = mix(c, highlightColor, volume *",
        "    smoothstep(highlightA, highlightB, abs(on.x)+abs(on.y)));",
        "",
        "",
        "  return c * volume;",
        "}",
        "",
        "float star(vec2 pos, float volume)",
        "{",
        "  float h = hash(pos);",
        "",
        "  float intensityCutoff = (1.0 - starDensity) - (volume * nebulaStarConcentration);",
        "  float starIntensity = smoothstep(intensityCutoff, 1.0, h);",
        "",
        "  return starIntensity * starBrightness;",
        "}",
        "",
        "void main(void)",
        "{",
        "  vec2 pos = gl_FragCoord.xy / 50.0 / scale;",
        "  pos += seed;",
        "  float volume = 0.0;",
        "  vec3 c = nebula(pos, volume);",
        "  c += vec3(star(pos, volume));",
        "",
        "  gl_FragColor = vec4(c, 1.0);",
        "}",
    ];
});
define("modules/defaultbackgrounds/drawNebula", ["require", "exports", "modules/defaultbackgrounds/Nebula", "src/colorGeneration", "src/pixiWrapperFunctions", "src/utility"], function (require, exports, Nebula_1, colorGeneration_7, pixiWrapperFunctions_6, utility_55) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var drawNebula = function (seed, size, renderer) {
        var oldRng = Math.random;
        Math.random = RNG.prototype.uniform.bind(new RNG(seed));
        var nebulaColorScheme = colorGeneration_7.generateColorScheme();
        var filter = new Nebula_1.default({
            baseColor: nebulaColorScheme.main.getRGB(),
            overlayColor: nebulaColorScheme.secondary.getRGB(),
            highlightColor: [1.0, 1.0, 1.0],
            coverage: utility_55.randRange(0.28, 0.32),
            scale: utility_55.randRange(4, 8),
            diffusion: utility_55.randRange(1.5, 3.0),
            streakiness: utility_55.randRange(1.5, 2.5),
            streakLightness: utility_55.randRange(1, 1.2),
            cloudLightness: utility_55.randRange(1, 1.2),
            highlightA: 0.9,
            highlightB: 2.2,
            starDensity: utility_55.randRange(0.0014, 0.0018),
            nebulaStarConcentration: utility_55.randRange(0.000, 0.004),
            starBrightness: 0.6,
            seed: [Math.random() * 100, Math.random() * 100],
        });
        var container = new PIXI.Container();
        var shaderSprite = pixiWrapperFunctions_6.makeShaderSprite(filter, 0, 0, size.width, size.height);
        container.addChild(shaderSprite);
        var texture = pixiWrapperFunctions_6.generateTextureWithBounds(renderer, container, PIXI.settings.SCALE_MODE, 1, size);
        var sprite = new PIXI.Sprite(texture);
        container.removeChildren();
        shaderSprite.destroy({ texture: true, baseTexture: true });
        Math.random = oldRng;
        return ({
            displayObject: sprite,
            destroy: texture.destroy.bind(texture),
        });
    };
    exports.default = drawNebula;
});
define("modules/defaultbackgrounds/defaultBackgrounds", ["require", "exports", "src/ModuleFileLoadingPhase", "modules/defaultbackgrounds/drawNebula"], function (require, exports, ModuleFileLoadingPhase_7, drawNebula_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var defaultBackgrounds = {
        key: "defaultBackgrounds",
        metaData: {
            name: "Default backgrounds",
            version: "0.1.0",
            author: "giraluna",
            description: "",
        },
        needsToBeLoadedBefore: ModuleFileLoadingPhase_7.default.Game,
        supportedLanguages: "all",
        constructModule: function (moduleData) {
            if (!moduleData.mapBackgroundDrawingFunction) {
                moduleData.mapBackgroundDrawingFunction = drawNebula_1.default;
            }
            if (!moduleData.starBackgroundDrawingFunction) {
                moduleData.starBackgroundDrawingFunction = drawNebula_1.default;
            }
            return moduleData;
        },
    };
    exports.default = defaultBackgrounds;
});
define("modules/defaultbuildings/templates/Templates", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sectorCommand = {
        type: "sectorCommand",
        category: "defence",
        family: "sectorCommand",
        displayName: "Sector Command",
        description: "Defence building with slight defender advantage. (All defence buildings must " +
            "be captured to gain control of area)",
        iconSrc: "sectorCommand.png",
        buildCost: 200,
        maxPerType: 1,
        maxUpgradeLevel: 1,
        upgradeInto: [
            {
                templateType: "sectorCommand1",
                level: 1,
            },
            {
                templateType: "sectorCommand2",
                level: 1,
            },
        ],
        defenderAdvantage: 0.2,
    };
    exports.sectorCommand1 = {
        type: "sectorCommand1",
        category: "defence",
        family: "sectorCommand",
        displayName: "Sector Command1",
        description: "just testing upgrade paths",
        iconSrc: "sectorCommand.png",
        buildCost: 100,
        maxPerType: 1,
        maxUpgradeLevel: 1,
        upgradeOnly: true,
        defenderAdvantage: 0.3,
    };
    exports.sectorCommand2 = {
        type: "sectorCommand2",
        category: "defence",
        family: "sectorCommand",
        displayName: "Sector Command2",
        description: "just testing upgrade paths",
        iconSrc: "sectorCommand.png",
        buildCost: 200,
        maxPerType: 1,
        maxUpgradeLevel: 1,
        upgradeOnly: true,
        defenderAdvantage: 0.3,
    };
    exports.starBase = {
        type: "starBase",
        category: "defence",
        displayName: "Starbase",
        description: "Defence building with no defender advantage. (All defence buildings must " +
            "be captured to gain control of area)",
        iconSrc: "starBase.png",
        buildCost: 200,
        maxPerType: 3,
        maxUpgradeLevel: 1,
        defenderAdvantage: 0.1,
        upgradeInto: [
            {
                templateType: "sectorCommand",
                level: 1,
            },
        ],
    };
    exports.commercialPort = {
        type: "commercialPort",
        category: "economy",
        displayName: "Commercial Spaceport",
        description: "Increase star income by 20",
        iconSrc: "commercialPort.png",
        buildCost: 200,
        maxPerType: 1,
        effect: {
            income: {
                flat: 20,
            },
        },
        maxUpgradeLevel: 4,
    };
    exports.deepSpaceRadar = {
        type: "deepSpaceRadar",
        category: "vision",
        displayName: "Deep Space Radar",
        description: "Increase star vision and detection radius",
        iconSrc: "commercialPort.png",
        buildCost: 200,
        maxPerType: 1,
        effect: {
            vision: 1,
            detection: 0.999,
        },
        maxUpgradeLevel: 2,
    };
    exports.resourceMine = {
        type: "resourceMine",
        category: "mine",
        displayName: "Mine",
        description: "Gathers resources from current star",
        iconSrc: "commercialPort.png",
        buildCost: 500,
        maxPerType: 1,
        effect: {
            resourceIncome: {
                flat: 1,
            },
        },
        maxUpgradeLevel: 3,
    };
    exports.reserachLab = {
        type: "reserachLab",
        category: "research",
        displayName: "Research Lab",
        description: "Increase research speed",
        iconSrc: "commercialPort.png",
        buildCost: 300,
        maxPerType: 1,
        effect: {
            research: {
                flat: 10,
            },
        },
        maxUpgradeLevel: 3,
    };
});
define("modules/defaultbuildings/BuildingTemplates", ["require", "exports", "modules/defaultbuildings/templates/Templates"], function (require, exports, Templates) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BuildingTemplates = (_a = {},
        _a[Templates.sectorCommand.type] = Templates.sectorCommand,
        _a[Templates.sectorCommand1.type] = Templates.sectorCommand1,
        _a[Templates.sectorCommand2.type] = Templates.sectorCommand2,
        _a[Templates.starBase.type] = Templates.starBase,
        _a[Templates.commercialPort.type] = Templates.commercialPort,
        _a[Templates.deepSpaceRadar.type] = Templates.deepSpaceRadar,
        _a[Templates.resourceMine.type] = Templates.resourceMine,
        _a[Templates.reserachLab.type] = Templates.reserachLab,
        _a);
    exports.default = BuildingTemplates;
    var _a;
});
define("src/cacheSpriteSheetAsImages", ["require", "exports", "src/App"], function (require, exports, App_14) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    ;
    function processSpriteSheet(sheetData, sheetImg, processFrameFN) {
        for (var spriteName in sheetData.frames) {
            processFrameFN(sheetImg, sheetData.frames[spriteName].frame, spriteName);
        }
    }
    function addImageToApp(name, image) {
        App_14.default.images[name] = image;
    }
    function cacheSpriteSheetAsImages(sheetData, sheetImg, onImageCreated) {
        if (onImageCreated === void 0) { onImageCreated = addImageToApp; }
        var spriteToImageFN = function (sheetImg, frame, spriteName) {
            var canvas = document.createElement("canvas");
            canvas.width = frame.w;
            canvas.height = frame.h;
            var context = canvas.getContext("2d");
            context.drawImage(sheetImg, frame.x, frame.y, frame.w, frame.h, 0, 0, frame.w, frame.h);
            var image = new Image();
            image.src = canvas.toDataURL();
            onImageCreated(spriteName, image);
        };
        processSpriteSheet(sheetData, sheetImg, spriteToImageFN);
    }
    exports.default = cacheSpriteSheetAsImages;
});
define("modules/defaultbuildings/defaultBuildings", ["require", "exports", "modules/defaultbuildings/BuildingTemplates", "src/ModuleFileLoadingPhase", "src/cacheSpriteSheetAsImages", "localization/defaultLanguages"], function (require, exports, BuildingTemplates_1, ModuleFileLoadingPhase_8, cacheSpriteSheetAsImages_1, Languages) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var defaultBuildings = {
        key: "defaultBuildings",
        metaData: {
            name: "Default Buildings",
            version: "0.1.0",
            author: "giraluna",
            description: "",
        },
        needsToBeLoadedBefore: ModuleFileLoadingPhase_8.default.MapGen,
        supportedLanguages: [Languages.en],
        loadAssets: function (onLoaded) {
            var loader = new PIXI.loaders.Loader();
            var spriteSheetKey = "buildings";
            loader.add(spriteSheetKey, "modules/defaultbuildings/img/buildings.json");
            loader.load(function (loader) {
                var json = loader.resources[spriteSheetKey].data;
                var image = loader.resources[spriteSheetKey + "_image"].data;
                cacheSpriteSheetAsImages_1.default(json, image);
                onLoaded();
            });
        },
        constructModule: function (moduleData) {
            moduleData.copyTemplates(BuildingTemplates_1.default, "Buildings");
            return moduleData;
        },
    };
    exports.default = defaultBuildings;
});
define("modules/defaultemblems/SubEmblemTemplates", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Aguila_explayada_2 = {
        key: "Aguila_explayada_2",
        src: "modules/defaultemblems/img/Aguila_explayada_2.svg",
    };
    exports.Berliner_Baer = {
        key: "Berliner_Baer",
        src: "modules/defaultemblems/img/Berliner_Baer.svg",
    };
    exports.Cles_en_sautoir = {
        key: "Cles_en_sautoir",
        src: "modules/defaultemblems/img/Cles_en_sautoir.svg",
    };
    exports.Coa_Illustration_Cross_Bowen_3 = {
        key: "Coa_Illustration_Cross_Bowen_3",
        src: "modules/defaultemblems/img/Coa_Illustration_Cross_Bowen_3.svg",
    };
    exports.Coa_Illustration_Cross_Malte_1 = {
        key: "Coa_Illustration_Cross_Malte_1",
        src: "modules/defaultemblems/img/Coa_Illustration_Cross_Malte_1.svg",
    };
    exports.Coa_Illustration_Elements_Planet_Moon = {
        key: "Coa_Illustration_Elements_Planet_Moon",
        src: "modules/defaultemblems/img/Coa_Illustration_Elements_Planet_Moon.svg",
    };
    exports.Couronne_heraldique_svg = {
        key: "Couronne_heraldique_svg",
        src: "modules/defaultemblems/img/Couronne_heraldique_svg.svg",
    };
    exports.Gomaisasa = {
        key: "Gomaisasa",
        src: "modules/defaultemblems/img/Gomaisasa.svg",
    };
    exports.Gryphon_Segreant = {
        key: "Gryphon_Segreant",
        src: "modules/defaultemblems/img/Gryphon_Segreant.svg",
    };
    exports.Heraldic_pentacle = {
        key: "Heraldic_pentacle",
        src: "modules/defaultemblems/img/Heraldic_pentacle.svg",
    };
    exports.Japanese_Crest_Futatsudomoe_1 = {
        key: "Japanese_Crest_Futatsudomoe_1",
        src: "modules/defaultemblems/img/Japanese_Crest_Futatsudomoe_1.svg",
    };
    exports.Japanese_Crest_Hana_Hisi = {
        key: "Japanese_Crest_Hana_Hisi",
        src: "modules/defaultemblems/img/Japanese_Crest_Hana_Hisi.svg",
    };
    exports.Japanese_Crest_Mitsumori_Janome = {
        key: "Japanese_Crest_Mitsumori_Janome",
        src: "modules/defaultemblems/img/Japanese_Crest_Mitsumori_Janome.svg",
    };
    exports.Japanese_Crest_Oda_ka = {
        key: "Japanese_Crest_Oda_ka",
        src: "modules/defaultemblems/img/Japanese_Crest_Oda_ka.svg",
    };
    exports.Japanese_crest_Tsuki_ni_Hoshi = {
        key: "Japanese_crest_Tsuki_ni_Hoshi",
        src: "modules/defaultemblems/img/Japanese_crest_Tsuki_ni_Hoshi.svg",
    };
    exports.Japanese_Crest_Ume = {
        key: "Japanese_Crest_Ume",
        src: "modules/defaultemblems/img/Japanese_Crest_Ume.svg",
    };
    exports.Mitsuuroko = {
        key: "Mitsuuroko",
        src: "modules/defaultemblems/img/Mitsuuroko.svg",
    };
    exports.Musubikashiwa = {
        key: "Musubikashiwa",
        src: "modules/defaultemblems/img/Musubi-kashiwa.svg",
    };
    exports.Takeda_mon = {
        key: "Takeda_mon",
        src: "modules/defaultemblems/img/Takeda_mon.svg",
    };
    exports.threeHorns = {
        key: "threeHorns",
        src: "modules/defaultemblems/img/threeHorns.svg",
    };
    exports.Flag_of_Edward_England = {
        key: "Flag_of_Edward_England",
        src: "modules/defaultemblems/img/Flag_of_Edward_England.svg",
        disallowRandomGeneration: true,
    };
    var SubEmblemTemplates = (_a = {},
        _a[exports.Aguila_explayada_2.key] = exports.Aguila_explayada_2,
        _a[exports.Berliner_Baer.key] = exports.Berliner_Baer,
        _a[exports.Cles_en_sautoir.key] = exports.Cles_en_sautoir,
        _a[exports.Coa_Illustration_Cross_Bowen_3.key] = exports.Coa_Illustration_Cross_Bowen_3,
        _a[exports.Coa_Illustration_Cross_Malte_1.key] = exports.Coa_Illustration_Cross_Malte_1,
        _a[exports.Coa_Illustration_Elements_Planet_Moon.key] = exports.Coa_Illustration_Elements_Planet_Moon,
        _a[exports.Couronne_heraldique_svg.key] = exports.Couronne_heraldique_svg,
        _a[exports.Gomaisasa.key] = exports.Gomaisasa,
        _a[exports.Gryphon_Segreant.key] = exports.Gryphon_Segreant,
        _a[exports.Heraldic_pentacle.key] = exports.Heraldic_pentacle,
        _a[exports.Japanese_Crest_Futatsudomoe_1.key] = exports.Japanese_Crest_Futatsudomoe_1,
        _a[exports.Japanese_Crest_Hana_Hisi.key] = exports.Japanese_Crest_Hana_Hisi,
        _a[exports.Japanese_Crest_Mitsumori_Janome.key] = exports.Japanese_Crest_Mitsumori_Janome,
        _a[exports.Japanese_Crest_Oda_ka.key] = exports.Japanese_Crest_Oda_ka,
        _a[exports.Japanese_crest_Tsuki_ni_Hoshi.key] = exports.Japanese_crest_Tsuki_ni_Hoshi,
        _a[exports.Japanese_Crest_Ume.key] = exports.Japanese_Crest_Ume,
        _a[exports.Mitsuuroko.key] = exports.Mitsuuroko,
        _a[exports.Musubikashiwa.key] = exports.Musubikashiwa,
        _a[exports.Takeda_mon.key] = exports.Takeda_mon,
        _a[exports.threeHorns.key] = exports.threeHorns,
        _a[exports.Flag_of_Edward_England.key] = exports.Flag_of_Edward_England,
        _a);
    exports.default = SubEmblemTemplates;
    var _a;
});
define("modules/defaultemblems/defaultEmblems", ["require", "exports", "modules/defaultemblems/SubEmblemTemplates", "src/App", "src/ModuleFileLoadingPhase"], function (require, exports, SubEmblemTemplates_1, App_15, ModuleFileLoadingPhase_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var defaultEmblems = {
        key: "defaultEmblems",
        metaData: {
            name: "Default Emblems",
            version: "0.1.0",
            author: "giraluna",
            description: "",
        },
        needsToBeLoadedBefore: ModuleFileLoadingPhase_9.default.Setup,
        supportedLanguages: "all",
        loadAssets: function (onLoaded) {
            var loader = new PIXI.loaders.Loader();
            for (var templateKey in SubEmblemTemplates_1.default) {
                var template = SubEmblemTemplates_1.default[templateKey];
                loader.add({
                    url: template.src,
                    loadType: 2,
                    xhrType: "png",
                });
            }
            loader.load(function (loader) {
                for (var templateKey in SubEmblemTemplates_1.default) {
                    var template = SubEmblemTemplates_1.default[templateKey];
                    var image = loader.resources[template.src].data;
                    App_15.default.images[template.src] = image;
                    if (!image.width) {
                        document.body.appendChild(image);
                        image.width = image.offsetWidth;
                        image.height = image.offsetHeight;
                        document.body.removeChild(image);
                    }
                }
                onLoaded();
            });
        },
        constructModule: function (moduleData) {
            moduleData.copyTemplates(SubEmblemTemplates_1.default, "SubEmblems");
            return moduleData;
        },
    };
    exports.default = defaultEmblems;
});
define("src/DamageType", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("modules/common/battlesfxfunctions/shaders/BlackToAlpha", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BlackToAlpha = (function (_super) {
        __extends(BlackToAlpha, _super);
        function BlackToAlpha(initialUniformValues) {
            var _this = this;
            var uniformData = BlackToAlpha.makeUniformDataObject(initialUniformValues);
            _this = _super.call(this, null, sourceLines.join("\n"), uniformData) || this;
            return _this;
        }
        BlackToAlpha.makeUniformDataObject = function (initialValues) {
            if (initialValues === void 0) { initialValues = {}; }
            return ({});
        };
        BlackToAlpha.prototype.setUniforms = function (uniforms) {
            for (var key in uniforms) {
                this.uniforms[key] = uniforms[key];
            }
        };
        return BlackToAlpha;
    }(PIXI.Filter));
    exports.default = BlackToAlpha;
    var sourceLines = [
        "precision mediump float;",
        "",
        "varying vec2 vTextureCoord;",
        "uniform sampler2D uSampler;",
        "",
        "void main()",
        "{",
        "  vec4 color = texture2D(uSampler, vTextureCoord);",
        "  color.a = (color.r + color.g + color.b) / 3.0;",
        "",
        "  gl_FragColor = color;",
        "}",
    ];
});
define("modules/common/battlesfxfunctions/shaders/ShinyParticle", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ShinyParticle = (function (_super) {
        __extends(ShinyParticle, _super);
        function ShinyParticle(initialUniformValues) {
            var _this = this;
            var uniformData = ShinyParticle.makeUniformDataObject(initialUniformValues);
            _this = _super.call(this, null, sourceLines.join("\n"), uniformData) || this;
            return _this;
        }
        ShinyParticle.makeUniformDataObject = function (initialValues) {
            if (initialValues === void 0) { initialValues = {}; }
            return ({
                highlightIntensity: { type: "float", value: initialValues.highlightIntensity },
                spikeColor: { type: "vec4", value: initialValues.spikeColor },
                spikeIntensity: { type: "float", value: initialValues.spikeIntensity },
            });
        };
        ShinyParticle.prototype.setUniforms = function (uniforms) {
            for (var key in uniforms) {
                this.uniforms[key] = uniforms[key];
            }
        };
        return ShinyParticle;
    }(PIXI.Filter));
    exports.default = ShinyParticle;
    var sourceLines = [
        "precision mediump float;",
        "",
        "#define DOMAIN 0 // 0 == pixi, 1 == shdr.bkcore.com",
        "",
        "#if DOMAIN == 0",
        "  varying vec2 vTextureCoord;",
        "  uniform sampler2D uSampler;",
        "",
        "  uniform float spikeIntensity;",
        "  uniform float highlightIntensity;",
        "  uniform vec4 spikeColor;",
        "#elif DOMAIN == 1",
        "  uniform vec2 resolution;",
        "",
        "  const float spikeIntensity = 1.0;",
        "  const float highlightIntensity = 0.1;",
        "  const vec4 spikeColor = vec4(0.3686274509803922, 0.792156862745098, 0.6941176470588235, 1.0);",
        "#endif",
        "",
        "",
        "const vec4 highlightColor = vec4(1.0, 1.0, 1.0, 1.0);",
        "const vec2 center = vec2(0.5, 0.5);",
        "const float angle = -0.1 * 3.141592;",
        "",
        "float spike(vec2 q)",
        "{",
        "  vec2 rotated;",
        "  rotated.x = cos(angle) * q.x - sin(angle) * q.y;",
        "  rotated.y = sin(angle) * q.x + cos(angle) * q.y;",
        "",
        "  float xStrength = max(0.5 - abs(rotated.x), 0.0);",
        "  float yStrength = max(0.5 - abs(rotated.y), 0.0);",
        "",
        "  return xStrength + yStrength;",
        "}",
        "",
        "void main()",
        "{",
        "  #if DOMAIN == 0",
        "    vec2 uv = vTextureCoord;",
        "    vec4 color = texture2D(uSampler, uv);",
        "  #elif DOMAIN == 1",
        "    vec2 uv = gl_FragCoord.xy / resolution;",
        "    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);",
        "  #endif",
        "",
        "  vec2 q = uv - 0.5;",
        "  // q *= 2.5;",
        "",
        "  float dist = length(q);",
        "",
        "  float spikeStrength = spike(q);",
        "  spikeStrength -= dist;",
        "  spikeStrength = pow(spikeStrength, 1.5);",
        "  spikeStrength *= spikeIntensity;",
        "",
        "  color += spikeColor * spikeStrength;",
        "",
        "",
        "  // center highlight",
        "  float highlightStrength = 1.0 - dist;",
        "  highlightStrength = pow(highlightStrength, 8.0);",
        "  highlightStrength *= highlightIntensity;",
        "",
        "  color += highlightColor * highlightStrength;",
        "",
        "",
        "  gl_FragColor = color;",
        "}",
    ];
});
define("modules/common/battlesfxfunctions/ProtonWrapper", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ProtonWrapper = (function () {
        function ProtonWrapper(renderer, container) {
            this.emitters = {};
            this.emitterKeysById = {};
            this.onSpriteCreated = {};
            this.onParticleUpdated = {};
            this.proton = new Proton();
            this.pixiRenderer = renderer;
            this.container = container;
            this.initProtonRenderer();
        }
        ProtonWrapper.prototype.destroy = function () {
            this.pixiRenderer = null;
            for (var key in this.emitters) {
                this.removeEmitterWithKey(key);
            }
            this.emitters = {};
            this.protonRenderer.stop();
            this.proton.destroy();
            this.proton = null;
        };
        ProtonWrapper.prototype.initProtonRenderer = function () {
            var renderer = this.protonRenderer = new Proton.Renderer("other", this.proton);
            renderer.onParticleCreated = this.onProtonParticleCreated.bind(this);
            renderer.onParticleUpdate = this.onProtonParticleUpdated.bind(this);
            renderer.onParticleDead = this.onProtonParticleDead.bind(this);
            renderer.start();
        };
        ProtonWrapper.prototype.onProtonParticleCreated = function (particle) {
            var sprite = new PIXI.Sprite(particle.target);
            sprite.anchor.x = 0.5;
            sprite.anchor.y = 0.5;
            particle.sprite = sprite;
            var emitter = particle.parent;
            var emitterKey = this.emitterKeysById[emitter.id];
            if (this.onSpriteCreated[emitterKey]) {
                this.onSpriteCreated[emitterKey](sprite);
            }
            this.container.addChild(sprite);
        };
        ProtonWrapper.prototype.onProtonParticleUpdated = function (particle) {
            if (particle.parent) {
                var emitter = particle.parent;
                var emitterKey = this.emitterKeysById[emitter.id];
                if (this.onParticleUpdated[emitterKey]) {
                    this.onParticleUpdated[emitterKey](particle);
                }
            }
        };
        ProtonWrapper.prototype.onProtonParticleDead = function (particle) {
            this.container.removeChild(particle.sprite);
        };
        ProtonWrapper.prototype.destroyEmitter = function (emitter) {
            emitter.stopEmit();
            emitter.removeAllParticles();
            emitter.destroy();
        };
        ProtonWrapper.prototype.addEmitter = function (emitter, key) {
            this.emitters[key] = emitter;
            this.emitterKeysById[emitter.id] = key;
            this.proton.addEmitter(emitter);
        };
        ProtonWrapper.prototype.getEmitterKeyWithId = function (id) {
            return this.emitterKeysById[id];
        };
        ProtonWrapper.prototype.getEmitterKey = function (emitter) {
            return this.getEmitterKeyWithId(emitter.id) || null;
        };
        ProtonWrapper.prototype.removeEmitterWithKey = function (key) {
            var emitter = this.emitters[key];
            this.destroyEmitter(emitter);
            this.emitterKeysById[emitter.id] = null;
            delete this.emitterKeysById[emitter.id];
            this.emitters[key] = null;
            delete this.emitters[key];
        };
        ProtonWrapper.prototype.removeEmitter = function (emitter) {
            this.removeEmitterWithKey(this.getEmitterKey(emitter));
        };
        ProtonWrapper.prototype.addInitializeToExistingParticles = function (emitter, initialize) {
            emitter.particles.forEach(function (particle) {
                initialize.initialize(particle);
            });
            emitter.addInitialize(initialize);
        };
        ProtonWrapper.prototype.update = function () {
            this.proton.update();
        };
        return ProtonWrapper;
    }());
    exports.default = ProtonWrapper;
});
define("modules/common/battlesfxfunctions/beam", ["require", "exports", "modules/common/battlesfxfunctions/shaders/ShinyParticle", "modules/common/battlesfxfunctions/sfxfragments/Beam", "modules/common/battlesfxfunctions/sfxfragments/LightBurst", "modules/common/battlesfxfunctions/sfxfragments/RampingValue", "modules/common/battlesfxfunctions/sfxfragments/ShockWave", "src/Color", "src/pixiWrapperFunctions", "modules/common/battlesfxfunctions/ProtonWrapper"], function (require, exports, ShinyParticle_1, Beam_4, LightBurst_3, RampingValue_5, ShockWave_2, Color_10, pixiWrapperFunctions_7, ProtonWrapper_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function beam(props) {
        var offsetUserData = props.user.drawingFunctionData.normalizeForBattleSFX(props.userOffset, props.width, "user");
        var mainContainer = new PIXI.Container();
        var impactHasOccurred = false;
        var relativeImpactTime = 0.18;
        var beamOrigin = offsetUserData.singleAttackOriginPoint;
        var relativeBeamOrigin = {
            x: beamOrigin.x / props.width,
            y: beamOrigin.y / props.height,
        };
        var renderTexture = PIXI.RenderTexture.create(props.width, props.height);
        var renderedSprite = new PIXI.Sprite(renderTexture);
        if (!props.facingRight) {
            renderedSprite.x = props.width;
            renderedSprite.scale.x = -1;
        }
        var finalColor = [
            0.368627450980392,
            0.792156862745098,
            0.694117647058823,
            1.0,
        ];
        var particleContainer = new PIXI.Container();
        mainContainer.addChild(particleContainer);
        var protonWrapper = new ProtonWrapper_1.default(props.renderer, particleContainer);
        var particleShaderColor = {
            r: 1.0,
            g: 1.0,
            b: 1.0,
            a: 1.0,
        };
        var particleShaderColorArray = [
            particleShaderColor.r,
            particleShaderColor.g,
            particleShaderColor.b,
            particleShaderColor.a,
        ];
        var particleShaderColorTween = new TWEEN.Tween(particleShaderColor).to({
            r: finalColor[0],
            g: finalColor[1],
            b: finalColor[2],
            a: 1.0,
        }, props.duration / 2);
        var particlesAmountScale = props.width / 700;
        var beamFragment = new Beam_4.default({
            color: new Color_10.default(finalColor[0], finalColor[1], finalColor[2]),
            relativeImpactTime: relativeImpactTime,
            relativeBeamOrigin: relativeBeamOrigin,
            size: {
                x: props.width,
                y: props.height,
            },
            timeScale: 100,
            noiseAmplitude: new RampingValue_5.default(0.0, 0.4, -0.4),
            lineIntensity: new RampingValue_5.default(2.0, 5.0, -5.0),
            bulgeIntensity: new RampingValue_5.default(0.0, 6.0, -6.0),
            bulgeSizeX: new RampingValue_5.default(0.0, 0.7, -0.7),
            bulgeSizeY: new RampingValue_5.default(0.0, 0.4, -0.4),
            lineYSize: new RampingValue_5.default(0.01, 0.2, -0.21),
            bulgeSharpness: new RampingValue_5.default(0.3, 0.35, -0.35),
            lineXSharpness: new RampingValue_5.default(0.99, -0.99, 0.99),
            lineYSharpness: new RampingValue_5.default(0.99, -0.15, 0.16),
        });
        beamFragment.draw();
        mainContainer.addChild(beamFragment.displayObject);
        var onParticleUpdateFN = function (particle) {
            var sprite = particle.sprite;
            sprite.position.x = particle.p.x;
            sprite.position.y = particle.p.y;
            sprite.scale.x = particle.scale;
            sprite.scale.y = particle.scale;
        };
        var smallEmitter = new Proton.BehaviourEmitter();
        smallEmitter.p.x = beamOrigin.x + 50;
        smallEmitter.p.y = beamOrigin.y;
        smallEmitter.damping = 0.013;
        var smallParticleGraphicsSize = {
            x: 4,
            y: 4,
        };
        var smallParticleGraphics = new PIXI.Graphics();
        smallParticleGraphics.beginFill(0x5ECAB1, 1.0);
        smallParticleGraphics.drawRect(smallParticleGraphicsSize.x / 2, smallParticleGraphicsSize.y / 2, smallParticleGraphicsSize.x, smallParticleGraphicsSize.y);
        smallParticleGraphics.endFill();
        var smallParticleTexture = pixiWrapperFunctions_7.generateTextureWithBounds(props.renderer, smallParticleGraphics, PIXI.settings.SCALE_MODE, 1, new PIXI.Rectangle(0, 0, smallParticleGraphicsSize.x * 1.5, smallParticleGraphicsSize.y * 1.5));
        smallEmitter.addInitialize(new Proton.ImageTarget(smallParticleTexture));
        smallEmitter.addInitialize(new Proton.Velocity(new Proton.Span(2.5, 3.5), new Proton.Span(270, 35, true), "polar"));
        smallEmitter.addInitialize(new Proton.Position(new Proton.RectZone(0, -30, props.width + 100 - smallEmitter.p.x, 30)));
        smallEmitter.addInitialize(new Proton.Life(new Proton.Span(props.duration * (1.0 - relativeImpactTime) / 6000, props.duration * (1.0 - relativeImpactTime) / 3000)));
        smallEmitter.addBehaviour(new Proton.Scale(new Proton.Span(0.8, 1), 0));
        smallEmitter.addBehaviour(new Proton.RandomDrift(20, 30, props.duration / 2000));
        protonWrapper.addEmitter(smallEmitter, "smallParticles");
        var smallParticleFilter = new ShinyParticle_1.default();
        var syncSmallParticleUniforms = function (time) {
            var lifeLeft = 1.0 - time;
            smallParticleFilter.setUniforms({
                spikeColor: particleShaderColorArray,
                spikeIntensity: Math.pow(lifeLeft, 1.5) * 0.4,
                highlightIntensity: Math.pow(lifeLeft, 1.5),
            });
        };
        protonWrapper.onParticleUpdated["smallParticles"] = onParticleUpdateFN;
        protonWrapper.onSpriteCreated["smallParticles"] = function (sprite) {
            pixiWrapperFunctions_7.attachShaderToSprite(sprite, smallParticleFilter);
            sprite.blendMode = PIXI.BLEND_MODES.SCREEN;
        };
        var shinyEmitter = new Proton.BehaviourEmitter();
        shinyEmitter.p.x = beamOrigin.x;
        shinyEmitter.p.y = beamOrigin.y;
        var shinyParticleTexture = pixiWrapperFunctions_7.getDummyTextureForShader();
        shinyEmitter.addInitialize(new Proton.ImageTarget(shinyParticleTexture));
        var shinyEmitterLifeInitialize = new Proton.Life(new Proton.Span(props.duration / 3000, props.duration / 1000));
        shinyEmitter.addInitialize(shinyEmitterLifeInitialize);
        shinyEmitter.damping = 0.009;
        var emitterZone = new Proton.RectZone(0, -5, props.width + 100 - shinyEmitter.p.x, 5);
        shinyEmitter.addInitialize(new Proton.Position(emitterZone));
        shinyEmitter.addBehaviour(new Proton.Scale(new Proton.Span(60, 100), 0));
        protonWrapper.addEmitter(shinyEmitter, "shinyParticles");
        var shinyParticleFilter = new ShinyParticle_1.default();
        var syncShinyParticleUniforms = function (time) {
            var lifeLeft = 1.0 - time;
            shinyParticleFilter.setUniforms({
                spikeColor: particleShaderColorArray,
                spikeIntensity: 1 - time * 0.1,
                highlightIntensity: Math.pow(lifeLeft, 2.0),
            });
        };
        protonWrapper.onParticleUpdated["shinyParticles"] = onParticleUpdateFN;
        protonWrapper.onSpriteCreated["shinyParticles"] = function (sprite) {
            pixiWrapperFunctions_7.attachShaderToSprite(sprite, shinyParticleFilter);
            sprite.blendMode = PIXI.BLEND_MODES.SCREEN;
        };
        shinyEmitter.rate = new Proton.Rate(150 * particlesAmountScale, 0);
        shinyEmitter.emit("once");
        var shockWaveSize = {
            x: props.width * 3.0,
            y: props.height * 3.0,
        };
        var shockWaveFragment = new ShockWave_2.default({
            size: shockWaveSize,
            intersectingEllipseOrigin: { x: 0.05, y: 0.0 },
            intersectingEllipseDrift: { x: 0.3, y: 0.0 },
            alpha: new RampingValue_5.default(1.0, -1.0, 0.0),
            mainEllipseScaleX: new RampingValue_5.default(0.0, 0.3, 0.0),
            mainEllipseScaleY: new RampingValue_5.default(0.0, 0.9, 0.0),
            mainEllipseSharpness: new RampingValue_5.default(0.95, -0.15, 0.0),
            intersectingEllipseScaleX: new RampingValue_5.default(0.0, 0.8, 0.0),
            intersectingEllipseScaleY: new RampingValue_5.default(0.0, 1.0, 0.0),
            intersectingEllipseSharpness: new RampingValue_5.default(0.8, -0.4, 0.0),
            color: new Color_10.default(1.0, 1.0, 1.0),
            delay: relativeImpactTime,
        });
        shockWaveFragment.draw();
        shockWaveFragment.position.set(beamOrigin.x - shockWaveSize.x / 2, beamOrigin.y - shockWaveSize.y / 2);
        mainContainer.addChild(shockWaveFragment.displayObject);
        var lightBurstSize = {
            x: props.height * 1.5,
            y: props.height * 3,
        };
        var lightBurstFragment = new LightBurst_3.default({
            size: lightBurstSize,
            delay: relativeImpactTime,
            sharpness: 2.0,
            color: new Color_10.default(0.75, 0.75, 0.62),
            centerSize: 1.0,
            rayStrength: 1.0,
        });
        lightBurstFragment.draw();
        lightBurstFragment.position.set(beamOrigin.x - lightBurstSize.x / 2, beamOrigin.y - lightBurstSize.y / 2);
        mainContainer.addChild(lightBurstFragment.displayObject);
        function animate() {
            var elapsedTime = Date.now() - startTime;
            protonWrapper.update();
            var tweenTime = window.performance.now();
            particleShaderColorTween.update(tweenTime);
            particleShaderColorArray[0] = particleShaderColor.r;
            particleShaderColorArray[1] = particleShaderColor.g;
            particleShaderColorArray[2] = particleShaderColor.b;
            particleShaderColorArray[3] = particleShaderColor.a;
            var relativeElapsedTime = elapsedTime / props.duration;
            var lifeLeft = 1 - relativeElapsedTime;
            if (relativeElapsedTime >= relativeImpactTime - 0.02) {
                if (!impactHasOccurred) {
                    impactHasOccurred = true;
                    var lifeLeftInSeconds = props.duration * lifeLeft / 1000;
                    var emitterLife = lifeLeftInSeconds * 0.8;
                    var velocityInitialize = new Proton.Velocity(new Proton.Span(1.5, 3), new Proton.Span(270, 25, true), "polar");
                    protonWrapper.addInitializeToExistingParticles(shinyEmitter, velocityInitialize);
                    shinyEmitter.removeInitialize(shinyEmitterLifeInitialize);
                    shinyEmitter.addInitialize(new Proton.Life(new Proton.Span(emitterLife / 4, emitterLife / 2.5)));
                    shinyEmitter.rate = new Proton.Rate(4 * particlesAmountScale, 0.02);
                    shinyEmitter.life = emitterLife;
                    shinyEmitter.emit();
                    smallEmitter.rate = new Proton.Rate(6 * particlesAmountScale, 0.02);
                    smallEmitter.life = emitterLife;
                    smallEmitter.emit();
                    props.triggerEffect();
                }
                syncSmallParticleUniforms(relativeElapsedTime);
            }
            beamFragment.animate(relativeElapsedTime);
            syncShinyParticleUniforms(relativeElapsedTime);
            shockWaveFragment.animate(relativeElapsedTime);
            lightBurstFragment.animate(relativeElapsedTime);
            props.renderer.render(mainContainer, renderTexture, true);
            if (elapsedTime < props.duration) {
                requestAnimationFrame(animate);
            }
            else {
                smallParticleTexture.destroy(true);
                protonWrapper.destroy();
                props.triggerEnd();
            }
        }
        props.triggerStart(renderedSprite);
        var startTime = Date.now();
        particleShaderColorTween.start();
        animate();
    }
    exports.default = beam;
});
define("modules/common/battlesfxfunctions/shaders/Guard", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Guard = (function (_super) {
        __extends(Guard, _super);
        function Guard(initialUniformValues) {
            var _this = this;
            var uniformData = Guard.makeUniformDataObject(initialUniformValues);
            _this = _super.call(this, null, sourceLines.join("\n"), uniformData) || this;
            return _this;
        }
        Guard.makeUniformDataObject = function (initialValues) {
            if (initialValues === void 0) { initialValues = {}; }
            return ({
                blockAlpha: { type: "float", value: initialValues.blockAlpha },
                blockSize: { type: "float", value: initialValues.blockSize },
                blockWidth: { type: "float", value: initialValues.blockWidth },
                frontier: { type: "float", value: initialValues.frontier },
                lineAlpha: { type: "float", value: initialValues.lineAlpha },
                seed: { type: "float", value: initialValues.seed },
                trailDistance: { type: "float", value: initialValues.trailDistance },
            });
        };
        Guard.prototype.setUniforms = function (uniforms) {
            for (var key in uniforms) {
                this.uniforms[key] = uniforms[key];
            }
        };
        return Guard;
    }(PIXI.Filter));
    exports.default = Guard;
    var sourceLines = [
        "precision mediump float;",
        "",
        "uniform float frontier;",
        "uniform float trailDistance;",
        "uniform float seed;",
        "uniform float blockSize;",
        "uniform float blockWidth;",
        "uniform float lineAlpha;",
        "uniform float blockAlpha;",
        "",
        "",
        "float minX = frontier - trailDistance;",
        "float maxX = frontier + 20.0;",
        "float frontGradientStart = frontier + 17.0;",
        "float blockEnd = maxX;",
        "",
        "float hash(float n)",
        "{",
        "  return fract(sin(n) * 1e4);",
        "}",
        "float hash(vec2 p)",
        "{",
        "  return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x))));",
        "}",
        "",
        "float noise(vec2 x)",
        "{",
        "  vec2 i = floor(x);",
        "  vec2 f = fract(x);",
        "  float a = hash(i);",
        "  float b = hash(i + vec2(1.0, 0.0));",
        "  float c = hash(i + vec2(0.0, 1.0));",
        "  float d = hash(i + vec2(1.0, 1.0));",
        "  vec2 u = f * f * (3.0 - 2.0 * f);",
        "  return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;",
        "}",
        "",
        "",
        "vec4 makeLines(vec2 coord)",
        "{",
        "  float gradientAlpha = smoothstep(minX, frontier, coord.x);",
        "  gradientAlpha -= smoothstep(frontGradientStart, maxX, coord.x);",
        "  gradientAlpha += 0.5 * gradientAlpha;",
        "",
        "  float n = noise(vec2(seed, coord.y));",
        "  n = pow(n, 3.5);",
        "  float alpha = n * gradientAlpha;",
        "",
        "",
        "  float r = hash(vec2(seed, coord.y));",
        "  r = clamp(r, 0.8, 0.9) * alpha;",
        "  float g = (r + 0.7 - r) * alpha;",
        "  float b = smoothstep(0.0, 0.28, alpha);",
        "",
        "  return vec4(r, g, b, alpha);",
        "}",
        "",
        "vec4 makeBlocks(vec2 coord)",
        "{",
        "  vec4 lineColor = makeLines(vec2(frontier, coord.y));",
        "  float h = hash(vec2(seed, coord.y));",
        "  float blockWidth = blockWidth * (h / 2.0 + 0.5);",
        "",
        "  float blockStart = frontier - blockWidth;",
        "  float alpha = step(0.01, mod(smoothstep(blockStart, blockEnd, coord.x), 1.0));",
        "",
        "",
        "  return lineColor * alpha;",
        "}",
        "",
        "void main()",
        "{",
        "  vec4 lineColor = makeLines(gl_FragCoord.xy);",
        "",
        "  vec4 blockColor = vec4(0.0);",
        "",
        "  for (float i = 0.0; i < 10.0; i += 1.0)",
        "  {",
        "    float y = gl_FragCoord.y + hash(i) * blockSize * 20.0;",
        "    float blockY = floor(y / blockSize);",
        "    blockColor += makeBlocks(vec2(gl_FragCoord.x, blockY)) * 0.2;",
        "  }",
        "",
        "  gl_FragColor = lineColor * lineAlpha + blockColor * blockAlpha;",
        "}",
    ];
});
define("modules/common/battlesfxfunctions/guard", ["require", "exports", "modules/common/battlesfxfunctions/shaders/Guard", "src/utility"], function (require, exports, Guard_1, utility_56) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function guard(props) {
        var offsetUserData = props.user.drawingFunctionData.normalizeForBattleSFX(props.userOffset, props.width, "user");
        var userX2 = offsetUserData.boundingBox.x + offsetUserData.boundingBox.width;
        var maxFrontier = Math.min(userX2 + 75, props.width / 2.2);
        var baseTrailDistance = 80;
        var maxTrailDistance = maxFrontier;
        var trailDistanceGrowth = maxTrailDistance - baseTrailDistance;
        var maxBlockWidth = maxFrontier * 2;
        var guardFilter = new Guard_1.default({
            frontier: 0,
            trailDistance: baseTrailDistance,
            seed: Math.random() * 420,
            blockSize: 90,
            blockWidth: 0,
            lineAlpha: 1.5,
            blockAlpha: 0,
        });
        var travelTime = 0.3;
        var hasTriggeredEffect = false;
        var syncUniformsFN = function (time) {
            if (time < travelTime) {
                var adjustedtime = time / travelTime;
                guardFilter.setUniforms({
                    frontier: maxFrontier * adjustedtime,
                });
            }
            else {
                if (props.triggerEffect && !hasTriggeredEffect) {
                    hasTriggeredEffect = true;
                    props.triggerEffect();
                }
                var relativeTime = utility_56.getRelativeValue(time, travelTime - 0.02, 1);
                var adjustedtime = Math.pow(relativeTime, 4);
                var relativeDistance = utility_56.getRelativeValue(Math.abs(0.2 - adjustedtime), 0, 0.8);
                guardFilter.setUniforms({
                    trailDistance: baseTrailDistance + trailDistanceGrowth * adjustedtime,
                    blockWidth: adjustedtime * maxBlockWidth,
                    lineAlpha: (1 - adjustedtime) * 1.5,
                    blockAlpha: 1 - relativeDistance,
                });
            }
        };
        var container = new PIXI.Container();
        container.filters = [guardFilter];
        container.filterArea = new PIXI.Rectangle(0, 0, maxFrontier + 20, props.height);
        var renderTexture = PIXI.RenderTexture.create(props.width, props.height);
        var sprite = new PIXI.Sprite(renderTexture);
        if (!props.facingRight) {
            sprite.x = props.width;
            sprite.scale.x = -1;
        }
        function animate() {
            var elapsedTime = Date.now() - startTime;
            var relativeTime = elapsedTime / props.duration;
            syncUniformsFN(relativeTime);
            props.renderer.render(container, renderTexture, true);
            if (elapsedTime < props.duration) {
                requestAnimationFrame(animate);
            }
            else {
                props.triggerEnd();
            }
        }
        props.triggerStart(sprite);
        var startTime = Date.now();
        animate();
    }
    exports.default = guard;
});
define("modules/common/battlesfxfunctions/makeSFXFromVideo", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeSFXFromVideo(videoSrc, onStartFN, props) {
        function clearBaseTextureListeners() {
            baseTexture.removeListener("loaded", onVideoLoaded);
            baseTexture.removeListener("error", onVideoError);
        }
        function onVideoLoaded() {
            clearBaseTextureListeners();
            baseTexture.autoUpdate = false;
            sprite.y = props.height - baseTexture.source.videoHeight;
            if (onStartFN) {
                onStartFN(sprite);
            }
            props.triggerStart(sprite);
            animate();
        }
        function onVideoError() {
            clearBaseTextureListeners();
            throw new Error("Video " + videoSrc + " failed to load.");
        }
        var baseTexture = PIXI.VideoBaseTexture.fromUrl(videoSrc);
        var texture = new PIXI.Texture(baseTexture);
        var sprite = new PIXI.Sprite(texture);
        if (!props.facingRight) {
            sprite.x = props.width;
            sprite.scale.x = -1;
        }
        if (baseTexture.hasLoaded) {
            onVideoLoaded();
        }
        else if (baseTexture.isLoading) {
            baseTexture.on("loaded", onVideoLoaded);
            baseTexture.on("error", onVideoError);
        }
        else {
            onVideoError();
        }
        function animate() {
            baseTexture.update();
            if (!baseTexture.source.paused && !baseTexture.source.ended) {
                requestAnimationFrame(animate);
            }
            else {
                props.triggerEnd();
                sprite.parent.removeChild(sprite);
                sprite.destroy({ texture: true, baseTexture: true });
            }
        }
    }
    exports.default = makeSFXFromVideo;
});
define("modules/common/battlesfxfunctions/placeholder", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function placeholder(params) {
        var container = new PIXI.Container();
        var sprite = PIXI.Sprite.fromImage("img/placeholder.png");
        sprite.anchor.set(0.5, 0.5);
        sprite.x = params.width / 2;
        sprite.y = params.height / 2;
        container.addChild(sprite);
        var startTime = performance.now();
        var endTime = startTime + params.duration;
        function animate(currentTime) {
            if (currentTime < endTime) {
                requestAnimationFrame(animate);
            }
            else {
                params.triggerEnd();
            }
        }
        params.triggerStart(container);
        animate(startTime);
    }
    exports.placeholder = placeholder;
});
define("modules/common/battlesfxfunctions/sfxfragments/ProjectileAttack", ["require", "exports", "modules/common/battlesfxfunctions/sfxfragments/SFXFragment", "modules/common/battlesfxfunctions/sfxfragments/props/PropInfoClasses", "src/utility"], function (require, exports, SFXFragment_5, PropInfo, utility_57) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Projectile = (function () {
        function Projectile(props) {
            this.hasImpacted = false;
            this.id = props.id;
            this.container = props.container;
            this.sprite = props.sprite;
            this.spawnTime = props.spawnTime;
            this.maxSpeed = props.maxSpeed;
            this.acceleration = props.acceleration;
            this.spawnPositionX = props.spawnPositionX;
            this.animateProjectile = props.animateProjectile;
            this.onImpact = props.onImpact;
            this.animateImpact = props.animateImpact;
            this.impactPosition = props.impactPosition;
            this.removeAfterImpact = props.removeAfterImpact;
            this.willImpact = isFinite(this.impactPosition);
            this.container.addChild(this.sprite);
            this.sprite.visible = false;
        }
        Projectile.prototype.draw = function (time) {
            var position = this.getPosition(time);
            var tipPosition = position + this.sprite.width;
            var hasReachedImpactPosition = this.willImpact &&
                tipPosition >= this.impactPosition;
            if (hasReachedImpactPosition) {
                if (!this.hasImpacted) {
                    this.hasImpacted = true;
                    if (this.onImpact) {
                        this.onImpact(this, this.container, time);
                    }
                }
                if (this.animateImpact) {
                    this.animateImpact(this, this.container, time);
                }
            }
            var shouldDraw = time >= this.spawnTime &&
                (!this.hasImpacted || !this.removeAfterImpact);
            if (!shouldDraw) {
                this.sprite.visible = false;
            }
            else {
                this.sprite.visible = true;
                this.sprite.position.x = position;
                if (this.animateProjectile) {
                    this.animateProjectile(this, time);
                }
            }
        };
        Projectile.prototype.getPosition = function (relativeTime) {
            var time = relativeTime - this.spawnTime;
            if (time < 0) {
                return undefined;
            }
            var timeForMaxSpeed = this.spawnTime + this.maxSpeed / this.acceleration;
            var timeAccelerated = Math.min(time, timeForMaxSpeed);
            var positionBeforeMaxSpeed = this.spawnPositionX +
                0.5 * this.acceleration * Math.pow(timeAccelerated, 2.0);
            if (time <= timeForMaxSpeed) {
                return positionBeforeMaxSpeed;
            }
            else {
                var timeAfterReachingMaxSpeed = time - timeForMaxSpeed;
                return positionBeforeMaxSpeed + timeAfterReachingMaxSpeed * this.maxSpeed;
            }
        };
        return Projectile;
    }());
    var ProjectileAttack = (function (_super) {
        __extends(ProjectileAttack, _super);
        function ProjectileAttack(props) {
            var _this = _super.call(this) || this;
            _this.displayName = "ProjectileAttack";
            _this.key = "projectileAttack";
            _this.propInfo = {
                makeProjectileSprite: new PropInfo.Function(undefined),
                animateProjectile: new PropInfo.Function(undefined),
                onImpact: new PropInfo.Function(undefined),
                animateImpact: new PropInfo.Function(undefined),
                useSequentialAttackOriginPoints: new PropInfo.Boolean(true),
                removeAfterImpact: new PropInfo.Boolean(true),
                impactRate: new PropInfo.Number(0.75),
                impactPosition: new PropInfo.Range({ min: 0.7, max: 1.0 }),
                maxSpeed: new PropInfo.Number(3),
                acceleration: new PropInfo.Number(0.05),
                amountToSpawn: new PropInfo.Number(20),
                spawnTimeStart: new PropInfo.Number(0),
                spawnTimeEnd: new PropInfo.Number(500),
            };
            _this.initializeProps(props);
            _this.container = new PIXI.Container();
            return _this;
        }
        ProjectileAttack.prototype.animate = function (time) {
            this.projectiles.forEach(function (projectile) {
                projectile.draw(time);
            });
        };
        ProjectileAttack.prototype.draw = function (userData, targetData) {
            this.container.removeChildren();
            this.projectiles = [];
            var spawningDuration = this.props.spawnTimeEnd - this.props.spawnTimeStart;
            for (var i = 0; i < this.props.amountToSpawn; i++) {
                var sprite = this.props.makeProjectileSprite(i);
                var spawnPosition = this.props.useSequentialAttackOriginPoints ?
                    userData.sequentialAttackOriginPoints[i % userData.sequentialAttackOriginPoints.length] :
                    userData.singleAttackOriginPoint;
                sprite.position.y = spawnPosition.y;
                sprite.anchor.set(0, 0.5);
                this.projectiles.push(new Projectile({
                    id: i,
                    container: this.container,
                    sprite: sprite,
                    spawnTime: this.props.spawnTimeStart + i * (spawningDuration / this.props.amountToSpawn),
                    spawnPositionX: spawnPosition.x,
                    maxSpeed: this.props.maxSpeed,
                    acceleration: this.props.acceleration,
                    animateProjectile: this.props.animateProjectile,
                    onImpact: this.props.onImpact,
                    animateImpact: this.props.animateImpact,
                    impactPosition: utility_57.randInt(this.props.impactPosition.min, this.props.impactPosition.max),
                    removeAfterImpact: this.props.removeAfterImpact,
                }));
            }
            this.setDisplayObject(this.container);
        };
        return ProjectileAttack;
    }(SFXFragment_5.default));
    exports.default = ProjectileAttack;
});
define("modules/common/battlesfxfunctions/rocketAttack", ["require", "exports", "modules/common/battlesfxfunctions/sfxfragments/ProjectileAttack"], function (require, exports, ProjectileAttack_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var hasLoaded = false;
    function rocketAttack(params) {
        if (hasLoaded) {
            playRocketAttack(params);
        }
        else {
            loadRocketAttack(function () {
                playRocketAttack(params);
            });
        }
    }
    exports.default = rocketAttack;
    var rocketUrl = "modules/common/battlesfxfunctions/img/rocket.png";
    function playRocketAttack(params) {
        var offsetTargetData = params.target.drawingFunctionData.normalizeForBattleSFX(params.targetOffset, params.width, "target");
        var offsetUserData = params.user.drawingFunctionData.normalizeForBattleSFX(params.userOffset, params.width, "user");
        var container = new PIXI.Container();
        if (!params.facingRight) {
            container.x = params.width;
            container.scale.x = -1;
        }
        var startTime = Date.now();
        var impactHasOccurred = false;
        var maxSpeedAt1000Duration = params.width * params.duration / 30;
        var maxSpeed = maxSpeedAt1000Duration * (1000 / params.duration);
        var acceleration = maxSpeed / 6;
        var explosionTextures = [];
        for (var i = 0; i < 26; i++) {
            var explosionTexture = PIXI.Texture.fromFrame("Explosion_Sequence_A " + (i + 1) + ".png");
            explosionTextures.push(explosionTexture);
        }
        var explosionsById = {};
        var relativeTimePerSecond = 1000 / params.duration;
        var relativeTimePerExplosionFrame = relativeTimePerSecond / 60;
        var projectileAttackFragment = new ProjectileAttack_1.default({
            makeProjectileSprite: function (i) {
                return new PIXI.Sprite(PIXI.Texture.fromFrame(rocketUrl));
            },
            maxSpeed: maxSpeed,
            acceleration: acceleration,
            amountToSpawn: offsetUserData.sequentialAttackOriginPoints.length > 1 ?
                offsetUserData.sequentialAttackOriginPoints.length :
                8,
            spawnTimeStart: 0,
            spawnTimeEnd: 0.4,
            removeAfterImpact: true,
            impactRate: 0.8,
            onImpact: function (projectile, container, time) {
                if (!impactHasOccurred) {
                    params.triggerEffect();
                    impactHasOccurred = true;
                }
                var remainingTime = 1 - time;
                var remainingTimePerFrame = remainingTime / explosionTextures.length;
                explosionsById[projectile.id] =
                    {
                        clip: new PIXI.extras.AnimatedSprite(explosionTextures),
                        startTime: time,
                        relativeTimePerFrame: Math.min(relativeTimePerExplosionFrame, remainingTimePerFrame),
                    };
                var explosionClip = explosionsById[projectile.id].clip;
                explosionClip.anchor.set(0.5, 0.5);
                explosionClip.loop = false;
                explosionClip.position.copy(projectile.sprite.position);
                explosionClip.position.x += projectile.sprite.width;
                container.addChild(explosionClip);
            },
            animateImpact: function (projectile, container, time) {
                var explosion = explosionsById[projectile.id];
                var relativeTimePlayed = time - explosion.startTime;
                var targetFrame = Math.round(relativeTimePlayed / explosion.relativeTimePerFrame);
                if (targetFrame >= 0 &&
                    targetFrame < explosion.clip.totalFrames) {
                    explosion.clip.gotoAndStop(targetFrame);
                    explosion.clip.visible = true;
                }
                else {
                    explosion.clip.visible = false;
                }
            },
            impactPosition: {
                min: offsetTargetData.boundingBox.x,
                max: offsetTargetData.boundingBox.x + offsetTargetData.boundingBox.width,
            },
        });
        projectileAttackFragment.draw(offsetUserData, offsetTargetData);
        container.addChild(projectileAttackFragment.displayObject);
        function animate() {
            var elapsedTime = Date.now() - startTime;
            var relativeTime = elapsedTime / params.duration;
            projectileAttackFragment.animate(relativeTime);
            if (elapsedTime < params.duration) {
                requestAnimationFrame(animate);
            }
            else {
                params.triggerEnd();
            }
        }
        params.triggerStart(container);
        animate();
    }
    function loadRocketAttack(callback) {
        var loader = new PIXI.loaders.Loader();
        loader.add("explosion", "modules/common/battlesfxfunctions/img/explosion.json");
        loader.add(rocketUrl);
        loader.load(callback);
    }
});
define("modules/common/battlesfxfunctions/ColorMatrixFilter", ["require", "exports", "src/Color"], function (require, exports, Color_11) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ColorMatrixFilter = (function (_super) {
        __extends(ColorMatrixFilter, _super);
        function ColorMatrixFilter() {
            return _super.call(this) || this;
        }
        ColorMatrixFilter.prototype.multiplyByMatrix = function (matrix) {
            this._loadMatrix(matrix, true);
        };
        ColorMatrixFilter.prototype.addMatrix = function (matrix) {
            if (matrix.length !== this.matrix.length) {
                throw new Error("Matrix must be 5x4");
            }
            this.matrix = this.matrix.map(function (oldValue, i) {
                return oldValue + matrix[i];
            });
        };
        ColorMatrixFilter.prototype.addColor = function (color) {
            var rgb = color.getRGB();
            var r = rgb[0];
            var g = rgb[1];
            var b = rgb[2];
            var matrix = [
                0, 0, 0, 0, r,
                0, 0, 0, 0, g,
                0, 0, 0, 0, b,
                0, 0, 0, 0, 0,
            ];
            this.addMatrix(matrix);
        };
        ColorMatrixFilter.prototype.multiplyRGB = function (amount) {
            this.multiplyByColor(new Color_11.default(amount, amount, amount));
        };
        ColorMatrixFilter.prototype.multiplyByColor = function (color) {
            var rgb = color.getRGB();
            var r = rgb[0];
            var g = rgb[1];
            var b = rgb[2];
            var matrix = [
                r, 0, 0, 0, 0,
                0, g, 0, 0, 0,
                0, 0, b, 0, 0,
                0, 0, 0, 1, 0,
            ];
            this.multiplyByMatrix(matrix);
        };
        return ColorMatrixFilter;
    }(PIXI.filters.ColorMatrixFilter));
    exports.default = ColorMatrixFilter;
});
define("modules/common/battlesfxfunctions/snipe", ["require", "exports", "src/Color", "src/UnitAttributes", "src/pixiWrapperFunctions", "modules/common/battlesfxfunctions/sfxfragments/FocusingBeam", "modules/common/battlesfxfunctions/sfxfragments/ProjectileAttack", "modules/common/battlesfxfunctions/sfxfragments/RampingValue", "modules/common/battlesfxfunctions/ColorMatrixFilter", "modules/common/battlesfxfunctions/ProtonWrapper"], function (require, exports, Color_12, UnitAttributes_2, pixiWrapperFunctions_8, FocusingBeam_2, ProjectileAttack_2, RampingValue_6, ColorMatrixFilter_1, ProtonWrapper_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var hasLoaded = false;
    function snipe(type, params) {
        if (hasLoaded) {
            playSnipe(type, params);
        }
        else {
            loadSnipe(type, function () {
                playSnipe(type, params);
            });
        }
    }
    exports.default = snipe;
    var colors = (_a = {},
        _a[UnitAttributes_2.UnitAttribute.Attack] = Color_12.default.fromHexString("FF4D77"),
        _a[UnitAttributes_2.UnitAttribute.Defence] = Color_12.default.fromHexString("0BB1FF"),
        _a[UnitAttributes_2.UnitAttribute.Intelligence] = Color_12.default.fromHexString("EB12FE"),
        _a[UnitAttributes_2.UnitAttribute.Speed] = Color_12.default.fromHexString("12FE9E"),
        _a);
    for (var attribute in colors) {
        var color = colors[attribute];
        var hsv = color.getHSV();
        hsv[1] = 0.6;
        colors[attribute] = Color_12.default.fromHSV.apply(null, hsv);
    }
    var projectileURL = "modules/common/battlesfxfunctions/img/ellipse.png";
    function playSnipe(type, params) {
        var mainContainer = new PIXI.Container();
        var offsetUserData = params.user.drawingFunctionData.normalizeForBattleSFX(params.userOffset, params.width, "user");
        var offsetTargetData = params.target.drawingFunctionData.normalizeForBattleSFX(params.targetOffset, params.width, "target");
        var renderTexture = PIXI.RenderTexture.create(params.width, params.height);
        var renderedSprite = new PIXI.Sprite(renderTexture);
        if (!params.facingRight) {
            renderedSprite.x = params.width;
            renderedSprite.scale.x = -1;
        }
        var beamOrigin = offsetUserData.singleAttackOriginPoint;
        var relativeBeamOrigin = {
            x: beamOrigin.x / params.width,
            y: beamOrigin.y / params.height,
        };
        var focusDuration = 0.15;
        var projectileLaunchTime = 0.35;
        var impactTime = 0.5;
        var projectileFlightDuration = impactTime - projectileLaunchTime;
        var impactHasOccurred = false;
        var beamFragment = new FocusingBeam_2.default({
            color: colors[type].saturate(-0.1),
            size: {
                x: params.width,
                y: params.height,
            },
            focusStartTime: 0,
            focusEndTime: focusDuration,
            decayStartTime: projectileLaunchTime,
            decayEndtime: projectileLaunchTime + projectileFlightDuration / 5,
            focusTimeExponent: 0.33,
            relativeYPosition: relativeBeamOrigin.y,
            beamIntensity: new RampingValue_6.default(5.0, 20.0, -25.0),
            beamSharpness: new RampingValue_6.default(0.75, 0.24, 0.0),
            beamSize: new RampingValue_6.default(0.12, -0.115, -0.005),
        });
        beamFragment.draw();
        mainContainer.addChild(beamFragment.displayObject);
        var maxSpeedAt1000Duration = params.width * params.duration / 2;
        var maxSpeed = maxSpeedAt1000Duration * (1000 / params.duration);
        var acceleration = maxSpeed / 0.5;
        var projectileColorMatrixFilter = new ColorMatrixFilter_1.default();
        projectileColorMatrixFilter.multiplyByColor(colors[type]);
        projectileColorMatrixFilter.multiplyRGB(3.0);
        var projectileFragment = new ProjectileAttack_2.default({
            makeProjectileSprite: function (i) {
                var sprite = new PIXI.Sprite(PIXI.Texture.fromFrame(projectileURL));
                sprite.height = 6;
                sprite.width = 32;
                sprite.filters = [projectileColorMatrixFilter];
                return sprite;
            },
            maxSpeed: maxSpeed,
            acceleration: acceleration,
            amountToSpawn: 1,
            useSequentialAttackOriginPoints: false,
            spawnTimeStart: projectileLaunchTime,
            spawnTimeEnd: 1,
            removeAfterImpact: true,
            impactRate: 1,
            onImpact: function (projectile, container, time) {
                if (!impactHasOccurred) {
                    impactHasOccurred = true;
                    params.triggerEffect();
                    emitters.forEach(function (emitter) {
                        emitter.p.x = projectile.sprite.position.x + projectile.sprite.width;
                        emitter.p.y = projectile.sprite.position.y;
                        emitter.emit("once");
                    });
                }
            },
            animateImpact: function (projectile, container, time) {
                params.renderer.render(particleBufferSprite, particleRenderTexture, true);
                params.renderer.render(particleContainer, particleRenderTexture, false);
                params.renderer.render(particleRenderSprite, particleBufferTexture, true);
                protonWrapper.update();
            },
            impactPosition: {
                min: offsetTargetData.boundingBox.x + offsetTargetData.boundingBox.width / 2,
                max: offsetTargetData.boundingBox.x + offsetTargetData.boundingBox.width / 2,
            },
        });
        projectileFragment.draw(offsetUserData, offsetTargetData);
        mainContainer.addChild(projectileFragment.displayObject);
        var particleContainer = new PIXI.Container();
        var protonWrapper = new ProtonWrapper_2.default(params.renderer, particleContainer);
        var particlesAmountScale = params.height / 600;
        var particleRenderTexture = PIXI.RenderTexture.create(params.width, params.height);
        var particleRenderSprite = new PIXI.Sprite(particleRenderTexture);
        mainContainer.addChild(particleRenderSprite);
        var particleBufferTexture = PIXI.RenderTexture.create(params.width, params.height);
        var particleBufferSprite = new PIXI.Sprite(particleBufferTexture);
        particleBufferSprite.alpha *= 0.9;
        var emitters = [
            {
                name: "white",
                color: 0xFFFFFF,
                amount: 275,
                size: 6,
            },
            {
                name: "colored",
                color: colors[type].getHex(),
                amount: 25,
                size: 4,
            },
        ].map(function (emitterData) {
            var emitter = new Proton.BehaviourEmitter();
            emitter.rate = new Proton.Rate(emitterData.amount * particlesAmountScale, 0.02);
            var particleTexture = (function () {
                var particleSize = emitterData.size;
                var gfx = new PIXI.Graphics();
                gfx.beginFill(emitterData.color);
                gfx.drawRect(particleSize / 2, particleSize / 2, particleSize, particleSize);
                gfx.endFill();
                return pixiWrapperFunctions_8.generateTextureWithBounds(params.renderer, gfx, PIXI.settings.SCALE_MODE, 1, new PIXI.Rectangle(0, 0, particleSize, particleSize));
            })();
            emitter.addInitialize(new Proton.ImageTarget(particleTexture));
            emitter.addInitialize(new Proton.Velocity(new Proton.Span(0.5, 5.0), new Proton.Span(270, 35, true), "polar"));
            var emitterArea = {
                x: Math.min(params.target.drawingFunctionData.boundingBox.width, 70),
                y: Math.min(params.target.drawingFunctionData.boundingBox.height, 70),
            };
            emitter.addInitialize(new Proton.Position(new Proton.RectZone(-emitterArea.x / 2, -emitterArea.y / 2, emitterArea.x, emitterArea.y)));
            emitter.addInitialize(new Proton.Life(new Proton.Span(params.duration * (1.0 - impactTime) / 3000, params.duration * (1.0 - impactTime) / 1500)));
            emitter.addBehaviour(new Proton.Scale(new Proton.Span(0.8, 1), 0));
            protonWrapper.addEmitter(emitter, emitterData.name);
            protonWrapper.onParticleUpdated[emitterData.name] = function (particle) {
                var sprite = particle.sprite;
                sprite.position.x = particle.p.x;
                sprite.position.y = particle.p.y;
                sprite.scale.x = particle.scale;
                sprite.scale.y = particle.scale;
            };
            return emitter;
        });
        function animate() {
            var elapsedTime = Date.now() - startTime;
            var relativeElapsedTime = elapsedTime / params.duration;
            beamFragment.animate(relativeElapsedTime);
            projectileFragment.animate(relativeElapsedTime);
            params.renderer.render(mainContainer, renderTexture, true);
            if (elapsedTime < params.duration) {
                requestAnimationFrame(animate);
            }
            else {
                params.triggerEnd();
            }
        }
        params.triggerStart(renderedSprite);
        var startTime = Date.now();
        animate();
    }
    function loadSnipe(type, callback) {
        var loader = new PIXI.loaders.Loader();
        loader.add(projectileURL);
        loader.load(callback);
    }
    var _a;
});
define("modules/common/battlesfxtemplates/battleSFX", ["require", "exports", "src/UnitAttributes", "modules/common/battlesfxfunctions/shaders/BlackToAlpha", "modules/common/battlesfxfunctions/beam", "modules/common/battlesfxfunctions/guard", "modules/common/battlesfxfunctions/makeSFXFromVideo", "modules/common/battlesfxfunctions/placeholder", "modules/common/battlesfxfunctions/rocketAttack", "modules/common/battlesfxfunctions/snipe", "src/pixiWrapperFunctions"], function (require, exports, UnitAttributes_3, BlackToAlpha_1, beam_1, guard_1, makeSFXFromVideo_1, placeholder_1, rocketAttack_1, snipe_1, pixiWrapperFunctions_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rocketAttack = {
        duration: 1500,
        battleOverlay: rocketAttack_1.default,
        SFXWillTriggerEffect: true,
    };
    exports.guard = {
        duration: 750,
        battleOverlay: guard_1.default,
        SFXWillTriggerEffect: true,
    };
    exports.beam = {
        duration: 3500,
        battleOverlay: beam_1.default,
        SFXWillTriggerEffect: true,
    };
    function makeSnipeTemplate(attribute) {
        return ({
            duration: 3000,
            battleOverlay: snipe_1.default.bind(null, attribute),
            SFXWillTriggerEffect: true,
        });
    }
    exports.snipeAttack = makeSnipeTemplate(UnitAttributes_3.UnitAttribute.Attack);
    exports.snipeDefence = makeSnipeTemplate(UnitAttributes_3.UnitAttribute.Defence);
    exports.snipeIntelligence = makeSnipeTemplate(UnitAttributes_3.UnitAttribute.Intelligence);
    exports.snipeSpeed = makeSnipeTemplate(UnitAttributes_3.UnitAttribute.Speed);
    exports.videoTest = {
        duration: 1000,
        battleOverlay: makeSFXFromVideo_1.default.bind(null, "img/bushiAttack.webm", function (sprite) {
            sprite.blendMode = PIXI.BLEND_MODES.SCREEN;
            pixiWrapperFunctions_9.attachShaderToSprite(sprite, new BlackToAlpha_1.default());
        }),
        SFXWillTriggerEffect: false,
    };
    exports.placeholder = {
        duration: 1000,
        battleOverlay: placeholder_1.placeholder,
        SFXWillTriggerEffect: false,
    };
});
define("modules/common/effectactiontemplates/damageAdjustments", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function getAdjustedTroopSize(unit) {
        var minEffectiveHealth = Math.max(unit.currentHealth, unit.battleStats.lastHealthBeforeReceivingDamage / 3);
        var effectiveHealth = unit.template.isSquadron ?
            minEffectiveHealth :
            Math.min(unit.maxHealth, minEffectiveHealth + unit.maxHealth * 0.2);
        if (effectiveHealth <= 500) {
            return effectiveHealth;
        }
        else if (effectiveHealth <= 2000) {
            return effectiveHealth / 2 + 250;
        }
        else {
            return effectiveHealth / 4 + 750;
        }
    }
    exports.getAdjustedTroopSize = getAdjustedTroopSize;
    function getAttackDamageIncrease(unit, damageType) {
        var attackStat;
        var attackFactor;
        switch (damageType) {
            case 0:
                {
                    attackStat = unit.attributes.attack;
                    attackFactor = 0.1;
                    break;
                }
            case 1:
                {
                    attackStat = unit.attributes.intelligence;
                    attackFactor = 0.1;
                    break;
                }
        }
        var adjustedTroopSize = getAdjustedTroopSize(unit);
        var increaseFromStats = attackStat * attackFactor;
        var damageIncrease = (1 + increaseFromStats) * adjustedTroopSize;
        return damageIncrease;
    }
    exports.getAttackDamageIncrease = getAttackDamageIncrease;
    function getReducedDamageFactor(unit, damageType) {
        var defenceStat;
        var defenceFactor;
        var finalDamageMultiplier = 1;
        switch (damageType) {
            case 0:
                {
                    defenceStat = unit.attributes.defence;
                    defenceFactor = 0.045;
                    var guardAmount = Math.min(unit.battleStats.guardAmount, 100);
                    finalDamageMultiplier = 1 - guardAmount / 200;
                    break;
                }
            case 1:
                {
                    defenceStat = unit.attributes.intelligence;
                    defenceFactor = 0.045;
                    break;
                }
        }
        var reductionFromStats = defenceStat * defenceFactor;
        var damageReduction = (1 - reductionFromStats) * finalDamageMultiplier;
        return damageReduction;
    }
    exports.getReducedDamageFactor = getReducedDamageFactor;
    function getAdjustedDamage(user, target, baseDamage, damageType) {
        var dealtDamage = baseDamage * getAttackDamageIncrease(user, damageType);
        var reducedDamage = dealtDamage * getReducedDamageFactor(target, damageType);
        var clampedDamage = Math.min(reducedDamage, target.currentHealth);
        return clampedDamage;
    }
    exports.getAdjustedDamage = getAdjustedDamage;
});
define("modules/common/effectactiontemplates/effectActions", ["require", "exports", "modules/common/effectactiontemplates/damageAdjustments", "src/StatusEffect", "src/utility"], function (require, exports, damageAdjustments_1, StatusEffect_2, utility_58) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function bindEffectActionData(toBind, data) {
        return toBind.bind(null, data);
    }
    exports.bindEffectActionData = bindEffectActionData;
    var calculateHealthAdjustment = function (user, target, data) {
        var healAmount = 0;
        if (data.flat) {
            healAmount += data.flat;
        }
        if (data.maxHealthPercentage) {
            healAmount += target.maxHealth * data.maxHealthPercentage;
        }
        if (data.perUserUnit) {
            healAmount += data.perUserUnit * damageAdjustments_1.getAttackDamageIncrease(user, 1);
        }
        return healAmount;
    };
    var resultType;
    (function (resultType) {
        resultType[resultType["HealthChanged"] = 0] = "HealthChanged";
    })(resultType = exports.resultType || (exports.resultType = {}));
    exports.inflictDamage = function (data, user, target, battle, executedEffectsResult) {
        var adjustedDamage = damageAdjustments_1.getAdjustedDamage(user, target, data.baseDamage, data.damageType);
        if (!executedEffectsResult[resultType.HealthChanged]) {
            executedEffectsResult[resultType.HealthChanged] = 0;
        }
        executedEffectsResult[resultType.HealthChanged] -= adjustedDamage;
        target.receiveDamage(adjustedDamage);
    };
    exports.addGuard = function (data, user, target, battle, executedEffectsResult) {
        var guardAmount = user.attributes.modifyValueByAttributes(data.flat, data.perAttribute);
        target.addGuard(guardAmount, data.coverage);
    };
    exports.receiveCounterAttack = function (data, user, target, battle, executedEffectsResult) {
        var counterStrength = target.getCounterAttackStrength();
        if (counterStrength) {
            exports.inflictDamage({
                baseDamage: data.baseDamage * counterStrength,
                damageType: 0,
            }, target, user, battle, executedEffectsResult);
        }
    };
    exports.increaseCaptureChance = function (data, user, target, battle, executedEffectsResult) {
        if (data.flat) {
            target.battleStats.captureChance += data.flat;
        }
        if (isFinite(data.multiplier)) {
            target.battleStats.captureChance *= data.multiplier;
        }
    };
    exports.addStatusEffect = function (data, user, target, battle, executedEffectsResult) {
        target.addStatusEffect(new StatusEffect_2.default({
            template: data.template,
            turnsToStayActiveFor: data.duration,
            sourceUnit: user,
        }));
    };
    exports.adjustHealth = function (data, user, target, battle, executedEffectsResult) {
        var healAmount = calculateHealthAdjustment(user, target, data);
        if (data.executedEffectsResultAdjustment) {
            healAmount += data.executedEffectsResultAdjustment(executedEffectsResult);
        }
        var minAdjustment = -target.currentHealth;
        var maxAdjustment = target.maxHealth - target.currentHealth;
        var clamped = utility_58.clamp(healAmount, minAdjustment, maxAdjustment);
        if (!executedEffectsResult[resultType.HealthChanged]) {
            executedEffectsResult[resultType.HealthChanged] = 0;
        }
        executedEffectsResult[resultType.HealthChanged] += clamped;
        target.addHealth(clamped);
    };
    exports.adjustCurrentAndMaxHealth = function (data, user, target, battle, executedEffectsResult) {
        var healAmount = calculateHealthAdjustment(user, target, data);
        if (data.executedEffectsResultAdjustment) {
            healAmount += data.executedEffectsResultAdjustment(executedEffectsResult);
        }
        target.addMaxHealth(healAmount);
        target.addHealth(healAmount);
    };
});
define("modules/common/statuseffecttemplates/snipe", ["require", "exports", "src/UnitAttributes"], function (require, exports, UnitAttributes_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeSnipeStatusEffect(attribute) {
        var attributeName = UnitAttributes_4.UnitAttribute[attribute];
        var capitalizedAttributeName = attributeName[0].toUpperCase() + attributeName.slice(1);
        var key = "snipe" + capitalizedAttributeName;
        var displayName = "Snipe: " + capitalizedAttributeName;
        return ({
            type: key,
            displayName: displayName,
            attributes: (_a = {},
                _a[attributeName] = {
                    multiplier: -0.5,
                },
                _a),
        });
        var _a;
    }
    exports.snipeAttack = makeSnipeStatusEffect(UnitAttributes_4.UnitAttribute.Attack);
    exports.snipeDefence = makeSnipeStatusEffect(UnitAttributes_4.UnitAttribute.Defence);
    exports.snipeIntelligence = makeSnipeStatusEffect(UnitAttributes_4.UnitAttribute.Intelligence);
    exports.snipeSpeed = makeSnipeStatusEffect(UnitAttributes_4.UnitAttribute.Speed);
});
define("modules/common/abilitytemplates/abilities", ["require", "exports", "src/UnitAttributes", "src/targeting", "modules/common/battlesfxtemplates/battleSFX", "modules/common/effectactiontemplates/effectActions", "modules/common/effectactiontemplates/effectActions", "modules/common/statuseffecttemplates/snipe"], function (require, exports, UnitAttributes_5, targeting_2, BattleSFX, EffectActions, effectActions_1, SnipeStatusEffects) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.closeAttack = {
        type: "closeAttack",
        displayName: "Close Attack",
        description: "Close range attack that hits adjacent targets in the same row",
        moveDelay: 90,
        actionsUse: 2,
        getPossibleTargets: function (user, battle) {
            return targeting_2.targetNextRow(user, battle).filter(function (unit) {
                unit.battleStats.side !== user.battleStats.side;
            });
        },
        mainEffect: {
            id: "damage",
            executeAction: effectActions_1.bindEffectActionData(EffectActions.inflictDamage, {
                baseDamage: 0.66,
                damageType: 0,
            }),
            getUnitsInArea: targeting_2.areaRowNeighbors,
            sfx: BattleSFX.rocketAttack,
        },
    };
    exports.beamAttack = {
        type: "beamAttack",
        displayName: "Beam Attack",
        description: "Attack units in a line",
        moveDelay: 300,
        actionsUse: 1,
        getPossibleTargets: targeting_2.targetEnemies,
        mainEffect: {
            id: "damage",
            executeAction: effectActions_1.bindEffectActionData(EffectActions.inflictDamage, {
                baseDamage: 0.75,
                damageType: 1,
            }),
            getUnitsInArea: targeting_2.areaColumn,
            sfx: BattleSFX.beam,
        },
        targetCannotBeDiverted: true,
    };
    exports.bombAttack = {
        type: "bombAttack",
        displayName: "Bomb Attack",
        description: "Ranged attack that hits all adjacent enemy units",
        moveDelay: 120,
        actionsUse: 1,
        getPossibleTargets: targeting_2.targetEnemies,
        mainEffect: {
            id: "damage",
            executeAction: effectActions_1.bindEffectActionData(EffectActions.inflictDamage, {
                baseDamage: 0.5,
                damageType: 0,
            }),
            getUnitsInArea: function (user, target, battle) {
                return targeting_2.areaOrthogonalNeighbors(user, target, battle).filter(function (unit) {
                    return !unit || unit.battleStats.side !== user.battleStats.side;
                });
            },
            sfx: BattleSFX.rocketAttack,
        },
    };
    exports.guardRow = {
        type: "guardRow",
        displayName: "Guard Row",
        description: "Protect allies in the same row and boost defence against physical attacks",
        moveDelay: 100,
        actionsUse: 1,
        getPossibleTargets: targeting_2.targetSelf,
        mainEffect: {
            id: "addGuard",
            executeAction: effectActions_1.bindEffectActionData(EffectActions.addGuard, {
                perAttribute: {
                    intelligence: { flat: 20 },
                },
                coverage: 0,
            }),
            getUnitsInArea: targeting_2.areaSingle,
            sfx: BattleSFX.guard,
        },
        doesNotRemoveUserGuard: true,
    };
    exports.boardingHook = {
        type: "boardingHook",
        displayName: "Boarding Hook",
        description: "0.8x damage but increases target capture chance",
        moveDelay: 100,
        actionsUse: 1,
        getPossibleTargets: targeting_2.targetEnemies,
        mainEffect: {
            id: "damage",
            executeAction: effectActions_1.bindEffectActionData(EffectActions.inflictDamage, {
                baseDamage: 0.8,
                damageType: 0,
            }),
            getUnitsInArea: targeting_2.areaSingle,
            sfx: BattleSFX.rocketAttack,
            attachedEffects: [
                {
                    id: "captureChance",
                    getUnitsInArea: targeting_2.areaSingle,
                    executeAction: effectActions_1.bindEffectActionData(EffectActions.increaseCaptureChance, {
                        flat: 0.5,
                    }),
                },
                {
                    id: "counter",
                    getUnitsInArea: targeting_2.areaSingle,
                    executeAction: effectActions_1.bindEffectActionData(EffectActions.receiveCounterAttack, {
                        baseDamage: 0.5,
                    }),
                },
            ],
        },
    };
    exports.debugAbility = {
        type: "debugAbility",
        displayName: "Debug Ability",
        description: "who knows what its going to do today",
        moveDelay: 0,
        actionsUse: 1,
        getPossibleTargets: targeting_2.targetAll,
        mainEffect: {
            id: "debugAbility",
            getUnitsInArea: targeting_2.areaSingle,
            executeAction: function () { },
            sfx: BattleSFX.guard,
        },
    };
    exports.rangedAttack = {
        type: "rangedAttack",
        displayName: "Ranged Attack",
        description: "Standard ranged attack",
        moveDelay: 100,
        actionsUse: 1,
        getPossibleTargets: targeting_2.targetEnemies,
        mainEffect: {
            id: "damage",
            executeAction: effectActions_1.bindEffectActionData(EffectActions.inflictDamage, {
                baseDamage: 1,
                damageType: 0,
            }),
            getUnitsInArea: targeting_2.areaSingle,
            sfx: BattleSFX.rocketAttack,
            attachedEffects: [
                {
                    id: "counter",
                    executeAction: effectActions_1.bindEffectActionData(EffectActions.receiveCounterAttack, {
                        baseDamage: 0.5,
                    }),
                    getUnitsInArea: targeting_2.areaSingle,
                },
            ],
        },
        canUpgradeInto: [
            exports.bombAttack,
            exports.boardingHook,
        ],
    };
    function makeSnipeTemplate(attribute) {
        var attributeName = UnitAttributes_5.UnitAttribute[attribute];
        var capitalizedAttributeName = attributeName[0].toUpperCase() + attributeName.slice(1);
        var key = "snipe" + capitalizedAttributeName;
        var displayName = "Snipe: " + capitalizedAttributeName;
        var description = "Deals damage and lowers target " + attributeName;
        var statusEffectTemplateByAttribute = (_a = {},
            _a[UnitAttributes_5.UnitAttribute.Attack] = SnipeStatusEffects.snipeAttack,
            _a[UnitAttributes_5.UnitAttribute.Defence] = SnipeStatusEffects.snipeDefence,
            _a[UnitAttributes_5.UnitAttribute.Intelligence] = SnipeStatusEffects.snipeIntelligence,
            _a[UnitAttributes_5.UnitAttribute.Speed] = SnipeStatusEffects.snipeSpeed,
            _a);
        return ({
            type: key,
            displayName: displayName,
            description: description,
            moveDelay: 100,
            actionsUse: 1,
            getPossibleTargets: targeting_2.targetEnemies,
            mainEffect: {
                id: "damage",
                executeAction: effectActions_1.bindEffectActionData(EffectActions.inflictDamage, {
                    baseDamage: 0.6,
                    damageType: 0,
                }),
                getUnitsInArea: targeting_2.areaSingle,
                sfx: BattleSFX[key],
                attachedEffects: [
                    {
                        id: "statusEffect",
                        executeAction: effectActions_1.bindEffectActionData(EffectActions.addStatusEffect, {
                            template: statusEffectTemplateByAttribute[attribute],
                            duration: -1,
                        }),
                        getUnitsInArea: targeting_2.areaSingle,
                    },
                ],
            },
        });
        var _a;
    }
    exports.snipeAttack = makeSnipeTemplate(UnitAttributes_5.UnitAttribute.Attack);
    exports.snipeDefence = makeSnipeTemplate(UnitAttributes_5.UnitAttribute.Defence);
    exports.snipeIntelligence = makeSnipeTemplate(UnitAttributes_5.UnitAttribute.Intelligence);
    exports.snipeSpeed = makeSnipeTemplate(UnitAttributes_5.UnitAttribute.Speed);
    exports.standBy = {
        type: "standBy",
        displayName: "Standby",
        description: "Skip a turn but next one comes faster",
        moveDelay: 50,
        actionsUse: 1,
        getPossibleTargets: targeting_2.targetSelf,
        mainEffect: {
            id: "standBy",
            getUnitsInArea: targeting_2.areaSingle,
            executeAction: function () { },
            sfx: {
                duration: 750,
            },
        },
        doesNotRemoveUserGuard: true,
        AIEvaluationPriority: 0.6,
        AIScoreAdjust: -0.1,
        disableInAIBattles: true,
    };
});
define("modules/common/statuseffecttemplates/autoHeal", ["require", "exports", "modules/common/effectactiontemplates/effectActions", "modules/common/effectactiontemplates/effectActions"], function (require, exports, effectActions_2, effectActions_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var autoHeal = {
        type: "autoHeal",
        displayName: "Auto heal",
        description: "Restore 50 health after every action",
        afterAbilityUse: [
            {
                id: "heal",
                getUnitsInArea: function (user) { return [user]; },
                executeAction: effectActions_3.bindEffectActionData(effectActions_2.adjustHealth, {
                    flat: 50,
                }),
                trigger: function (user) { return user.currentHealth < user.maxHealth; },
            },
        ],
    };
    exports.default = autoHeal;
});
define("modules/common/statuseffecttemplates/poisoned", ["require", "exports", "modules/common/effectactiontemplates/effectActions", "modules/common/effectactiontemplates/effectActions"], function (require, exports, effectActions_4, effectActions_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var poisoned = {
        type: "poisoned",
        displayName: "Poisoned",
        description: "-10% max health per turn",
        attributes: {
            attack: {
                flat: 9,
            },
            defence: {
                flat: 9,
            },
            speed: {
                flat: 9,
            },
        },
        afterAbilityUse: [
            {
                id: "removeHealth",
                getUnitsInArea: function (user, target, battle) { return [user]; },
                executeAction: effectActions_5.bindEffectActionData(effectActions_4.adjustHealth, {
                    maxHealthPercentage: -0.1,
                }),
                sfx: {
                    duration: 1200,
                    userOverlay: function (props) {
                        var canvas = document.createElement("canvas");
                        canvas.width = props.width;
                        canvas.height = props.height;
                        var ctx = canvas.getContext("2d");
                        ctx.fillStyle = "rgba(30, 150, 30, 0.5)";
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        return canvas;
                    },
                },
            },
        ],
    };
    exports.default = poisoned;
});
define("modules/common/passiveskilltemplates/passiveSkills", ["require", "exports", "modules/common/statuseffecttemplates/autoHeal", "modules/common/statuseffecttemplates/poisoned", "modules/common/effectactiontemplates/effectActions", "modules/common/effectactiontemplates/effectActions"], function (require, exports, autoHeal_1, poisoned_1, EffectActions, effectActions_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.autoHeal = {
        type: "autoHeal",
        displayName: "Auto heal",
        description: "Restore 50 health after every action",
        atBattleStart: [
            {
                id: "addStatusEffect",
                getUnitsInArea: function (user) { return [user]; },
                executeAction: effectActions_6.bindEffectActionData(EffectActions.addStatusEffect, {
                    duration: -1,
                    template: autoHeal_1.default,
                }),
            },
        ],
    };
    exports.overdrive = {
        type: "overdrive",
        displayName: "Overdrive",
        description: "Gives buffs at battle start but become poisoned",
        atBattleStart: [
            {
                id: "addStatusEffect",
                getUnitsInArea: function (user) { return [user]; },
                executeAction: effectActions_6.bindEffectActionData(EffectActions.addStatusEffect, {
                    duration: 2,
                    template: poisoned_1.default,
                }),
            },
        ],
    };
    exports.initialGuard = {
        type: "initialGuard",
        displayName: "Initial Guard",
        description: "Adds initial guard",
        isHidden: true,
        atBattleStart: [
            {
                id: "addStatusEffect",
                getUnitsInArea: function (user) { return [user]; },
                executeAction: effectActions_6.bindEffectActionData(EffectActions.addGuard, {
                    coverage: 0,
                    flat: 50,
                }),
            },
        ],
        inBattlePrep: [
            function (user, battlePrep) {
                EffectActions.addGuard({
                    coverage: 0,
                    flat: 50,
                }, user, user, null, {});
            },
        ],
    };
    exports.medic = {
        type: "medic",
        displayName: "Medic",
        description: "Heals all units in same star to full at turn start",
        atTurnStart: [
            function (user) {
                var star = user.fleet.location;
                var allFriendlyUnits = star.getUnits(function (player) { return player === user.fleet.player; });
                for (var i = 0; i < allFriendlyUnits.length; i++) {
                    allFriendlyUnits[i].addHealth(allFriendlyUnits[i].maxHealth);
                }
            },
        ],
    };
    exports.warpJammer = {
        type: "warpJammer",
        displayName: "Warp Jammer",
        description: "Forces an extra unit to defend in neutral territory",
        inBattlePrep: [
            function (user, battlePrep) {
                if (battlePrep.isLocationNeutral() && user.fleet.player === battlePrep.attacker) {
                    battlePrep.minDefenders += 1;
                }
            },
        ],
        canUpgradeInto: [exports.medic],
    };
});
define("modules/defaultitems/ItemTemplates", ["require", "exports", "modules/common/abilitytemplates/abilities", "modules/common/passiveskilltemplates/passiveSkills"], function (require, exports, abilities_1, passiveSkills_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var bombLauncher1 = {
        type: "bombLauncher1",
        displayName: "Bomb Launcher 1",
        description: "",
        icon: "modules/defaultitems/img/cannon.png",
        techLevel: 1,
        buildCost: 100,
        slot: "high",
        ability: abilities_1.bombAttack,
    };
    var bombLauncher2 = {
        type: "bombLauncher2",
        displayName: "Bomb Launcher 2",
        description: "",
        icon: "modules/defaultitems/img/cannon.png",
        techLevel: 2,
        buildCost: 200,
        attributeAdjustments: {
            attack: { flat: 1 },
        },
        slot: "high",
        ability: abilities_1.bombAttack,
    };
    var bombLauncher3 = {
        type: "bombLauncher3",
        displayName: "Bomb Launcher 3",
        description: "",
        icon: "modules/defaultitems/img/cannon.png",
        techLevel: 3,
        buildCost: 300,
        attributeAdjustments: {
            attack: { flat: 3 },
        },
        slot: "high",
        ability: abilities_1.bombAttack,
    };
    var afterBurner1 = {
        type: "afterBurner1",
        displayName: "Afterburner 1",
        description: "",
        icon: "modules/defaultitems/img/blueThing.png",
        techLevel: 1,
        buildCost: 100,
        attributeAdjustments: {
            speed: { flat: 1 },
        },
        slot: "mid",
        passiveSkill: passiveSkills_1.overdrive,
    };
    var afterBurner2 = {
        type: "afterBurner2",
        displayName: "Afterburner 2",
        description: "",
        icon: "modules/defaultitems/img/blueThing.png",
        techLevel: 2,
        buildCost: 200,
        attributeAdjustments: {
            speed: { flat: 2 },
        },
        slot: "mid",
    };
    var afterBurner3 = {
        type: "afterBurner3",
        displayName: "Afterburner 3",
        description: "",
        icon: "modules/defaultitems/img/blueThing.png",
        techLevel: 3,
        buildCost: 300,
        attributeAdjustments: {
            maxActionPoints: { flat: 1 },
            speed: { flat: 3 },
        },
        slot: "mid",
    };
    var shieldPlating1 = {
        type: "shieldPlating1",
        displayName: "Shield Plating 1",
        description: "",
        icon: "modules/defaultitems/img/armor1.png",
        techLevel: 1,
        buildCost: 100,
        attributeAdjustments: {
            defence: { flat: 1 },
        },
        slot: "low",
    };
    var shieldPlating2 = {
        type: "shieldPlating2",
        displayName: "Shield Plating 2",
        description: "",
        icon: "modules/defaultitems/img/armor1.png",
        techLevel: 2,
        buildCost: 200,
        attributeAdjustments: {
            defence: { flat: 2 },
        },
        slot: "low",
    };
    var shieldPlating3 = {
        type: "shieldPlating3",
        displayName: "Shield Plating 3",
        description: "",
        icon: "modules/defaultitems/img/armor1.png",
        techLevel: 3,
        buildCost: 300,
        attributeAdjustments: {
            defence: { flat: 3 },
            speed: { flat: -1 },
        },
        slot: "low",
        ability: abilities_1.guardRow,
    };
    var ItemTemplates = (_a = {},
        _a[bombLauncher1.type] = bombLauncher1,
        _a[bombLauncher2.type] = bombLauncher2,
        _a[bombLauncher3.type] = bombLauncher3,
        _a[afterBurner1.type] = afterBurner1,
        _a[afterBurner2.type] = afterBurner2,
        _a[afterBurner3.type] = afterBurner3,
        _a[shieldPlating1.type] = shieldPlating1,
        _a[shieldPlating2.type] = shieldPlating2,
        _a[shieldPlating3.type] = shieldPlating3,
        _a);
    exports.default = ItemTemplates;
    var _a;
});
define("modules/defaultitems/defaultItems", ["require", "exports", "modules/defaultitems/ItemTemplates", "src/ModuleFileLoadingPhase", "localization/defaultLanguages"], function (require, exports, ItemTemplates_1, ModuleFileLoadingPhase_10, Languages) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var defaultItems = {
        key: "defaultItems",
        metaData: {
            name: "Default items",
            version: "0.1.0",
            author: "giraluna",
            description: "",
        },
        needsToBeLoadedBefore: ModuleFileLoadingPhase_10.default.MapGen,
        supportedLanguages: [Languages.en],
        constructModule: function (moduleData) {
            moduleData.copyTemplates(ItemTemplates_1.default, "Items");
            return moduleData;
        },
    };
    exports.default = defaultItems;
});
define("src/Region", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Region = (function () {
        function Region(id, initialStars) {
            var _this = this;
            this.stars = [];
            this.starsById = {};
            this.id = id;
            if (initialStars) {
                initialStars.forEach(function (star) { return _this.addStar(star); });
            }
        }
        Region.prototype.addStar = function (star) {
            this.stars.push(star);
            this.starsById[star.id] = star;
        };
        Region.prototype.hasStar = function (star) {
            return Boolean(this.starsById[star.id]);
        };
        Region.prototype.severLinksToRegionsExcept = function (exemptRegions) {
            this.severLinksForQualifier(function (a, b) {
                var isPartOfExemptRegion = exemptRegions.some(function (region) {
                    return region.hasStar(b);
                });
                return !isPartOfExemptRegion;
            });
        };
        Region.prototype.getBorderLengthWithStars = function (stars) {
            var sharedHalfEdges = this.getSharedHalfEdgesWithStars(stars);
            var borderLength = sharedHalfEdges.reduce(function (borderLength, halfEdge) {
                var edge = halfEdge.edge;
                var edgeLength = Math.abs(edge.va.x - edge.vb.x) + Math.abs(edge.va.y - edge.vb.y);
                return edgeLength;
            }, 0);
            return borderLength;
        };
        Region.prototype.getStarsByDistanceToQualifier = function (qualifierFN) {
            var starsByDistance = {};
            this.stars.forEach(function (star) {
                var nearestStar = star.getNearestStarForQualifier(qualifierFN);
                var distanceToNearestStar = star.getDistanceToStar(nearestStar);
                if (!starsByDistance[distanceToNearestStar]) {
                    starsByDistance[distanceToNearestStar] = [];
                }
                starsByDistance[distanceToNearestStar].push(star);
            });
            return starsByDistance;
        };
        Region.prototype.getLinkedStars = function () {
            var _this = this;
            return this.getUniqueStarsFromCallback(function (star) {
                var linkedStars = star.getLinkedInRange(1).all;
                return linkedStars.filter(function (linkedStar) {
                    return !_this.hasStar(linkedStar);
                });
            });
        };
        Region.prototype.getMajorityRegions = function (regionsToCheck) {
            var overlappingStarsWithRegions = this.getOverlappingStarsWithRegions(regionsToCheck);
            var maxStarCount = 0;
            var regionsByOverlappingStarCount = {};
            overlappingStarsWithRegions.forEach(function (regionWithStars) {
                var starCount = regionWithStars.stars.length;
                if (!regionsByOverlappingStarCount[starCount]) {
                    regionsByOverlappingStarCount[starCount] = [];
                }
                regionsByOverlappingStarCount[starCount].push(regionWithStars.region);
                maxStarCount = Math.max(maxStarCount, starCount);
            });
            return regionsByOverlappingStarCount[maxStarCount];
        };
        Region.prototype.getLinkedRegions = function (regionsToCheck) {
            return this.getLinkedStarsWithRegions(regionsToCheck).map(function (rs) {
                return rs.region;
            });
        };
        Region.prototype.getSharedHalfEdgesWithStars = function (stars) {
            var _this = this;
            var toCheckRegion = new Region(null, stars);
            var sharedStarsWithRegion = this.getNeighboringStarsWithRegions([toCheckRegion])[0];
            var neighboringStars = sharedStarsWithRegion ? sharedStarsWithRegion.stars : [];
            var sharedHalfEdges = [];
            neighboringStars.forEach(function (star) {
                star.voronoiCell.halfedges.forEach(function (halfEdge) {
                    var edge = halfEdge.edge;
                    var edgeNeighborsThisRegion = ((edge.lSite && _this.hasStar(edge.lSite)) ||
                        (edge.rSite && _this.hasStar(edge.rSite)));
                    if (edgeNeighborsThisRegion) {
                        sharedHalfEdges.push(halfEdge);
                    }
                });
            });
            return sharedHalfEdges;
        };
        Region.prototype.getLinkedStarsWithRegions = function (regionsToCheck) {
            return Region.getRegionsWithStarsForQualifier(regionsToCheck, this.getLinkedStars(), function (region, star) { return region.hasStar(star); });
        };
        Region.prototype.getOverlappingStarsWithRegions = function (regionsToCheck) {
            return Region.getRegionsWithStarsForQualifier(regionsToCheck, this.stars, function (region, star) { return region.hasStar(star); });
        };
        Region.prototype.getNeighboringStarsWithRegions = function (regionsToCheck) {
            return Region.getRegionsWithStarsForQualifier(regionsToCheck, this.getNeighboringStars(), function (region, star) { return region.hasStar(star); });
        };
        Region.getRegionsWithStarsForQualifier = function (regionsToCheck, starsToCheck, qualifierFN) {
            var regionsWithStarsForQualifier = regionsToCheck.map(function (region) {
                var starsThatPassQualifier = starsToCheck.filter(function (star) {
                    return qualifierFN(region, star);
                });
                return ({
                    region: region,
                    stars: starsThatPassQualifier,
                });
            });
            return regionsWithStarsForQualifier.filter(function (regionWithStars) {
                return regionWithStars.stars.length > 0;
            });
        };
        Region.prototype.severLinksForQualifier = function (qualifierFN) {
            this.stars.forEach(function (star) {
                star.getAllLinks().forEach(function (linkedStar) {
                    if (qualifierFN(star, linkedStar)) {
                        star.removeLink(linkedStar);
                    }
                });
            });
        };
        Region.prototype.getNeighboringStars = function () {
            var _this = this;
            return this.getUniqueStarsFromCallback(function (star) {
                var neighborPoints = star.getNeighbors();
                return neighborPoints.filter(function (neighbor) {
                    var isFillerPoint = !isFinite(neighbor.id);
                    return !isFillerPoint && !_this.hasStar(neighbor);
                });
            });
        };
        Region.prototype.getUniqueStarsFromCallback = function (callbackFN) {
            var resultStars = [];
            var alreadyAdded = {};
            this.stars.forEach(function (star) {
                var starsFromCallback = callbackFN(star);
                var newStarsFromCallback = starsFromCallback.filter(function (star) {
                    return !alreadyAdded[star.id];
                });
                newStarsFromCallback.forEach(function (star) {
                    alreadyAdded[star.id] = true;
                    resultStars.push(star);
                });
            });
            return resultStars;
        };
        return Region;
    }());
    exports.default = Region;
});
define("src/templateinterfaces/Distributable", ["require", "exports", "src/utility"], function (require, exports, utility_59) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function getRandomWeightedDistributable(candidates) {
        var maxWeight = candidates.map(function (distributable) {
            return distributable.distributionData.weight;
        }).reduce(function (total, current) {
            return Math.max(total, current);
        }, -Infinity);
        if (maxWeight <= 0) {
            var candidatesWithMaxWeight = candidates.filter(function (distributable) {
                return distributable.distributionData.weight === maxWeight;
            });
            return utility_59.getRandomArrayItem(candidatesWithMaxWeight);
        }
        else {
            while (true) {
                var candidate = utility_59.getRandomArrayItem(candidates);
                if (Math.random() < candidate.distributionData.weight / maxWeight) {
                    return candidate;
                }
            }
        }
    }
    exports.getRandomWeightedDistributable = getRandomWeightedDistributable;
    function getDistributablesMatchingHighestPriorityGroup(candidates, groupsByPriority) {
        if (groupsByPriority.length === 0) {
            return candidates;
        }
        var distributablesThatDidntMatchGroups = [];
        var _loop_13 = function (i) {
            var group = groupsByPriority[i];
            var distributablesWithGroup = candidates.filter(function (distributable) {
                var distributableHasGroup = distributable.distributionData.distributionGroups.indexOf(group) !== -1;
                if (i === groupsByPriority.length - 1 && !distributableHasGroup) {
                    distributablesThatDidntMatchGroups.push(distributable);
                }
                return distributableHasGroup;
            });
            if (distributablesWithGroup.length > 0) {
                return { value: distributablesWithGroup };
            }
        };
        for (var i = 0; i < groupsByPriority.length; i++) {
            var state_1 = _loop_13(i);
            if (typeof state_1 === "object")
                return state_1.value;
        }
        return distributablesThatDidntMatchGroups;
    }
    exports.getDistributablesMatchingHighestPriorityGroup = getDistributablesMatchingHighestPriorityGroup;
    function filterCandidatesByGroups(candidates, groupsToMatch, valueWhenGroupMatches) {
        return candidates.filter(function (candidate) {
            var hasGroupMatch = candidate.distributionData.distributionGroups.some(function (candidateGroup) {
                return groupsToMatch.indexOf(candidateGroup) !== -1;
            });
            if (valueWhenGroupMatches === true) {
                return hasGroupMatch;
            }
            else {
                return !hasGroupMatch;
            }
        });
    }
    exports.filterCandidatesByGroups = filterCandidatesByGroups;
    function getDistributablesWithGroups(candidates, groupsToFilter) {
        return filterCandidatesByGroups(candidates, groupsToFilter, true);
    }
    exports.getDistributablesWithGroups = getDistributablesWithGroups;
    function getDistributablesWithoutGroups(candidates, groupsToFilter) {
        return filterCandidatesByGroups(candidates, groupsToFilter, false);
    }
    exports.getDistributablesWithoutGroups = getDistributablesWithoutGroups;
});
define("src/TemplateIndexes", ["require", "exports", "src/activeModuleData"], function (require, exports, activeModuleData_28) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TemplateIndexes = (function () {
        function TemplateIndexes() {
            this.builtIndexes = {
                distributablesByTypeAndDistributionGroup: null,
                itemsByTechLevel: null,
            };
        }
        Object.defineProperty(TemplateIndexes.prototype, "distributablesByDistributionGroup", {
            get: function () {
                if (!this.builtIndexes.distributablesByTypeAndDistributionGroup) {
                    this.builtIndexes.distributablesByTypeAndDistributionGroup =
                        TemplateIndexes.getDistributablesByTypeAndDistributionGroup();
                }
                return this.builtIndexes.distributablesByTypeAndDistributionGroup;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TemplateIndexes.prototype, "itemsByTechLevel", {
            get: function () {
                if (!this.builtIndexes.itemsByTechLevel) {
                    this.builtIndexes.itemsByTechLevel = TemplateIndexes.getItemsByTechLevel();
                }
                return this.builtIndexes.itemsByTechLevel;
            },
            enumerable: true,
            configurable: true
        });
        TemplateIndexes.prototype.clear = function () {
            for (var key in this.builtIndexes) {
                this.builtIndexes[key] = null;
            }
        };
        TemplateIndexes.getDistributablesByTypeAndDistributionGroup = function () {
            return ({
                resources: TemplateIndexes.getDistributablesByGroup(activeModuleData_28.activeModuleData.Templates.Resources),
                races: TemplateIndexes.getDistributablesByGroup(activeModuleData_28.activeModuleData.Templates.Races),
            });
        };
        TemplateIndexes.getDistributablesByGroup = function (allDistributables) {
            var byGroup = {};
            var _loop_14 = function (key) {
                var distributable = allDistributables[key];
                distributable.distributionData.distributionGroups.forEach(function (group) {
                    if (!byGroup[group]) {
                        byGroup[group] = [];
                    }
                    byGroup[group].push(distributable);
                });
            };
            for (var key in allDistributables) {
                _loop_14(key);
            }
            return byGroup;
        };
        TemplateIndexes.getItemsByTechLevel = function () {
            var itemsByTechLevel = {};
            for (var itemName in activeModuleData_28.activeModuleData.Templates.Items) {
                var item = activeModuleData_28.activeModuleData.Templates.Items[itemName];
                if (!itemsByTechLevel[item.techLevel]) {
                    itemsByTechLevel[item.techLevel] = [];
                }
                itemsByTechLevel[item.techLevel].push(item);
            }
            return itemsByTechLevel;
        };
        return TemplateIndexes;
    }());
    var indexes = new TemplateIndexes();
    exports.default = indexes;
});
define("modules/defaultmapgen/common/MapGenPoint", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MapGenPoint = (function () {
        function MapGenPoint(x, y) {
            this.mapGenData = {};
            this.x = x;
            this.y = y;
        }
        return MapGenPoint;
    }());
    exports.default = MapGenPoint;
});
define("modules/defaultmapgen/common/Triangle", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Triangle = (function () {
        function Triangle(a, b, c) {
            this.a = a;
            this.b = b;
            this.c = c;
        }
        Triangle.prototype.getPoints = function () {
            return [this.a, this.b, this.c];
        };
        Triangle.prototype.calculateCircumCircle = function (tolerance) {
            if (tolerance === void 0) { tolerance = 0.00001; }
            var pA = this.a;
            var pB = this.b;
            var pC = this.c;
            var m1, m2;
            var mx1, mx2;
            var my1, my2;
            var cX, cY;
            if (Math.abs(pB.y - pA.y) < tolerance) {
                m2 = -(pC.x - pB.x) / (pC.y - pB.y);
                mx2 = (pB.x + pC.x) * 0.5;
                my2 = (pB.y + pC.y) * 0.5;
                cX = (pB.x + pA.x) * 0.5;
                cY = m2 * (cX - mx2) + my2;
            }
            else {
                m1 = -(pB.x - pA.x) / (pB.y - pA.y);
                mx1 = (pA.x + pB.x) * 0.5;
                my1 = (pA.y + pB.y) * 0.5;
                if (Math.abs(pC.y - pB.y) < tolerance) {
                    cX = (pC.x + pB.x) * 0.5;
                    cY = m1 * (cX - mx1) + my1;
                }
                else {
                    m2 = -(pC.x - pB.x) / (pC.y - pB.y);
                    mx2 = (pB.x + pC.x) * 0.5;
                    my2 = (pB.y + pC.y) * 0.5;
                    cX = (m1 * mx1 - m2 * mx2 + my2 - my1) / (m1 - m2);
                    cY = m1 * (cX - mx1) + my1;
                }
            }
            this.circumCenterX = cX;
            this.circumCenterY = cY;
            mx1 = pB.x - cX;
            my1 = pB.y - cY;
            this.circumRadius = Math.sqrt(mx1 * mx1 + my1 * my1);
        };
        Triangle.prototype.circumCircleContainsPoint = function (point) {
            this.calculateCircumCircle();
            var x = point.x - this.circumCenterX;
            var y = point.y - this.circumCenterY;
            var contains = x * x + y * y <= this.circumRadius * this.circumRadius;
            return (contains);
        };
        Triangle.prototype.getEdges = function () {
            var edges = [
                [this.a, this.b],
                [this.b, this.c],
                [this.c, this.a],
            ];
            return edges;
        };
        Triangle.prototype.getAmountOfSharedVerticesWith = function (toCheckAgainst) {
            var ownPoints = this.getPoints();
            var otherPoints = toCheckAgainst.getPoints();
            var shared = 0;
            for (var i = 0; i < ownPoints.length; i++) {
                if (otherPoints.indexOf(ownPoints[i]) >= 0) {
                    shared++;
                }
            }
            return shared;
        };
        return Triangle;
    }());
    exports.default = Triangle;
});
define("modules/defaultmapgen/common/triangulate", ["require", "exports", "modules/defaultmapgen/common/Triangle", "src/utility"], function (require, exports, Triangle_1, utility_60) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function triangulate(vertices) {
        var triangles = [];
        var superTriangle = makeSuperTriangle(vertices);
        triangles.push(superTriangle);
        for (var i = 0; i < vertices.length; i++) {
            var vertex = vertices[i];
            var edgeBuffer = [];
            for (var j = 0; j < triangles.length; j++) {
                var triangle = triangles[j];
                if (triangle.circumCircleContainsPoint(vertex)) {
                    var edges = triangle.getEdges();
                    edgeBuffer.push.apply(edgeBuffer, edges);
                    triangles.splice(j, 1);
                    j--;
                }
            }
            if (i >= vertices.length)
                continue;
            for (var j = edgeBuffer.length - 2; j >= 0; j--) {
                for (var k = edgeBuffer.length - 1; k >= j + 1; k--) {
                    if (edgesEqual(edgeBuffer[k], edgeBuffer[j])) {
                        edgeBuffer.splice(k, 1);
                        edgeBuffer.splice(j, 1);
                        k--;
                        continue;
                    }
                }
            }
            for (var j = 0; j < edgeBuffer.length; j++) {
                var newTriangle = new Triangle_1.default(edgeBuffer[j][0], edgeBuffer[j][1], vertex);
                triangles.push(newTriangle);
            }
        }
        for (var i = triangles.length - 1; i >= 0; i--) {
            if (triangles[i].getAmountOfSharedVerticesWith(superTriangle)) {
                triangles.splice(i, 1);
            }
        }
        var trianglesWithoutSuperTriangle = triangles.filter(function (triangle) {
            var verticesSharedWithSuperTriangle = triangle.getAmountOfSharedVerticesWith(superTriangle);
            return verticesSharedWithSuperTriangle === 0;
        });
        return trianglesWithoutSuperTriangle;
    }
    exports.default = triangulate;
    function makeSuperTriangle(vertices, highestCoordinateValue) {
        var max;
        if (highestCoordinateValue) {
            max = highestCoordinateValue;
        }
        else {
            max = vertices[0].x;
            for (var i = 0; i < vertices.length; i++) {
                if (vertices[i].x > max) {
                    max = vertices[i].x;
                }
                if (vertices[i].y > max) {
                    max = vertices[i].y;
                }
            }
        }
        var triangle = new Triangle_1.default({
            x: 3 * max,
            y: 0,
        }, {
            x: 0,
            y: 3 * max,
        }, {
            x: -3 * max,
            y: -3 * max,
        });
        return triangle;
    }
    function edgesEqual(e1, e2) {
        return ((utility_60.pointsEqual(e1[0], e2[0]) && utility_60.pointsEqual(e1[1], e2[1])) ||
            (utility_60.pointsEqual(e1[0], e2[1]) && utility_60.pointsEqual(e1[1], e2[0])));
    }
});
define("modules/defaultmapgen/common/mapGenUtils", ["require", "exports", "modules/defaultbuildings/templates/Templates", "modules/defaultmapgen/common/triangulate", "src/Building", "src/Region", "src/Star", "src/pathFinding", "src/utility"], function (require, exports, Templates_1, triangulate_1, Building_4, Region_1, Star_4, pathFinding_3, utility_61) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function linkStarsByTriangulation(stars) {
        if (stars.length < 3) {
            if (stars.length === 2) {
                stars[0].addLink(stars[1]);
            }
            return;
        }
        var triangles = triangulate_1.default(stars);
        for (var i = 0; i < triangles.length; i++) {
            var edges = triangles[i].getEdges();
            for (var j = 0; j < edges.length; j++) {
                edges[j][0].addLink(edges[j][1]);
            }
        }
    }
    exports.linkStarsByTriangulation = linkStarsByTriangulation;
    function partiallySeverLinks(stars, mapGenDataByStarId, minConnectionsToKeep, maxCuts) {
        stars.forEach(function (star) {
            var cutsDone = 0;
            var neighbors = star.getAllLinks();
            var mapGenDistance = mapGenDataByStarId[star.id].mapGenDistance;
            if (neighbors.length > minConnectionsToKeep) {
                for (var j = neighbors.length - 1; j >= 0; j--) {
                    var neighbor = neighbors[j];
                    if (cutsDone < maxCuts) {
                        var neighborLinks = neighbor.getAllLinks();
                        if (neighbors.length <= minConnectionsToKeep || neighborLinks.length <= minConnectionsToKeep)
                            continue;
                        var totalLinks = neighbors.length + neighborLinks.length;
                        var cutThreshhold = 0.05 + 0.025 * (totalLinks - minConnectionsToKeep) * (1 - mapGenDistance);
                        var minMultipleCutThreshhold = 0.15;
                        if (cutThreshhold > 0) {
                            if (Math.random() < cutThreshhold) {
                                star.removeLink(neighbor);
                                neighbors.pop();
                                if (!cutsDone) {
                                    cutsDone = 0;
                                }
                                cutsDone++;
                                var path = pathFinding_3.aStar(star, neighbor);
                                if (!path) {
                                    star.addLink(neighbor);
                                    cutsDone--;
                                    neighbors.push(neighbor);
                                }
                            }
                            cutThreshhold -= minMultipleCutThreshhold;
                        }
                    }
                }
            }
        });
    }
    exports.partiallySeverLinks = partiallySeverLinks;
    function getStarConnectedness(star, maxRange) {
        var connectedness = 0;
        var linkedByRange = star.getLinkedInRange(maxRange).byRange;
        for (var rangeString in linkedByRange) {
            var range = parseInt(rangeString);
            connectedness += linkedByRange[rangeString].length / range;
        }
        return connectedness;
    }
    exports.getStarConnectedness = getStarConnectedness;
    function makeSectors(stars, mapGenDataByStarId, minSize, maxSize) {
        var totalStars = stars.length;
        var averageSize = (minSize + maxSize) / 2;
        var averageSectorsAmount = Math.round(totalStars / averageSize);
        var sectorIdGen = 0;
        var sectorsById = {};
        var sectorsByStarId = {};
        var unassignedStars = stars.slice(0);
        var leftoverStars = [];
        unassignedStars.sort(function (a, b) {
            return mapGenDataByStarId[b.id].connectedness - mapGenDataByStarId[a.id].connectedness;
        });
        var _loop_15 = function () {
            var seedStar = unassignedStars.pop();
            var islandForSameSector = Star_4.default.getIslandForQualifier([seedStar], null, function (a, b) {
                return sectorsByStarId[a.id] === sectorsByStarId[b.id];
            });
            var canFormMinSizeSector = islandForSameSector.length >= minSize;
            if (canFormMinSizeSector) {
                var sectorId = sectorIdGen++;
                var sector_1 = new Region_1.default("sector_" + sectorId);
                sectorsById[sectorId] = sector_1;
                var discoveryStarIndex = 0;
                sector_1.addStar(seedStar);
                sectorsByStarId[seedStar.id] = sector_1;
                while (sector_1.stars.length < minSize) {
                    var discoveryStar = sector_1.stars[discoveryStarIndex];
                    var discoveryStarLinkedNeighbors = discoveryStar.getLinkedInRange(1).all;
                    var frontier = discoveryStarLinkedNeighbors.filter(function (star) {
                        var starHasSector = Boolean(sectorsByStarId[star.id]);
                        return !starHasSector;
                    });
                    var _loop_16 = function () {
                        var frontierSortScores = {};
                        frontier.forEach(function (star) {
                            var borderLengthWithSector = sector_1.getBorderLengthWithStars([star]);
                            var borderScore = borderLengthWithSector / 15;
                            var connectedness = mapGenDataByStarId[star.id].connectedness;
                            frontierSortScores[star.id] = borderScore - connectedness;
                        });
                        frontier.sort(function (a, b) {
                            return frontierSortScores[b.id] - frontierSortScores[a.id];
                        });
                        var toAdd = frontier.pop();
                        unassignedStars.splice(unassignedStars.indexOf(toAdd), 1);
                        sector_1.addStar(toAdd);
                        sectorsByStarId[toAdd.id] = sector_1;
                    };
                    while (sector_1.stars.length < minSize && frontier.length > 0) {
                        _loop_16();
                    }
                    discoveryStarIndex++;
                }
            }
            else {
                leftoverStars.push(seedStar);
            }
        };
        while (averageSectorsAmount > 0 && unassignedStars.length > 0) {
            _loop_15();
        }
        var _loop_17 = function () {
            var star = leftoverStars.pop();
            var neighbors = star.getLinkedInRange(1).all;
            var alreadyAddedNeighborSectors = {};
            var candidateSectors = [];
            neighbors.forEach(function (neighbor) {
                var neighborSector = sectorsByStarId[neighbor.id];
                if (neighborSector) {
                    if (!alreadyAddedNeighborSectors[neighborSector.id]) {
                        alreadyAddedNeighborSectors[neighborSector.id] = true;
                        candidateSectors.push(neighborSector);
                    }
                }
            });
            if (candidateSectors.length < 1) {
                leftoverStars.unshift(star);
                return "continue";
            }
            else {
                var unclaimedNeighborsPerSector_1 = {};
                candidateSectors.forEach(function (sector) {
                    var sectorLinkedStars = sector.getLinkedStars();
                    var unclaimedSectorLinkedStars = sectorLinkedStars.filter(function (star) {
                        return !sectorsByStarId[star.id];
                    });
                    unclaimedNeighborsPerSector_1[sector.id] = unclaimedSectorLinkedStars.length;
                });
                candidateSectors.sort(function (a, b) {
                    var sizeSort = a.stars.length - b.stars.length;
                    if (sizeSort)
                        return sizeSort;
                    var unclaimedSort = unclaimedNeighborsPerSector_1[b.id] -
                        unclaimedNeighborsPerSector_1[a.id];
                    if (sizeSort)
                        return unclaimedSort;
                    var perimeterSort = b.getBorderLengthWithStars([star]) - a.getBorderLengthWithStars([star]);
                    if (perimeterSort)
                        return perimeterSort;
                    return a.id.localeCompare(b.id);
                });
                candidateSectors[0].addStar(star);
                sectorsByStarId[star.id] = candidateSectors[0];
            }
        };
        while (leftoverStars.length > 0) {
            _loop_17();
        }
        return Object.keys(sectorsById).map(function (sectorId) {
            return sectorsById[sectorId];
        });
    }
    exports.makeSectors = makeSectors;
    function distributeDistributablesPerSector(sectors, distributionFlagsBySectorId, distributablesByDistributionGroup, placerFunction) {
        var probabilityWeights = {};
        var allDistributablesByType = {};
        var addedDistributablesByRegionId = {};
        for (var distributionGroup in distributablesByDistributionGroup) {
            var distributables = distributablesByDistributionGroup[distributionGroup];
            distributables.forEach(function (distributable) {
                probabilityWeights[distributable.type] = distributable.distributionData.weight;
                allDistributablesByType[distributable.type] = distributable;
            });
        }
        sectors.forEach(function (sector) {
            var alreadyAddedByWeight = utility_61.getRelativeWeightsFromObject(probabilityWeights);
            var distributionFlags = distributionFlagsBySectorId[sector.id];
            var distributablesForSector = distributionFlags.reduce(function (distributables, flag) {
                return distributables.concat(distributablesByDistributionGroup[flag]);
            }, []);
            if (distributablesForSector.length < 1) {
                return;
            }
            var linkedNeighborRegions = sector.getLinkedRegions(sectors);
            var candidatesNotInNeighboringSectors = distributablesForSector.filter(function (candidate) {
                return linkedNeighborRegions.some(function (linkedRegion) {
                    return (addedDistributablesByRegionId[linkedRegion.id] &&
                        addedDistributablesByRegionId[linkedRegion.id][candidate.type]);
                });
            });
            var candidates = candidatesNotInNeighboringSectors.length > 0 ?
                candidatesNotInNeighboringSectors :
                distributablesForSector;
            var candidatesByWeight = {};
            candidates.forEach(function (candidate) {
                candidatesByWeight[candidate.type] = alreadyAddedByWeight[candidate.type];
            });
            var selectedKey = utility_61.getRandomKeyWithWeights(candidatesByWeight);
            var selectedType = allDistributablesByType[selectedKey];
            probabilityWeights[selectedKey] /= 2;
            placerFunction(sector, selectedType);
            if (!addedDistributablesByRegionId[sector.id]) {
                addedDistributablesByRegionId[sector.id] = {};
            }
            addedDistributablesByRegionId[sector.id][selectedKey] = true;
        });
    }
    exports.distributeDistributablesPerSector = distributeDistributablesPerSector;
    function addDefenceBuildings(star, amount, addSectorCommand) {
        if (amount === void 0) { amount = 1; }
        if (addSectorCommand === void 0) { addSectorCommand = true; }
        var buildingsToAdd = amount;
        if (!star.owner) {
            console.warn("Tried to add defence buildings to star without owner.");
            return;
        }
        if (buildingsToAdd < 1) {
            return;
        }
        if (addSectorCommand) {
            star.addBuilding(new Building_4.default({
                template: Templates_1.sectorCommand,
                location: star,
            }));
            buildingsToAdd -= 1;
        }
        for (var i = 0; i < buildingsToAdd; i++) {
            star.addBuilding(new Building_4.default({
                template: Templates_1.starBase,
                location: star,
            }));
        }
    }
    exports.addDefenceBuildings = addDefenceBuildings;
    function severLinksToNonAdjacentStars(star) {
        var allLinks = star.getAllLinks();
        var neighbors = star.getNeighbors();
        allLinks.forEach(function (linkedStar) {
            if (neighbors.indexOf(linkedStar) === -1) {
                star.removeLink(linkedStar);
            }
        });
    }
    exports.severLinksToNonAdjacentStars = severLinksToNonAdjacentStars;
});
define("modules/defaultmapgen/common/setupIndependents", ["require", "exports", "modules/defaultmapgen/common/mapGenUtils", "src/activeModuleData", "src/utility"], function (require, exports, mapGenUtils_1, activeModuleData_29, utility_62) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function setupIndependents(props) {
        var independentStars = props.region.stars.filter(function (star) {
            return !star.owner || star.owner.isIndependent;
        });
        independentStars.forEach(function (star) {
            props.player.addStar(star);
            mapGenUtils_1.addDefenceBuildings(star, 1, false);
        });
        var starsByDistance = getStarsByDistanceToPlayer(independentStars, props.mapGenDataByStarId);
        var maxDistanceFromPlayer = getMaxDistanceFromStarsByDistance(starsByDistance);
        var starsAtMaxDistance = starsByDistance[maxDistanceFromPlayer];
        var commanderStar = getMostSuitableCommanderStarFromStars(starsAtMaxDistance, props.mapGenDataByStarId);
        var globalMaxDistanceFromPlayer = (function () {
            var maxDistance = 0;
            for (var starId in props.mapGenDataByStarId) {
                var distance = props.mapGenDataByStarId[starId].distanceFromPlayerOwnedLocation;
                maxDistance = Math.max(maxDistance, distance);
            }
            return maxDistance;
        })();
        independentStars.forEach(function (star) {
            var mapGenData = props.mapGenDataByStarId[star.id];
            var distanceFromPlayer = mapGenData.distanceFromPlayerOwnedLocation - 1;
            var relativeDistanceFromPlayer = distanceFromPlayer / globalMaxDistanceFromPlayer;
            var globalStrength = Math.pow(relativeDistanceFromPlayer, 1.8) * props.intensity + utility_62.randRange(-props.variance, props.variance);
            var localStrength = star === commanderStar ? 1 : 0.5;
            star.race.generateIndependentFleets(props.player, star, globalStrength, localStrength, activeModuleData_29.activeModuleData.ruleSet.battle.maxUnitsPerSide);
        });
    }
    exports.default = setupIndependents;
    function getStarsByDistanceToPlayer(stars, mapGenDataByStarId) {
        var starsByDistance = {};
        stars.forEach(function (star) {
            var distance = mapGenDataByStarId[star.id].distanceFromPlayerOwnedLocation;
            if (!starsByDistance[distance]) {
                starsByDistance[distance] = [];
            }
            starsByDistance[distance].push(star);
        });
        return starsByDistance;
    }
    function getMaxDistanceFromStarsByDistance(starsByDistance) {
        var numericDistances = Object.keys(starsByDistance).map(function (distanceString) {
            return parseInt(distanceString);
        });
        var maxDistance = Math.max.apply(null, numericDistances);
        return maxDistance;
    }
    function getMostSuitableCommanderStarFromStars(stars, mapGenDataByStarId) {
        return stars.sort(function (a, b) {
            var connectednessSort = mapGenDataByStarId[b.id].connectedness - mapGenDataByStarId[a.id].connectedness;
            if (connectednessSort) {
                return connectednessSort;
            }
            else {
                return mapGenDataByStarId[b.id].mapGenDistance - mapGenDataByStarId[a.id].mapGenDistance;
            }
        })[0];
    }
});
define("modules/defaultmapgen/spiralGalaxy/SpiralGalaxyOptionValues", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("modules/defaultmapgen/spiralGalaxy/generateSpiralPoints", ["require", "exports", "modules/defaultmapgen/common/MapGenPoint", "src/utility"], function (require, exports, MapGenPoint_1, utility_63) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function generateSpiralPoints(options) {
        var sg = convertMapGenOptionValues(options);
        var makePoint = function (distanceMin, distanceMax, arm, maxOffset) {
            var distance = utility_63.randRange(distanceMin, distanceMax);
            var offset = Math.random() * maxOffset - maxOffset / 2;
            offset *= (1 / distance);
            if (offset < 0) {
                offset = Math.pow(offset, 2) * -1;
            }
            else {
                offset = Math.pow(offset, 2);
            }
            var armRotation = distance * sg.armRotationFactor;
            var angle = arm * sg.armDistance + sg.galaxyRotation + offset + armRotation;
            var width = options.defaultOptions.width / 2;
            var height = options.defaultOptions.height / 2;
            var x = Math.cos(angle) * distance * width + width;
            var y = Math.sin(angle) * distance * height + height;
            var point = new MapGenPoint_1.default(x, y);
            point.mapGenData.mapGenDistance = distance;
            return point;
        };
        var points = [];
        for (var i = 0; i < sg.totalArms; i++) {
            var currentArmIsFiller = i % 2 !== 0;
            var amountForThisArm = currentArmIsFiller ? sg.amountPerFillerArm : sg.amountPerArm;
            var shouldMakeUpDeficitForThisArm = sg.armsToMakeUpDeficit.indexOf(i) !== -1;
            var amountForThisCenter = sg.amountPerCenter +
                (shouldMakeUpDeficitForThisArm ? sg.starsToAddPerDeficitArm : 0);
            var maxOffsetForThisArm = currentArmIsFiller ? sg.armOffsetMax / 2 : sg.armOffsetMax;
            for (var j = 0; j < amountForThisArm; j++) {
                var point = makePoint(sg.centerSize, 1, i, maxOffsetForThisArm);
                points.push(point);
                point.mapGenData.tags = ["arm_" + i];
                point.mapGenData.isFiller = currentArmIsFiller;
            }
            for (var j = 0; j < amountForThisCenter; j++) {
                var point = makePoint(0, sg.centerSize, i, maxOffsetForThisArm);
                points.push(point);
                point.mapGenData.tags = ["center"];
                point.mapGenData.isFiller = false;
            }
        }
        return points;
    }
    exports.default = generateSpiralPoints;
    function convertMapGenOptionValues(options) {
        var totalStars = options.defaultOptions.starCount;
        var actualArms = options.basicOptions.arms;
        var totalArms = actualArms * 2;
        var percentageInCenter = 0.3;
        var percentageInArms = 1 - percentageInCenter;
        var amountInCenter = totalStars * percentageInCenter;
        var amountPerArm = Math.round(totalStars / actualArms * percentageInArms);
        var amountPerFillerArm = Math.round(amountPerArm / 2);
        var amountPerCenter = Math.round(amountInCenter / totalArms);
        var actualStarsInArms = actualArms * amountPerArm;
        var actualStarsInCenter = totalArms * amountPerCenter;
        var actualStars = actualStarsInCenter + actualStarsInArms;
        var starsDeficit = totalStars - actualStars;
        var armsToMakeUpDeficit = [];
        var starsToAddPerDeficitArm = 0;
        if (starsDeficit !== 0) {
            starsToAddPerDeficitArm = starsDeficit > 0 ? 1 : -1;
            var deficitStep = totalArms / Math.abs(starsDeficit);
            for (var i = 0; i < totalArms; i += deficitStep) {
                armsToMakeUpDeficit.push(Math.round(i));
            }
        }
        return ({
            totalArms: totalArms,
            armsToMakeUpDeficit: armsToMakeUpDeficit,
            starsToAddPerDeficitArm: starsToAddPerDeficitArm,
            amountPerArm: amountPerArm,
            amountPerFillerArm: amountPerFillerArm,
            amountPerCenter: amountPerCenter,
            centerSize: 0.4,
            armDistance: Math.PI * 2 / totalArms,
            armOffsetMax: 0.5,
            armRotationFactor: actualArms / 3,
            galaxyRotation: utility_63.randRange(0, Math.PI * 2),
        });
    }
});
define("modules/defaultmapgen/spiralGalaxy/spiralGalaxyGeneration", ["require", "exports", "src/activeModuleData", "src/FillerPoint", "src/MapGenResult", "src/Region", "src/Star", "src/TemplateIndexes", "src/utility", "src/voronoi", "modules/defaultmapgen/common/mapGenUtils", "modules/defaultmapgen/common/setupIndependents", "modules/defaultmapgen/spiralGalaxy/generateSpiralPoints"], function (require, exports, activeModuleData_30, FillerPoint_2, MapGenResult_2, Region_2, Star_5, TemplateIndexes_1, utility_64, voronoi_2, mapGenUtils_2, setupIndependents_1, generateSpiralPoints_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var spiralGalaxyGeneration = function (options, players) {
        var seed = "" + Math.random();
        var oldRandom = Math.random;
        Math.random = RNG.prototype.uniform.bind(new RNG(seed));
        var points = generateSpiralPoints_1.default(options);
        var voronoiRegularity = options.basicOptions.starSizeRegularity / 100;
        var centerDensity = options.basicOptions.centerDensity / 100;
        var inverseCenterDensity = 1 - centerDensity;
        var getRelaxAmountFN = function (point) {
            return (inverseCenterDensity + centerDensity * point.mapGenData.mapGenDistance) * voronoiRegularity;
        };
        for (var i = 0; i < 2; i++) {
            var diagram_1 = voronoi_2.makeVoronoi(points, options.defaultOptions.width, options.defaultOptions.height);
            voronoi_2.relaxVoronoi(diagram_1, getRelaxAmountFN);
        }
        var starsWithMapGenPoints = [];
        var stars = [];
        var fillerPoints = [];
        points.forEach(function (point) {
            if (point.mapGenData.isFiller) {
                var fillerPoint = new FillerPoint_2.default(point.x, point.y);
                fillerPoints.push(fillerPoint);
            }
            else {
                var star = new Star_5.default({
                    x: point.x,
                    y: point.y,
                });
                stars.push(star);
                starsWithMapGenPoints.push({
                    star: star,
                    mapGenpoint: point,
                });
            }
        });
        var allPoints = [].concat(stars, fillerPoints);
        var diagram = voronoi_2.makeVoronoi(allPoints, options.defaultOptions.width, options.defaultOptions.height);
        voronoi_2.setVoronoiCells(diagram.cells);
        var mapGenDataByStarId = {};
        starsWithMapGenPoints.forEach(function (starWithMapGenPoint) {
            mapGenDataByStarId[starWithMapGenPoint.star.id] =
                starWithMapGenPoint.mapGenpoint.mapGenData;
        });
        var regions = [];
        var regionsById = {};
        starsWithMapGenPoints.forEach(function (starWithMapGenPoint) {
            var tags = starWithMapGenPoint.mapGenpoint.mapGenData.tags;
            tags.forEach(function (tag) {
                if (!regionsById[tag]) {
                    regionsById[tag] = new Region_2.default(tag);
                    regions.push(regionsById[tag]);
                }
                regionsById[tag].addStar(starWithMapGenPoint.star);
            });
        });
        stars.forEach(function (star) {
            star.getNeighbors().filter(function (neighbor) {
                var castedPoint = neighbor;
                var isFiller = !isFinite(castedPoint.id);
                return !isFiller;
            }).forEach(function (neighbor) {
                star.addLink(neighbor);
            });
        });
        var armRegions = regions.filter(function (region) {
            return region !== regionsById["center"];
        });
        armRegions.forEach(function (region) {
            region.severLinksToRegionsExcept([region, regionsById["center"]]);
        });
        var entireMapIsConnected = stars[0].getAllLinkedStars().length === stars.length;
        if (!entireMapIsConnected) {
            console.log("Regenerated map due to insufficient connections");
            return spiralGalaxyGeneration(options, players);
        }
        mapGenUtils_2.partiallySeverLinks(stars, mapGenDataByStarId, 4, 2);
        stars.forEach(function (star) {
            mapGenDataByStarId[star.id].connectedness = mapGenUtils_2.getStarConnectedness(star, 3);
        });
        var sectors = mapGenUtils_2.makeSectors(stars, mapGenDataByStarId, 3, 3);
        var distributionFlagsBySectorId = {};
        sectors.forEach(function (sector) {
            var distributionFlagsByKeyWord = {
                arm: "common",
                center: "rare",
            };
            var foundDistributionFlags = {
                common: false,
                rare: false,
            };
            var distributionFlags = [];
            var majorityRegions = sector.getMajorityRegions(regions);
            majorityRegions.forEach(function (region) {
                for (var keyWord in distributionFlagsByKeyWord) {
                    if (region.id.indexOf(keyWord) !== -1) {
                        var distributionFlag = distributionFlagsByKeyWord[keyWord];
                        if (!foundDistributionFlags[distributionFlag]) {
                            foundDistributionFlags[distributionFlag] = true;
                            distributionFlags.push(distributionFlag);
                        }
                    }
                }
                distributionFlagsBySectorId[sector.id] = distributionFlags;
            });
        });
        var startRegions = (function setStartingRegions() {
            var availableStartRegions = regions.filter(function (region) {
                return region.id.indexOf("center") === -1;
            });
            var armCount = options.basicOptions.arms;
            var playersInArmsCount = Math.min(players.length, armCount);
            var playerArmStep = armCount / playersInArmsCount;
            var startRegions = [];
            for (var i = 0; i < playersInArmsCount; i++) {
                var regionNumber = Math.floor(i * playerArmStep);
                var regionToAdd = availableStartRegions[regionNumber];
                startRegions.push(regionToAdd);
            }
            var leftOverPlayerCount = playersInArmsCount - armCount;
            for (var i = 0; i < leftOverPlayerCount; i++) {
                startRegions.push(regionsById["center"]);
            }
            return startRegions;
        })();
        var startPositions = (function getStartPoints(regions) {
            var startPositions = [];
            for (var i = 0; i < regions.length; i++) {
                var region = regions[i];
                var starsByDistance = region.stars.slice(0).sort(function (a, b) {
                    return mapGenDataByStarId[b.id].mapGenDistance - mapGenDataByStarId[a.id].mapGenDistance;
                });
                var star = starsByDistance[0];
                startPositions.push(star);
            }
            return startPositions;
        })(startRegions);
        for (var i = 0; i < startPositions.length; i++) {
            var star = startPositions[i];
            var player = players[i];
            player.addStar(star);
            star.race = player.race;
            mapGenUtils_2.addDefenceBuildings(star, 2);
            star.buildManufactory();
        }
        (function setDistanceFromPlayer() {
            var isPlayerOwnedFN = (function (star) {
                return star.owner && !star.owner.isIndependent;
            });
            stars.forEach(function (star) {
                var nearestPlayerStar = star.getNearestStarForQualifier(isPlayerOwnedFN);
                var distanceToPlayer = star.getDistanceToStar(nearestPlayerStar);
                mapGenDataByStarId[star.id].distanceFromPlayerOwnedLocation = distanceToPlayer;
            });
        })();
        var racePlacerFN = function (sector, race) {
            var existingStarsWithRace = sector.stars.filter(function (star) { return Boolean(star.race); });
            var existingRaceInSector = existingStarsWithRace.length > 0 ? existingStarsWithRace[0].race : null;
            sector.stars.forEach(function (star) {
                star.race = existingRaceInSector || race;
            });
        };
        mapGenUtils_2.distributeDistributablesPerSector(sectors, distributionFlagsBySectorId, TemplateIndexes_1.default.distributablesByDistributionGroup.races, racePlacerFN);
        var resourcePlacerFN = function (sector, resource) {
            sector.stars[0].setResource(resource);
        };
        mapGenUtils_2.distributeDistributablesPerSector(sectors, distributionFlagsBySectorId, TemplateIndexes_1.default.distributablesByDistributionGroup.resources, resourcePlacerFN);
        var independents = [];
        sectors.forEach(function (sector) {
            var sectorRace = sector.stars[0].race;
            var sectorIndependents = sectorRace.generateIndependentPlayer(activeModuleData_30.activeModuleData.Templates.SubEmblems);
            independents.push(sectorIndependents);
            setupIndependents_1.default({
                player: sectorIndependents,
                region: sector,
                intensity: 1,
                variance: 0,
                mapGenDataByStarId: mapGenDataByStarId,
            });
        });
        stars.forEach(function (star) {
            star.baseIncome = utility_64.randInt(4, 6) * 10;
        });
        Math.random = oldRandom;
        return new MapGenResult_2.default({
            stars: stars,
            fillerPoints: fillerPoints,
            width: options.defaultOptions.width,
            height: options.defaultOptions.height,
            seed: seed,
            independents: independents,
        });
    };
    exports.default = spiralGalaxyGeneration;
});
define("modules/defaultmapgen/templates/spiralGalaxy", ["require", "exports", "modules/defaultmapgen/spiralGalaxy/spiralGalaxyGeneration"], function (require, exports, spiralGalaxyGeneration_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var spiralGalaxy = {
        key: "spiralGalaxy",
        displayName: "Spiral galaxy",
        description: "Create a spiral galaxy with arms",
        minPlayers: 2,
        maxPlayers: 5,
        mapGenFunction: spiralGalaxyGeneration_1.default,
        options: {
            defaultOptions: {
                height: {
                    displayName: "Height",
                    range: {
                        min: 800,
                        max: 1600,
                        step: 1,
                    },
                },
                width: {
                    displayName: "Width",
                    range: {
                        min: 800,
                        max: 1600,
                        step: 1,
                    },
                },
                starCount: {
                    displayName: "Star count",
                    range: {
                        min: 20,
                        max: 40,
                        step: 1,
                    },
                },
            },
            basicOptions: {
                arms: {
                    displayName: "Arms",
                    range: {
                        min: 3,
                        max: 6,
                        step: 1,
                        defaultValue: 5,
                    },
                },
                starSizeRegularity: {
                    displayName: "Star size regularity",
                    range: {
                        min: 1,
                        max: 100,
                        step: 1,
                        defaultValue: 100,
                    },
                },
                centerDensity: {
                    displayName: "Center density",
                    range: {
                        min: 1,
                        max: 90,
                        step: 1,
                        defaultValue: 50,
                    },
                },
            },
        },
    };
    exports.default = spiralGalaxy;
});
define("modules/defaultmapgen/templates/tinierSpiralGalaxy", ["require", "exports", "modules/defaultmapgen/spiralGalaxy/spiralGalaxyGeneration"], function (require, exports, spiralGalaxyGeneration_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tinierSpiralGalaxy = {
        key: "tinierSpiralGalaxy",
        displayName: "Tinier Spiral galaxy",
        description: "Create a spiral galaxy with arms but tinier (just for testing)",
        minPlayers: 2,
        maxPlayers: 4,
        mapGenFunction: spiralGalaxyGeneration_2.default,
        options: {
            defaultOptions: {
                height: {
                    displayName: "height",
                    range: {
                        min: 500,
                        max: 1000,
                        step: 1,
                    },
                },
                width: {
                    displayName: "width",
                    range: {
                        min: 500,
                        max: 1000,
                        step: 1,
                    },
                },
                starCount: {
                    displayName: "starCount",
                    range: {
                        min: 15,
                        max: 30,
                        step: 1,
                        defaultValue: 20,
                    },
                },
            },
            basicOptions: {
                arms: {
                    displayName: "arms",
                    range: {
                        min: 2,
                        max: 5,
                        step: 1,
                        defaultValue: 4,
                    },
                },
                starSizeRegularity: {
                    displayName: "starSizeRegularity",
                    range: {
                        min: 1,
                        max: 100,
                        step: 1,
                        defaultValue: 100,
                    },
                },
                centerDensity: {
                    displayName: "centerDensity",
                    range: {
                        min: 1,
                        max: 90,
                        step: 1,
                        defaultValue: 50,
                    },
                },
            },
        },
    };
    exports.default = tinierSpiralGalaxy;
});
define("modules/defaultmapgen/defaultMapgen", ["require", "exports", "src/ModuleFileLoadingPhase", "modules/defaultmapgen/templates/spiralGalaxy", "modules/defaultmapgen/templates/tinierSpiralGalaxy", "localization/defaultLanguages"], function (require, exports, ModuleFileLoadingPhase_11, spiralGalaxy_1, tinierSpiralGalaxy_1, Languages) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Templates = (_a = {},
        _a[spiralGalaxy_1.default.key] = spiralGalaxy_1.default,
        _a[tinierSpiralGalaxy_1.default.key] = tinierSpiralGalaxy_1.default,
        _a);
    var defaultMapGen = {
        key: "defaultMapGen",
        metaData: {
            name: "Default map gen",
            version: "0.1.0",
            author: "giraluna",
            description: "",
        },
        needsToBeLoadedBefore: ModuleFileLoadingPhase_11.default.Setup,
        supportedLanguages: [Languages.en],
        constructModule: function (moduleData) {
            moduleData.copyTemplates(Templates, "MapGen");
            if (!moduleData.defaultMap) {
                moduleData.defaultMap = spiralGalaxy_1.default;
            }
            return moduleData;
        },
    };
    exports.default = defaultMapGen;
    var _a;
});
define("modules/defaultmapmodes/maplayertemplates/nonFillerStars", ["require", "exports", "src/eventManager", "src/pixiWrapperFunctions"], function (require, exports, eventManager_39, pixiWrapperFunctions_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var nonFillerStars = {
        key: "nonFillerStars",
        displayName: "Stars",
        interactive: true,
        isUsedForCameraBounds: false,
        drawingFunction: function (map, perspectivePlayer) {
            var doc = new PIXI.Container();
            var points = perspectivePlayer ? perspectivePlayer.getRevealedStars() : map.stars;
            var onClickFN = function (star) {
                eventManager_39.default.dispatchEvent("starClick", star);
            };
            var mouseOverFN = function (star) {
                eventManager_39.default.dispatchEvent("hoverStar", star);
            };
            var mouseOutFN = function (event) {
                eventManager_39.default.dispatchEvent("clearHover");
            };
            for (var i = 0; i < points.length; i++) {
                var star = points[i];
                var starSize = 1;
                if (star.buildings["defence"]) {
                    starSize += star.buildings["defence"].length * 2;
                }
                var gfx = new PIXI.Graphics();
                if (!star.owner.isIndependent) {
                    gfx.lineStyle(starSize / 2, star.owner.color.getHex(), 1);
                }
                gfx.beginFill(0xFFFFF0);
                gfx.drawCircle(star.x, star.y, starSize);
                gfx.endFill();
                gfx.interactive = true;
                gfx.hitArea = pixiWrapperFunctions_10.makePolygonFromPoints(star.voronoiCell.vertices);
                var gfxClickFN = function (star, event) {
                    var originalEvent = event.data.originalEvent;
                    if (originalEvent.button)
                        return;
                    onClickFN(star);
                }.bind(null, star);
                gfx.on("click", gfxClickFN);
                gfx.on("mouseover", mouseOverFN.bind(gfx, star));
                gfx.on("mouseout", mouseOutFN);
                gfx.on("tap", gfxClickFN);
                doc.addChild(gfx);
            }
            doc.interactive = true;
            doc.on("touchmove", function (event) {
                var local = event.data.getLocalPosition(doc);
                var starAtLocal = map.voronoi.getStarAtPoint(local);
                if (starAtLocal) {
                    eventManager_39.default.dispatchEvent("hoverStar", starAtLocal);
                }
            });
            return doc;
        },
    };
    exports.default = nonFillerStars;
});
define("modules/defaultmapmodes/maplayertemplates/starLinks", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var starLinks = {
        key: "starLinks",
        displayName: "Links",
        interactive: false,
        isUsedForCameraBounds: false,
        drawingFunction: function (map, perspectivePlayer) {
            var doc = new PIXI.Container();
            var gfx = new PIXI.Graphics();
            doc.addChild(gfx);
            gfx.lineStyle(1, 0xCCCCCC, 0.6);
            var points = perspectivePlayer ? perspectivePlayer.getRevealedStars() : map.stars;
            var starsFullyConnected = {};
            for (var i = 0; i < points.length; i++) {
                var star = points[i];
                if (starsFullyConnected[star.id])
                    continue;
                starsFullyConnected[star.id] = true;
                for (var j = 0; j < star.linksTo.length; j++) {
                    gfx.moveTo(star.x, star.y);
                    gfx.lineTo(star.linksTo[j].x, star.linksTo[j].y);
                }
                for (var j = 0; j < star.linksFrom.length; j++) {
                    gfx.moveTo(star.linksFrom[j].x, star.linksFrom[j].y);
                    gfx.lineTo(star.x, star.y);
                }
            }
            return doc;
        },
    };
    exports.default = starLinks;
});
define("modules/defaultmapmodes/maplayertemplates/fleets", ["require", "exports", "src/App", "src/eventManager"], function (require, exports, App_16, eventManager_40) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var fleets = {
        key: "fleets",
        displayName: "Fleets",
        interactive: true,
        isUsedForCameraBounds: false,
        destroy: function () {
            for (var fleetSize in fleetTextTextureCache) {
                fleetTextTextureCache[fleetSize].destroy(true);
                fleetTextTextureCache[fleetSize] = null;
                delete fleetTextTextureCache[fleetSize];
            }
        },
        drawingFunction: function (map, perspectivePlayer) {
            var doc = new PIXI.Container();
            var points = perspectivePlayer ? perspectivePlayer.getVisibleStars() : map.stars;
            var mouseOverFN = function (fleet) {
                eventManager_40.default.dispatchEvent("hoverStar", fleet.location);
            };
            var fleetClickFN = function (fleet, event) {
                var originalEvent = event.data.originalEvent;
                ;
                if (originalEvent.button === 0) {
                    eventManager_40.default.dispatchEvent("selectFleets", [fleet]);
                }
            };
            function singleFleetDrawFN(fleet) {
                var fleetContainer = new PIXI.Container();
                var color = fleet.player.color.getHex();
                var fillAlpha = fleet.isStealthy ? 0.3 : 0.7;
                var textTexture = getFleetTextTexture(fleet);
                var text = new PIXI.Sprite(textTexture);
                var containerGfx = new PIXI.Graphics();
                containerGfx.lineStyle(1, 0x00000, 1);
                containerGfx.beginFill(color, fillAlpha);
                containerGfx.drawRect(0, 0, text.width + 4, text.height);
                containerGfx.endFill();
                fleetContainer.addChild(containerGfx);
                fleetContainer.addChild(text);
                text.x += 2;
                text.y -= 1;
                fleetContainer.interactive = true;
                var boundFleetClickFN = fleetClickFN.bind(null, fleet);
                fleetContainer.on("click", boundFleetClickFN);
                fleetContainer.on("tap", boundFleetClickFN);
                fleetContainer.on("mouseover", mouseOverFN.bind(null, fleet));
                return fleetContainer;
            }
            for (var i = 0; i < points.length; i++) {
                var star = points[i];
                var fleets_1 = star.getFleets();
                if (!fleets_1 || fleets_1.length < 1) {
                    continue;
                }
                var fleetsContainer = new PIXI.Container();
                fleetsContainer.x = star.x;
                fleetsContainer.y = star.y - 40;
                for (var j = 0; j < fleets_1.length; j++) {
                    if (fleets_1[j].units.length === 0) {
                        continue;
                    }
                    if (fleets_1[j].isStealthy && perspectivePlayer && !perspectivePlayer.starIsDetected(fleets_1[j].location)) {
                        continue;
                    }
                    var drawnFleet = singleFleetDrawFN(fleets_1[j]);
                    drawnFleet.position.x = fleetsContainer.width;
                    fleetsContainer.addChild(drawnFleet);
                }
                if (fleetsContainer.children.length > 0) {
                    fleetsContainer.x -= fleetsContainer.width / 2;
                    doc.addChild(fleetsContainer);
                }
            }
            return doc;
        },
    };
    exports.default = fleets;
    var fleetTextTextureCache = {};
    function getFleetTextTexture(fleet) {
        var fleetSize = fleet.units.length;
        if (!fleetTextTextureCache[fleetSize]) {
            var text_1 = new PIXI.Text("" + fleetSize, {
                fill: "#FFFFFF",
                stroke: "#000000",
                strokeThickness: 3,
            });
            text_1.getBounds();
            fleetTextTextureCache[fleetSize] = App_16.default.renderer.renderer.generateTexture(text_1);
            window.setTimeout(function () {
                text_1.texture.destroy(true);
            }, 0);
        }
        return fleetTextTextureCache[fleetSize];
    }
});
define("modules/defaultmapmodes/maplayertemplates/nonFillerVoronoiLines", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var nonFillerVoronoiLines = {
        key: "nonFillerVoronoiLines",
        displayName: "Star borders",
        interactive: false,
        isUsedForCameraBounds: true,
        drawingFunction: function (map, perspectivePlayer) {
            var doc = new PIXI.Container();
            var gfx = new PIXI.Graphics();
            doc.addChild(gfx);
            gfx.lineStyle(1, 0xA0A0A0, 0.5);
            var visible = perspectivePlayer ? perspectivePlayer.getRevealedStars() : null;
            var lines = map.voronoi.getNonFillerVoronoiLines(visible);
            for (var i = 0; i < lines.length; i++) {
                var line = lines[i];
                gfx.moveTo(line.va.x, line.va.y);
                gfx.lineTo(line.vb.x, line.vb.y);
            }
            return doc;
        },
    };
    exports.default = nonFillerVoronoiLines;
});
define("modules/defaultmapmodes/maplayertemplates/resources", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var resources = {
        key: "resources",
        displayName: "Resources",
        interactive: false,
        isUsedForCameraBounds: false,
        drawingFunction: function (map, perspectivePlayer) {
            var doc = new PIXI.Container();
            var points = perspectivePlayer ? perspectivePlayer.getRevealedStars() : map.stars;
            for (var i = 0; i < points.length; i++) {
                var star = points[i];
                if (!star.resource)
                    continue;
                var text = new PIXI.Text(star.resource.displayName, {
                    fill: "#FFFFFF",
                    stroke: "#000000",
                    strokeThickness: 2,
                });
                text.x = star.x;
                text.x -= text.width / 2;
                text.y = star.y + 8;
                doc.addChild(text);
            }
            return doc;
        },
    };
    exports.default = resources;
});
define("modules/defaultmapmodes/maplayertemplates/shaders/Occupation", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Occupation = (function (_super) {
        __extends(Occupation, _super);
        function Occupation(initialUniformValues) {
            var _this = this;
            var uniformData = Occupation.makeUniformDataObject(initialUniformValues);
            _this = _super.call(this, null, sourceLines.join("\n"), uniformData) || this;
            return _this;
        }
        Occupation.makeUniformDataObject = function (initialValues) {
            if (initialValues === void 0) { initialValues = {}; }
            return ({
                angle: { type: "float", value: initialValues.angle },
                offset: { type: "vec2", value: initialValues.offset },
                scale: { type: "float", value: initialValues.scale },
                stripeColor: { type: "vec4", value: initialValues.stripeColor },
                stripeSize: { type: "float", value: initialValues.stripeSize },
            });
        };
        Occupation.prototype.setUniforms = function (uniforms) {
            for (var key in uniforms) {
                this.uniforms[key] = uniforms[key];
            }
        };
        return Occupation;
    }(PIXI.Filter));
    exports.default = Occupation;
    var sourceLines = [
        "precision mediump float;",
        "",
        "varying vec2 vTextureCoord;",
        "uniform sampler2D uSampler;",
        "",
        "uniform vec2 offset;",
        "uniform float scale;",
        "uniform float angle;",
        "uniform vec4 stripeColor;",
        "uniform float stripeSize;",
        "",
        "void main()",
        "{",
        "  vec4 color = texture2D(uSampler, vTextureCoord);",
        "",
        "  vec2 pos = gl_FragCoord.xy + offset;",
        "",
        "  vec2 q;",
        "  q.x = cos(angle) * pos.x - sin(angle) * pos.y;",
        "  q.y = sin(angle) * pos.x + cos(angle) * pos.y;",
        "",
        "  q /= scale;",
        "",
        "  float stripeIntensity = sin(q.x) / 2.0 + 0.5;",
        "  stripeIntensity = step(stripeIntensity, stripeSize);",
        "",
        "  gl_FragColor = mix(color, stripeColor * color.a, stripeIntensity);",
        "}",
    ];
});
define("modules/defaultmapmodes/maplayertemplates/starOwners", ["require", "exports", "src/eventManager", "src/pixiWrapperFunctions", "modules/defaultmapmodes/maplayertemplates/shaders/Occupation"], function (require, exports, eventManager_41, pixiWrapperFunctions_11, Occupation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var starOwners = {
        key: "starOwners",
        displayName: "Star owners",
        interactive: false,
        isUsedForCameraBounds: true,
        alpha: 0.5,
        destroy: function () {
            for (var key in occupationShaders) {
                delete occupationShaders[key];
            }
        },
        drawingFunction: function (map, perspectivePlayer) {
            var doc = new PIXI.Container();
            var points = perspectivePlayer ? perspectivePlayer.getRevealedStars() : map.stars;
            for (var i = 0; i < points.length; i++) {
                var star = points[i];
                var occupier = star.getSecondaryController();
                if (!star.owner || (!occupier && star.owner.colorAlpha === 0)) {
                    continue;
                }
                var poly = pixiWrapperFunctions_11.makePolygonFromPoints(star.voronoiCell.vertices);
                var gfx = new PIXI.Graphics();
                var alpha = 1;
                if (isFinite(star.owner.colorAlpha)) {
                    alpha *= star.owner.colorAlpha;
                }
                gfx.beginFill(star.owner.color.getHex(), alpha);
                gfx.drawShape(poly);
                gfx.endFill();
                if (occupier) {
                    gfx.filters = [getOccupationShader(star.owner, occupier)];
                }
                doc.addChild(gfx);
            }
            return doc;
        },
    };
    exports.default = starOwners;
    var occupationShaders = {};
    var hasAddedEventListeners = false;
    function getOccupationShader(owner, occupier) {
        if (!hasAddedEventListeners) {
            eventManager_41.default.addEventListener("cameraZoomed", updateShaderZoom);
            eventManager_41.default.addEventListener("cameraMoved", updateShaderOffset);
        }
        if (!occupationShaders[owner.id]) {
            occupationShaders[owner.id] = {};
        }
        if (!occupationShaders[owner.id][occupier.id]) {
            occupationShaders[owner.id][occupier.id] = new Occupation_1.default({
                stripeColor: occupier.color.getRGBA(1.0),
                stripeSize: 0.33,
                offset: [0.0, 0.0],
                angle: 0.25 * Math.PI,
                scale: 8.0,
            });
        }
        return occupationShaders[owner.id][occupier.id];
    }
    function forEachOccupationShader(cb) {
        for (var ownerId in occupationShaders) {
            for (var occupierId in occupationShaders[ownerId]) {
                cb(occupationShaders[ownerId][occupierId]);
            }
        }
    }
    function updateShaderOffset(x, y) {
        forEachOccupationShader(function (shader) {
            shader.uniforms.offset = [-x, y];
        });
    }
    function updateShaderZoom(zoom) {
        forEachOccupationShader(function (shader) {
            shader.uniforms.scale = zoom * 8.0;
        });
    }
});
define("modules/defaultmapmodes/maplayertemplates/fogOfWar", ["require", "exports", "src/App", "src/pixiWrapperFunctions"], function (require, exports, App_17, pixiWrapperFunctions_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var fogOfWar = {
        key: "fogOfWar",
        displayName: "Fog of war",
        interactive: false,
        isUsedForCameraBounds: false,
        alpha: 0.35,
        destroy: function () {
            for (var starId in fogOfWarSpriteByStarId) {
                fogOfWarSpriteByStarId[starId].renderable = false;
                fogOfWarSpriteByStarId[starId].texture.destroy(true);
                fogOfWarSpriteByStarId[starId] = null;
                delete fogOfWarSpriteByStarId[starId];
            }
        },
        drawingFunction: function (map, perspectivePlayer) {
            var doc = new PIXI.Container();
            if (perspectivePlayer) {
                var starsInFogOfWar = perspectivePlayer.getRevealedButNotVisibleStars();
                for (var i = 0; i < starsInFogOfWar.length; i++) {
                    var star = starsInFogOfWar[i];
                    var sprite = getFogOfWarSpriteForStar(star, map.width, map.height);
                    doc.addChild(sprite);
                }
            }
            return doc;
        },
    };
    exports.default = fogOfWar;
    var fogOfWarTilingSprite;
    function getfogOfWarTilingSprite(width, height) {
        if (!fogOfWarTilingSprite) {
            var fowTexture = PIXI.Texture.fromFrame("modules/defaultmapmodes/img/fowTexture.png");
            fogOfWarTilingSprite = new PIXI.extras.TilingSprite(fowTexture, width, height);
        }
        return fogOfWarTilingSprite;
    }
    var fogOfWarSpriteByStarId = {};
    function getFogOfWarSpriteForStar(star, width, height) {
        var tiled = getfogOfWarTilingSprite(width, height);
        if (!fogOfWarSpriteByStarId[star.id] || Object.keys(fogOfWarSpriteByStarId).length < 4) {
            var poly = pixiWrapperFunctions_12.makePolygonFromPoints(star.voronoiCell.vertices);
            var gfx = new PIXI.Graphics();
            gfx.isMask = true;
            gfx.beginFill(0);
            gfx.drawShape(poly);
            gfx.endFill();
            tiled.removeChildren();
            tiled.mask = gfx;
            tiled.addChild(gfx);
            var bounds = tiled.getBounds();
            var rendered = pixiWrapperFunctions_12.generateTextureWithBounds(App_17.default.renderer.renderer, tiled, PIXI.settings.SCALE_MODE, 1, bounds);
            var sprite = new PIXI.Sprite(rendered);
            fogOfWarSpriteByStarId[star.id] = sprite;
            tiled.mask = null;
        }
        return fogOfWarSpriteByStarId[star.id];
    }
});
define("src/borderPolygon", ["require", "exports", "src/Options", "src/Star", "src/utility"], function (require, exports, Options_12, Star_6, utility_65) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function starsOnlyShareNarrowBorder(a, b) {
        var minBorderWidth = Options_12.default.display.borderWidth * 2;
        var edge = a.getEdgeWith(b);
        if (!edge) {
            return false;
        }
        var edgeLength = Math.abs(edge.va.x - edge.vb.x) + Math.abs(edge.va.y - edge.vb.y);
        if (edgeLength < minBorderWidth) {
            var sharedNeighbors = a.getSharedNeighborsWith(b);
            var sharedOwnedNeighbors = sharedNeighbors.filter(function (sharedNeighbor) {
                return sharedNeighbor.owner === a.owner;
            });
            return sharedOwnedNeighbors.length === 0;
        }
        else {
            return false;
        }
    }
    exports.starsOnlyShareNarrowBorder = starsOnlyShareNarrowBorder;
    function getBorderingHalfEdges(stars) {
        var borderingHalfEdges = [];
        function getHalfEdgeOppositeSite(halfEdge) {
            return halfEdge.edge.lSite === halfEdge.site ?
                halfEdge.edge.rSite : halfEdge.edge.lSite;
        }
        function halfEdgeIsBorder(halfEdge) {
            var oppositeSite = getHalfEdgeOppositeSite(halfEdge);
            var isBorderWithOtherOwner = !oppositeSite || !oppositeSite.owner || (oppositeSite.owner !== halfEdge.site.owner);
            var isBorderWithSameOwner = false;
            if (!isBorderWithOtherOwner) {
                isBorderWithSameOwner = starsOnlyShareNarrowBorder(halfEdge.site, oppositeSite) ||
                    halfEdge.site.getDistanceToStar(oppositeSite) > 3;
            }
            return isBorderWithOtherOwner || isBorderWithSameOwner;
        }
        function halfEdgeSharesOwner(halfEdge) {
            var oppositeSite = getHalfEdgeOppositeSite(halfEdge);
            var sharesOwner = Boolean(oppositeSite) && Boolean(oppositeSite.owner) &&
                (oppositeSite.owner === halfEdge.site.owner);
            return sharesOwner && !starsOnlyShareNarrowBorder(halfEdge.site, oppositeSite);
        }
        function getContiguousHalfEdgeBetweenSharedSites(sharedEdge) {
            var contiguousEdgeEndPoint = sharedEdge.getStartpoint();
            var oppositeSite = getHalfEdgeOppositeSite(sharedEdge);
            for (var i = 0; i < oppositeSite.voronoiCell.halfedges.length; i++) {
                var halfEdge = oppositeSite.voronoiCell.halfedges[i];
                if (halfEdge.getStartpoint() === contiguousEdgeEndPoint) {
                    return halfEdge;
                }
            }
            return false;
        }
        var startEdge;
        var star;
        for (var i = 0; i < stars.length; i++) {
            if (star)
                break;
            for (var j = 0; j < stars[i].voronoiCell.halfedges.length; j++) {
                var halfEdge = stars[i].voronoiCell.halfedges[j];
                if (halfEdgeIsBorder(halfEdge)) {
                    star = stars[i];
                    startEdge = halfEdge;
                    break;
                }
            }
        }
        if (!star)
            throw new Error("Couldn't find starting location for border polygon");
        var hasProcessedStartEdge = false;
        var contiguousEdge = null;
        for (var j = 0; j < stars.length * 40; j++) {
            var indexShift = 0;
            for (var _i = 0; _i < star.voronoiCell.halfedges.length; _i++) {
                if (!hasProcessedStartEdge) {
                    contiguousEdge = startEdge;
                }
                if (contiguousEdge) {
                    indexShift = star.voronoiCell.halfedges.indexOf(contiguousEdge);
                    contiguousEdge = null;
                }
                var i = (_i + indexShift) % (star.voronoiCell.halfedges.length);
                var halfEdge = star.voronoiCell.halfedges[i];
                if (halfEdgeIsBorder(halfEdge)) {
                    borderingHalfEdges.push({
                        star: star,
                        halfEdge: halfEdge,
                    });
                    if (!startEdge) {
                        startEdge = halfEdge;
                    }
                    else if (halfEdge === startEdge) {
                        if (!hasProcessedStartEdge) {
                            hasProcessedStartEdge = true;
                        }
                        else {
                            return borderingHalfEdges;
                        }
                    }
                }
                else if (halfEdgeSharesOwner(halfEdge)) {
                    contiguousEdge = getContiguousHalfEdgeBetweenSharedSites(halfEdge);
                    star = contiguousEdge.site;
                    break;
                }
            }
        }
        throw new Error("getHalfEdgesConnectingStars got stuck in infinite loop when star id = " + star.id);
    }
    exports.getBorderingHalfEdges = getBorderingHalfEdges;
    function joinPointsWithin(points, maxDistance) {
        for (var i = points.length - 2; i >= 0; i--) {
            var x1 = points[i].x;
            var y1 = points[i].y;
            var x2 = points[i + 1].x;
            var y2 = points[i + 1].y;
            if (Math.abs(x1 - x2) + Math.abs(y1 - y2) < maxDistance) {
                var newPoint = {
                    x: (x1 + x2) / 2,
                    y: (y1 + y2) / 2,
                };
                points.splice(i, 2, newPoint);
            }
        }
    }
    exports.joinPointsWithin = joinPointsWithin;
    function convertHalfEdgeDataToOffset(halfEdgeData) {
        var convertedToPoints = halfEdgeData.map(function (data) {
            var v1 = data.halfEdge.getStartpoint();
            return ({
                x: v1.x,
                y: v1.y,
            });
        });
        joinPointsWithin(convertedToPoints, Options_12.default.display.borderWidth / 2);
        var offset = new Offset();
        offset.arcSegments(0);
        var convertedToOffset = offset.data(convertedToPoints).padding(Options_12.default.display.borderWidth / 2);
        return convertedToOffset;
    }
    exports.convertHalfEdgeDataToOffset = convertHalfEdgeDataToOffset;
    function getRevealedBorderEdges(revealedStars, voronoiInfo) {
        var polyLines = [];
        var processedStarsById = {};
        for (var ii = 0; ii < revealedStars.length; ii++) {
            var star = revealedStars[ii];
            if (processedStarsById[star.id]) {
                continue;
            }
            if (!star.owner.isIndependent) {
                var ownedIsland = Star_6.default.getIslandForQualifier([star], null, function (a, b) {
                    return (a.owner === b.owner && !starsOnlyShareNarrowBorder(a, b));
                });
                var currentPolyLine = [];
                var halfEdgesDataForIsland = getBorderingHalfEdges(ownedIsland);
                var offsetted = convertHalfEdgeDataToOffset(halfEdgesDataForIsland);
                for (var j = 0; j < offsetted.length; j++) {
                    var point = offsetted[j];
                    var nextPoint = offsetted[(j + 1) % offsetted.length];
                    var edgeCenter = {
                        x: utility_65.clamp((point.x + nextPoint.x) / 2, voronoiInfo.bounds.x1, voronoiInfo.bounds.x2),
                        y: utility_65.clamp((point.y + nextPoint.y) / 2, voronoiInfo.bounds.y1, voronoiInfo.bounds.y2),
                    };
                    var pointStar = point.star || voronoiInfo.getStarAtPoint(edgeCenter);
                    if (!pointStar) {
                        pointStar = voronoiInfo.getStarAtPoint(point);
                        if (!pointStar) {
                            pointStar = voronoiInfo.getStarAtPoint(nextPoint);
                        }
                    }
                    processedStarsById[pointStar.id] = true;
                    point.star = pointStar;
                }
                var startIndex = 0;
                for (var j = 0; j < offsetted.length; j++) {
                    var currPoint = offsetted[j];
                    var prevPoint = offsetted[(j === 0 ? offsetted.length - 1 : j - 1)];
                    if (revealedStars.indexOf(currPoint.star) !== -1 && revealedStars.indexOf(prevPoint.star) === -1) {
                        startIndex = j;
                    }
                }
                for (var _j = startIndex; _j < offsetted.length + startIndex; _j++) {
                    var j = _j % offsetted.length;
                    var point = offsetted[j];
                    if (revealedStars.indexOf(point.star) === -1) {
                        if (currentPolyLine.length > 1) {
                            currentPolyLine.push(point);
                            polyLines.push(currentPolyLine);
                            currentPolyLine = [];
                        }
                    }
                    else {
                        currentPolyLine.push(point);
                    }
                }
                if (currentPolyLine.length > 1) {
                    polyLines.push(currentPolyLine);
                }
            }
        }
        var polyLinesData = [];
        for (var i = 0; i < polyLines.length; i++) {
            var polyLine = polyLines[i];
            var isClosed = utility_65.pointsEqual(polyLine[0], polyLine[polyLine.length - 1]);
            if (isClosed)
                polyLine.pop();
            for (var j = 0; j < polyLine.length; j++) {
                polyLine[j].x += (j % 2) * 0.1;
                polyLine[j].y += (j % 2) * 0.1;
            }
            polyLinesData.push({
                points: polyLine,
                isClosed: isClosed,
            });
        }
        return polyLinesData;
    }
    exports.getRevealedBorderEdges = getRevealedBorderEdges;
});
define("modules/defaultmapmodes/maplayertemplates/ownerBorders", ["require", "exports", "src/Options", "src/borderPolygon", "src/pixiWrapperFunctions"], function (require, exports, Options_13, borderPolygon_1, pixiWrapperFunctions_13) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ownerBorders = {
        key: "ownerBorders",
        displayName: "Owner borders",
        interactive: false,
        isUsedForCameraBounds: true,
        alpha: 0.7,
        drawingFunction: function (map, perspectivePlayer) {
            var doc = new PIXI.Container();
            if (Options_13.default.display.borderWidth <= 0) {
                return doc;
            }
            var revealedStars = perspectivePlayer.getRevealedStars();
            var borderEdges = borderPolygon_1.getRevealedBorderEdges(revealedStars, map.voronoi);
            for (var i = 0; i < borderEdges.length; i++) {
                var gfx = new PIXI.Graphics();
                doc.addChild(gfx);
                var polyLineData = borderEdges[i];
                var player = polyLineData.points[0].star.owner;
                gfx.lineStyle(Options_13.default.display.borderWidth, player.secondaryColor.getHex(), 1);
                if (polyLineData.isClosed) {
                    polyLineData.points.push(polyLineData.points[0]);
                }
                var polygon = pixiWrapperFunctions_13.makePolygonFromPoints(polyLineData.points);
                polygon.closed = polyLineData.isClosed;
                gfx.drawShape(polygon);
            }
            return doc;
        },
    };
    exports.default = ownerBorders;
});
define("modules/defaultmapmodes/maplayertemplates/starIncome", ["require", "exports", "src/Color", "src/pixiWrapperFunctions"], function (require, exports, Color_13, pixiWrapperFunctions_14) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var starIncome = {
        key: "starIncome",
        displayName: "Income",
        interactive: false,
        isUsedForCameraBounds: true,
        drawingFunction: function (map, perspectivePlayer) {
            var doc = new PIXI.Container();
            var points = perspectivePlayer ? perspectivePlayer.getRevealedStars() : map.stars;
            var incomeBounds = map.getIncomeBounds();
            function getRelativeValue(min, max, value) {
                var difference = Math.max(max - min, 1);
                var threshhold = Math.max(difference / 10, 1);
                var relative = (Math.round(value / threshhold) * threshhold - min) / (difference);
                return relative;
            }
            var colorIndexes = {};
            function getRelativeColor(min, max, value) {
                if (!colorIndexes[value]) {
                    if (value < 0)
                        value = 0;
                    else if (value > 1)
                        value = 1;
                    var deviation = Math.abs(0.5 - value) * 2;
                    var hue = 110 * value;
                    var saturation = 0.5 + 0.2 * deviation;
                    var lightness = 0.6 + 0.25 * deviation;
                    colorIndexes[value] = Color_13.default.fromHSL(hue / 360, saturation, lightness / 2).getHex();
                }
                return colorIndexes[value];
            }
            for (var i = 0; i < points.length; i++) {
                var star = points[i];
                var income = star.getIncome();
                var relativeIncome = getRelativeValue(incomeBounds.min, incomeBounds.max, income);
                var color = getRelativeColor(incomeBounds.min, incomeBounds.max, relativeIncome);
                var poly = pixiWrapperFunctions_14.makePolygonFromPoints(star.voronoiCell.vertices);
                var gfx = new PIXI.Graphics();
                gfx.beginFill(color, 0.6);
                gfx.drawShape(poly);
                gfx.endFill();
                doc.addChild(gfx);
            }
            return doc;
        },
    };
    exports.default = starIncome;
});
define("modules/defaultmapmodes/allMapLayerTemplates", ["require", "exports", "modules/defaultmapmodes/maplayertemplates/nonFillerStars", "modules/defaultmapmodes/maplayertemplates/starLinks", "modules/defaultmapmodes/maplayertemplates/fleets", "modules/defaultmapmodes/maplayertemplates/nonFillerVoronoiLines", "modules/defaultmapmodes/maplayertemplates/resources", "modules/defaultmapmodes/maplayertemplates/starOwners", "modules/defaultmapmodes/maplayertemplates/fogOfWar", "modules/defaultmapmodes/maplayertemplates/ownerBorders", "modules/defaultmapmodes/maplayertemplates/starIncome"], function (require, exports, nonFillerStars_1, starLinks_1, fleets_2, nonFillerVoronoiLines_1, resources_1, starOwners_1, fogOfWar_1, ownerBorders_1, starIncome_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.nonFillerStars = nonFillerStars_1.default;
    exports.starLinks = starLinks_1.default;
    exports.fleets = fleets_2.default;
    exports.nonFillerVoronoiLines = nonFillerVoronoiLines_1.default;
    exports.resources = resources_1.default;
    exports.starOwners = starOwners_1.default;
    exports.fogOfWar = fogOfWar_1.default;
    exports.ownerBorders = ownerBorders_1.default;
    exports.starIncome = starIncome_1.default;
});
define("modules/defaultmapmodes/MapLayerTemplates", ["require", "exports", "modules/defaultmapmodes/allMapLayerTemplates"], function (require, exports, MapLayers) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MapLayerTemplates = (_a = {},
        _a[MapLayers.nonFillerStars.key] = MapLayers.nonFillerStars,
        _a[MapLayers.starLinks.key] = MapLayers.starLinks,
        _a[MapLayers.fleets.key] = MapLayers.fleets,
        _a[MapLayers.nonFillerVoronoiLines.key] = MapLayers.nonFillerVoronoiLines,
        _a[MapLayers.resources.key] = MapLayers.resources,
        _a[MapLayers.starOwners.key] = MapLayers.starOwners,
        _a[MapLayers.fogOfWar.key] = MapLayers.fogOfWar,
        _a[MapLayers.ownerBorders.key] = MapLayers.ownerBorders,
        _a[MapLayers.starIncome.key] = MapLayers.starIncome,
        _a);
    exports.default = MapLayerTemplates;
    var _a;
});
define("modules/defaultmapmodes/mapmodetemplates/mapModes", ["require", "exports", "modules/defaultmapmodes/allMapLayerTemplates"], function (require, exports, MapLayers) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultMapMode = {
        key: "defaultMapMode",
        displayName: "Default",
        layers: [
            MapLayers.nonFillerVoronoiLines,
            MapLayers.starOwners,
            MapLayers.ownerBorders,
            MapLayers.starLinks,
            MapLayers.nonFillerStars,
            MapLayers.fogOfWar,
            MapLayers.fleets,
        ],
    };
    exports.noStatic = {
        key: "noStatic",
        displayName: "No Static Layers",
        layers: [
            MapLayers.starOwners,
            MapLayers.ownerBorders,
            MapLayers.nonFillerStars,
            MapLayers.fogOfWar,
            MapLayers.fleets,
        ],
    };
    exports.income = {
        key: "income",
        displayName: "Income",
        layers: [
            MapLayers.starIncome,
            MapLayers.nonFillerVoronoiLines,
            MapLayers.starLinks,
            MapLayers.nonFillerStars,
            MapLayers.fleets,
        ],
    };
    exports.resources = {
        key: "resources",
        displayName: "Resources",
        layers: [
            MapLayers.nonFillerVoronoiLines,
            MapLayers.starLinks,
            MapLayers.nonFillerStars,
            MapLayers.fogOfWar,
            MapLayers.fleets,
            MapLayers.resources,
        ],
    };
});
define("modules/defaultmapmodes/MapModeTemplates", ["require", "exports", "modules/defaultmapmodes/mapmodetemplates/mapModes"], function (require, exports, MapModes) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MapModeTemplates = (_a = {},
        _a[MapModes.defaultMapMode.key] = MapModes.defaultMapMode,
        _a[MapModes.noStatic.key] = MapModes.noStatic,
        _a[MapModes.income.key] = MapModes.income,
        _a[MapModes.resources.key] = MapModes.resources,
        _a);
    exports.default = MapModeTemplates;
    var _a;
});
define("modules/defaultmapmodes/defaultMapmodes", ["require", "exports", "modules/defaultmapmodes/MapLayerTemplates", "modules/defaultmapmodes/MapModeTemplates", "src/ModuleFileLoadingPhase", "localization/defaultLanguages"], function (require, exports, MapLayerTemplates_1, MapModeTemplates_1, ModuleFileLoadingPhase_12, Languages) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var defaultMapModes = {
        key: "defaultMapModes",
        metaData: {
            name: "Default map modes",
            version: "0.1.0",
            author: "giraluna",
            description: "",
        },
        needsToBeLoadedBefore: ModuleFileLoadingPhase_12.default.Game,
        supportedLanguages: [Languages.en],
        loadAssets: function (onLoaded) {
            var loader = new PIXI.loaders.Loader();
            loader.add("modules/defaultmapmodes/img/fowTexture.png");
            loader.load(function (loader) {
                onLoaded();
            });
        },
        constructModule: function (moduleData) {
            moduleData.copyTemplates(MapLayerTemplates_1.default, "MapRendererLayers");
            moduleData.copyTemplates(MapModeTemplates_1.default, "MapRendererMapModes");
            return moduleData;
        },
    };
    exports.default = defaultMapModes;
});
define("modules/defaultnotifications/notifications/uicomponents/BattleFinishNotification", ["require", "exports", "react"], function (require, exports, React) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BattleFinishNotification = (function (_super) {
        __extends(BattleFinishNotification, _super);
        function BattleFinishNotification(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "BattleFinishNotification";
            return _this;
        }
        BattleFinishNotification.prototype.render = function () {
            var notification = this.props.notification;
            var p = notification.props;
            var attacker = p.attacker;
            var defender = p.defender;
            var victor = p.victor;
            var location = p.location;
            var attackerGainedControl = location.owner === attacker;
            var attackSuccessString = victor === attacker ?
                " succesfully " :
                " unsuccesfully ";
            var controllerString = attackerGainedControl ?
                " now " + victor.name.pluralizeVerbWithS("control") + " " :
                " " + victor.name.pluralizeVerbWithS("maintain") + " control of ";
            return (React.DOM.div({
                className: "battle-finish-notification",
            }, "" + attacker.name + attackSuccessString + "attacked " + defender.name + " in " +
                location.name + ". " + victor.name + controllerString + location.name + "."));
        };
        return BattleFinishNotification;
    }(React.Component));
    var Factory = React.createFactory(BattleFinishNotification);
    exports.default = Factory;
});
define("modules/defaultnotifications/notifications/battleFinishNotification", ["require", "exports", "modules/defaultnotifications/notifications/uicomponents/BattleFinishNotification", "src/NotificationFilterState", "src/NotificationWitnessCriterion", "src/activeNotificationLog"], function (require, exports, BattleFinishNotification_1, NotificationFilterState_3, NotificationWitnessCriterion_2, activeNotificationLog_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.battleFinishNotification = {
        key: "battleFinishNotification",
        displayName: "Battle finished",
        category: "combat",
        defaultFilterState: [NotificationFilterState_3.default.NeverShow],
        witnessCriteria: [
            [NotificationWitnessCriterion_2.NotificationWitnessCriterion.IsInvolved],
            [NotificationWitnessCriterion_2.NotificationWitnessCriterion.LocationIsVisible]
        ],
        iconSrc: "modules/common/resourcetemplates/img/test1.png",
        contentConstructor: BattleFinishNotification_1.default,
        messageConstructor: function (props) {
            var message = "A battle was fought in " + props.location.name + " between " +
                props.attacker.name.fullName + " and " + props.defender.name.fullName;
            return message;
        },
        getTitle: function (props) { return "Battle finished"; },
        serializeProps: function (props) {
            return ({
                attackerId: props.attacker.id,
                defenderId: props.defender.id,
                locationId: props.location.id,
                victorId: props.victor.id,
            });
        },
        deserializeProps: function (props, gameLoader) {
            return ({
                attacker: gameLoader.playersById[props.attackerId],
                defender: gameLoader.playersById[props.defenderId],
                location: gameLoader.starsById[props.locationId],
                victor: gameLoader.playersById[props.victorId],
            });
        },
    };
    exports.battleFinishNotificationCreationScripts = {
        battle: {
            battleFinish: [
                {
                    key: "makeBattleFinishNotification",
                    priority: 0,
                    script: function (battle) {
                        activeNotificationLog_4.activeNotificationLog.makeNotification({
                            template: exports.battleFinishNotification,
                            props: {
                                location: battle.battleData.location,
                                attacker: battle.battleData.attacker.player,
                                defender: battle.battleData.defender.player,
                                victor: battle.victor,
                            },
                            involvedPlayers: [battle.side1Player, battle.side2Player],
                            location: battle.battleData.location,
                        });
                    },
                },
            ],
        },
    };
});
define("modules/defaultnotifications/notifications/uicomponents/PlayerDiedNotification", ["require", "exports", "react"], function (require, exports, React) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PlayerDiedNotification = (function (_super) {
        __extends(PlayerDiedNotification, _super);
        function PlayerDiedNotification(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "PlayerDiedNotification";
            return _this;
        }
        PlayerDiedNotification.prototype.render = function () {
            var notification = this.props.notification;
            return (React.DOM.div({
                className: "player-died-notification",
            }, "Here lies " + notification.props.deadPlayerName + ".", React.DOM.br(null), React.DOM.br(null), "He never scored."));
        };
        return PlayerDiedNotification;
    }(React.Component));
    var Factory = React.createFactory(PlayerDiedNotification);
    exports.default = Factory;
});
define("modules/defaultnotifications/notifications/playerDiedNotification", ["require", "exports", "modules/defaultnotifications/notifications/uicomponents/PlayerDiedNotification", "src/NotificationFilterState", "src/NotificationWitnessCriterion", "src/activeNotificationLog"], function (require, exports, PlayerDiedNotification_1, NotificationFilterState_4, NotificationWitnessCriterion_3, activeNotificationLog_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.playerDiedNotification = {
        key: "playerDiedNotification",
        displayName: "Player died",
        category: "game",
        defaultFilterState: [NotificationFilterState_4.default.AlwaysShow],
        witnessCriteria: [[NotificationWitnessCriterion_3.NotificationWitnessCriterion.MetOneInvolvedPlayer]],
        iconSrc: "modules/common/resourcetemplates/img/test3.png",
        contentConstructor: PlayerDiedNotification_1.default,
        messageConstructor: function (props) {
            var message = "Player " + props.deadPlayerName + " died";
            return message;
        },
        getTitle: function (props) { return "Player died"; },
        serializeProps: function (props) {
            return ({
                deadPlayerName: props.deadPlayerName,
            });
        },
        deserializeProps: function (props, gameLoader) {
            return ({
                deadPlayerName: props.deadPlayerName,
            });
        },
    };
    exports.playerDiedNotificationCreationScripts = {
        player: {
            onDeath: [
                {
                    key: "playerDiedNotification",
                    priority: 0,
                    script: function (player) {
                        activeNotificationLog_5.activeNotificationLog.makeNotification({
                            template: exports.playerDiedNotification,
                            props: {
                                deadPlayerName: player.name.fullName,
                            },
                            involvedPlayers: [player],
                            location: null,
                        });
                    },
                },
            ],
        },
    };
});
define("modules/defaultnotifications/notifications/uicomponents/WarDeclarationNotification", ["require", "exports", "react"], function (require, exports, React) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var WarDeclarationNotification = (function (_super) {
        __extends(WarDeclarationNotification, _super);
        function WarDeclarationNotification(props) {
            var _this = _super.call(this, props) || this;
            _this.displayName = "WarDeclarationNotification";
            return _this;
        }
        WarDeclarationNotification.prototype.render = function () {
            var notification = this.props.notification;
            var p = notification.props;
            return (React.DOM.div({
                className: "war-declaration-notification",
            }, p.aggressor.name + " declared war on " + p.defender.name + "."));
        };
        return WarDeclarationNotification;
    }(React.Component));
    var Factory = React.createFactory(WarDeclarationNotification);
    exports.default = Factory;
});
define("modules/defaultnotifications/notifications/warDeclarationNotification", ["require", "exports", "modules/defaultnotifications/notifications/uicomponents/WarDeclarationNotification", "src/NotificationFilterState", "src/NotificationWitnessCriterion", "src/activeNotificationLog"], function (require, exports, WarDeclarationNotification_1, NotificationFilterState_5, NotificationWitnessCriterion_4, activeNotificationLog_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.warDeclarationNotification = {
        key: "warDeclarationNotification",
        displayName: "War declaration",
        category: "diplomacy",
        defaultFilterState: [NotificationFilterState_5.default.ShowIfInvolved],
        witnessCriteria: [
            [NotificationWitnessCriterion_4.NotificationWitnessCriterion.IsInvolved],
            [NotificationWitnessCriterion_4.NotificationWitnessCriterion.MetAllInvolvedPlayers],
        ],
        iconSrc: "modules/common/resourcetemplates/img/test2.png",
        contentConstructor: WarDeclarationNotification_1.default,
        messageConstructor: function (props) {
            var message = props.aggressor.name + " declared war on " + props.defender.name;
            return message;
        },
        getTitle: function (props) { return "War declaration"; },
        serializeProps: function (props) {
            return ({
                aggressorId: props.aggressor.id,
                defenderId: props.defender.id,
            });
        },
        deserializeProps: function (props, gameLoader) {
            return ({
                aggressor: gameLoader.playersById[props.aggressorId],
                defender: gameLoader.playersById[props.defenderId],
            });
        },
    };
    exports.warDeclarationNotificationCreationScripts = {
        diplomacy: {
            onWarDeclaration: [
                {
                    key: "makeWarDeclarationNotification",
                    priority: 0,
                    script: function (aggressor, defender) {
                        activeNotificationLog_6.activeNotificationLog.makeNotification({
                            template: exports.warDeclarationNotification,
                            props: {
                                aggressor: aggressor,
                                defender: defender,
                            },
                            involvedPlayers: [aggressor, defender],
                            location: null,
                        });
                    },
                },
            ],
        },
    };
});
define("modules/defaultnotifications/NotificationTemplates", ["require", "exports", "modules/defaultnotifications/notifications/battleFinishNotification", "modules/defaultnotifications/notifications/playerDiedNotification", "modules/defaultnotifications/notifications/warDeclarationNotification"], function (require, exports, battleFinishNotification_1, playerDiedNotification_1, warDeclarationNotification_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.notificationTemplates = (_a = {},
        _a[battleFinishNotification_1.battleFinishNotification.key] = battleFinishNotification_1.battleFinishNotification,
        _a[playerDiedNotification_1.playerDiedNotification.key] = playerDiedNotification_1.playerDiedNotification,
        _a[warDeclarationNotification_1.warDeclarationNotification.key] = warDeclarationNotification_1.warDeclarationNotification,
        _a);
    exports.notificationCreationScripts = [
        battleFinishNotification_1.battleFinishNotificationCreationScripts,
        playerDiedNotification_1.playerDiedNotificationCreationScripts,
        warDeclarationNotification_1.warDeclarationNotificationCreationScripts,
    ];
    var _a;
});
define("modules/defaultnotifications/defaultNotifications", ["require", "exports", "src/ModuleFileLoadingPhase", "modules/defaultnotifications/NotificationTemplates", "localization/defaultLanguages"], function (require, exports, ModuleFileLoadingPhase_13, NotificationTemplates_1, Languages) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var defaultNotifications = {
        key: "defaultNotifications",
        metaData: {
            name: "Default Notifications",
            version: "0.1.0",
            author: "giraluna",
            description: "",
        },
        needsToBeLoadedBefore: ModuleFileLoadingPhase_13.default.Game,
        supportedLanguages: [Languages.en],
        constructModule: function (moduleData) {
            moduleData.copyTemplates(NotificationTemplates_1.notificationTemplates, "Notifications");
            (_a = moduleData.scripts).add.apply(_a, NotificationTemplates_1.notificationCreationScripts);
            return moduleData;
            var _a;
        },
    };
    exports.default = defaultNotifications;
});
define("modules/common/distributionGroups", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.distributionGroups = {
        common: "common",
        rare: "rare",
        unique: "unique",
        debugModeOnly: "debugModeOnly",
    };
});
define("modules/common/generateIndependentFleets", ["require", "exports", "src/Fleet", "src/Name", "src/Unit", "src/templateinterfaces/Distributable", "modules/common/distributionGroups"], function (require, exports, Fleet_5, Name_4, Unit_6, Distributable_1, distributionGroups_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var unitRoleData = {
        normal: {
            namePrefix: "",
            health: 1,
            attributes: 1,
            filterCandidates: function (candidates) {
                return Distributable_1.getDistributablesWithGroups(candidates, [distributionGroups_1.distributionGroups.common]);
            },
        },
        elite: {
            namePrefix: "",
            health: 1.2,
            attributes: 1.2,
            filterCandidates: function (candidates) {
                return Distributable_1.getDistributablesWithGroups(candidates, [distributionGroups_1.distributionGroups.rare]);
            },
        },
        leader: {
            namePrefix: "",
            health: 1.35,
            attributes: 1.35,
            filterCandidates: function (candidates) {
                return Distributable_1.getDistributablesWithGroups(candidates, [distributionGroups_1.distributionGroups.unique]);
            },
        },
    };
    function generateIndependentFleets(race, player, location, globalStrength, localStrength, maxUnitsPerSideInBattle) {
        var locationHasLeader = localStrength > 0.8;
        var allBuildableUnitTypes = race.getBuildableUnitTypes(player);
        var unitCountFromGlobalStrength = maxUnitsPerSideInBattle * 0.34 + maxUnitsPerSideInBattle * 0.66 * globalStrength;
        var unitCountFromLocalStrength = locationHasLeader ? 1 : 0;
        var unitCount = Math.min(Math.round(unitCountFromGlobalStrength + unitCountFromLocalStrength), maxUnitsPerSideInBattle);
        var eliteCount = Math.ceil((unitCount / maxUnitsPerSideInBattle - 0.499) * 3);
        var units = [];
        for (var i = 0; i < unitCount; i++) {
            var unitRole = void 0;
            if (locationHasLeader && i === 0) {
                unitRole = "leader";
            }
            else if (i < eliteCount) {
                unitRole = "elite";
            }
            else {
                unitRole = "normal";
            }
            var candidateUnitTemplates = unitRoleData[unitRole].filterCandidates(allBuildableUnitTypes);
            var unitTemplate = Distributable_1.getRandomWeightedDistributable(candidateUnitTemplates);
            var healthModifier = unitRoleData[unitRole].health;
            var attributesModifier = unitRoleData[unitRole].attributes;
            var unitName = "" + unitRoleData[unitRole].namePrefix + race.getUnitName(unitTemplate);
            var unit = Unit_6.default.fromTemplate({
                template: unitTemplate,
                race: race,
                name: unitName,
                attributeMultiplier: (1 + globalStrength * 0.2) * attributesModifier,
                healthMultiplier: (1 + globalStrength) * healthModifier,
            });
            units.push(unit);
            player.addUnit(unit);
        }
        var fleets = Fleet_5.Fleet.createFleetsFromUnits(units);
        fleets.forEach(function (fleet) {
            player.addFleet(fleet);
            location.addFleet(fleet);
            fleet.name = new Name_4.default("Independent " + race.displayName + " Fleet", false);
        });
        return fleets;
    }
    exports.generateIndependentFleets = generateIndependentFleets;
});
define("modules/common/generateIndependentPlayer", ["require", "exports", "src/Name", "src/Player"], function (require, exports, Name_5, Player_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function generateIndependentPlayer(race) {
        var player = new Player_4.default({
            isAI: true,
            isIndependent: true,
            race: race,
            money: -1,
            name: new Name_5.default("Independent " + race.displayName, race.displayName.isPlural),
        });
        player.colorAlpha = 0.66;
        return player;
    }
    exports.generateIndependentPlayer = generateIndependentPlayer;
});
define("modules/defaultunits/UnitArchetypes", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.combat = {
        type: "combat",
        idealWeightInBattle: 1,
        idealWeightInFleet: 1,
        rowScores: {
            ROW_FRONT: 1,
            ROW_BACK: 0.6,
        },
    };
    exports.utility = {
        type: "utility",
        idealWeightInBattle: 0.33,
        idealWeightInFleet: 0.5,
        rowScores: {
            ROW_FRONT: 0.4,
            ROW_BACK: 0.6,
        },
    };
    exports.scouting = {
        type: "scouting",
        idealWeightInBattle: 0.01,
        idealWeightInFleet: 0.2,
        rowScores: {
            ROW_FRONT: 0.01,
            ROW_BACK: 0.02,
        },
    };
    exports.defence = {
        type: "defence",
        idealWeightInBattle: 0.5,
        idealWeightInFleet: 0.5,
        rowScores: {
            ROW_FRONT: 1,
            ROW_BACK: 0.5,
        },
        scoreMultiplierForRowFN: function (row, rowUnits, enemyUnits) {
            var multiplier = (row === "ROW_BACK" ? 0.7 : 1);
            var unitDefenceThreshhold = 6;
            var totalDefenceUnderThreshhold = rowUnits.filter(function (unit) { return Boolean(unit); }).map(function (unit) {
                var defenceUnderThreshhold = Math.max(unit.attributes.defence - unitDefenceThreshhold);
                return defenceUnderThreshhold;
            }).reduce(function (total, current) {
                return total + current;
            }, 0);
            return multiplier + totalDefenceUnderThreshhold * 0.2;
        },
    };
    var UnitArchetypes = (_a = {},
        _a[exports.combat.type] = exports.combat,
        _a[exports.utility.type] = exports.utility,
        _a[exports.scouting.type] = exports.scouting,
        _a[exports.defence.type] = exports.defence,
        _a);
    exports.default = UnitArchetypes;
    var _a;
});
define("modules/defaultunits/defaultUnitDrawingFunction", ["require", "exports", "src/App", "src/UnitDrawingFunctionData", "src/utility"], function (require, exports, App_18, UnitDrawingFunctionData_1, utility_66) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var defaultUnitDrawingFunction = function (unit, SFXParams) {
        var spriteTemplate = unit.template.sprite;
        var texture = PIXI.Texture.fromFrame(spriteTemplate.imageSrc);
        var container = new PIXI.Container;
        var props = {
            zDistance: 8,
            xDistance: 5,
            maxUnitsPerColumn: 7,
            curvature: -0.5,
            rotationAngle: 70,
            scalingFactor: 0.04,
        };
        var maxUnitsPerColumn = props.maxUnitsPerColumn;
        var maxColumns = 3;
        var isConvex = props.curvature >= 0;
        var curvature = Math.abs(props.curvature);
        var image = App_18.default.images[spriteTemplate.imageSrc];
        var zDistance = props.zDistance;
        var xDistance = props.xDistance;
        var unitsToDraw;
        if (!unit.template.isSquadron) {
            unitsToDraw = 1;
        }
        else {
            var lastHealthDrawnAt = unit.lastHealthDrawnAt || unit.battleStats.lastHealthBeforeReceivingDamage;
            unit.lastHealthDrawnAt = unit.currentHealth;
            unitsToDraw = Math.round(lastHealthDrawnAt * 0.04) * (1 / unit.template.maxHealth);
            var heightRatio = 25 / image.height;
            heightRatio = Math.min(heightRatio, 1.25);
            maxUnitsPerColumn = Math.round(maxUnitsPerColumn * heightRatio);
            unitsToDraw = Math.round(unitsToDraw * heightRatio);
            zDistance *= (1 / heightRatio);
            unitsToDraw = utility_66.clamp(unitsToDraw, 1, maxUnitsPerColumn * maxColumns);
        }
        var rotationAngle = Math.PI / 180 * props.rotationAngle;
        var sA = Math.sin(rotationAngle);
        var cA = Math.cos(rotationAngle);
        var rotationMatrix = [
            1, 0, 0,
            0, cA, -sA,
            0, sA, cA,
        ];
        var minXOffset = isConvex ? 0 : Math.sin(Math.PI / (maxUnitsPerColumn + 1));
        var yPadding = Math.min(SFXParams.height * 0.1, 30);
        var desiredHeight = SFXParams.height - yPadding;
        var averageHeight = image.height * (maxUnitsPerColumn / 2 * props.scalingFactor);
        var spaceToFill = desiredHeight - (averageHeight * maxUnitsPerColumn);
        zDistance = spaceToFill / maxUnitsPerColumn * 1.35;
        var boundingBox = {
            x1: undefined,
            x2: undefined,
            y1: undefined,
            y2: undefined,
        };
        var allUnitBoundingBoxes = [];
        var primaryAttackOriginPoint;
        var sequentialAttackOriginPoints = [];
        var lastColumn = Math.floor(unitsToDraw / maxUnitsPerColumn);
        var maxUnitsInLastColumn = unitsToDraw % maxUnitsPerColumn;
        var firstIndexForLastColumn = maxUnitsPerColumn * lastColumn;
        var unitsInFirstColumn = lastColumn > 0 ? maxUnitsPerColumn : unitsToDraw;
        var centermostUnitInFirstColumn = Math.ceil(unitsInFirstColumn / 2) - 1;
        for (var i = 0; i < unitsToDraw; i++) {
            var column = Math.floor(i / maxUnitsPerColumn);
            var columnFromRight = lastColumn - column;
            var zPos = void 0;
            if (column === lastColumn) {
                if (maxUnitsInLastColumn === 1) {
                    zPos = (maxUnitsPerColumn - 1) / 2;
                }
                else {
                    var positionInLastColumn = i - firstIndexForLastColumn;
                    zPos = positionInLastColumn * ((maxUnitsPerColumn - 1) / (maxUnitsInLastColumn - 1));
                }
            }
            else {
                zPos = i % maxUnitsPerColumn;
            }
            var xOffset = Math.sin(Math.PI / (maxUnitsPerColumn + 1) * (zPos + 1));
            if (isConvex) {
                xOffset = 1 - xOffset;
            }
            xOffset -= minXOffset;
            var scale = 1 - zPos * props.scalingFactor;
            var scaledWidth = image.width * scale;
            var scaledHeight = image.height * scale;
            var x = xOffset * scaledWidth * curvature + columnFromRight * (scaledWidth + xDistance * scale);
            var y = (scaledHeight + zDistance * scale) * (maxUnitsPerColumn - zPos);
            var translated = utility_66.transformMat3({ x: x, y: y }, rotationMatrix);
            x = Math.round(translated.x);
            y = Math.round(translated.y);
            var attackOriginPoint = {
                x: x + scaledWidth * spriteTemplate.attackOriginPoint.x,
                y: y + scaledHeight * spriteTemplate.attackOriginPoint.y,
            };
            sequentialAttackOriginPoints.push(attackOriginPoint);
            if (column === 0 && i === centermostUnitInFirstColumn) {
                primaryAttackOriginPoint = attackOriginPoint;
            }
            var sprite = new PIXI.Sprite(texture);
            sprite.scale.x = sprite.scale.y = scale;
            sprite.x = x;
            sprite.y = y;
            container.addChild(sprite);
            var unitBounds = new PIXI.Rectangle(x, y, scaledWidth, scaledHeight);
            allUnitBoundingBoxes.push(unitBounds);
            boundingBox.x1 = isFinite(boundingBox.x1) ? Math.min(boundingBox.x1, x) : x;
            boundingBox.y1 = isFinite(boundingBox.y1) ? Math.min(boundingBox.y1, y) : y;
            boundingBox.x2 = isFinite(boundingBox.x2) ? Math.max(boundingBox.x2, x + scaledWidth) : x + scaledWidth;
            boundingBox.y2 = isFinite(boundingBox.y2) ? Math.max(boundingBox.y2, y + scaledHeight) : y + scaledHeight;
        }
        unit.drawingFunctionData = new UnitDrawingFunctionData_1.default({
            boundingBox: new PIXI.Rectangle(boundingBox.x1, boundingBox.y1, boundingBox.x2 - boundingBox.x1, boundingBox.y2 - boundingBox.y1),
            individualUnitBoundingBoxes: allUnitBoundingBoxes,
            singleAttackOriginPoint: primaryAttackOriginPoint,
            sequentialAttackOriginPoints: sequentialAttackOriginPoints,
        });
        SFXParams.triggerStart(container);
    };
    exports.default = defaultUnitDrawingFunction;
});
define("modules/common/itemSlot", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var itemSlot = {
        low: "low",
        mid: "mid",
        high: "high",
    };
    exports.default = itemSlot;
});
define("modules/defaultunits/templates/stealthShip", ["require", "exports", "modules/defaultunits/UnitArchetypes", "modules/defaultunits/defaultUnitDrawingFunction", "modules/common/abilitytemplates/abilities", "modules/common/distributionGroups", "modules/common/itemSlot"], function (require, exports, UnitArchetypes, defaultUnitDrawingFunction_1, abilities_2, distributionGroups_2, itemSlot_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var stealthShip = {
        type: "stealthShip",
        displayName: "Stealth Ship",
        description: "Weak ship that is undetectable by regular vision",
        archetype: UnitArchetypes.scouting,
        sprite: {
            imageSrc: "scout.png",
            anchor: { x: 0.5, y: 0.5 },
            attackOriginPoint: { x: 0.75, y: 0.5 },
        },
        isSquadron: true,
        buildCost: 500,
        icon: "modules/defaultunits/img/icons/sc.png",
        maxHealth: 0.6,
        maxMovePoints: 1,
        maxOffensiveBattlesPerTurn: 1,
        visionRange: 1,
        detectionRange: -1,
        isStealthy: true,
        attributeLevels: {
            attack: 0.5,
            defence: 0.5,
            intelligence: 0.8,
            speed: 0.7,
        },
        possibleAbilities: [
            {
                flatProbability: 1,
                probabilityItems: [
                    abilities_2.rangedAttack,
                    abilities_2.standBy,
                ],
            },
        ],
        itemSlots: (_a = {},
            _a[itemSlot_1.default.low] = 1,
            _a[itemSlot_1.default.mid] = 1,
            _a[itemSlot_1.default.high] = 1,
            _a),
        unitDrawingFN: defaultUnitDrawingFunction_1.default,
        distributionData: {
            weight: 1,
            distributionGroups: [
                distributionGroups_2.distributionGroups.rare,
                distributionGroups_2.distributionGroups.unique,
            ],
        },
    };
    exports.default = stealthShip;
    var _a;
});
define("modules/defaulttechnologies/TechnologyTemplates", ["require", "exports", "modules/defaultunits/templates/stealthShip"], function (require, exports, stealthShip_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stealth = {
        key: "stealth",
        displayName: "Stealth",
        description: "stealthy stuff",
        maxLevel: 9,
        unlocksPerLevel: {
            1: [stealthShip_1.default],
        },
    };
    exports.lasers = {
        key: "lasers",
        displayName: "Lasers",
        description: "pew pew",
        maxLevel: 9,
        unlocksPerLevel: {},
    };
    exports.missiles = {
        key: "missiles",
        displayName: "Missiles",
        description: "boom",
        maxLevel: 9,
        unlocksPerLevel: {},
    };
    exports.test1 = {
        key: "test1",
        displayName: "test1",
        description: "test1",
        maxLevel: 1,
        unlocksPerLevel: {},
    };
    exports.test2 = {
        key: "test2",
        displayName: "test2",
        description: "test2",
        maxLevel: 2,
        unlocksPerLevel: {},
    };
    var TechnologyTemplates = (_a = {},
        _a[exports.stealth.key] = exports.stealth,
        _a[exports.lasers.key] = exports.lasers,
        _a[exports.missiles.key] = exports.missiles,
        _a[exports.test1.key] = exports.test1,
        _a[exports.test2.key] = exports.test2,
        _a);
    exports.default = TechnologyTemplates;
    var _a;
});
define("modules/defaultunits/templates/battleCruiser", ["require", "exports", "modules/defaultunits/UnitArchetypes", "modules/defaultunits/defaultUnitDrawingFunction", "modules/common/abilitytemplates/abilities", "modules/common/distributionGroups", "modules/common/itemSlot"], function (require, exports, UnitArchetypes, defaultUnitDrawingFunction_2, abilities_3, distributionGroups_3, itemSlot_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var battleCruiser = {
        type: "battleCruiser",
        displayName: "Battlecruiser",
        description: "Strong combat ship with low speed",
        archetype: UnitArchetypes.combat,
        sprite: {
            imageSrc: "battleCruiser.png",
            anchor: { x: 0.5, y: 0.5 },
            attackOriginPoint: { x: 0.75, y: 0.5 },
        },
        isSquadron: true,
        buildCost: 200,
        icon: "modules/defaultunits/img/icons/bc.png",
        maxHealth: 1,
        maxMovePoints: 1,
        maxOffensiveBattlesPerTurn: 1,
        visionRange: 1,
        detectionRange: -1,
        attributeLevels: {
            attack: 0.8,
            defence: 0.8,
            intelligence: 0.7,
            speed: 0.6,
        },
        possibleAbilities: [
            {
                flatProbability: 1,
                probabilityItems: [
                    abilities_3.rangedAttack,
                    abilities_3.beamAttack,
                    abilities_3.standBy,
                ],
            },
        ],
        itemSlots: (_a = {},
            _a[itemSlot_2.default.low] = 1,
            _a[itemSlot_2.default.mid] = 1,
            _a[itemSlot_2.default.high] = 2,
            _a),
        unitDrawingFN: defaultUnitDrawingFunction_2.default,
        distributionData: {
            weight: 1,
            distributionGroups: [
                distributionGroups_3.distributionGroups.common,
                distributionGroups_3.distributionGroups.rare,
                distributionGroups_3.distributionGroups.unique,
            ],
        },
    };
    exports.default = battleCruiser;
    var _a;
});
define("modules/defaultunits/templates/bomberSquadron", ["require", "exports", "modules/defaultunits/UnitArchetypes", "modules/defaultunits/defaultUnitDrawingFunction", "modules/common/abilitytemplates/abilities", "modules/common/distributionGroups", "modules/common/itemSlot"], function (require, exports, UnitArchetypes, defaultUnitDrawingFunction_3, abilities_4, distributionGroups_4, itemSlot_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var bomberSquadron = {
        type: "bomberSquadron",
        displayName: "Bomber Squadron",
        description: "Can damage multiple targets with special bomb attack",
        archetype: UnitArchetypes.combat,
        sprite: {
            imageSrc: "bomber.png",
            anchor: { x: 0.5, y: 0.5 },
            attackOriginPoint: { x: 0.75, y: 0.5 },
        },
        isSquadron: true,
        buildCost: 200,
        icon: "modules/defaultunits/img/icons/fb.png",
        maxHealth: 0.5,
        maxMovePoints: 1,
        maxOffensiveBattlesPerTurn: 1,
        visionRange: 1,
        detectionRange: -1,
        attributeLevels: {
            attack: 0.7,
            defence: 0.4,
            intelligence: 0.5,
            speed: 0.8,
        },
        possibleAbilities: [
            {
                flatProbability: 1,
                probabilityItems: [
                    abilities_4.rangedAttack,
                    abilities_4.bombAttack,
                    abilities_4.standBy,
                ],
            },
        ],
        itemSlots: (_a = {},
            _a[itemSlot_3.default.low] = 1,
            _a[itemSlot_3.default.mid] = 1,
            _a[itemSlot_3.default.high] = 1,
            _a),
        unitDrawingFN: defaultUnitDrawingFunction_3.default,
        distributionData: {
            weight: 1,
            distributionGroups: [
                distributionGroups_4.distributionGroups.common,
                distributionGroups_4.distributionGroups.rare,
            ],
        },
    };
    exports.default = bomberSquadron;
    var _a;
});
define("modules/defaultunits/templates/commandShip", ["require", "exports", "modules/defaultunits/UnitArchetypes", "modules/defaultunits/defaultUnitDrawingFunction", "modules/common/abilitytemplates/abilities", "modules/common/distributionGroups", "modules/common/itemSlot", "modules/common/passiveskilltemplates/passiveSkills"], function (require, exports, UnitArchetypes, defaultUnitDrawingFunction_4, abilities_5, distributionGroups_5, itemSlot_4, passiveSkills_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var commandShip = {
        type: "commandShip",
        displayName: "Command Ship",
        description: "todo",
        archetype: UnitArchetypes.utility,
        sprite: {
            imageSrc: "shieldBoat.png",
            anchor: { x: 0.5, y: 0.5 },
            attackOriginPoint: { x: 0.75, y: 0.5 },
        },
        isSquadron: false,
        buildCost: 300,
        icon: "modules/defaultunits/img/icons/sh.png",
        maxHealth: 0.7,
        maxMovePoints: 1,
        maxOffensiveBattlesPerTurn: 1,
        visionRange: 1,
        detectionRange: -1,
        attributeLevels: {
            attack: 0.5,
            defence: 0.6,
            intelligence: 0.7,
            speed: 0.6,
        },
        possibleAbilities: [
            {
                flatProbability: 1,
                probabilityItems: [
                    abilities_5.rangedAttack,
                    abilities_5.standBy,
                ],
            },
        ],
        possiblePassiveSkills: [
            {
                flatProbability: 1,
                probabilityItems: [
                    passiveSkills_2.initialGuard,
                ],
            },
        ],
        itemSlots: (_a = {},
            _a[itemSlot_4.default.low] = 1,
            _a[itemSlot_4.default.mid] = 1,
            _a[itemSlot_4.default.high] = 1,
            _a),
        unitDrawingFN: defaultUnitDrawingFunction_4.default,
        distributionData: {
            weight: 1,
            distributionGroups: [
                distributionGroups_5.distributionGroups.rare,
                distributionGroups_5.distributionGroups.unique,
            ],
        },
    };
    exports.default = commandShip;
    var _a;
});
define("modules/defaultunits/templates/debugShip", ["require", "exports", "modules/defaultunits/UnitArchetypes", "modules/defaultunits/defaultUnitDrawingFunction", "modules/common/abilitytemplates/abilities", "modules/common/distributionGroups", "modules/common/itemSlot", "modules/common/passiveskilltemplates/passiveSkills"], function (require, exports, UnitArchetypes, defaultUnitDrawingFunction_5, abilities_6, distributionGroups_6, itemSlot_5, passiveSkills_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var debugShip = {
        type: "debugShip",
        displayName: "Debug Ship",
        description: "debug",
        archetype: UnitArchetypes.combat,
        sprite: {
            imageSrc: "debugShip.png",
            anchor: { x: 0.5, y: 0.5 },
            attackOriginPoint: { x: 0.75, y: 0.5 },
        },
        isSquadron: false,
        buildCost: 0,
        icon: "modules/defaultunits/img/icons/f.png",
        maxHealth: 1,
        maxMovePoints: 999,
        maxOffensiveBattlesPerTurn: 999,
        visionRange: 999,
        detectionRange: 999,
        attributeLevels: {
            attack: 9,
            defence: 9,
            intelligence: 9,
            speed: 9,
        },
        possibleAbilities: [
            {
                flatProbability: 1,
                probabilityItems: [
                    abilities_6.debugAbility,
                    abilities_6.rangedAttack,
                    abilities_6.standBy,
                ],
            },
            {
                flatProbability: 1,
                probabilityItems: [
                    {
                        weight: 0.33,
                        probabilityItems: [abilities_6.bombAttack],
                    },
                    {
                        weight: 0.33,
                        probabilityItems: [abilities_6.boardingHook],
                    },
                    {
                        weight: 0.33,
                        probabilityItems: [abilities_6.guardRow],
                    },
                ],
            },
            {
                flatProbability: 1,
                probabilityItems: [
                    { weight: 0.25, probabilityItems: [abilities_6.snipeAttack] },
                    { weight: 0.25, probabilityItems: [abilities_6.snipeDefence] },
                    { weight: 0.25, probabilityItems: [abilities_6.snipeIntelligence] },
                    { weight: 0.25, probabilityItems: [abilities_6.snipeSpeed] },
                ],
            },
        ],
        possiblePassiveSkills: [
            {
                flatProbability: 1,
                probabilityItems: [
                    {
                        weight: 0.33,
                        probabilityItems: [passiveSkills_3.autoHeal],
                    },
                    {
                        weight: 0.33,
                        probabilityItems: [passiveSkills_3.warpJammer],
                    },
                    {
                        weight: 0.33,
                        probabilityItems: [passiveSkills_3.medic],
                    },
                ],
            },
        ],
        learnableAbilities: [
            abilities_6.guardRow,
            abilities_6.closeAttack,
        ],
        itemSlots: (_a = {},
            _a[itemSlot_5.default.low] = 1,
            _a[itemSlot_5.default.mid] = 1,
            _a[itemSlot_5.default.high] = 1,
            _a),
        unitDrawingFN: defaultUnitDrawingFunction_5.default,
        distributionData: {
            weight: 0,
            distributionGroups: [distributionGroups_6.distributionGroups.debugModeOnly],
        },
    };
    exports.default = debugShip;
    var _a;
});
define("modules/defaultunits/templates/fighterSquadron", ["require", "exports", "modules/defaultunits/UnitArchetypes", "modules/defaultunits/defaultUnitDrawingFunction", "modules/common/abilitytemplates/abilities", "modules/common/distributionGroups", "modules/common/itemSlot"], function (require, exports, UnitArchetypes, defaultUnitDrawingFunction_6, abilities_7, distributionGroups_7, itemSlot_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var fighterSquadron = {
        type: "fighterSquadron",
        displayName: "Fighter Squadron",
        description: "Fast and cheap unit with good attack and speed but low defence",
        archetype: UnitArchetypes.combat,
        sprite: {
            imageSrc: "fighter.png",
            anchor: { x: 0.5, y: 0.5 },
            attackOriginPoint: { x: 0.75, y: 0.5 },
        },
        isSquadron: true,
        buildCost: 100,
        icon: "modules/defaultunits/img/icons/fa.png",
        maxHealth: 0.7,
        maxMovePoints: 2,
        maxOffensiveBattlesPerTurn: 1,
        visionRange: 1,
        detectionRange: -1,
        attributeLevels: {
            attack: 0.8,
            defence: 0.6,
            intelligence: 0.4,
            speed: 1,
        },
        possibleAbilities: [
            {
                flatProbability: 1,
                probabilityItems: [
                    abilities_7.rangedAttack,
                    abilities_7.closeAttack,
                    abilities_7.standBy,
                ],
            },
        ],
        itemSlots: (_a = {},
            _a[itemSlot_6.default.low] = 1,
            _a[itemSlot_6.default.mid] = 3,
            _a[itemSlot_6.default.high] = 2,
            _a),
        unitDrawingFN: defaultUnitDrawingFunction_6.default,
        distributionData: {
            weight: 1,
            distributionGroups: [
                distributionGroups_7.distributionGroups.common,
                distributionGroups_7.distributionGroups.rare,
            ],
        },
    };
    exports.default = fighterSquadron;
    var _a;
});
define("modules/defaultunits/templates/scout", ["require", "exports", "modules/defaultunits/UnitArchetypes", "modules/defaultunits/defaultUnitDrawingFunction", "modules/common/abilitytemplates/abilities", "modules/common/distributionGroups", "modules/common/itemSlot"], function (require, exports, UnitArchetypes, defaultUnitDrawingFunction_7, abilities_8, distributionGroups_8, itemSlot_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var scout = {
        type: "scout",
        displayName: "Scout",
        description: "Weak in combat, but has high vision and can reveal stealthy units and details of units in same star",
        archetype: UnitArchetypes.scouting,
        sprite: {
            imageSrc: "scout.png",
            anchor: { x: 0.5, y: 0.5 },
            attackOriginPoint: { x: 0.75, y: 0.5 },
        },
        isSquadron: true,
        buildCost: 200,
        icon: "modules/defaultunits/img/icons/sc.png",
        maxHealth: 0.6,
        maxMovePoints: 2,
        maxOffensiveBattlesPerTurn: 1,
        visionRange: 2,
        detectionRange: 0,
        attributeLevels: {
            attack: 0.5,
            defence: 0.5,
            intelligence: 0.8,
            speed: 0.7,
        },
        possibleAbilities: [
            {
                flatProbability: 1,
                probabilityItems: [
                    abilities_8.rangedAttack,
                    abilities_8.standBy,
                ],
            },
        ],
        itemSlots: (_a = {},
            _a[itemSlot_7.default.low] = 1,
            _a[itemSlot_7.default.mid] = 1,
            _a[itemSlot_7.default.high] = 1,
            _a),
        unitDrawingFN: defaultUnitDrawingFunction_7.default,
        distributionData: {
            weight: 1,
            distributionGroups: [
                distributionGroups_8.distributionGroups.common,
                distributionGroups_8.distributionGroups.rare,
            ],
        },
    };
    exports.default = scout;
    var _a;
});
define("modules/defaultunits/templates/shieldBoat", ["require", "exports", "modules/defaultunits/UnitArchetypes", "modules/defaultunits/defaultUnitDrawingFunction", "modules/common/abilitytemplates/abilities", "modules/common/distributionGroups", "modules/common/itemSlot", "modules/common/passiveskilltemplates/passiveSkills"], function (require, exports, UnitArchetypes, defaultUnitDrawingFunction_8, abilities_9, distributionGroups_9, itemSlot_8, passiveSkills_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var shieldBoat = {
        type: "shieldBoat",
        displayName: "Shield Boat",
        description: "Great defence and ability to protect allies in same row",
        archetype: UnitArchetypes.defence,
        sprite: {
            imageSrc: "shieldBoat.png",
            anchor: { x: 0.5, y: 0.5 },
            attackOriginPoint: { x: 0.75, y: 0.5 },
        },
        isSquadron: true,
        buildCost: 200,
        icon: "modules/defaultunits/img/icons/sh.png",
        maxHealth: 0.9,
        maxMovePoints: 1,
        maxOffensiveBattlesPerTurn: 1,
        visionRange: 1,
        detectionRange: -1,
        attributeLevels: {
            attack: 0.5,
            defence: 0.9,
            intelligence: 0.6,
            speed: 0.4,
        },
        possibleAbilities: [
            {
                flatProbability: 1,
                probabilityItems: [
                    abilities_9.rangedAttack,
                    abilities_9.guardRow,
                    abilities_9.standBy,
                ],
            },
        ],
        possiblePassiveSkills: [
            {
                flatProbability: 1,
                probabilityItems: [
                    passiveSkills_4.initialGuard,
                ],
            },
        ],
        itemSlots: (_a = {},
            _a[itemSlot_8.default.low] = 1,
            _a[itemSlot_8.default.mid] = 1,
            _a[itemSlot_8.default.high] = 1,
            _a),
        unitDrawingFN: defaultUnitDrawingFunction_8.default,
        distributionData: {
            weight: 1,
            distributionGroups: [
                distributionGroups_9.distributionGroups.common,
                distributionGroups_9.distributionGroups.rare,
                distributionGroups_9.distributionGroups.unique,
            ],
        },
    };
    exports.default = shieldBoat;
    var _a;
});
define("modules/defaultunits/UnitTemplates", ["require", "exports", "modules/defaultunits/templates/battleCruiser", "modules/defaultunits/templates/bomberSquadron", "modules/defaultunits/templates/commandShip", "modules/defaultunits/templates/debugShip", "modules/defaultunits/templates/fighterSquadron", "modules/defaultunits/templates/scout", "modules/defaultunits/templates/shieldBoat", "modules/defaultunits/templates/stealthShip"], function (require, exports, battleCruiser_1, bomberSquadron_1, commandShip_1, debugShip_1, fighterSquadron_1, scout_1, shieldBoat_1, stealthShip_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var UnitTemplates = (_a = {},
        _a[battleCruiser_1.default.type] = battleCruiser_1.default,
        _a[commandShip_1.default.type] = commandShip_1.default,
        _a[stealthShip_2.default.type] = stealthShip_2.default,
        _a[debugShip_1.default.type] = debugShip_1.default,
        _a[scout_1.default.type] = scout_1.default,
        _a[bomberSquadron_1.default.type] = bomberSquadron_1.default,
        _a[fighterSquadron_1.default.type] = fighterSquadron_1.default,
        _a[shieldBoat_1.default.type] = shieldBoat_1.default,
        _a);
    exports.default = UnitTemplates;
    var _a;
});
define("modules/defaultraces/common", ["require", "exports", "modules/defaulttechnologies/TechnologyTemplates", "modules/defaultunits/UnitTemplates"], function (require, exports, TechnologyTemplates, UnitTemplates_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultRaceTechnologyValues = [
        {
            tech: TechnologyTemplates.stealth,
            startingLevel: 0,
            maxLevel: 9,
        },
        {
            tech: TechnologyTemplates.lasers,
            startingLevel: 0,
            maxLevel: 9,
        },
        {
            tech: TechnologyTemplates.missiles,
            startingLevel: 0,
            maxLevel: 9,
        },
    ];
    function mergeTechnologyValues() {
        var valuesToMerge = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            valuesToMerge[_i] = arguments[_i];
        }
        var valuesByTechKey = {};
        valuesToMerge.forEach(function (techValues) {
            techValues.forEach(function (techValue) {
                valuesByTechKey[techValue.tech.key] = techValue;
            });
        });
        var mergedValues = [];
        for (var key in valuesByTechKey) {
            mergedValues.push(valuesByTechKey[key]);
        }
        return mergedValues;
    }
    exports.mergeTechnologyValues = mergeTechnologyValues;
    var defaultUnitsArray = Object.keys(UnitTemplates_1.default).map(function (templateType) {
        return UnitTemplates_1.default[templateType];
    });
    function getDefaultUnits() {
        return defaultUnitsArray;
    }
    exports.getDefaultUnits = getDefaultUnits;
});
define("modules/defaultraces/templates/federationAlliance", ["require", "exports", "src/Name", "src/utility", "modules/common/generateIndependentFleets", "modules/common/generateIndependentPlayer", "modules/defaultai/mapai/DefaultAIConstructor", "modules/defaulttechnologies/TechnologyTemplates", "modules/defaultraces/common"], function (require, exports, Name_6, utility_67, generateIndependentFleets_1, generateIndependentPlayer_1, DefaultAIConstructor_2, TechnologyTemplates, common_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var federationAlliance = {
        type: "federationAlliance",
        displayName: new Name_6.default("Federation Alliance", false),
        description: "The good guys",
        distributionData: {
            weight: 0,
            distributionGroups: [],
        },
        getBuildableUnitTypes: function (player) {
            return common_1.getDefaultUnits().filter(function (unitTemplate) {
                return !unitTemplate.technologyRequirements ||
                    player.meetsTechnologyRequirements(unitTemplate.technologyRequirements);
            });
        },
        getUnitName: function (unitTemplate) {
            return "Federation " + unitTemplate.displayName;
        },
        getUnitPortrait: function (unitTemplate, allTemplates) {
            return utility_67.getRandomProperty(allTemplates);
        },
        generateIndependentPlayer: function (emblemTemplates) {
            var player = generateIndependentPlayer_1.generateIndependentPlayer(federationAlliance);
            player.name = new Name_6.default(federationAlliance.displayName + " Independents", true);
            return player;
        },
        generateIndependentFleets: function (player, location, globalStrength, localStrength, maxUnitsPerSideInBattle) {
            return generateIndependentFleets_1.generateIndependentFleets(federationAlliance, player, location, globalStrength, localStrength, maxUnitsPerSideInBattle);
        },
        technologies: common_1.mergeTechnologyValues(common_1.defaultRaceTechnologyValues, [
            {
                tech: TechnologyTemplates.test1,
                startingLevel: 1,
                maxLevel: 5,
            },
        ]),
        getAITemplateConstructor: function (player) { return DefaultAIConstructor_2.default; },
    };
    exports.default = federationAlliance;
});
define("modules/defaultraces/templates/wormThings", ["require", "exports", "src/Name", "src/utility", "modules/common/generateIndependentFleets", "modules/common/generateIndependentPlayer", "modules/defaultai/mapai/DefaultAIConstructor", "modules/defaulttechnologies/TechnologyTemplates", "modules/defaultraces/common"], function (require, exports, Name_7, utility_68, generateIndependentFleets_2, generateIndependentPlayer_2, DefaultAIConstructor_3, TechnologyTemplates, common_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var wormThings = {
        type: "wormThings",
        displayName: new Name_7.default("Worm Things", true),
        description: "The gross guys",
        distributionData: {
            weight: 0,
            distributionGroups: [],
        },
        getBuildableUnitTypes: function (player) {
            return common_2.getDefaultUnits().filter(function (unitTemplate) {
                return !unitTemplate.technologyRequirements ||
                    player.meetsTechnologyRequirements(unitTemplate.technologyRequirements);
            });
        },
        getUnitName: function (unitTemplate) {
            return "Infested " + unitTemplate.displayName;
        },
        getUnitPortrait: function (unitTemplate, allTemplates) {
            return utility_68.getRandomProperty(allTemplates);
        },
        generateIndependentPlayer: function (emblemTemplates) {
            return generateIndependentPlayer_2.generateIndependentPlayer(wormThings);
        },
        generateIndependentFleets: function (player, location, globalStrength, localStrength, maxUnitsPerSideInBattle) {
            return generateIndependentFleets_2.generateIndependentFleets(wormThings, player, location, globalStrength, localStrength, maxUnitsPerSideInBattle);
        },
        technologies: common_2.mergeTechnologyValues(common_2.defaultRaceTechnologyValues, [
            {
                tech: TechnologyTemplates.test2,
                startingLevel: 1,
                maxLevel: 5,
            },
        ]),
        getAITemplateConstructor: function (player) { return DefaultAIConstructor_3.default; },
    };
    exports.default = wormThings;
});
define("modules/defaultraces/RaceTemplates", ["require", "exports", "modules/defaultraces/templates/federationAlliance", "modules/defaultraces/templates/wormThings"], function (require, exports, federationAlliance_1, wormThings_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var RaceTemplates = (_a = {},
        _a[federationAlliance_1.default.type] = federationAlliance_1.default,
        _a[wormThings_1.default.type] = wormThings_1.default,
        _a);
    exports.default = RaceTemplates;
    var _a;
});
define("modules/defaultraces/defaultRaces", ["require", "exports", "modules/defaultraces/RaceTemplates", "src/ModuleFileLoadingPhase", "localization/defaultLanguages"], function (require, exports, RaceTemplates_1, ModuleFileLoadingPhase_14, Languages) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var defaultRaces = {
        key: "defaultRaces",
        metaData: {
            name: "Default Buildings",
            version: "0.1.0",
            author: "giraluna",
            description: "",
        },
        needsToBeLoadedBefore: ModuleFileLoadingPhase_14.default.Setup,
        supportedLanguages: [Languages.en],
        constructModule: function (moduleData) {
            moduleData.copyTemplates(RaceTemplates_1.default, "Races");
            return moduleData;
        },
    };
    exports.default = defaultRaces;
});
define("modules/defaultruleset/defaultRuleset", ["require", "exports", "src/ModuleFileLoadingPhase"], function (require, exports, ModuleFileLoadingPhase_15) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var defaultRuleSet = {
        key: "defaultRuleSet",
        metaData: {
            name: "Default Ruleset",
            version: "0.1.0",
            author: "giraluna",
            description: "",
        },
        needsToBeLoadedBefore: ModuleFileLoadingPhase_15.default.MapGen,
        supportedLanguages: "all",
        constructModule: function (moduleData) {
            moduleData.applyRuleSet({
                units: {
                    baseAttributeValue: 5,
                    attributeVariance: 1.2,
                    baseHealthValue: 250,
                    healthVariance: 50,
                },
                manufactory: {
                    startingCapacity: 1,
                    maxCapacity: 3,
                    buildCost: 1000,
                },
                research: {
                    baseResearchSpeed: 3000,
                },
                battle: {
                    rowsPerFormation: 2,
                    cellsPerRow: 3,
                    maxUnitsPerSide: 6,
                    maxUnitsPerRow: 3,
                    baseMaxCapturedUnits: 1,
                    absoluteMaxCapturedUnits: 3,
                    baseUnitCaptureChance: 0.1,
                    humanUnitDeathChance: 0.65,
                    aiUnitDeathChance: 0.65,
                    independentUnitDeathChance: 1.0,
                    loserUnitExtraDeathChance: 0.35,
                },
            });
        },
    };
    exports.default = defaultRuleSet;
});
define("modules/defaulttechnologies/defaultTechnologies", ["require", "exports", "modules/defaulttechnologies/TechnologyTemplates", "src/ModuleFileLoadingPhase", "src/setDynamicTemplateProperties", "localization/defaultLanguages"], function (require, exports, TechnologyTemplates_1, ModuleFileLoadingPhase_16, setDynamicTemplateProperties_2, Languages) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var defaultTechnologies = {
        key: "defaultTechnologies",
        metaData: {
            name: "Default technologies",
            version: "0.1.0",
            author: "giraluna",
            description: "",
        },
        needsToBeLoadedBefore: ModuleFileLoadingPhase_16.default.MapGen,
        supportedLanguages: [Languages.en],
        constructModule: function (moduleData) {
            setDynamicTemplateProperties_2.setTechnologyRequirements(TechnologyTemplates_1.default);
            moduleData.copyTemplates(TechnologyTemplates_1.default, "Technologies");
            return moduleData;
        },
    };
    exports.default = defaultTechnologies;
});
define("modules/defaultunits/defaultUnits", ["require", "exports", "modules/defaultunits/UnitArchetypes", "modules/defaultunits/UnitTemplates", "src/ModuleFileLoadingPhase", "src/cacheSpriteSheetAsImages", "localization/defaultLanguages"], function (require, exports, UnitArchetypes_1, UnitTemplates_2, ModuleFileLoadingPhase_17, cacheSpriteSheetAsImages_2, Languages) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var defaultUnits = {
        key: "defaultUnits",
        metaData: {
            name: "Default units",
            version: "0.1.0",
            author: "giraluna",
            description: "",
        },
        needsToBeLoadedBefore: ModuleFileLoadingPhase_17.default.MapGen,
        supportedLanguages: [Languages.en],
        loadAssets: function (onLoaded) {
            var loader = new PIXI.loaders.Loader();
            var spriteSheetKey = "units";
            loader.add(spriteSheetKey, "modules/defaultunits/img/sprites/units.json");
            loader.load(function (loader) {
                var json = loader.resources[spriteSheetKey].data;
                var image = loader.resources[spriteSheetKey + "_image"].data;
                cacheSpriteSheetAsImages_2.default(json, image);
                onLoaded();
            });
        },
        constructModule: function (moduleData) {
            moduleData.copyTemplates(UnitTemplates_2.default, "Units");
            moduleData.copyTemplates(UnitArchetypes_1.default, "UnitArchetypes");
            return moduleData;
        },
    };
    exports.default = defaultUnits;
});
define("modules/paintingportraits/paintingPortraitTemplates", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.paintingPortraitTemplates = {
        adelaide_hanscom1: {
            key: "adelaide_hanscom1",
            imageSrc: "modules/paintingportraits/img/adelaide_hanscom1.png",
        },
        alessandro_allori1: {
            key: "alessandro_allori1",
            imageSrc: "modules/paintingportraits/img/alessandro_allori1.png",
        },
        alessandro_allori2: {
            key: "alessandro_allori2",
            imageSrc: "modules/paintingportraits/img/alessandro_allori2.png",
        },
        alexandre_cabanel1: {
            key: "alexandre_cabanel1",
            imageSrc: "modules/paintingportraits/img/alexandre_cabanel1.png",
        },
        alexei_harlamov1: {
            key: "alexei_harlamov1",
            imageSrc: "modules/paintingportraits/img/alexei_harlamov1.png",
        },
        alexey_petrovich_antropov1: {
            key: "alexey_petrovich_antropov1",
            imageSrc: "modules/paintingportraits/img/alexey_petrovich_antropov1.png",
        },
        alice_pike_barney1: {
            key: "alice_pike_barney1",
            imageSrc: "modules/paintingportraits/img/alice_pike_barney1.png",
        },
        aman_theodor1: {
            key: "aman_theodor1",
            imageSrc: "modules/paintingportraits/img/aman_theodor1.png",
        },
        antonello_messina1: {
            key: "antonello_messina1",
            imageSrc: "modules/paintingportraits/img/antonello_messina1.png",
        },
        antonio_herrera_toro1: {
            key: "antonio_herrera_toro1",
            imageSrc: "modules/paintingportraits/img/antonio_herrera_toro1.png",
        },
        benjaminconstant1: {
            key: "benjaminconstant1",
            imageSrc: "modules/paintingportraits/img/benjamin-constant1.png",
        },
        benoist_marieguillemine1: {
            key: "benoist_marieguillemine1",
            imageSrc: "modules/paintingportraits/img/benoist_marie-guillemine1.png",
        },
        bouguereau_williamadolphe1: {
            key: "bouguereau_williamadolphe1",
            imageSrc: "modules/paintingportraits/img/bouguereau_william-adolphe1.png",
        },
        byron1: {
            key: "byron1",
            imageSrc: "modules/paintingportraits/img/byron1.png",
        },
        carl_fredric_breda1: {
            key: "carl_fredric_breda1",
            imageSrc: "modules/paintingportraits/img/carl_fredric_breda1.png",
        },
        carl_fredric_breda2: {
            key: "carl_fredric_breda2",
            imageSrc: "modules/paintingportraits/img/carl_fredric_breda2.png",
        },
        cramacj_lucas1: {
            key: "cramacj_lucas1",
            imageSrc: "modules/paintingportraits/img/cramacj_lucas1.png",
        },
        cranach_lucas2: {
            key: "cranach_lucas2",
            imageSrc: "modules/paintingportraits/img/cranach_lucas2.png",
        },
        cristobal_rojas1: {
            key: "cristobal_rojas1",
            imageSrc: "modules/paintingportraits/img/cristobal_rojas1.png",
        },
        delacroix_eugene_ferdinand_victor1: {
            key: "delacroix_eugene_ferdinand_victor1",
            imageSrc: "modules/paintingportraits/img/delacroix_eugene_ferdinand_victor1.png",
        },
        domenikos_theotokopoulos1: {
            key: "domenikos_theotokopoulos1",
            imageSrc: "modules/paintingportraits/img/domenikos_theotokopoulos1.png",
        },
        edmund_blair_leighton1: {
            key: "edmund_blair_leighton1",
            imageSrc: "modules/paintingportraits/img/edmund_blair_leighton1.png",
        },
        edmund_blair_leighton2: {
            key: "edmund_blair_leighton2",
            imageSrc: "modules/paintingportraits/img/edmund_blair_leighton2.png",
        },
        edwin_longsden_long1: {
            key: "edwin_longsden_long1",
            imageSrc: "modules/paintingportraits/img/edwin_longsden_long1.png",
        },
        falero_luis_ricardo1: {
            key: "falero_luis_ricardo1",
            imageSrc: "modules/paintingportraits/img/falero_luis_ricardo1.png",
        },
        felix_bonfils1: {
            key: "felix_bonfils1",
            imageSrc: "modules/paintingportraits/img/felix_bonfils1.png",
        },
        francesco_hayez1: {
            key: "francesco_hayez1",
            imageSrc: "modules/paintingportraits/img/francesco_hayez1.png",
        },
        francisco_goya_lucientes1: {
            key: "francisco_goya_lucientes1",
            imageSrc: "modules/paintingportraits/img/francisco_goya_lucientes1.png",
        },
        francisco_goya_lucientes2: {
            key: "francisco_goya_lucientes2",
            imageSrc: "modules/paintingportraits/img/francisco_goya_lucientes2.png",
        },
        francisco_zurbaran1: {
            key: "francisco_zurbaran1",
            imageSrc: "modules/paintingportraits/img/francisco_zurbaran1.png",
        },
        franz_von_defregger1: {
            key: "franz_von_defregger1",
            imageSrc: "modules/paintingportraits/img/franz_von_defregger1.png",
        },
        franz_von_defregger2: {
            key: "franz_von_defregger2",
            imageSrc: "modules/paintingportraits/img/franz_von_defregger2.png",
        },
        franz_von_defregger3: {
            key: "franz_von_defregger3",
            imageSrc: "modules/paintingportraits/img/franz_von_defregger3.png",
        },
        frederick_leighton1: {
            key: "frederick_leighton1",
            imageSrc: "modules/paintingportraits/img/frederick_leighton1.png",
        },
        frederic_westin1: {
            key: "frederic_westin1",
            imageSrc: "modules/paintingportraits/img/frederic_westin1.png",
        },
        frederic_yates1: {
            key: "frederic_yates1",
            imageSrc: "modules/paintingportraits/img/frederic_yates1.png",
        },
        gaston_bussiere1: {
            key: "gaston_bussiere1",
            imageSrc: "modules/paintingportraits/img/gaston_bussiere1.png",
        },
        george_henry_hall1: {
            key: "george_henry_hall1",
            imageSrc: "modules/paintingportraits/img/george_henry_hall1.png",
        },
        giovanni_battista_tiepolo1: {
            key: "giovanni_battista_tiepolo1",
            imageSrc: "modules/paintingportraits/img/giovanni_battista_tiepolo1.png",
        },
        giovanni_bellini1: {
            key: "giovanni_bellini1",
            imageSrc: "modules/paintingportraits/img/giovanni_bellini1.png",
        },
        hans_holbein1: {
            key: "hans_holbein1",
            imageSrc: "modules/paintingportraits/img/hans_holbein1.png",
        },
        hayez_francesco1: {
            key: "hayez_francesco1",
            imageSrc: "modules/paintingportraits/img/hayez_francesco1.png",
        },
        henryk_siemiradzki1: {
            key: "henryk_siemiradzki1",
            imageSrc: "modules/paintingportraits/img/henryk_siemiradzki1.png",
        },
        ilja_jefimowitsch_repin1: {
            key: "ilja_jefimowitsch_repin1",
            imageSrc: "modules/paintingportraits/img/ilja_jefimowitsch_repin1.png",
        },
        james_carrol_beckwith1: {
            key: "james_carrol_beckwith1",
            imageSrc: "modules/paintingportraits/img/james_carrol_beckwith1.png",
        },
        jeanbaptistecamille_corot1: {
            key: "jeanbaptistecamille_corot1",
            imageSrc: "modules/paintingportraits/img/jean-baptiste-camille_corot1.png",
        },
        jeanbaptistecamille_corot2: {
            key: "jeanbaptistecamille_corot2",
            imageSrc: "modules/paintingportraits/img/jean-baptiste-camille_corot2.png",
        },
        jeanleon_gerome1: {
            key: "jeanleon_gerome1",
            imageSrc: "modules/paintingportraits/img/jean-leon_gerome1.png",
        },
        jeanleon_gerome2: {
            key: "jeanleon_gerome2",
            imageSrc: "modules/paintingportraits/img/jean-leon_gerome2.png",
        },
        jeanleon_gerome3: {
            key: "jeanleon_gerome3",
            imageSrc: "modules/paintingportraits/img/jean-leon_gerome3.png",
        },
        jeanleon_gerome4: {
            key: "jeanleon_gerome4",
            imageSrc: "modules/paintingportraits/img/jean-leon_gerome4.png",
        },
        john_william_godward1: {
            key: "john_william_godward1",
            imageSrc: "modules/paintingportraits/img/john_william_godward1.png",
        },
        john_william_godward2: {
            key: "john_william_godward2",
            imageSrc: "modules/paintingportraits/img/john_william_godward2.png",
        },
        john_william_godward3: {
            key: "john_william_godward3",
            imageSrc: "modules/paintingportraits/img/john_william_godward3.png",
        },
        julije_klovic1: {
            key: "julije_klovic1",
            imageSrc: "modules/paintingportraits/img/julije_klovic1.png",
        },
        juriaen_streek1: {
            key: "juriaen_streek1",
            imageSrc: "modules/paintingportraits/img/juriaen_streek1.png",
        },
        kiprenskij_orest_adamovic1: {
            key: "kiprenskij_orest_adamovic1",
            imageSrc: "modules/paintingportraits/img/kiprenskij_orest_adamovic1.png",
        },
        konstantin_makovsky1: {
            key: "konstantin_makovsky1",
            imageSrc: "modules/paintingportraits/img/konstantin_makovsky1.png",
        },
        lefebvre_jules_joseph1: {
            key: "lefebvre_jules_joseph1",
            imageSrc: "modules/paintingportraits/img/lefebvre_jules_joseph1.png",
        },
        leonfrancois_comerre1: {
            key: "leonfrancois_comerre1",
            imageSrc: "modules/paintingportraits/img/leon-francois_comerre1.png",
        },
        leopold_loffler1: {
            key: "leopold_loffler1",
            imageSrc: "modules/paintingportraits/img/leopold_loffler1.png",
        },
        lewis_john_frederick1: {
            key: "lewis_john_frederick1",
            imageSrc: "modules/paintingportraits/img/lewis_john_frederick1.png",
        },
        madrazo_garreta_raimundo1: {
            key: "madrazo_garreta_raimundo1",
            imageSrc: "modules/paintingportraits/img/madrazo_garreta_raimundo1.png",
        },
        marie_bashkirtseff1: {
            key: "marie_bashkirtseff1",
            imageSrc: "modules/paintingportraits/img/marie_bashkirtseff1.png",
        },
        moritz_kellerhoven1: {
            key: "moritz_kellerhoven1",
            imageSrc: "modules/paintingportraits/img/moritz_kellerhoven1.png",
        },
        nathaniel_jocelyn1: {
            key: "nathaniel_jocelyn1",
            imageSrc: "modules/paintingportraits/img/nathaniel_jocelyn1.png",
        },
        nikolai_alexandrowitsch_jaroschenko1: {
            key: "nikolai_alexandrowitsch_jaroschenko1",
            imageSrc: "modules/paintingportraits/img/nikolai_alexandrowitsch_jaroschenko1.png",
        },
        nils_johan_olsson_blommer1: {
            key: "nils_johan_olsson_blommer1",
            imageSrc: "modules/paintingportraits/img/nils_johan_olsson_blommer1.png",
        },
        paolo_veronese1: {
            key: "paolo_veronese1",
            imageSrc: "modules/paintingportraits/img/paolo_veronese1.png",
        },
        parmigianino1: {
            key: "parmigianino1",
            imageSrc: "modules/paintingportraits/img/parmigianino1.png",
        },
        paul_cesar_helleu1: {
            key: "paul_cesar_helleu1",
            imageSrc: "modules/paintingportraits/img/paul_cesar_helleu1.png",
        },
        regnault_henri1: {
            key: "regnault_henri1",
            imageSrc: "modules/paintingportraits/img/regnault_henri1.png",
        },
        richard_bergh1: {
            key: "richard_bergh1",
            imageSrc: "modules/paintingportraits/img/richard_bergh1.png",
        },
        richard_bergh2: {
            key: "richard_bergh2",
            imageSrc: "modules/paintingportraits/img/richard_bergh2.png",
        },
        robert_dampier1: {
            key: "robert_dampier1",
            imageSrc: "modules/paintingportraits/img/robert_dampier1.png",
        },
        robert_lefevre1: {
            key: "robert_lefevre1",
            imageSrc: "modules/paintingportraits/img/robert_lefevre1.png",
        },
        robert_leopold1: {
            key: "robert_leopold1",
            imageSrc: "modules/paintingportraits/img/robert_leopold1.png",
        },
        sichel_nathanael1: {
            key: "sichel_nathanael1",
            imageSrc: "modules/paintingportraits/img/sichel_nathanael1.png",
        },
        svetoslav_roerich1: {
            key: "svetoslav_roerich1",
            imageSrc: "modules/paintingportraits/img/svetoslav_roerich1.png",
        },
        velazquez_diego1: {
            key: "velazquez_diego1",
            imageSrc: "modules/paintingportraits/img/velazquez_diego1.png",
        },
        viktor_vasnetsov1: {
            key: "viktor_vasnetsov1",
            imageSrc: "modules/paintingportraits/img/viktor_vasnetsov1.png",
        },
        williamadolphe_bouguereau1: {
            key: "williamadolphe_bouguereau1",
            imageSrc: "modules/paintingportraits/img/william-adolphe_bouguereau1.png",
        },
    };
});
define("modules/paintingportraits/paintingPortraits", ["require", "exports", "src/ModuleFileLoadingPhase", "modules/paintingportraits/paintingPortraitTemplates"], function (require, exports, ModuleFileLoadingPhase_18, paintingPortraitTemplates_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var paintingPortraits = {
        key: "paintingPortraits",
        metaData: {
            name: "Painting portraits",
            version: "0.1.0",
            author: "various artists",
            description: "old ppl",
        },
        needsToBeLoadedBefore: ModuleFileLoadingPhase_18.default.MapGen,
        supportedLanguages: "all",
        constructModule: function (moduleData) {
            moduleData.copyTemplates(paintingPortraitTemplates_1.paintingPortraitTemplates, "Portraits");
            return moduleData;
        },
    };
    exports.default = paintingPortraits;
});
define("modules/drones/statusEffects", ["require", "exports", "modules/common/effectactiontemplates/effectActions", "modules/common/battlesfxtemplates/battleSFX"], function (require, exports, effectActions_7, battleSFX_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.infest = {
        type: "infest",
        displayName: "Infest",
        description: "Deal increasing damage at the end of every turn",
        afterAbilityUse: [
            {
                id: "damage",
                getUnitsInArea: function (user) { return [user]; },
                executeAction: function (user, target, battle, executedEffectsResult, sourceStatusEffect) {
                    var tick = sourceStatusEffect.turnsHasBeenActiveFor + 1;
                    var relativeTick = tick / sourceStatusEffect.turnsToStayActiveFor;
                    var damageDealtThisTurn = 0.5 / relativeTick;
                    effectActions_7.adjustHealth({ maxHealthPercentage: -damageDealtThisTurn }, user, target, battle, executedEffectsResult);
                },
                sfx: battleSFX_1.placeholder,
            },
        ],
    };
    exports.merge = {
        type: "merge",
        displayName: "Merge",
        attributes: {
            attack: { flat: 1 },
            defence: { flat: 1 },
            intelligence: { flat: 1 },
            speed: { flat: 1 },
        },
    };
    exports.statusEffectTemplates = (_a = {},
        _a[exports.infest.type] = exports.infest,
        _a[exports.merge.type] = exports.merge,
        _a);
    var _a;
});
define("modules/drones/abilities", ["require", "exports", "src/targeting", "modules/common/battlesfxtemplates/battleSFX", "modules/common/effectactiontemplates/effectActions", "modules/common/effectactiontemplates/effectActions", "modules/drones/statusEffects"], function (require, exports, targeting_3, battleSFX_2, EffectActions, effectActions_8, DroneStatusEffects) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assimilate = {
        type: "assimilate",
        displayName: "Assimilate",
        description: "Deal damage and increase own troop size by 10% of damage dealt",
        moveDelay: 100,
        actionsUse: 1,
        getPossibleTargets: targeting_3.targetEnemies,
        mainEffect: {
            id: "damage",
            executeAction: effectActions_8.bindEffectActionData(EffectActions.inflictDamage, {
                baseDamage: 0.8,
                damageType: 0,
            }),
            getUnitsInArea: targeting_3.areaSingle,
            sfx: battleSFX_2.placeholder,
            attachedEffects: [
                {
                    id: "increaseUserHealth",
                    getUnitsInArea: function (user) { return [user]; },
                    executeAction: effectActions_8.bindEffectActionData(EffectActions.adjustCurrentAndMaxHealth, {
                        executedEffectsResultAdjustment: function (executedEffectsResult) {
                            var damageDealt = executedEffectsResult[effectActions_8.resultType.HealthChanged] || 0;
                            return damageDealt * -0.1;
                        },
                    }),
                },
            ],
        },
    };
    exports.merge = {
        type: "merge",
        displayName: "Merge",
        description: "Transfer up to 25% of own current health to target ally and increase target stats",
        moveDelay: 100,
        actionsUse: 1,
        getPossibleTargets: targeting_3.targetAllies,
        mainEffect: {
            id: "removeOwnHealth",
            executeAction: effectActions_8.bindEffectActionData(EffectActions.adjustHealth, {
                maxHealthPercentage: -0.25,
            }),
            getUnitsInArea: function (user) { return [user]; },
            sfx: battleSFX_2.placeholder,
        },
        secondaryEffects: [
            {
                id: "addStatusEffect",
                getUnitsInArea: targeting_3.areaSingle,
                trigger: function (user, target, battle, executedEffectsResult) {
                    return Boolean(executedEffectsResult[effectActions_8.resultType.HealthChanged]);
                },
                executeAction: effectActions_8.bindEffectActionData(EffectActions.addStatusEffect, {
                    duration: -1,
                    template: DroneStatusEffects.merge,
                }),
                attachedEffects: [
                    {
                        id: "addTargetHealth",
                        getUnitsInArea: targeting_3.areaSingle,
                        trigger: function (user, target, battle, executedEffectsResult) {
                            return Boolean(executedEffectsResult[effectActions_8.resultType.HealthChanged]);
                        },
                        executeAction: effectActions_8.bindEffectActionData(EffectActions.adjustHealth, {
                            executedEffectsResultAdjustment: function (executedEffectsResult) {
                                return -executedEffectsResult[effectActions_8.resultType.HealthChanged];
                            },
                        }),
                    },
                ],
            },
        ],
    };
    exports.infest = {
        type: "infest",
        displayName: "Infest",
        description: "Increase target capture chance and deal damage over time",
        moveDelay: 100,
        actionsUse: 1,
        getPossibleTargets: targeting_3.targetEnemies,
        mainEffect: {
            id: "addStatusEffect",
            getUnitsInArea: targeting_3.areaSingle,
            executeAction: effectActions_8.bindEffectActionData(EffectActions.addStatusEffect, {
                duration: 3,
                template: DroneStatusEffects.infest,
            }),
            sfx: battleSFX_2.placeholder,
            attachedEffects: [
                {
                    id: "increaseCaptureChance",
                    getUnitsInArea: targeting_3.areaSingle,
                    executeAction: effectActions_8.bindEffectActionData(EffectActions.increaseCaptureChance, {
                        flat: 0.4,
                    }),
                },
            ],
        },
    };
    exports.repair = {
        type: "repair",
        displayName: "Repair",
        description: "Restore health to one ally",
        moveDelay: 100,
        actionsUse: 1,
        getPossibleTargets: targeting_3.targetAllies,
        mainEffect: {
            id: "heal",
            getUnitsInArea: targeting_3.areaSingle,
            executeAction: effectActions_8.bindEffectActionData(EffectActions.adjustHealth, {
                perUserUnit: 0.5,
            }),
            sfx: battleSFX_2.placeholder,
        },
    };
    exports.massRepair = {
        type: "massRepair",
        displayName: "Mass Repair",
        description: "Restore health to all allies",
        moveDelay: 100,
        actionsUse: 1,
        getPossibleTargets: targeting_3.targetAllies,
        mainEffect: {
            id: "heal",
            getUnitsInArea: targeting_3.areaAll,
            executeAction: effectActions_8.bindEffectActionData(EffectActions.adjustHealth, {
                perUserUnit: 0.33,
            }),
            sfx: battleSFX_2.placeholder,
        },
    };
    exports.abilityTemplates = (_a = {},
        _a[exports.assimilate.type] = exports.assimilate,
        _a[exports.merge.type] = exports.merge,
        _a[exports.infest.type] = exports.infest,
        _a[exports.repair.type] = exports.repair,
        _a[exports.massRepair.type] = exports.massRepair,
        _a);
    var _a;
});
define("modules/drones/units/droneBase", ["require", "exports", "modules/defaultunits/UnitArchetypes", "modules/defaultunits/defaultUnitDrawingFunction", "modules/common/abilitytemplates/abilities", "modules/common/distributionGroups", "modules/drones/abilities"], function (require, exports, UnitArchetypes, defaultUnitDrawingFunction_9, CommonAbility, distributionGroups_10, DroneAbility) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.droneBase = {
        type: "droneBase",
        displayName: "Drone Base",
        description: "Base o drones",
        archetype: UnitArchetypes.utility,
        sprite: {
            imageSrc: "img/placeholder.png",
            anchor: { x: 0.5, y: 0.5 },
            attackOriginPoint: { x: 0.75, y: 0.5 },
        },
        icon: "img/placeholder.png",
        unitDrawingFN: defaultUnitDrawingFunction_9.default,
        isSquadron: false,
        buildCost: 500,
        maxHealth: 1.0,
        maxMovePoints: 1,
        maxOffensiveBattlesPerTurn: 1,
        visionRange: 1,
        detectionRange: -1,
        attributeLevels: {
            attack: 0.7,
            defence: 0.9,
            intelligence: 0.8,
            speed: 0.6,
        },
        possibleAbilities: [
            {
                flatProbability: 1,
                probabilityItems: [
                    DroneAbility.assimilate,
                    CommonAbility.standBy,
                ],
            },
            {
                flatProbability: 1,
                probabilityItems: [
                    {
                        flatProbability: 0.5,
                        probabilityItems: [DroneAbility.repair],
                    },
                    {
                        flatProbability: 0.5,
                        probabilityItems: [DroneAbility.massRepair],
                    },
                ],
            },
        ],
        itemSlots: {},
        distributionData: {
            weight: 1,
            distributionGroups: [distributionGroups_10.distributionGroups.unique],
        },
    };
});
define("modules/drones/units/droneCommander", ["require", "exports", "modules/defaultunits/UnitArchetypes", "modules/defaultunits/defaultUnitDrawingFunction", "modules/common/abilitytemplates/abilities", "modules/common/distributionGroups", "modules/drones/abilities"], function (require, exports, UnitArchetypes, defaultUnitDrawingFunction_10, CommonAbility, distributionGroups_11, DroneAbility) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.droneCommander = {
        type: "droneCommander",
        displayName: "Drone Commander",
        description: "Commander o drones",
        archetype: UnitArchetypes.utility,
        sprite: {
            imageSrc: "img/placeholder.png",
            anchor: { x: 0.5, y: 0.5 },
            attackOriginPoint: { x: 0.75, y: 0.5 },
        },
        icon: "img/placeholder.png",
        unitDrawingFN: defaultUnitDrawingFunction_10.default,
        isSquadron: false,
        buildCost: 200,
        maxHealth: 0.75,
        maxMovePoints: 1,
        maxOffensiveBattlesPerTurn: 1,
        visionRange: 1,
        detectionRange: -1,
        attributeLevels: {
            attack: 0.7,
            defence: 0.5,
            intelligence: 0.5,
            speed: 0.7,
        },
        possibleAbilities: [
            {
                flatProbability: 1,
                probabilityItems: [
                    DroneAbility.assimilate,
                    DroneAbility.repair,
                    CommonAbility.standBy,
                ],
            },
            {
                flatProbability: 0.25,
                probabilityItems: [DroneAbility.infest],
            },
        ],
        learnableAbilities: [
            DroneAbility.infest,
        ],
        itemSlots: {},
        distributionData: {
            weight: 1,
            distributionGroups: [distributionGroups_11.distributionGroups.rare],
        },
    };
});
define("modules/drones/units/droneSwarm", ["require", "exports", "modules/defaultunits/UnitArchetypes", "modules/defaultunits/defaultUnitDrawingFunction", "modules/common/abilitytemplates/abilities", "modules/common/distributionGroups", "modules/drones/abilities"], function (require, exports, UnitArchetypes, defaultUnitDrawingFunction_11, CommonAbility, distributionGroups_12, DroneAbility) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.droneSwarm = {
        type: "droneSwarm",
        displayName: "Drone Swarm",
        description: "Swarm o drones",
        archetype: UnitArchetypes.combat,
        sprite: {
            imageSrc: "img/placeholder.png",
            anchor: { x: 0.5, y: 0.5 },
            attackOriginPoint: { x: 0.75, y: 0.5 },
        },
        icon: "img/placeholder.png",
        unitDrawingFN: defaultUnitDrawingFunction_11.default,
        isSquadron: true,
        buildCost: 150,
        maxHealth: 0.6,
        maxMovePoints: 1,
        maxOffensiveBattlesPerTurn: 1,
        visionRange: 1,
        detectionRange: -1,
        attributeLevels: {
            attack: 0.6,
            defence: 0.4,
            intelligence: 0.4,
            speed: 0.6,
        },
        possibleAbilities: [
            {
                flatProbability: 1,
                probabilityItems: [
                    DroneAbility.assimilate,
                    CommonAbility.standBy,
                ],
            },
            {
                flatProbability: 0.25,
                probabilityItems: [DroneAbility.merge],
            },
        ],
        learnableAbilities: [
            DroneAbility.merge,
        ],
        itemSlots: {},
        distributionData: {
            weight: 1,
            distributionGroups: [distributionGroups_12.distributionGroups.common],
        },
    };
});
define("modules/drones/raceTemplate", ["require", "exports", "src/Name", "src/utility", "modules/common/distributionGroups", "modules/common/generateIndependentFleets", "modules/common/generateIndependentPlayer", "modules/drones/units/droneBase", "modules/drones/units/droneCommander", "modules/drones/units/droneSwarm", "modules/defaultai/mapai/DefaultAIConstructor"], function (require, exports, Name_8, utility_69, distributionGroups_13, generateIndependentFleets_3, generateIndependentPlayer_3, droneBase_1, droneCommander_1, droneSwarm_1, DefaultAIConstructor_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.drones = {
        type: "drones",
        displayName: new Name_8.default("Drones", true),
        description: "",
        distributionData: {
            weight: 1,
            distributionGroups: [distributionGroups_13.distributionGroups.common, distributionGroups_13.distributionGroups.rare],
        },
        isNotPlayable: true,
        getBuildableUnitTypes: function (player) {
            return ([
                droneSwarm_1.droneSwarm,
                droneCommander_1.droneCommander,
                droneBase_1.droneBase,
            ]);
        },
        getUnitName: function (unitTemplate) {
            return unitTemplate.displayName + " #" + utility_69.randInt(0, 20000);
        },
        getUnitPortrait: function (unitTemplate, allTemplates) {
            return utility_69.getRandomProperty(allTemplates);
        },
        generateIndependentPlayer: function (emblemTemplates) {
            return generateIndependentPlayer_3.generateIndependentPlayer(exports.drones);
        },
        generateIndependentFleets: function (player, location, globalStrength, localStrength, maxUnitsPerSideInBattle) {
            return generateIndependentFleets_3.generateIndependentFleets(exports.drones, player, location, globalStrength, localStrength, maxUnitsPerSideInBattle);
        },
        technologies: [],
        getAITemplateConstructor: function (player) { return DefaultAIConstructor_4.default; },
    };
    exports.raceTemplates = (_a = {},
        _a[exports.drones.type] = exports.drones,
        _a);
    var _a;
});
define("modules/drones/unitTemplates", ["require", "exports", "modules/drones/units/droneBase", "modules/drones/units/droneCommander", "modules/drones/units/droneSwarm"], function (require, exports, droneBase_2, droneCommander_2, droneSwarm_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unitTemplates = (_a = {},
        _a[droneSwarm_2.droneSwarm.type] = droneSwarm_2.droneSwarm,
        _a[droneCommander_2.droneCommander.type] = droneCommander_2.droneCommander,
        _a[droneBase_2.droneBase.type] = droneBase_2.droneBase,
        _a);
    var _a;
});
define("modules/drones/moduleFile", ["require", "exports", "src/App", "src/ModuleFileLoadingPhase", "modules/drones/abilities", "modules/drones/raceTemplate", "modules/drones/statusEffects", "modules/drones/unitTemplates", "localization/defaultLanguages"], function (require, exports, App_19, ModuleFileLoadingPhase_19, abilities_10, raceTemplate_1, statusEffects_1, unitTemplates_1, Languages) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.drones = {
        key: "drones",
        metaData: {
            name: "Drones",
            version: "0.1.0",
            author: "giraluna",
            description: "",
        },
        needsToBeLoadedBefore: ModuleFileLoadingPhase_19.default.Setup,
        supportedLanguages: [Languages.en],
        loadAssets: function (onLoaded) {
            var placeHolderResourceName = "placeHolder";
            var placeHolderURL = "img/placeholder.png";
            var loader = new PIXI.loaders.Loader();
            loader.add(placeHolderResourceName, placeHolderURL);
            loader.load(function () {
                var image = loader.resources[placeHolderResourceName].data;
                App_19.default.images[placeHolderURL] = image;
                onLoaded();
            });
        },
        constructModule: function (moduleData) {
            moduleData.copyTemplates(abilities_10.abilityTemplates, "Abilities");
            moduleData.copyTemplates(raceTemplate_1.raceTemplates, "Races");
            moduleData.copyTemplates(statusEffects_1.statusEffectTemplates, "StatusEffects");
            moduleData.copyTemplates(unitTemplates_1.unitTemplates, "Units");
            return moduleData;
        },
    };
});
define("src/defaultModuleData", ["require", "exports", "modules/core/core", "modules/defaultai/defaultAI", "modules/defaultattitudemodifiers/defaultAttitudemodifiers", "modules/defaultbackgrounds/defaultBackgrounds", "modules/defaultbuildings/defaultBuildings", "modules/defaultemblems/defaultEmblems", "modules/defaultitems/defaultItems", "modules/defaultmapgen/defaultMapgen", "modules/defaultmapmodes/defaultMapmodes", "modules/defaultnotifications/defaultNotifications", "modules/defaultraces/defaultRaces", "modules/defaultruleset/defaultRuleset", "modules/defaulttechnologies/defaultTechnologies", "modules/defaultunits/defaultUnits", "modules/paintingportraits/paintingPortraits", "modules/drones/moduleFile"], function (require, exports, core_1, defaultAI_1, defaultAttitudemodifiers_1, defaultBackgrounds_1, defaultBuildings_1, defaultEmblems_1, defaultItems_1, defaultMapgen_1, defaultMapmodes_1, defaultNotifications_1, defaultRaces_1, defaultRuleset_1, defaultTechnologies_1, defaultUnits_1, paintingPortraits_1, moduleFile_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultModuleData = {
        moduleFiles: [
            core_1.default,
            defaultEmblems_1.default,
            defaultRuleset_1.default,
            defaultAI_1.default,
            defaultItems_1.default,
            defaultTechnologies_1.default,
            defaultAttitudemodifiers_1.default,
            defaultMapgen_1.default,
            defaultUnits_1.default,
            defaultBackgrounds_1.default,
            defaultMapmodes_1.default,
            paintingPortraits_1.default,
            defaultBuildings_1.default,
            defaultNotifications_1.default,
            defaultRaces_1.default,
            moduleFile_1.drones,
        ],
    };
});
define("modules/common/resourcetemplates/resources", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.testResource1 = {
        type: "testResource1",
        displayName: "Test Resource 1",
        icon: "modules/common/resourcetemplates/img/test1.png",
        distributionData: {
            weight: 1,
            distributionGroups: ["common"],
        },
    };
    exports.testResource2 = {
        type: "testResource2",
        displayName: "Test Resource 2",
        icon: "modules/common/resourcetemplates/img/test2.png",
        distributionData: {
            weight: 1,
            distributionGroups: ["common"],
        },
    };
    exports.testResource3 = {
        type: "testResource3",
        displayName: "Test Resource 3",
        icon: "modules/common/resourcetemplates/img/test3.png",
        distributionData: {
            weight: 1,
            distributionGroups: ["common"],
        },
    };
    exports.testResource4 = {
        type: "testResource4",
        displayName: "Test Resource 4",
        icon: "modules/common/resourcetemplates/img/test4.png",
        distributionData: {
            weight: 1,
            distributionGroups: ["rare"],
        },
    };
    exports.testResource5 = {
        type: "testResource5",
        displayName: "Test Resource 5",
        icon: "modules/common/resourcetemplates/img/test5.png",
        distributionData: {
            weight: 1,
            distributionGroups: ["rare"],
        },
    };
});
define("modules/common/statuseffecttemplates/statusEffectTemplates", ["require", "exports", "modules/common/statuseffecttemplates/autoHeal", "modules/common/statuseffecttemplates/poisoned", "modules/common/statuseffecttemplates/snipe"], function (require, exports, autoHeal_2, poisoned_2, snipe_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.statusEffectTemplates = (_a = {},
        _a[autoHeal_2.default.type] = autoHeal_2.default,
        _a[poisoned_2.default.type] = poisoned_2.default,
        _a[snipe_2.snipeAttack.type] = snipe_2.snipeAttack,
        _a[snipe_2.snipeDefence.type] = snipe_2.snipeDefence,
        _a[snipe_2.snipeIntelligence.type] = snipe_2.snipeIntelligence,
        _a[snipe_2.snipeSpeed.type] = snipe_2.snipeSpeed,
        _a);
    var _a;
});
define("modules/common/addCommonToModuleData", ["require", "exports", "modules/common/abilitytemplates/abilities", "modules/common/battlesfxtemplates/battleSFX", "modules/common/passiveskilltemplates/passiveSkills", "modules/common/resourcetemplates/resources", "modules/common/statuseffecttemplates/statusEffectTemplates", "modules/common/attachedUnitData"], function (require, exports, AbilityTemplates, BattleSFXTemplates, PassiveSkillTemplates, ResourceTemplates, statusEffectTemplates_1, attachedUnitData_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function addCommonToModuleData(moduleData) {
        moduleData.copyTemplates(AbilityTemplates, "Abilities");
        moduleData.copyTemplates(ResourceTemplates, "Resources");
        moduleData.copyTemplates(BattleSFXTemplates, "BattleSFX");
        moduleData.copyTemplates(PassiveSkillTemplates, "PassiveSkills");
        moduleData.copyTemplates(statusEffectTemplates_1.statusEffectTemplates, "StatusEffects");
        moduleData.scripts.add(attachedUnitData_2.attachedUnitDataScripts);
    }
    exports.default = addCommonToModuleData;
});
define("src/App", ["require", "exports", "src/Game", "src/GameLoader", "src/MapRenderer", "src/ModuleFileLoadingPhase", "src/ModuleLoader", "src/NotificationLog", "src/Options", "src/Player", "src/PlayerControl", "src/ReactUI", "src/Renderer", "src/activeModuleData", "src/activeNotificationLog", "src/activePlayer", "src/centerCameraOnPosition", "src/defaultModuleData", "src/idGenerators", "src/utility", "src/tutorials/TutorialStatus", "src/localization/activeLanguage", "modules/common/addCommonToModuleData"], function (require, exports, Game_2, GameLoader_1, MapRenderer_1, ModuleFileLoadingPhase_20, ModuleLoader_1, NotificationLog_3, Options_14, Player_5, PlayerControl_1, ReactUI_1, Renderer_1, activeModuleData_31, activeNotificationLog_7, activePlayer_5, centerCameraOnPosition_3, defaultModuleData_1, idGenerators_10, utility_70, TutorialStatus_5, activeLanguage_4, addCommonToModuleData_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var App = (function () {
        function App() {
            var _this = this;
            this.images = {};
            PIXI.utils.skipHello();
            this.seed = "" + Math.random();
            Math.random = RNG.prototype.uniform.bind(new RNG(this.seed));
            this.moduleLoader = new ModuleLoader_1.default(activeModuleData_31.activeModuleData);
            this.initUI();
            utility_70.onDOMLoaded(function () {
                defaultModuleData_1.defaultModuleData.moduleFiles.forEach(function (moduleFile) {
                    _this.moduleLoader.addModuleFile(moduleFile);
                });
                addCommonToModuleData_1.default(_this.moduleLoader.moduleData);
                window.setTimeout(function () {
                    _this.makeApp();
                }, 0);
            });
        }
        App.prototype.makeGameFromSetup = function (map, players) {
            var _this = this;
            this.destroy();
            this.initUI();
            this.moduleLoader.loadModulesNeededForPhase(ModuleFileLoadingPhase_20.default.Game, function () {
                _this.game = new Game_2.default(map, players);
                _this.initGame();
                _this.initDisplay();
                _this.hookUI();
                centerCameraOnPosition_3.centerCameraOnPosition(activePlayer_5.activePlayer.controlledLocations[0]);
                _this.reactUI.switchScene("galaxyMap");
            });
        };
        App.prototype.load = function (saveKey) {
            var _this = this;
            var data = localStorage.getItem(saveKey);
            if (!data) {
                return;
            }
            var parsed = JSON.parse(data);
            idGenerators_10.default.setValues(parsed.idGenerators);
            this.destroy();
            this.initUI();
            this.moduleLoader.loadModulesNeededForPhase(ModuleFileLoadingPhase_20.default.Game, function () {
                _this.game = new GameLoader_1.default().deserializeGame(parsed.gameData);
                _this.game.gameStorageKey = saveKey;
                _this.initGame();
                _this.initDisplay();
                _this.hookUI();
                if (parsed.cameraLocation) {
                    centerCameraOnPosition_3.centerCameraOnPosition(parsed.cameraLocation);
                }
                _this.reactUI.switchScene("galaxyMap");
            });
        };
        App.prototype.makeApp = function () {
            var _this = this;
            var startTime = Date.now();
            Options_14.default.load();
            TutorialStatus_5.default.load();
            var initialLanguageCode = this.getInitialLanguageCode();
            activeLanguage_4.setActiveLanguageCode(initialLanguageCode);
            if (!Options_14.default.debug.enabled) {
                this.moduleLoader.progressivelyLoadModulesByPhase(0);
            }
            var initialScene = this.getInitialScene();
            var switchSceneFN = function () {
                _this.reactUI.switchScene(initialScene);
                console.log("Init in " + (Date.now() - startTime) + " ms");
            };
            if (initialScene === "galaxyMap") {
                this.moduleLoader.loadModulesNeededForPhase(ModuleFileLoadingPhase_20.default.Game, function () {
                    _this.game = _this.makeGame();
                    _this.initGame();
                    _this.initDisplay();
                    _this.hookUI();
                    centerCameraOnPosition_3.centerCameraOnPosition(activePlayer_5.activePlayer.controlledLocations[0]);
                    switchSceneFN();
                });
            }
            else {
                switchSceneFN();
            }
        };
        App.prototype.destroy = function () {
            if (this.game) {
                this.game.destroy();
                this.game = null;
            }
            if (this.mapRenderer) {
                this.mapRenderer.destroy();
                this.mapRenderer = null;
            }
            if (this.renderer) {
                this.renderer.destroy();
                this.renderer = null;
            }
            if (this.playerControl) {
                this.playerControl.destroy();
                this.playerControl = null;
            }
            if (this.reactUI) {
                this.reactUI.destroy();
                this.reactUI = null;
            }
        };
        App.prototype.makeGame = function () {
            var playerData = this.makePlayers();
            var players = playerData.players;
            var map = this.makeMap(playerData);
            var game = new Game_2.default(map, players);
            return game;
        };
        App.prototype.makePlayers = function () {
            var players = [];
            var candidateRaces = Object.keys(activeModuleData_31.activeModuleData.Templates.Races).map(function (raceKey) {
                return activeModuleData_31.activeModuleData.Templates.Races[raceKey];
            }).filter(function (raceTemplate) {
                return !raceTemplate.isNotPlayable;
            });
            for (var i = 0; i < 5; i++) {
                players.push(new Player_5.default({
                    isAI: i > 0,
                    isIndependent: false,
                    race: utility_70.getRandomArrayItem(candidateRaces),
                    money: 1000,
                }));
            }
            return ({
                players: players,
            });
        };
        App.prototype.makeMap = function (playerData) {
            var optionValues = {
                defaultOptions: {
                    height: 1200,
                    width: 1200,
                    starCount: 30,
                },
                basicOptions: {
                    arms: 5,
                    centerDensity: 40,
                    starSizeRegularity: 100,
                },
            };
            var mapGenResult = activeModuleData_31.activeModuleData.getDefaultMap().mapGenFunction(optionValues, playerData.players);
            var galaxyMap = mapGenResult.makeMap();
            return galaxyMap;
        };
        App.prototype.initGame = function () {
            var _this = this;
            if (!this.game) {
                throw new Error("App tried to init game without having one specified");
            }
            activePlayer_5.setActivePlayer(this.game.players[0]);
            activePlayer_5.activePlayer.isAI = false;
            if (this.playerControl) {
                this.playerControl.removeEventListeners();
            }
            this.playerControl = new PlayerControl_1.default(activePlayer_5.activePlayer);
            if (!activeNotificationLog_7.activeNotificationLog) {
                var playersToSubscribe = this.game.getLiveMajorPlayers();
                activeNotificationLog_7.setActiveNotificationLog(new NotificationLog_3.default(playersToSubscribe));
                activeNotificationLog_7.activeNotificationLog.currentTurn = this.game.turnNumber;
            }
            activeModuleData_31.activeModuleData.scripts.game.afterInit.forEach(function (script) {
                script(_this.game);
            });
            this.game.players.forEach(function (player) {
                if (!player.AIController) {
                    player.AIController = player.makeRandomAIController(_this.game);
                }
            });
        };
        App.prototype.initDisplay = function () {
            this.renderer = new Renderer_1.default(this.game.galaxyMap.seed, activeModuleData_31.activeModuleData.mapBackgroundDrawingFunction);
            this.mapRenderer = new MapRenderer_1.default(this.game.galaxyMap, activePlayer_5.activePlayer);
            this.mapRenderer.setParent(this.renderer.layers.map);
            this.mapRenderer.init();
        };
        App.prototype.initUI = function () {
            this.reactUI = new ReactUI_1.default(document.getElementById("react-container"), this.moduleLoader);
        };
        App.prototype.hookUI = function () {
            this.reactUI.game = this.game;
            this.reactUI.player = activePlayer_5.activePlayer;
            this.reactUI.playerControl = this.playerControl;
            this.reactUI.renderer = this.renderer;
            this.reactUI.mapRenderer = this.mapRenderer;
        };
        App.prototype.getInitialScene = function () {
            var urlParser = document.createElement("a");
            urlParser.href = document.URL;
            var hash = urlParser.hash;
            if (hash) {
                return hash.slice(1);
            }
            else {
                return "setupGame";
            }
        };
        App.prototype.getInitialLanguageCode = function () {
            var storedLanguageCode = localStorage.getItem("Rance.language");
            if (storedLanguageCode) {
                return storedLanguageCode;
            }
            else {
                return "en";
            }
        };
        return App;
    }());
    var app = new App();
    exports.default = app;
});
//# sourceMappingURL=main.js.map